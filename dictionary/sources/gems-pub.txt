sh 'cspell lint --no-progress "**/*"'
puts "--- Running #{gem} specs"
sh("bundle install --jobs=3 --retry=3")
RSpec::Core::RakeTask.new(:spec) do |t|
t.rspec_opts = %w{--profile}
RSpec::Core::RakeTask.new(:all) do |t|
RSpec::Core::RakeTask.new(:doc) do |t|
t.rspec_opts = %w{--format specdoc --dry-run --profile}
puts "--- Running chef #{sub} specs"
t.rspec_opts = %w{--profile --format doc}
STDERR.puts "\n*** RSpec not available. (sudo) gem install rspec to run unit tests. ***\n\n"
$:.unshift(File.expand_path(File.join(__dir__, "lib")))
return nil if default.nil? || default == "" || default == "lazy default"
text = ""
text << "#{resource_name} 'name' do\n"
text << "\n"
text << "end"
text = props.size == 2 ? props.join(" ") : props.join(", ")
text << ( props.size > 1 ? " are the properties" : " is the property" )
fixed_arr = Array(arr).map do |x|
fixed_arr.compact.join(", ")
values = {}
properties = {}
description_pattern = /(Note:|Warning:)?((?:(?!Note:|Warning:).)*)/m
element = { "markdown" => body }
when "Note:"
description << { "note" => element }
description << { "warning" => element }
raise "Unexpected thing happened! preface: '#{preface}', body: '#{body}'"
r = {}
puts "=========="
File.open("docs_site/#{resource}.yaml", "w") { |f| f.write(YAML.dump(resource_data)) }
task update: %w{
}
rm_f "#{dir}/Gemfile.lock"
)
let(:value1) { { name: "one", type: :string, data: "1" } }
let(:value1_upcase_name) { { name: "ONE", type: :string, data: "1" } }
let(:key) { "Software\\OpscodeNumbers" }
let(:key_parent) { "Software" }
let(:key_to_delete) { "OpscodeNumbers" }
let(:sub_key) { "OpscodePrimes" }
let(:missing_key_path) { "HKCU\\Software" }
let(:reg_mock) { double("reg") }
expect(reg_mock).to receive(:write).with("one", 1, "1")
expect(reg_mock).to receive(:each).with(no_args).and_yield("one", 1, "1")
expect(reg_mock).to receive(:each).with(no_args).and_yield("one", 1, "2")
described_class.symlink("a", "b")
let(:input) { "1.2.3" }
it { is_expected.to eq "1.2.3" }
it { is_expected.to eql "1.2.3" }
it { is_expected.to be == "1.2.3" }
it { is_expected.to be < "abc" }
it { is_expected.to be > "0" }
it { is_expected.to eq described_class.new("1.2.3") }
it { is_expected.to be == described_class.new("1.2.3") }
context "with !=" do
subject { described_object != "1.2.4" }
it { is_expected.to be true }
context "with +" do
it { is_expected.to eq "1.2.3asdf" }
context "with *" do
it { is_expected.to eq "1.2.31.2.31.2.3" }
subject { described_class.new("1.02.3") }
it { is_expected.to be > "1.2.2" }
it { is_expected.to be > "1.2.3a" }
it { is_expected.to be < "1.2.4" }
subject { described_object =~ /^1/ }
it { is_expected.to eq 0 }
subject { described_object =~ Gem::Requirement.create("~> 1.0") }
subject { described_object =~ "~> 1.0" }
subject { /^2/ =~ described_object }
it { is_expected.to be nil }
subject { "~> 1.0" =~ described_object }
it "should raise #{v_error} when given #{s}" do
bad_op.each do |s|
it "should raise #{o_error} when given #{s}" do
expect(vc.to_s).to eq("= 1.2.3")
it "should default to >= 0.0.0" do
expect(vc.to_s).to eq(">= 0.0.0")
expect(Chef::VersionConstraint.new(nil).to_s).to eq(">= 0.0.0")
expect(Chef::VersionConstraint.new(">=1.2.3")).to eql(Chef::VersionConstraint.new(">= 1.2.3"))
expect(Chef::VersionConstraint.new("<=1.2.3")).to eql(Chef::VersionConstraint.new("<= 1.2.3"))
@vc = Chef::VersionConstraint.new "> 1.2.3"
expect(@vc).to include "1.4"
cv = Chef::CookbookVersion.new("alice", "/tmp/blah.txt")
cv.version = "1.4"
vc = Chef::VersionConstraint.new "< 1.2.3"
expect(vc).not_to include "1.3.0"
expect(vc).not_to include "1.2.3"
expect(vc).to include "1.2.2"
vc = Chef::VersionConstraint.new "> 1.2.3"
expect(vc).to include "1.3.0"
expect(vc).not_to include "1.2.2"
vc = Chef::VersionConstraint.new "<= 1.2.3"
expect(vc).to include "1.2.3"
vc = Chef::VersionConstraint.new ">= 1.2.3"
it "equal to" do
vc = Chef::VersionConstraint.new "= 1.2.3"
expect(vc).not_to include "0.3.0"
it "pessimistic ~> x.y.z" do
vc = Chef::VersionConstraint.new "~> 1.2.3"
expect(vc).to include "1.2.4"
expect(vc).not_to include "2.0.0"
it "pessimistic ~> x.y" do
vc = Chef::VersionConstraint.new "~> 1.2"
expect(vc).to include "1.3.3"
vc = Chef::VersionConstraint.new "~> 1.2.0"
expect(vc.to_s).to eq("~> 1.2.0")
expect(vc.to_s).to eq("~> 1.2")
expect(vc.inspect).to eq("(~> 1.2.0)")
expect(vc.inspect).to eq("(~> 1.2)")
it "pessimistic ~> x" do
@v0 = Chef::Version.new "0.0.0"
@v123 = Chef::Version.new "1.2.3"
expect(@v0.to_s).to eq("0.0.0")
expect(@v123.to_s).to eq("1.2.3")
a = Chef::Version.new(@v123.to_s)
expect(a).to eq(@v123)
expect(Chef::Version.new("1.2").to_s).to eq("1.2.0")
a = Chef::Version.new "01.002.0003"
good_versions = %w{1.2 1.2.3 1000.80.50000 0.300.25 001.02.00003}
it "should accept '#{v}'" do
it "should raise #{the_error} when given '#{v}'" do
describe "<=>" do
expect(Chef::Version.new("1.2")).to eq(Chef::Version.new("1.2.0"))
expect(Chef::Version.new("1.04")).to eq(Chef::Version.new("1.4"))
expect(Chef::Version.new("2.0")).to be < Chef::Version.new("11.0")
expect(sm).to be < lg
expect(lg).to be > sm
a = %w{0.0.0 0.0.1 0.1.0 0.1.1 1.0.0 1.1.0 1.1.1}.map do |s|
got = a.sort.map(&:to_s)
expect(got).to eq(%w{0.0.0 0.0.1 0.1.0 0.1.1 1.0.0 1.1.0 1.1.1})
a = %w{9.8.7 1.0.0 1.2.3 4.4.6 4.5.6 0.8.6 4.5.5 5.9.8 3.5.7}.map do |s|
expect(got).to eq(%w{0.8.6 1.0.0 1.2.3 3.5.7 4.4.6 4.5.5 4.5.6 5.9.8 9.8.7})
v = Chef::Version::Platform.new("1.1")
expect(Chef::Version::Platform.new("1").to_s).to eq("1.0.0")
expect(Chef::Version::Platform.new("1")).to eq(Chef::Version::Platform.new("1.0.0"))
let(:session_user) { nil }
let(:session_domain) { nil }
let(:password) { nil }
let(:password) { "ponies" }
let(:session_domain) { "fairyland" }
let(:session_user) { "chalena" }
5.times { queue << job }
let(:path) { "/path/to/awesome directory" }
let(:username) { "foo" }
let(:hosts_content) { "" }
expect(editor.lines).to be == IO.readlines(__FILE__)
let(:input_lines) { %w{one two two three} }
subject(:execute) { editor.append_line_after("two", "new") }
expect(editor.append_line_after(/^ee/, "new")).to be == 0
expect(editor.append_line_after(/ee$/, "new")).to be == 1
it "adds a line to the end" do
subject(:execute) { editor.append_line_if_missing("one", "new") }
expect(editor.append_line_if_missing(/ee$/, "new")).to be == 0
expect(editor.append_line_if_missing(/^ee/, "new")).to be == 1
expect(editor.lines).to be == %w{one three}
expect(editor.remove_lines(/^ee/)).to be == 0
expect(editor.remove_lines(/ee$/)).to be == 1
subject(:execute) { editor.replace("missing", "new") }
subject(:execute) { editor.replace("two", "new") }
expect(editor.replace(/^ee/, "new")).to be == 0
expect(editor.replace(/ee$/, "new")).to be == 1
subject(:execute) { editor.replace_lines("missing", "new") }
subject(:execute) { editor.replace_lines("two", "new") }
expect(editor.replace_lines(/^ee/, "new")).to be == 0
expect(editor.replace_lines(/ee$/, "new")).to be == 1
expect(editor.lines).to be == %w{one two two new}
{
let(:lcm_command_ps4) { ps4_base_command + " -whatif; if (! $?) { exit 1 }" }
let(:lcm_result) { "" }
let(:lcm_result) { "some output" }
%w{! @ # $ % ^ & * & * ( ) - = + \{ \} . ? < > \\ /}.each do |sym|
%w{` " # '}.each do |c|
it "escapes #{c}" do
expect(conf_man.send(:escape_parameter_value, "stuff #{c}")).to eql("stuff `#{c}")
conf_man.send(:command_switches_string, { "foo" => "bar" })
conf_man.send(:command_switches_string, { foo!: "bar" })
expect(conf_man.send(:command_switches_string, { foo: false })).to eql("")
expect(conf_man.send(:command_switches_string, { foo: "bar" })).to eql("-foo 'bar'")
expect(conf_man.send(:command_switches_string, { foo: "" })).to eql("-foo ''")
expect(conf_man.send(:command_switches_string, { foo: 1 })).to eql("-foo 1")
expect(conf_man.send(:command_switches_string, { foo: 1.0 })).to eql("-foo 1.0")
expect(conf_man.send(:command_switches_string, { foo: true })).to eql("-foo")
merged = conf_man.send(:get_merged_configuration_flags!, { "flag" => "a" }, "hello")
conf_man.send(:get_merged_configuration_flags!, { "outputpath" => "a" }, "hello")
conf_man.send(:get_merged_configuration_flags!, { "OutputPath" => "a" }, "hello")
merged = conf_man.send(:get_merged_configuration_flags!, { "FLAG" => "a" }, "hello")
merged = conf_man.send(:get_merged_configuration_flags!, { flag: "a" }, "hello")
merged = conf_man.send(:get_merged_configuration_flags!, { FLAG: "a" }, "hello")
let(:file_like_object) { double("file like object") }
allow(File).to receive(:join) do |a, b|
allow(Dir).to receive(:entries).with("tmp++hello") { %w{f1 f2 f3} }
dsc = conf_man.send(:configuration_code, "archive{}", "hello", {})
dsc.split(";").each do |command|
if /\s*configuration\s+'hello'\s*\{\s*node\s+'localhost'\s*\{\s*archive\s*\{\s*\}\s*\}\s*\}\s*/.match?(command.downcase)
dsc = conf_man.send(:configuration_code, "archive{}", "hello", { "FooModule" => %w{FooResource BarResource} })
let!(:old_tempfile) { Tempfile.new("chef-util diff-spec") }
let!(:new_tempfile) { Tempfile.new("chef-util diff-spec") }
let!(:old_tempfile) { Tempfile.new("chef-util-diff-spec") }
let!(:new_tempfile) { Tempfile.new("chef-util-diff-spec") }
old_tempfile.write("#{0x01.chr}#{0xFF.chr}")
new_tempfile.write("#{0x01.chr}#{0xFF.chr}")
expect(differ.for_output.join("\\n")).to match(/\A--- .*\\n\+\+\+ .*\\n@@/m)
expect(differ.for_reporting).to match(/\A--- .*\\n\+\+\+ .*\\n@@/m)
let!(:old_file) { old_tempfile.path }
let!(:new_file) { new_tempfile.path }
let(:utf_8) { "testing utf-8 unicode...\n\n\non a new line: \xE2\x80\x93\n" } # unicode em-dash
let(:latin_1) { "It is more metal.\nif you have an #{0xFD.chr}mlaut.\n" } # NB: changed to y-with-diaresis, but i'm American so I don't know the difference
let(:shift_jis) { "I have no idea what this character is:\n #{0x83.chr}#{0x80.chr}.\n" } # seriously, no clue, but \x80 is nice and illegal in other encodings
expect(@backup).to receive(:path).and_return("/a/b/c.txt")
expect(@backup.send(:backup_filename)).to match(%r|^/a/b/c.txt.chef-\d{14}.\d{6}$|)
expect(@backup).to receive(:path).and_return('c:\a\b\c.txt')
expect(@backup.send(:backup_filename)).to match(/^\\a\\b\\c.txt.chef-\d{14}.\d{6}$/)
expect(@backup).to receive(:path).and_return("c:/a/b/c.txt")
expect(@backup.send(:backup_path)).to match(%r|^/a/b/c.txt.chef-\d{14}.\d{6}$|)
expect(@backup).to receive(:path).and_return("c:\\a\\b\\c.txt")
let(:method) { :create_key }
let(:method) { :public_key }
let(:method) { :private_key }
let(:method) { :display_name }
let(:method) { :first_name }
let(:method) { :middle_name }
let(:method) { :last_name }
let(:method) { :email }
let(:method) { :password }
@json = @user.to_json
expect(@json).to match(/^\{.+\}$/)
expect(@json).to include(%q{"username":"black"})
expect(@user.to_json).to include(%{"first_name":"char"})
expect(@user.to_json).to include(%{"middle_name":"man"})
@user.last_name("der")
expect(@user.to_json).to include(%{"last_name":"der"})
expect(@user.to_json).to include(%{"public_key":"crowes"})
let(:jsonable) { @user }
user = {
expect(@user.last_name).to eq("der")
let(:response_406) { OpenStruct.new(code: "406") }
email: "some_email",
let(:response_400) { OpenStruct.new(code: "400") }
let(:http_verb) { :put }
let(:rest_v0) { @user.chef_root_rest_v0 }
let(:rest_v1) { @user.chef_root_rest_v1 }
expect(@user.chef_root_rest_v1).to receive(:post).with("users", payload.merge({ middle_name: "some_middle_name" })).and_return({})
let(:http_verb) { :post }
expect(@user.chef_root_rest_v0).to receive(:post).with("users", payload.merge({ middle_name: "some_middle_name" })).and_return({})
expect(@user.chef_root_rest_v0).to receive(:put).with("users/#{@user.username}", payload.merge({ "private_key" => true })).and_return({})
@osc_response = { "admin" => "http://www.example.com/users/admin" }
@osc_inflated_response = { "admin" => @user }
expect(@http_client).to receive(:get).with("users/foobar").and_return({ "username" => "foobar", "admin" => true, "public_key" => "pubkey" })
@user = Chef::User.new
it "should be a Chef::User" do
expect(@user.name("ops_master")).to eq("ops_master")
@user.name("black")
expect(@json).to include(%q{"name":"black"})
expect(@json).to include(%{"public_key":"crowes"})
expect(@json).to include(%q{"admin":false})
user = { "name" => "mr_spinks",
expect(@http_client).to receive(:post).with("users", { name: "foobar", admin: false, password: "password" }).and_return({})
expect(@http_client).to receive(:get).with("users/foobar").and_return({ "name" => "foobar", "admin" => true, "public_key" => "pubkey" })
user = Chef::User.load("foobar")
expect(@http_client).to receive(:put).with("users/foobar", { name: "foobar", admin: false }).and_return({})
let(:good_credentials) { { "switch.cisco.com" => { "user" => "cisco", "password" => "cisco", "enable_password" => "secret" } } }
allow(transport).to receive(:parse_credentials_file).and_return({ "foo" => { "example" => { "org" => {} } } })
expect(Chef::Log).to receive(:warn).with(/as a Hash/)
@conf = new_conf
Shell.irb_conf = {}
it "has a prompt like ``chef > '' in the default context" do
expect(conf.return_format).to eq(" => %s \n")
it "has a prompt like ``chef:recipe > '' in recipe context" do
conf.main = Chef::Recipe.new(nil, nil, Chef::RunContext.new(Chef::Node.new, {}, events))
expect(@chef_object.help_banner).to match(/^\|\ Command\s+\|\ Description\s*$/)
expect(@chef_object.help_banner).to match(/^\|\ rspec_method\s+\|\ rspecin\'\s*$/)
let(:json_attribs) { { "a" => "b" } }
let(:chef_rest) { double("Chef::ServerAPI") }
let(:node) { Chef::Node.build("foo") }
sync_cookbooks: {})
let(:node) { Chef::Node.new }
let(:recipe) { Chef::Recipe.new(nil, nil, run_context) }
session.node_attributes = { "besnard_lakes" => "are_the_dark_horse" }
node = double("node", attribute: { foo: :bar })
expect(@root_context).to receive(:pp).with({ foo: :bar })
it "says if echo is on or off" do
entries = %w{. .. someFile}
@root_context.ls "/tmp"
@run_context = Chef::RunContext.new(Chef::Node.new, {}, @events)
@model = OpenStruct.new(name: "Chef::Node")
@node_1 = Chef::Node.new
@node_1.name("sammich")
@node_2 = Chef::Node.new
@node_2.name("yummy")
@server_response = { node_1: @node_1, node_2: @node_2 }
@searcher = double("Chef::Search::Query #{__FILE__}:#{__LINE__}")
expect(@wrapper.find(:all)).to include(@node_1, @node_2)
expect(@searcher).to receive(:search).with(:node, "name:app*").and_yield(@node_1).and_yield(@node_2)
expect(@wrapper.find("name:app*")).to include(@node_1, @node_2)
expect(@wrapper.find(:name => "app*", "name" => "app*")).to include(@node_1, @node_2)
Chef::ServerAPIVersions.instance.set_versions({ "min_version" => 0, "max_version" => 2 })
let(:url) { "http://chef.example.com:4000" }
let(:key_path) { "/tmp/foo" }
post_body = { bar: "baz" }
stub_request(:post, "http://chef.example.com:4000/foo").with(body: post_body.to_json, headers: headers).to_return(status: 200, body: "", headers: {})
put_body = { bar: "baz" }
stub_request(:put, "http://chef.example.com:4000/foo").with(body: put_body.to_json, headers: headers).to_return(status: 200, body: "", headers: {})
stub_request(:get, "http://chef.example.com:4000/foo").with(headers: headers).to_return(status: 200, body: "", headers: {})
stub_request(:get, "http://chef.example.com:4000/foo").with(headers: { "X-Ops-Server-Api-Version" => "0" }).to_return(status: 200, body: "", headers: {})
let(:fetcher_impl) { SecretFetcherImpl.new({}, nil) }
let(:fetcher) {
Chef::SecretFetcher.for_service(:example, { "key1" => "value1" }, nil)
fetcher.fetch("key1", "v1")
require_relative "../../spec_helper"
let(:node) { {} }
let(:run_context) { double("run_context", node: node) }
token: "t.1234abcd",
data: {
},
lease_id: "",
}))
let(:config) { { vault: "my-vault" } }
let(:secrets_response_body) { '{ "value" : "my secret value" }' }
rm = Net::HTTPSuccess.new("1.0", "400", "OK")
let(:http_mock) { instance_double("Net::HTTP", :use_ssl= => nil) }
let(:vault_name) { "my-vault" }
let(:secret_name) { "my-secret" }
let(:vault_secret_uri) { URI.parse("https://#{vault_name}.vault.azure.net/secrets/#{secret_name}/?api-version=7.2") }
let(:token_response_mock) { Net::HTTPBadRequest.new("1.0", "400", "Bad Request") }
let(:config) { { vault: "my-vault", object_id: object_id } }
let(:config) { { vault: "my-vault", client_id: client_id } }
let(:config) { { vault: "my-vault", mi_res_id: mi_res_id } }
expect(token_uri.query).to match(/mi_res_id=#{mi_res_id}/)
let(:config) { {} }
let(:secrets_response_body) { '{ "error" : { "code" : 404, "message" : "secret not found" } }' }
let(:aws_global_config) { {} }
let(:fetcher_config) { {} }
let(:fetcher_config) { { region: "region-from-caller" } }
let(:node) { { "ec2" => { "region" => "region-from-ohai-data" } } }
let(:rest) { double("Chef::ServerAPI") }
let(:query) { Chef::Search::Query.new }
let(:default_rows) { 1000 }
let(:args) { { filter_key => filter_hash } }
{ "url" => "#{server_url}/my-name-is-node",
{ "url" => "#{server_url}/my-name-is-jonas",
{ "url" => "#{server_url}/my-name-is-flipper",
{ "url" => "#{server_url}/my-name-is-butters",
{ "env" => "elysium", "ruby_plat" => "nudibranch" },
{ "env" => "hades", "ruby_plat" => "i386-mingw32" },
{ "env" => "elysium", "ruby_plat" => "centos" },
{ "env" => "moon", "ruby_plat" => "solaris2" },
{ "name" => "my-name-is-node",
{ "name" => "my-name-is-jonas",
{ "name" => "my-name-is-flipper",
{ "name" => "my-name-is-butters",
expect { query.search(:node, "platform:rhel", total: 10) }
@call_me = double("blocky")
query.search(:node) { |r| @call_me.do(r) }
query.search(:node, "*:*", start: 0, rows: 4) { |r| @call_me.do(r) }
query.search(:node, "platform:rhel") do |r|
query.search(:node, "platform:rhel", rows: 4) do |r|
query.search("node", "free.messi", fuzz: true)
let(:filter_key) { :filter_result }
@real_file = "/tmp/foo/bar/real/file"
f.owner("root")
f.group("root")
f.mode("0755")
@stat = double("File::Stat for #{@new_resource.path}", uid: 0, gid: 0, mode: 00100644)
@root_passwd = double("Struct::Passwd for uid 0", name: "root")
@group_entry = double("Struct::Group for wheel", name: "wheel")
@action = :fail
let(:node) do
let(:runner) { Chef::Runner.new(run_context) }
rescue => e
expected_message = <<~E
@node = Chef::Node.new
@run_context = Chef::RunContext.new(@node, {}, @events)
@end_time = @start_time + 23
default_cache_path = windows? ? 'C:\chef' : "/var/chef"
let(:lockfile) { "/tmp/chef-client-running.pid" }
@timeout = 0.1
describe "<<" do
@run_list << "needy"
describe "==" do
@run_list << "foo"
r << "foo"
expect(@run_list).to eq(r)
@run_list << "baz"
expect(@run_list).to eq(%w{foo baz})
@run_list << "chromeo"
@run_list << "bar"
@run_list.each { |r| seen << r }
to_add.each { |i| @run_list << i }
@run_list.include?("foo")
list.each { |i| expect(@run_list).to be_include(i) }
@role = Chef::Role.new
@role.run_list "one", "two"
@rest = double("Chef::ServerAPI", { get: @role.to_hash, url: "/" })
@run_list << "kitty"
@run_list.expand("_default", "disk")
expansion = @run_list.expand("_default", "server")
dog = Chef::Role.new
expansion = @run_list.expand("_default", "disk")
let(:jsonable) { @run_list }
recipes.each { |r| list << r }
let(:recipes) { %w{ apt god apache2 } }
list.add_recipe "rails", "1.0.0"
expect(list.with_versions).to include({ name: "rails", version: "1.0.0" })
list.add_recipe "apt", "1.2.3"
expect(list.with_versions).to include({ name: "apt", version: "1.2.3" })
{ name: "apt", version: "1.0.0" },
{ name: "god", version: nil },
{ name: "apache2", version: "0.0.1" },
{ name: "apt", version: "~> 1.2.0" },
let(:recipes) { %w{ apache2 } }
expect(fq_names).to eq( %w{ apache2::default } )
let(:recipes) { %w{ mysql::server } }
expect(fq_names).to eq( %w{ mysql::server } )
{ name: "apt::cacher", version: "~> 1.2.0" },
let(:recipes) { %w{ foo bar::default } }
item = Chef::RunList::RunListItem.new(type: "fuuu", name: "uuuu")
expect(item.version).to eq("0.1.0")
@rage_role = Chef::Role.new.tap do |r|
r.name("rage")
@first_role.default_attributes({ "foo" => "bar" })
@first_role.override_attributes({ "baz" => "qux" })
@second_role.default_attributes({ "foo" => "boo" })
@second_role.override_attributes({ "baz" => "bux" })
expect(@expansion.default_attrs).to eq({ "foo" => "bar" })
expect(@expansion.override_attrs).to eq({ "baz" => "qux" })
node.run_list << "test" << "test::one" << "test::two"
it "has a node" do
let(:declared_type) { :alpaca }
let(:recipe) { "dependency1::default" }
f = Chef::Resource::File.new("hi", child)
src = Chef::Resource::File.new("hi", child)
dest = Chef::Resource::File.new("argh", child)
it "has a name" do
expect(@role.name("ops_master")).to eq("ops_master")
@role.name("base")
expect(@role.run_list_for("_default")).to eq(@role.run_list)
expect(@role.run_list_for("qa")).to eq(@role.run_list)
expect(@role.recipes(%w{one two})).to eq(%w{one two})
@role.recipes(%w{one two})
expect(@role.recipes).to eq(%w{one two})
expect(@role.default_attributes({ one: "two" })).to eq({ one: "two" })
@role.default_attributes({ one: "two" })
expect(@role.default_attributes).to eq({ one: "two" })
expect(@role.override_attributes({ one: "two" })).to eq({ one: "two" })
@role.override_attributes({ one: "two" })
expect(@role.override_attributes).to eq({ one: "two" })
expect(Chef::JSONCompat.to_json(@role)).to match(/^\{.+\}$/)
let(:jsonable) { @role }
@role.default_attributes({ "el_groupo" => "nuevo" })
%w{
}.each do |t|
expect(@deserial.send(t.to_sym)).to eq(@role.send(t.to_sym))
expect(IO).to receive(:read).with(file_path).and_return('{"name": "ceiling_cat", "json_class": "Chef::Role" }')
expect(IO).to receive(:read).with(js_path).and_return('{"name": "ceiling_cat", "json_class": "Chef::Role" }')
let(:root) { windows? ? "C:/path1" : "/path1" }
expect(IO).to receive(:read).with("#{root}/lolcat.json").and_return('{"name": "ceiling_cat", "json_class": "Chef::Role" }')
expect(IO).to receive(:read).with("#{root}/path2/lolcat.json").and_return('{"name": "ceiling_cat", "json_class": "Chef::Role" }')
let(:resource_sans_id) { Chef::Resource.new("my-name") }
expect(resource.name %w{a b}).to eql("a, b")
expect(resource.delayed_notifications.detect { |e| e.resource.name == "coffee, tea" && e.action == :reload }).not_to be_nil
expect(zr.delayed_notifications.detect { |e| e.resource.name == "funk" && e.action == :reload }).not_to be_nil
r = c.new("hi")
r.declared_type = :d
let(:resource_class) { Class.new(Chef::Resource) { property :a, default: 1 } }
resource.only_if { snitch_var1 = 1 }
resource.only_if { snitch_var2 = 2 }
resource.only_if("true", cwd: "/tmp")
expect(resource.only_if.first.command_opts).to eq({ cwd: "/tmp" })
resource.not_if { puts "foo" }
resource.not_if("pwd" , cwd: "/tmp")
expect(resource.not_if.first.command_opts).to eq({ cwd: "/tmp" })
resource1.not_if { snitch_var1 = 2 }
resource1.not_if { snitch_var2 = 2 }
let(:klz) { Class.new(Chef::Resource) }
it "adds mappings for all platforms", ruby: "< 2.7" do
:tape_deck, Chef::Resource::Klz, {}
it "adds mappings for all platforms", ruby: ">= 2.7" do
let(:klz1) { Class.new(Chef::Resource) }
let(:klz2) { Class.new(Chef::Resource) }
let(:klz3) { Class.new(Chef::Resource) }
let(:action) { :create }
let(:resource) { resource_class.new("test", nil) }
before { resource.action("two") }
before { resource.action(%i{two one}) }
it { is_expected.to eq %i{two one} }
before { resource.action = :one }
before { resource.action = %i{two one} }
let(:default_action) {}
let(:default_action) { :one }
let(:default_action) { "one" }
let(:default_action) { %i{two one} }
let(:klass) { Class.new(Chef::Resource) }
it "can be set to true" do
Chef::Recipe.new("hjk", "test", run_context)
let!(:original_umask) { ::File.umask }
it "is a no-op on Windows" do
actual_value = block_value.to_s(8).rjust(4, "0")
it "#resolve" do
it "#list" do
let(:rest_client) { double("Chef::ServerAPI (mock)") }
let(:new_resource) { Chef::Resource::File.new("/tmp/a-file.txt") }
let(:current_resource) { Chef::Resource::File.new("/tmp/a-file.txt") }
let(:run_context) { Chef::RunContext.new(node, {}, events) }
let(:start_time) { Time.new }
let(:end_time) { Time.new + 20 }
let(:run_list) { Chef::RunList.new }
let(:run_id) { run_status.run_id }
let(:cookbook_name) { "monkey" }
let(:cookbook_version) { double("Cookbook::Version", version: "1.2.3") }
allow(rest_client).to receive(:raw_request).and_return({ "result" => "ok" })
allow(rest_client).to receive(:post).and_return({ "uri" => "https://example.com/reports/nodes/spitfire/runs/#{@run_id}" })
allow(@bad_resource).to receive(:name).and_return({ foo: :bar })
allow(@bad_resource).to receive(:path).and_return({ foo: :bar })
@bad_resource = Chef::Resource::File.new("/tmp/a-file.txt")
it "sets before to {} instead of nil" do
it "sets after to {} instead of 'Running'" do
@response = Net::HTTPNotFound.new("a response body", "404", "Not Found")
.with("reports/nodes/spitfire/runs", { action: :start, run_id: @run_id,
start_time: start_time.to_s },
.with("reports/nodes/spitfire/runs", { action: :start, run_id: @run_id, start_time: start_time.to_s },
response = { "uri" => "https://example.com/reports/nodes/spitfire/runs/@run_id" }
response = { "result" => "ok" }
expect(headers).to eq({ "Content-Encoding" => "gzip",
})
dummy_no_desc: nil })
defn.define(:smoke, cigar: "cuban", cigarette: "marlboro") {}
expect(defn.to_s).to eql("woot")
rc.each do |r|
rc.each_index do |i|
rc << zmr
check_by_names(results, "monkey", "dog")
it "should find resources of multiple kinds (:zen_master => a, :file => b)" do
res = Chef::Resource.new("foo", nil)
let(:jsonable) { rc }
let(:parent_run_context) { Chef::RunContext.new(node, {}, nil) }
a.content("foo")
b.content("bar")
expect(results.detect { |res| res.name == res_name }).not_to eql(nil)
%w{dog cat monkey}.each do |n|
rc << Chef::Resource::File.new("something")
sum = 0
sum += int
collected = {}
expect(collected).to eq({ 0 => 1, 1 => 2, 2 => 3, 3 => 4 })
@collection << lambda { @snitch_var = 23 }
@collection << lambda { @snitch_var = 42 }
@collection.insert(2, lambda { @snitch_var = 815 })
let(:zen_master_name) { "Neo" }
let(:zen_master2_name) { "Morpheus" }
let(:zen_follower_name) { "Squid" }
it "should find resources of multiple kinds (:zen_master => a, :zen_follower => b)" do
let(:zen_master_name) { "" }
expect(results.detect { |r| r.name == name }).to_not eq(nil)
current += 1
os: "linux",
flush_hash = { before: false, after: false }
flush_hash = { before: true, after: true }
let(:resource) { Chef::Resource::YumPackage.new("foo") }
it "supports :add, :set, :clear, :remove actions" do
expect { resource.send(:validate_start_time, "2:30", :once) }.to raise_error(ArgumentError, "`start_time` property must be in the HH:mm format (e.g. 6:20pm -> 18:20).")
expect(resource.send(:sec_to_dur, 0)).to eql("PT0S")
expect(resource.send(:sec_to_dur, 1)).to eql("PT1S")
expect(resource.path).to eql("C:\\chef")
resource.path("C:\\chef")
{ 2 => :automatic, 3 => :manual, 4 => :disabled }.each_pair do |k, v|
it "it coerces startup_type property #{type} to :#{type}" do
resource.send("#{prop}=", "some value")
resource.send("#{prop}=", 1)
resource.send("#{prop}=", true)
os: "windows",
let(:resource_source) { "https://foo.bar/solitare.msi" }
it "sets a group" do
it "sets #{prop} to nil" do
it "sets #{prop} to false" do
%w{uid gid}.each do |attrib|
let(:resource) { Chef::Resource::User.new("root") }
double("shell_out", stdout: "UTC\n", exitstatus: 0, error?: false)
double("shell_out", exitstatus: 0, error?: false, stdout: <<-OUTPUT)
double("shell_out!", stdout: "Time Zone: UTC", exitstatus: 0, error?: false)
resource.helper(:example_1) { "example_1" }
resource.helper(:example_2) { "example_2" }
modules.each { |m| o.extend(m) }
expect(o.shout("shout")).to eq("SHOUT")
it "coerces filename property values . & ~ to __" do
os: "solaris2",
os: "linux"
let(:resource) { Chef::Resource::Service.new("chef") }
it "supports :disable, :enable, :mask, :reload, :restart, :start, :stop, :unmask actions" do
resource.pattern(/.*/)
param_hash = { something: nil }
support_hash = { status: nil, restart: nil, reload: nil }
support_hash = { status: true, restart: true }
let(:semanage_list) { double("shellout", stdout: "") }
expect(resource.roles).to eq(%w{a b c})
expect(provider.semanage_user_args).to eq(" -L s0 -r s0 -R 'staff_r sysadm_r'")
expect(provider.semanage_user_args).to eq(" -L s0 -R 'staff_r sysadm_r'")
expect(provider.semanage_user_args).to eq(" -r s0 -R 'staff_r sysadm_r'")
file_type = "te"
it "checks 'a', 'f', 'd', 'c', 'b', 's', 'l', 'p' as valid file_type property values" do
let(:selinux_state) { double("shellout!", stdout: "permissive") }
let(:resource_name) { :script }
it "supports :checkout, :diff, :export, :log, :sync actions" do
let(:ten_seconds) { 10 }
let(:test_environment) { { "CHEF_ENV" => "/tmp" } }
name: :git,
let(:resource) { Chef::Resource::Git.new("fakey_fakerton") }
end.call).to eql("foo")
%w{linux aix}.each do |os|
os: os
let(:resource) { Chef::Resource::RpmPackage.new("foo") }
let(:resource) { Chef::Resource::Route.new("10.0.0.10") }
let(:run_context) { Chef::RunContext.new(node, {}, event_dispatch) }
let(:cmd) { double("cmd") }
let(:serials) { { "pool1" => "serial1", "pool2" => "serial2" } }
let(:with_katello) { double("shell_out", stdout: <<~RPM) }
let(:without_katello) { double("shell_out", stdout: "") }
let(:satellite_host) { "sat-host" }
let(:train) {
resource.address = "192.0.2.1"
response = "{ data: nil }"
address: "192.0.2.1",
name: "set_address",
expect(provider.rest_identity_values).to eq({ "ip" => "192.0.2.1" })
let(:address_exists) { JSON.generate({ "address": "192.0.2.1", "prefix": 24, "gateway": "192.0.2.1" }) }
let(:prefix_wrong) { JSON.generate({ "address": "192.0.2.1", "prefix": 25, "gateway": "192.0.2.1" }) }
.to_return(status: 200, body: address_exists, headers: { "Content-Type" => "application/json" })
.to_return(status: 200, body: prefix_wrong, headers: { "Content-Type" => "application/json" })
.with(
body: "{\"address\":\"192.0.2.1\",\"prefix\":25}",
headers: {
body: "{\"address\":\"192.0.2.1\",\"prefix\":24,\"ip\":\"192.0.2.1\"}"
.to_return(status: 404, body: "", headers: {})
.to_return(status: 200, body: "", headers: {})
expect(provider.rest_identity_values).to eq({ "address" => "192.0.2.1" })
@long_cat = Chef::Resource::Cat.new("long_cat")
@cheez_cat = Chef::Resource::Cat.new("cheez_cat")
resource.source("file:///C:/foo bar")
resource.values( { name: "poosh", type: :string, data: "carmen" } )
resource.values( { name: "poosh", type: :binary, data: 255.chr * 1 })
it "allows #{arch} as a symbol" do
let(:resource) { Chef::Resource::Reboot.new("reboot me!") }
it "provider_name accepts 'Programs', 'msi', 'NuGet', 'msu', 'PowerShellGet', 'psl', 'chocolatey', 'winget'" do
expect(resource.plistbuddy_command(:print, "Foo Bar Baz", "path/to/file.plist")).to eq "/usr/libexec/PlistBuddy -c 'Print :\"Foo Bar Baz\"' \"path/to/file.plist\""
expect(resource.plistbuddy_command(:add, "Foo Bar Baz", "path/to/file.plist", true)).to eq "/usr/libexec/PlistBuddy -c 'Add :\"Foo Bar Baz\" bool' \"path/to/file.plist\""
let(:resource) { Chef::Resource::Package.new("emacs") }
resource.options "-a -b 'arg with spaces' -b \"and quotes\""
test_profile = { "profile" => false }
<?xml version="1.0" encoding="UTF-8"?>
<plist version="1.0">
<dict>
</dict>
</array>
</plist>
{}
it "has a default key_type of 'ec'" do
it "has a default key_type of 'rsa'" do
it "has a default mode of '0640'" do
it "has a default mode of '0600'" do
mock_ohai = {
fqdn: @fqdn,
data2: {
expect(resource.mount_point).to eql("127.0.0.1:/")
it "sets fsck_device to '-' by default" do
support_hash = { remount: false }
support_hash = { remount: true }
os: "mac_os_x"
let(:test_value) { "fakest_key_value" }
let(:test_key) { "fakest_key" }
let(:resource) {
let(:log_str) { "this is my string to log" }
let(:resource) { Chef::Resource::Log.new(log_str) }
it "has a name of log" do
let(:resource) { Chef::Resource::Log.new("ery day I'm loggin-in") }
it "is non empty" do
expect { resource.lc_env({ "LC_TIME" => "" }) }.to raise_error(validation)
expect { resource.lc_env({ "LC_TIME" => " XX" }) }.to raise_error(validation)
expect { resource.lc_env({ "LC_TIMES" => " XX" }) }.to raise_error(validation)
expect { resource.lc_env({ "Lc_Time" => " XX" }) }.to raise_error(validation)
expect(provider.new_content.split("\n").map { |x| x.split("=") }.collect(&:first)).to eq(%w{LANG LC_MESSAGES LC_TIME})
let(:resource) { Chef::Resource::Ksh.new("fakey_fakerton") }
Chef::RunContext.new(node, {}, events).tap do |rc|
{ "ssh-01": {
} }
{ "ssh-01" => {
resource.name "acme_comp.*::ssh.*"
resource.name "evil_comp.*::etcd.*"
it "loads a Hash" do
{ "ssh_custom_path": "/whatever2" }
{ ssh_custom_path: "/whatever2" }
it "supports :delete, :get, :head, :options, :patch, :post, :put actions" do
resource.headers({ "head" => "tail" })
let(:brew_update_cmd) { %w{homebrew update} }
let(:user) { "Captain Picard" }
let(:user) { 1001 }
it "(#{method}) allows an Array" do
it "(#{method}) does not allow a Hash" do
let(:resource) { Chef::Resource::GemPackage.new("foo") }
let(:t_block) { Proc.new { true } }
let(:f_block) { Proc.new { false } }
let(:path_block) { Proc.new { |path| path } }
let(:temp_path) { "/tmp/foobar" }
let(:parent_resource) { Chef::Resource.new("llama") }
v = Chef::Resource::File::Verification.new(parent_resource, nil, {}) {}
expect { v.verify("/foo/bar") }.to_not raise_error
expect { v.verify("/foo/bar", { future: true }) }.to_not raise_error
expect(v.to_s).to eq("<Proc>")
it "raises an error when \%{file} is used" do
expect(v.to_s).to eq("some command --here")
@valid_yaml = "valid-#{Time.now.to_i}.yaml"
f = File.new(@valid_yaml, "w")
@invalid_yaml = "invalid-#{Time.now.to_i}.yaml"
f = File.new(@invalid_yaml, "w")
@empty_yaml = "empty-#{Time.now.to_i}.yaml"
File.new(@empty_yaml, "w").close
let(:command) { "#{systemd_analyze_path} verify %{path}" }
let(:opts) { { future: true } }
let(:systemd_dir) { "/etc/systemd/system" }
let(:temp_path) { "/tmp" }
let(:unit_name) { "sysstat-collect.timer" }
let(:unit_path) { "#{systemd_dir}/#{unit_name}" }
let(:unit_temp_path) { "#{systemd_dir}/.chef-#{unit_name}" }
let(:unit_test_path) { "#{temp_path}/#{unit_name}" }
.with("chef-systemd-unit") { |&b| b.call temp_path }
.and_return("foo")
@valid_json = "valid-#{Time.now.to_i}.json"
f = File.new(@valid_json, "w")
f.write('{
}')
@invalid_json = "invalid-#{Time.now.to_i}.json"
f = File.new(@invalid_json, "w")
f.write("{
}")
@empty_json = "empty-#{Time.now.to_i}.json"
File.new(@empty_json, "w").close
let(:password) { "password" }
let(:domain) { nil }
let(:username) { "user@domain" }
let(:username) { "domain\\user" }
let(:username) { 499 }
let(:username) { nil }
let(:username) { "starchild" }
let(:elevated) { false }
let(:domain) { "mothership" }
let(:password) { "we.funk!" }
let(:username) { "user@domain@domain" }
let(:domain) { "some_domain" }
let(:elevated) { true }
let(:username) { "user" }
let(:resource_name) { "DSCTest" }
let(:configuration_data) { '@{AllNodes = @( @{ NodeName = "localhost"; PSDscAllowPlainTextPassword = $true })}' }
let(:dsc_test_resource_name) { "DSCTest" }
let(:dsc_test_resource_module_version) { "2.7.2" }
let(:dsc_test_timeout) { 101 }
it "has a default action of `:run`" do
let(:resource) { Chef::Resource::DnfPackage.new("foo") }
resource.path("/tmp/foo/bar/")
let(:resource) { Chef::Resource::Csh.new("fakey_fakerton") }
let(:resource) { Chef::Resource::Cron.new("cronify") }
expect(resource.send(x, "*")).to eql("*")
expect(resource.send(x, "1-2,5")).to eql("1-2,5")
expect(resource.send(x)).to eql("*")
let(:resource) { Chef::Resource::CronAccess.new("bob") }
@status.send(:"success?=", false)
<?xml version="1.0" encoding="utf-8"?>
</config>
</sources>
<apiKeys />
let(:resource) { Chef::Resource::ChefSleep.new("30") }
name: :chef_gem,
let(:resource) { Chef::Resource::ChefGem.new("foo") }
Chef::RunContext.new(node, {}, nil)
let(:root_path) { windows? ? "C:\\chef/client.rb" : "/etc/chef/client.rb" }
expect(provider.chef_client_cmd).to eql("/opt/chef/bin/chef-client --foo 1 --bar 2 -c #{root_path}")
resource.environment({ "foo" => "bar" })
it "set splay to 0" do
expect(provider.splay_sleep_time(300)).to satisfy { |v| v >= 0 && v <= 300 }
expect(provider.client_cmd).to eql("C:/foo/bar/chef-client -L /etc/chef/log/client.log -c /etc/chef/client.rb") | eql("C:/foo/bar/chef-client -L C:\\chef/log/client.log -c C:\\chef/client.rb")
expect(resource.name).to match(/breakpoint_spec\.rb\:\d{2}\:in \`new\'$/)
let(:resource_name) { :batch }
let(:interpreter_file_name) { "cmd.exe" }
let(:path) { File.expand_path("/tmp/foo.zip") }
let(:entry_time) { Time.new(2021, 5, 25, 2, 2, 0, "-05:00") }
let(:older_time) { entry_time - 100 }
let(:newer_time) { entry_time + 100 }
expect(FileUtils).to receive(:chown).with("root", "root", "#{destination}/folder-1/")
let(:resource) { Chef::Resource::AptPackage.new("foo") }
cookbook_repo = File.expand_path(File.join(__dir__, "..", "data", "cookbooks"))
%w{monkey dog cat}.each do |name|
recipe.tag "foo", "bar"
recipe.untag "bar", "foo"
---
- one
- type: "execute"
{ "name" => "running some commands", "type" => "execute", "command" => "whoami" },
{ "name" => "preparing the bits", "type" => "service", "action" => "start", "service_name" => "bit_launcher" },
let(:app) { Chef::Application.new }
pub:-:2048:1:ABF5BD827BD9BF62:1313747554:1718374819::-:::scSC::::::23::0:
gpg (GnuPG) 2.2.20
let(:logger) { double("Mixlib::Log::Child").as_null_object }
let(:gpg_20) do
let(:gpg_22) do
let(:gpg_ver) do
result = {
start_day: 2,
end_month: 0,
end_day: 0,
end_year: 0,
type: { once: nil },
expect(result).to eq({ once: nil })
expect(result).to eq({ days_interval: 2 })
expect(result).to eq({ weeks_interval: 2, days_of_week: 4 })
expect(result).to eq({ months: 4095, days: 1 })
expect(result).to eq({ months: 4095, days_of_week: 4, weeks_of_month: 7 })
it "returns the binary value 127 if day is set as 'Mon, tue, wed, thu, fri, sat, sun'" do
new_resource.day "Mon, tue, wed, thu, fri, sat, sun"
it "returns the binary value 4095 if day is set as 'jan, Feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec'" do
new_resource.months "jan, Feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec"
expect(provider.send(:get_day, "01/02/2018")).to eq("TUE")
@new_resource.user("<System>")
@new_resource.delim ";"
@new_resource.value("C:/baz/bin")
@new_resource.value("C:/foo/bin")
@new_resource.value("C:/foo/bin;C:/bar/bin")
@new_resource.value("C:/bar")
@new_resource.delim(";")
@current_resource.value("C:/bar;C:/foo;C:/baz")
@current_resource.value("C:/biz;C:/foo/bin;C:/baz")
@new_resource.value("C:/biz;C:/baz")
@new_resource.value("C:/biz;C:/baz;C:/bin")
@current_resource.value("C:/baz;C:/foo/bin;C:/biz")
new_value = "C:/bar/bin"
@new_resource.value("C:/foo;C:/bar;C:/baz")
@current_resource.value("C:/bar;C:/baz;C:/foo/bar")
expect(@new_resource.value).to eq("C:/foo;C:/bar;C:/baz;C:/foo/bar")
@current_resource.value("C:/foo/bar;C:/baz;C:/bar")
let(:system_root) { "%SystemRoot%" }
let(:system_root_value) { "D:\\Windows" }
stub_const("ENV", { "PATH" => "" })
EtcPwnamIsh = Struct.new(:name, :passwd, :uid, :gid, :gecos, :dir, :shell, :change, :uclass, :expire)
EtcGrnamIsh = Struct.new(:name, :passwd, :gid, :mem)
@pw_user.gid = 1000
@pw_user.uid = 1000
@pw_user.shell = "/usr/bin/zsh"
@pw_user.passwd = "*"
user_attrib_map = {
uid: :uid,
gid: :gid,
home: :dir,
user = @pw_user.dup
user.name = "root"
user.passwd = "x"
sp_warn: 7, sp_inact: -1, sp_expire: -1, sp_flag: -1)
%w{uid gid}.each do |property|
@net_user = double("Chef::Util::Windows::NetUser")
it "should not pass -r" do
expect(provider).to receive(:shell_out_compacted!).with( "useradd", "-m", "adam")
let(:user_lock) { "adam:FOO:::::::" }
user1:LK:::::::
user2:NP:::::::
let(:user_lock) { "other_user:FOO:::::::" }
context "for user 'adam' with entry '#{shadow}'" do
let(:user_lock) { shadow }
shell_return = shellcmdresult.new("", "", 0)
field_list = {
match_array << "hola"
match_array << "-m"
expect(@provider).to receive(:shell_out_compacted!).with( "pw", "useradd", "adam", "-m").and_return(true)
expect(@provider).to receive(:shell_out_compacted!).with( "pw", "usermod", "adam", "-m").and_return(true)
let(:new_resource) { Chef::Resource::User::MacUser.new("jane") }
cr.home "/home/adam"
expect(provider).to receive(:shell_out_compacted!).with("useradd", "-g", "system", "adam")
allow(provider).to receive(:shell_out_compacted!).with("usermod", "-d", "/home/adam", "adam")
allow(provider).to receive(:shell_out_compacted!).with("usermod", "-d", "/mnt/home/adam", "adam")
expect(FileUtils).to receive(:mv).with("/home/adam", "/mnt/home/adam")
it "should not pass -m" do
expect(provider).to receive(:shell_out_compacted!).with("usermod", "-d", "/home/adam", "adam")
variables: {},
name: "helpers.erb",
let(:unit_name) { "sysstat-collect\\x2d.timer" }
let(:user_name) { "joe" }
user: "joe",
.with(systemctl_path, "--user", "daemon-reload", **user_cmd_opts, default_env: false)
.with(systemctl_path, "--user", "preset", unit_name, **user_cmd_opts)
.with(systemctl_path, "--user", "revert", unit_name, **user_cmd_opts)
.with(systemctl_path, "--system", "preset", unit_name)
.with(systemctl_path, "--system", "revert", unit_name)
.with(systemctl_path, "--user", "reenable", unit_name, **user_cmd_opts)
.with(systemctl_path, "--user", "enable", unit_name, **user_cmd_opts)
.with(systemctl_path, "--user", "disable", unit_name, **user_cmd_opts)
.with(systemctl_path, "--system", "reenable", unit_name)
.with(systemctl_path, "--system", "enable", unit_name)
.with(systemctl_path, "--system", "disable", unit_name)
.with(systemctl_path, "--user", "mask", unit_name, **user_cmd_opts)
.with(systemctl_path, "--user", "unmask", unit_name, **user_cmd_opts)
.with(systemctl_path, "--system", "mask", unit_name)
.with(systemctl_path, "--system", "unmask", unit_name)
.with(systemctl_path, "--user", "start", unit_name, **user_cmd_opts, default_env: false)
.with(systemctl_path, "--user", "stop", unit_name, **user_cmd_opts, default_env: false)
.with(systemctl_path, "--system", "start", unit_name, default_env: false)
.with(systemctl_path, "--system", "stop", unit_name, default_env: false)
.with(systemctl_path, "--user", "restart", unit_name, **user_cmd_opts, default_env: false)
.with(systemctl_path, "--user", "reload", unit_name, **user_cmd_opts, default_env: false)
.with(systemctl_path, "--user", "try-restart", unit_name, **user_cmd_opts, default_env: false)
.with(systemctl_path, "--user", "reload-or-restart", unit_name, **user_cmd_opts, default_env: false)
nil_and_inactive_h = {
expect(@provider.run_options).to eq({ user: "deployninja", environment: { "HOME" => "/home/deployninja" } })
@stdout = double("stdout")
@stderr = double("stderr")
expect(::File).to receive(:exist?).with("/my/deploy/dir/.svn").and_return(false)
example_svn_info = "Path: .\n" +
expect(::File).to receive(:exist?).with("/my/deploy/dir/.svn").and_return(true)
allow(::File).to receive(:exist?).with("/my/deploy/dir/.svn").and_return(false)
allow(::File).to receive(:exist?).with("/my/deploy/dir").and_return(true)
expect(@provider).to receive(:shell_out!).with(expected_cmd, { user: "whois", group: "thisis", environment: { "HOME" => "/home/whois" } })
let(:http_proxy_uri) { "http://somehost:1" }
let(:http_no_proxy) { "svn.example.org" }
let(:repository_url) { "http://svn.example.org/trunk/" }
let(:repository_url) { "https://svn.example.org/trunk/" }
let(:chef_service_name) { "chef-client" }
load_order_group: "",
tag_id: 0,
wait_hint: 0,
pid: 0,
it "does not set #{prop}" do
provider.new_resource.send("#{attr}=", "new value")
provider.new_resource.send("#{attr}=", 2)
let(:start_command) { "sc start #{chef_service_name}" }
let(:username) { "unit_test_user" }
@status = double("Status", exitstatus: 0, stdout: "", stderr: "")
@new_resource.parameters({ "OSD_ID" => "2" })
let(:service_name) { "rsyslog\\x2d.service" }
let(:service_name_escaped) { "rsyslog\\\\x2d.service" }
double("shell_out", exitstatus: 0, error?: false, stdout: "")
double("shell_out", exitstatus: 1, error?: true, stdout: "")
@enabled_svc_status = double("Status", exitstatus: 0, stdout: enabled_svc_stdout, stdin: "", stderr: "")
@disabled_svc_status = double("Status", exitstatus: 0, stdout: disabled_svc_stdout, stdin: "", stderr: "")
@no_svc_status = double("Status", exitstatus: 1, stdout: "", stdin: "", stderr: "svcs: Pattern 'chef' doesn't match any instances\n")
@success = double("clear", exitstatus: 0, stdout: "", stdin: "", stderr: "")
expect(@provider).to receive(:shell_out!).with("/usr/sbin/svcadm", "enable", "-s", "-r", @current_resource.service_name).and_return(@success)
expect(@provider).to receive(:shell_out!).with("/usr/sbin/svcadm", "enable", "-s", "-r", "-t", @current_resource.service_name).and_return(@success)
expect(@provider).to receive(:shell_out!).with("/usr/sbin/svcadm", "disable", "-s", "chef").and_return(@success)
expect(@provider).to receive(:shell_out!).with("/usr/sbin/svcadm", "disable", "-s", "-t", "chef").and_return(@success)
expect(@provider).to receive(:shell_out!).with("/usr/sbin/svcadm", "refresh", "chef")
status = double("Status", exitstatus: 0, stdout: "" , stderr: "")
@new_resource.supports( { status: false } )
@new_resource.send("#{action}_command", "/etc/init.d/chef #{action}")
let(:supports) { { status: false } }
allow(::File).to receive(:read).with("/etc/rc.conf").and_return("")
allow(::File).to receive(:read).with("/etc/rc.conf.local").and_return("")
let(:status) { double(stdout: "", exitstatus: 0) }
let(:supports) { { status: true } }
expect(::File).to receive(:open).with("/etc/rc.d/#{new_resource.service_name}")
let(:supports) { { restart: true } }
expect(::File).to receive(:write).with("/etc/rc.conf.local", /^(?!#{provider.builtin_service_enable_variable_name})$/)
provider.rc_conf = ""
expect(::File).to receive(:write).with("/etc/rc.conf.local", "\npkg_scripts=\"#{new_resource.service_name}\"\n")
expect(::File).to receive(:write).with("/etc/rc.conf.local", /^(?!#{new_resource.service_name})$/)
let(:plutil_stdout) { String.new <<~XML }
<key>Label</key>
let(:session) { StringIO.new }
if service_type == "Agent"
let(:session) { "-S Aqua " }
let(:su_cmd) { "su -l igor -c" }
@stat = double("File::Stat", { uid: 501 })
@getpwuid = double("Etc::Passwd", { name: "mikedodge04" })
.with(/(#{su_cmd} '#{cmd}'|#{cmd})/, default_env: false)
.with(/plutil -convert xml1 -o/)
);
};
cmd = "/bin/launchctl load -w " + session + plist
.with(/(#{su_cmd} .#{cmd}.|#{cmd})/, default_env: false)
cmd = "/bin/launchctl unload -w " + plist
@stdout = StringIO.new(<<~PS)
@status = double("Process::Status mock", exitstatus: 0, stdout: "")
expect(::File).to receive(:exist?).with("/etc/rc.conf").and_return(false)
expect(::File).to receive(:exist?).with("/etc/rc.conf").and_return(true)
%Q{#{new_resource.service_name}_enable="NO"},
%Q{#{new_resource.service_name}_enable="YES"},
rcvar_stdout = <<~EOF
@pid, @stdin, @stdout, @stderr = nil, nil, nil, nil
allow(::File).to receive(:exist?).with("/etc/rc.d/chef").and_return(false)
allow(::File).to receive(:exist?).with("/etc/rc.conf").and_return(true)
allow(::File).to receive(:exist?).with("/etc/rc.conf").and_return(false)
allow(::File).to receive(:read).with("/etc/rc.conf").and_return("DAEMONS=(network !apache ssh)")
allow(::File).to receive(:read).with("/etc/rc.conf").and_return("DAEMONS=(network)")
allow(::File).to receive(:read).with("/etc/rc.conf").and_return("DAEMONS=(network chef)")
expect(@provider).to receive(:create_symlink).with(2, "S", "")
expect(@provider).to receive(:create_symlink).with(2, "K", "")
new_resource.code "$| = 1; print 'i like beans'"
expect(provider.command).to eq(%q{"perl" -f})
opts = {
input: "$| = 1; print 'i like beans'",
it "accepts `create' as an alias for `run'" do
@new_resource = Chef::Resource::Route.new("10.0.0.10")
resource = Chef::Resource::Route.new("10.10.10.0/24")
@resource_add = Chef::Resource::Route.new("192.168.1.0/24 via 192.168.0.1")
expect(route_file.string).to match(%r{^192\.168\.1\.0/24 via 192\.168\.0\.1$})
expect(@provider.generate_command(:add).join(" ")).to match(%r{/\d{1,2}})
expect(@provider.generate_command(:add).join(" ")).not_to match(%r{/\d{1,2}})
expect(@default_provider.generate_command(:add).join(" ")).to match(/10.0.0.10/)
expect(@provider.generate_command(:delete).join(" ")).to match(%r{/\d{1,2}})
expect(@provider.generate_command(:delete).join(" ")).not_to match(%r{/\d{1,2}})
expect(@provider.config_file_contents(:add, target: @new_resource.target)).not_to match(%r{/\d{1,2}.*\n$})
r.target "192.168.4.0"
r.gateway "192.168.0.1"
expect(route_file.string).to match(%r{^192\.168\.2\.0/24 via 192\.168\.0\.1$})
expect(route_file.string).to match(%r{^192\.168\.3\.0/24 via 192\.168\.0\.1$})
expect(route_file.string).to match(%r{^192\.168\.4\.0/24 via 192\.168\.0\.1$})
let(:sftp) do
sftp = double(Net::SFTP, {})
uri.userinfo = "conan:"
uri.user = "conan"
uri.path = ""
uri.path = "/"
uri.path = "/the/whole/path/"
let(:source) { "\\\\foohost\\fooshare\\Foo.tar.gz" }
let(:tempfile) { double("Tempfile", path: "/tmp/foo/bar/Foo.tar.gz", close: nil) }
let(:source_file) { double("::File", read: nil) }
let(:uri) { URI.parse("file:///nyan_cat.png") }
let(:uri) { URI.parse("file:///z:/windows/path/file.txt") }
let(:uri) { URI.parse(Addressable::URI.encode("file:///z:/windows/path/foo & bar.txt")) }
let(:uri) { URI.parse("file:////server/share/windows/path/file.txt") }
let(:uri) { URI.parse(Addressable::URI.encode("file:////server/share/windows/path/foo & bar.txt")) }
let(:tempfile) { double("Tempfile", path: "/tmp/foo/bar/nyan.png", close: nil) }
let(:uri) { URI.parse("http://opscode.com/seattle.txt") }
expect(fetcher.headers).to eq({ "x-myapp-header" => "custom-header-value" })
let(:etag) { "\"a-strong-unique-identifier\"" }
let(:mtime) { "Tue, 21 May 2013 19:19:23 GMT" }
let(:expected_http_opts) { {} }
let(:last_response) { {} }
let(:rest) do
let(:last_response) { { "etag" => nil } }
let(:last_response) { { "etag" => "abc123" } }
let(:last_response) { { "date" => nil, "last_modified" => nil } }
{ "date" => "Fri, 17 May 2013 23:23:23 GMT", "last_modified" => "Fri, 17 May 2013 11:11:11 GMT" }
{ "date" => "Fri, 17 May 2013 23:23:23 GMT", "last_modified" => nil }
let(:uri) { URI.parse("http://opscode.com/tarball.tgz") }
let(:expected_http_opts) { { disable_gzip: true } }
let(:ftp) do
ftp = double(Net::FTP, {})
let(:uri) { URI.parse("ftp://opscode.com/seattle.txt") }
uri.typecode = "d"
let(:uri) { URI.parse("ftp://opscode.com:8021/seattle.txt") }
let(:uri) { URI.parse("ftp://opscode.com/the/whole/path/seattle.txt") }
stub_const("ENV", "ftp_proxy" => "socks5://bill:ted@socks.example.com:5000")
let(:new_resource) { double("new resource") }
let(:source) { "\\\\127.0.0.1\\fooshare\\Foo.tar.gz" }
let(:uri) { double("uri", scheme: "http" ) }
let(:uri) { double("uri", scheme: "https" ) }
let(:uri) { double("uri", scheme: "ftp" ) }
let(:uri) { double("uri", scheme: "file" ) }
let(:uri) { double("uri", scheme: "xyzzy" ) }
let(:run_context) { double("Chef::RunContext") }
@uri = double("URI")
let(:mtime) { Time.now }
let(:tempfile) { double("Tempfile") }
exception_class.new("message", { "something" => 1 })
@uri0 = double("URI0")
@uri1 = double("URI1")
1 +
let(:uri) { URI.parse("http://www.google.com/robots.txt") }
let(:uri) { URI.parse("http://bob:password@example.org/") }
let(:etag) { "\"a-strong-identifier\"" }
cache = {}
let(:cache_json_data) { "" }
data = {}
let(:uri) { URI.parse(long_remote_path) }
File.open(@destination_dir + "/remote_dir_file1.txt", "a") { |f| f.puts "blah blah blah" }
File.open(@destination_dir + "/remotesubdir/remote_subdir_file1.txt", "a") { |f| f.puts "blah blah blah" }
expect(::File.exist?(@destination_dir + "/a/foo.txt")).to be_falsey
::File.open(@destination_dir + "/remote_dir_file1.txt", "a") { |f| f.puts "blah blah blah" }
::File.open(@destination_dir + "/remotesubdir/remote_subdir_file1.txt", "a") { |f| f.puts "blah blah blah" }
let(:keyname) { "HKLM\\Software\\Opscode\\Testing\\Safe" }
let(:testval1) { { name: "one", type: :string, data: "1" } }
let(:testval1_wrong_type) { { name: "one", type: :multi_string, data: "1" } }
let(:testval1_wrong_data) { { name: "one", type: :string, data: "2" } }
let(:testval2) { { name: "two", type: :string, data: "2" } }
let(:testval1) { { name: "one", type: :binary, data: 255.chr * 1 } }
let(:testval1_wrong_type) { { name: "one", type: :string, data: 255.chr * 1 } }
let(:testval1_wrong_data) { { name: "one", type: :binary, data: 254.chr * 1 } }
let(:testval2) { { name: "two", type: :binary, data: 0.chr * 1 } }
let(:keyname) { "hklm\\software\\opscode\\testing\\dword" }
let(:dword_passed_as_integer) { { name: "one", type: :dword, data: 12345 } }
let(:testval1) { { name: "one", type: :dword, data: "12345" } }
{ name: "one", type: :string, data: "initial value" },
{ name: "two", type: :dword, data: 9001 },
let(:testval1) { { name: "one", type: :string, data: "first_value" } }
let(:testval1) { { name: "two", type: :dword, data: 12345 } }
let(:events) { double("Chef::Events").as_null_object }
{ name: "input1_value2", type: :string, data: "my_value2" },
{ name: "input2_value2", data: "my_value2" },
{ name: "input3_value2", type: :string, data: "my_value2" },
{ name: "input4_value2", type: :string },
{ name: "input5_value2", type: :string },
{ name: "input6_value2" },
let(:run_context) { Chef::RunContext.new(Chef::Node.new, {}, events) }
expected = <<~CMD.strip
let(:candidate_version) { "1.0" }
let(:new_resource) { Chef::Resource::Package.new(%w{emacs vi}) }
%w{emacs vi},
expect(provider.version_compare("1.3", "1.3")).to eql(0)
expect(provider.version_compare("1.2", "1.3")).to eql(-1)
expect(provider.version_compare("1.5", "1.3")).to eql(1)
expect(provider.version_compare("1.10", "1.2")).to eql(1)
expect(provider.version_compare("1.3_3", "1.3")).to eql(0)
let(:status) { double(stdout: "\n", exitstatus: 0) }
let(:source) { "/tmp/wget_1.11.4-1ubuntu1_amd64.rpm" }
allow(provider).to receive(:`).and_return("2.0")
Mixlib::ShellOut, stdout: "1 | somethingelse | package | (any)"
))
Mixlib::ShellOut, stdout: "1 | cups | package | (any)"
allow(provider).to receive(:`).and_return("0.11.6")
expect( python_helper ).to receive(:package_query).with(:whatavailable, "foo", arch: nil).and_return( yum_version("foo", "1.2.3-1", "x86_64") )
expect( python_helper ).to receive(:package_query).with(:whatavailable, "foo", version: "1.2.3", arch: nil).and_return( yum_version("foo", nil, nil) )
expect( yum_cache.version_available?("foo", "1.2.3") ).to be false
expect( python_helper ).to receive(:package_query).with(:whatavailable, "foo", version: "1.2.3", arch: nil).and_return( yum_version("foo", "1.2.3-1", "x86_64") )
expect( yum_cache.version_available?("foo", "1.2.3") ).to be true
expect( python_helper ).to receive(:package_query).with(:whatavailable, "foo", version: "1.2.3", arch: "x86_64").and_return( yum_version("foo", nil, nil) )
expect( yum_cache.version_available?("foo", "1.2.3", "x86_64") ).to be false
expect( python_helper ).to receive(:package_query).with(:whatavailable, "foo", version: "1.2.3", arch: "x86_64").and_return( yum_version("foo", "1.2.3-1", "x86_64") )
expect( yum_cache.version_available?("foo", "1.2.3", "x86_64") ).to be true
expect( python_helper ).to receive(:package_query).with(:whatinstalled, "foo", arch: nil).and_return( yum_version("foo", "1.2.3-1", "x86_64") )
expect( yum_cache.installed_version("foo") ).to eql("1.2.3-1.x86_64")
expect( python_helper ).to receive(:package_query).with(:whatinstalled, "foo", arch: "x86_64").and_return( yum_version("foo", "1.2.3-1", "x86_64") )
expect( yum_cache.installed_version("foo", "x86_64") ).to eql("1.2.3-1.x86_64")
expect( yum_cache.available_version("foo") ).to eql("1.2.3-1.x86_64")
expect( python_helper ).to receive(:package_query).with(:whatavailable, "foo", arch: "x86_64").and_return( yum_version("foo", "1.2.3-1", "x86_64") )
expect( yum_cache.available_version("foo", "x86_64") ).to eql("1.2.3-1.x86_64")
let(:resource_name) { "calculator" }
let(:installer_type) { nil }
let(:cache_path) { "c:\\cache\\" }
installed_version: "1.0", package_version: "2.0"))
let(:uninstall_key) { "blah" }
let(:uninstall_key) { "blah_is1" }
let(:resource_source) { "setup.exe" }
let(:resource_name) { "blah" }
let(:resource_source) { "blah.exe" }
let(:installer_type) { :inno }
let(:resource_source) { nil }
let(:installer_type) { :msi }
before { new_resource.version("5.5.5") }
let(:resource_source) { "C:/a_missing_file.exe" }
let(:hkey) { :hkey } # mock all the methods
let(:key) { :key }
let(:package_name) { nil }
let(:package_name) { " " }
let(:package_name) { "hive" }
let(:package_name) { "Chef" }
let(:package_name) { "Chef Client" }
let(:display_name) { "Chef Client" }
let(:node) { double("Chef::Node") }
let(:run_context) { double("Chef::RunContext", node: node, events: events) }
let(:package_name) { "calculator" }
let(:resource_version) { nil }
expect(provider.expand_options("--train nope --town no_way")).to eql(" --train nope --town no_way")
it "calls msiexec /qn /i" do
expect(provider).to receive(:shell_out!).with(%r{msiexec /qn /i \"#{Regexp.quote(new_resource.source)}\"}, kind_of(Hash))
it "calls msiexec /qn /x" do
expect(provider).to receive(:shell_out!).with(%r{msiexec /qn /x \"#{Regexp.quote(new_resource.source)}\"}, kind_of(Hash))
expect(provider).to receive(:shell_out!).with(%r{msiexec /x {guid} /q}, kind_of(Hash))
expect(provider).to receive(:shell_out!).with(%r{msiexec /x {guid2} /q}, kind_of(Hash))
before { new_resource.options("/Q") }
expect(provider).to receive(:shell_out!).with(%r{msiexec /x {guid} /Q}, kind_of(Hash))
before { new_resource.options("/qn") }
expect(provider).to receive(:shell_out!).with(%r{msiexec /x {guid} /qn}, kind_of(Hash))
expect(provider).to receive(:shell_out!).with(%r{start \"\" /wait \"uninst_dir/uninst_file\" /S /NCRC & exit %%%%ERRORLEVEL%%%%}, kind_of(Hash))
expect(provider).to receive(:shell_out!).with(%r{start \"\" /wait \"uninst_dir2/uninst_file2\" /S /NCRC & exit %%%%ERRORLEVEL%%%%}, kind_of(Hash))
expect(provider).to receive(:shell_out!).with(%r{start \"\" /wait \"uninst_dir1/uninst_file1\" /S /NCRC & exit %%%%ERRORLEVEL%%%%}, kind_of(Hash))
@status = double("Status", stdout: "", exitstatus: 0)
expect(@provider).to receive(:shell_out_compacted).with("pkginfo", "-l", "-d", "/tmp/bash.pkg", "SUNWbash", { timeout: 900 }).and_return(status)
expect(@provider).to receive(:shell_out_compacted).with("pkginfo", "-l", "SUNWbash", { timeout: 900 }).and_return(@status)
expect(@provider).to receive(:shell_out_compacted).with("pkginfo", "-l", "-d", "/tmp/bash.pkg", "SUNWbash", { timeout: 900 }).and_return(@status)
status = double(stdout: "", exitstatus: -1)
status = double(stdout: "", exitstatus: 0)
status = double(stdout: "", exitstatus: 1)
expect(@provider).to receive(:shell_out_compacted!).with("pkgadd", "-n", "-d", "/tmp/bash.pkg", "all", { timeout: 900 })
expect(@provider).to receive(:shell_out_compacted!).with("pkgadd", "-n", "-a", "/tmp/myadmin", "-d", "/tmp/bash.pkg", "all", { timeout: 900 })
expect(@provider).to receive(:shell_out_compacted!).with("pkgrm", "-n", "SUNWbash", { timeout: 900 })
expect(@provider).to receive(:shell_out_compacted!).with("pkgrm", "-n", "-a", "/tmp/myadmin", "SUNWbash", { timeout: 900 })
let(:package) { "hello" }
let(:source) { "/tmp/hello_20.snap" }
version: 2.10 -
--foo
options = {}
let(:source) { nil }
@stdout = "varnish-2.1.5nb2\n"
@pid = 10
@shell_out = double("shell_out!", stdout: search)
expect(@provider).to receive(:shell_out_compacted!).with("/opt/local/bin/pkgin", "-y", "install", "varnish-2.1.5nb2", { env: nil, timeout: 900 }).and_return(out)
Gem::Specification.new { |s| s.name = name; s.version = version }
stubs.select! { |stub| stub.name == "rspec-core" && Gem::Dependency.new("rspec-core", ">= 0").requirement.satisfied_by?(stub.version) }
if Gem::Version.new(Gem::VERSION) >= Gem::Version.new("2.7")
dep = Gem::Dependency.new("sexp_processor", ">= 0")
dep = Gem::Dependency.new("nonexistent_gem", ">= 0")
dep = Gem::Dependency.new("lksdjflksdjflsdkfj", ">= 0")
@gem_env.uninstall("rspec", "1.2.3")
- ruby
- /Users/you/.rvm/gems/jruby-1.5.0
- :update_sources => true
- :verbose => true
- :benchmark => false
- :backtrace => false
- :bulk_threshold => 1000
- "install" => "--env-shebang"
- "update" => "--env-shebang"
- "gem" => "--no-rdoc --no-ri"
- https://rubygems.org/
- http://gems.github.com/
let(:target_version) { nil }
let(:gem_name) { "rspec-core" }
let(:gem_binary) { nil }
let(:bindir) { "/usr/bin" }
let(:options) { nil }
let(:current_resource) { nil }
_ = provider
let(:gem_binary) { "/usr/weird/bin/gem" }
let(:options) { { fail: :burger } }
let(:bindir) { "/opt/opscode/embedded/bin" }
let(:bindir) { "/opt/chef/embedded/bin" }
let(:bindir) { "d:/opscode/chef/embedded/bin" }
let(:target_version) { "~> 9000.0.2" }
let(:target_version) { "9000.0.2" }
let(:gem_name) { "no-such-gem-should-exist-with-this-name" }
let(:target_version) { ">= 0" }
.and_return(Gem::Version.new("9000.0.2"))
.with(gem_dep, "https://mirror1/")
let(:source) { "http://mygems.example.com" }
.with(gem_dep, *source)
let(:gem_name) { "chef-integration-test" }
let(:source) { CHEF_SPEC_DATA + "/gems/chef-integration-test-0.1.0.gem" }
let(:current_version) { nil }
let(:candidate_version) { "9000.0.2" }
let(:source) { "http://gems.example.org" }
let(:gem_name) { CHEF_SPEC_DATA + "/gems/chef-integration-test-0.1.0.gem" }
let(:options) { "-i /alt/install/location" }
expected = "gem install rspec-core -q --no-document -v \"#{target_version}\" --source=https://rubygems.org #{options}"
expected = "gem install rspec-core -q --no-rdoc --no-ri -v \"#{target_version}\" --source=https://rubygems.org #{options}"
let(:gem_binary) { "/foo/bar" }
expected = "#{gem_binary} install rspec-core -q --no-document -v \"#{target_version}\" --clear-sources --source=https://mirror1"
let(:source) { "http://mirror.ops.rhcloud.com/mirror/ruby" }
expected = "#{gem_binary} install rspec-core -q --no-document -v \"#{target_version}\" --clear-sources --source=#{source}"
expected = "#{gem_binary} install rspec-core -q --no-document -v \"#{target_version}\" --clear-sources --source=#{source} --source=https://rubygems.org"
expected = "#{gem_binary} install rspec-core -q --no-document -v \"#{target_version}\" --clear-sources --source=https://mirror1 --source=https://mirror2"
expected = "#{gem_binary} install rspec-core -q --no-document -v \"#{target_version}\" --clear-sources --source=https://mirror1 --source=https://mirror2 --source=https://rubygems.org"
expected = "#{gem_binary} install rspec-core -q --no-document -v \"#{target_version}\" --source=#{source}"
expected = "gem install rspec-core -q --no-document -v \"#{candidate_version}\" --source=https://rubygems.org #{options}"
let(:options) { { install_dir: "/alt/install/location" } }
let(:target_version) { ">=2.3.0" }
let(:current_version) { "2.3.3" }
let(:target_version) { "~>2.3.0" }
expect(provider).to receive(:shell_out_compacted!).with("#{gem_binary} install rspec-core -q --no-rdoc --no-ri -v \"#{target_version}\" --source=https://rubygems.org", env: nil, timeout: 900)
expect(provider).to receive(:shell_out_compacted!).with("#{gem_binary} install #{source} -q --no-document -v \"#{target_version}\"", env: nil, timeout: 900)
expect(provider).to receive(:shell_out_compacted!).with("#{gem_binary} install #{gem_name} -q --no-document -v \"#{target_version}\"", env: nil, timeout: 900)
let(:gem_name) { "rspec" }
let(:current_version) { "1.2.3" }
let(:target_version) { "1.2.3" }
let(:package_source) { "/tmp/ImageMagick-c++-6.5.4.7-7.el6_5.x86_64.rpm" }
let(:package_name) { "ImageMagick-c++" }
let(:package_source) { "foobar://example.com/ImageMagick-c++-6.5.4.7-7.el6_5.x86_64.rpm" }
.with("rpm", "-qp", "--queryformat", "%{NAME} %{VERSION}-%{RELEASE}\n", package_source, timeout: 900)
.with("rpm", "-q", "--queryformat", "%{NAME} %{VERSION}-%{RELEASE}\n", package_name, timeout: 900)
let(:rpm_qp_stdout) { "ImageMagick-c++ 6.5.4.7-7.el6_5" }
let(:rpm_q_stdout) { "" }
let(:rpm_qp_exitstatus) { 0 }
let(:rpm_q_exitstatus) { -1 }
let(:rpm_q_stdout) { "ImageMagick-c++ 6.5.4.7-7.el6_5" }
let(:rpm_q_exitstatus) { 0 }
let(:action) { :install }
expect(provider).to_not receive(:shell_out_compacted!).with("rpm", "-i", "/tmp/imagemagick-c++-6.5.4.7-7.el6_5.x86_64.rpm", timeout: 900)
let(:rpm_q_stdout) { "imagemagick-c++ 0.5.4.7-7.el6_5" }
expect(provider).to receive(:shell_out_compacted!).with("rpm", "-U", "--oldpackage", "/tmp/ImageMagick-c++-6.5.4.7-7.el6_5.x86_64.rpm", timeout: 900)
let(:rpm_q_stdout) { "imagemagick-c++ 21.4-19.el6_5" }
let(:action) { :upgrade }
let(:action) { :remove }
expect(provider).to receive(:shell_out_compacted!).with("rpm", "-e", "ImageMagick-c++-6.5.4.7-7.el6_5", timeout: 900)
let(:package_name) { "supermarket" }
let(:package_source) { "/tmp/supermarket-1.10.1~alpha.0-1.el5.x86_64.rpm" }
let(:rpm_qp_stdout) { "supermarket 1.10.1~alpha.0-1.el5" }
let(:rpm_q_stdout) { "supermarket 1.10.1~alpha.0-1.el5" }
let(:package_name) { "chef-server-core" }
let(:package_source) { "#{scheme}://example.com/ImageMagick-c++-6.5.4.7-7.el6_5.x86_64.rpm" }
let(:package_name) { "openssh-askpass" }
let(:package_source) { "/tmp/openssh-askpass-1.2.3-4.el6_5.x86_64.rpm" }
let(:rpm_qp_stdout) { "openssh-askpass 1.2.3-4.el6_5" }
expect(provider).to receive(:shell_out_compacted!).with("rpm", "--dbpath", "/var/lib/rpm", "-i", package_source, timeout: 900)
expect(provider).to_not receive(:shell_out_compacted!).with("rpm", "-e", "ImageMagick-c++-6.5.4.7-7.el6_5", timeout: 900)
expect(provider).to receive(:shell_out_compacted!).with("rpm", "-i", "/tmp/ImageMagick-c++-6.5.4.7-7.el6_5.x86_64.rpm", timeout: 900)
provider.install_package("/tmp/ImageMagick-c++-6.5.4.7-7.el6_5.x86_64.rpm", "6.5.4.7-7.el6_5")
provider.upgrade_package("/tmp/ImageMagick-c++-6.5.4.7-7.el6_5.x86_64.rpm", "6.5.4.7-7.el6_5")
let(:timeout) { 900 }
double("powershell_exec", result: "2.1.0.0\r\n")
double("powershell_exec", result: "2.0.0.0\r\n")
double("powershell_exec", result: "2.12.0.0\r\n")
double("powershell_exec", result: "2.11.0.0\r\n")
double("powershell_exec", result: "16.02\r\n")
let(:timeout) { 3600 }
status = double(stdout: "", stderr: "", exitstatus: 1)
status = double(stdout: "dev-vcs/git-2.16.2", exitstatus: 0)
stderr_output = <<~EOF
expect(@provider).to receive(:shell_out_compacted!).with("emerge", "-g", "--color", "n", "--nospinner", "--quiet", "=dev-util/git-1.0.0", timeout: 3600)
@provider.install_package("dev-util/git", "1.0.0")
expect(@provider).to receive(:shell_out_compacted!).with("emerge", "-g", "--color", "n", "--nospinner", "--quiet", "~dev-util/git-1.0.0", timeout: 3600)
@provider.install_package("dev-util/git", "~1.0.0")
expect(@provider).to receive(:shell_out_compacted!).with("emerge", "--unmerge", "--color", "n", "--nospinner", "--quiet", "dev-util/git", timeout: 3600)
expect(@provider).to receive(:shell_out_compacted!).with("emerge", "--unmerge", "--color", "n", "--nospinner", "--quiet", "=dev-util/git-1.0.0", timeout: 3600)
@provider.remove_package("dev-util/git", "1.0.0")
@pid = 12345
expect(@provider).to receive(:shell_out_compacted!).with("cave", "-L", "warning", "resolve", "-x", "=net/ntp-4.2.6_p5-r2", { timeout: @new_resource.timeout || 900 })
@provider.install_package("net/ntp", "4.2.6_p5-r2")
expect(@provider).to receive(:shell_out_compacted!).with("cave", "-L", "warning", "resolve", "-x", "=sys-process/lsof-4.87", { timeout: @new_resource.timeout || 900 })
@provider.upgrade_package("net/ntp", "4.2.6_p5-r2")
expect(@provider).to receive(:shell_out_compacted!).with("cave", "-L", "warning", "uninstall", "-x", "=net/ntp-4.2.6_p5-r2", timeout: 900)
@provider.remove_package("net/ntp", "4.2.6_p5-r2")
let(:name) { "ihavetoes" }
let(:version) { "0.0" }
allow(provider).to receive(:shell_out_compacted!).with("pkg_info", "-e", "#{name}->0", anything).and_return(instance_double("shellout", stdout: ""))
instance_double("shellout", stdout: "#{name}-#{version}\n")
{ env: { "PKG_PATH" => "http://ftp.OpenBSD.org/pub/OpenBSD/5.5/packages/amd64/" }, timeout: 900 }
) { OpenStruct.new status: true }
let(:flavor_a) { "flavora" }
let(:flavor_b) { "flavorb" }
instance_double("shellout", stdout: "#{name}-#{version}-#{flavor_a}\n#{name}-#{version}-#{flavor_b}\n")
let(:flavor) { "flavora" }
let(:package_name) { "ihavetoes" }
let(:name) { "#{package_name}--#{flavor}" }
expect(provider).to receive(:shell_out_compacted!).with("pkg_info", "-e", "#{package_name}->0", anything).and_return(instance_double("shellout", stdout: ""))
instance_double("shellout", stdout: "#{name}-#{version}-#{flavor}\n")
expect(provider).to receive(:shell_out_compacted!).with("pkg_info", "-I", "#{name}-#{version}-#{flavor_b}", anything).and_return(
instance_double("shellout", stdout: "#{name}-#{version}-#{flavor_a}\n")
new_resource.version("#{version}-#{flavor_b}")
@name = "ihavetoes"
let(:timeout) {}
cab_file = "c:\\temp\\test6.1-kb2664825-v3-x64.cab"
expect(path).to be == "C:\\chef\\abc\\package\\Test6.1-KB2664825-v3-x64.msu"
stdout = <<~EOF
openssl @0.9.8k_0 (active)
status = double(stdout: "version: 4.2.7\n", exitstatus: 0)
expect(@provider).to receive(:shell_out_compacted!).with("port", "install", "zsh", "@4.2.7", timeout: 900)
@provider.install_package("zsh", "4.2.7")
expect(@provider).to receive(:shell_out_compacted!).with("port", "-f", "install", "zsh", "@4.2.7", timeout: 900)
expect(@provider).to receive(:shell_out_compacted!).with("port", "uninstall", "zsh", "@4.2.7", timeout: 900)
@provider.purge_package("zsh", "4.2.7")
expect(@provider).to receive(:shell_out_compacted!).with("port", "-f", "uninstall", "zsh", "@4.2.7", timeout: 900)
expect(@provider).to receive(:shell_out_compacted!).with("port", "deactivate", "zsh", "@4.2.7", timeout: 900)
@provider.remove_package("zsh", "4.2.7")
expect(@provider).to receive(:shell_out_compacted!).with("port", "-f", "deactivate", "zsh", "@4.2.7", timeout: 900)
expect(@provider).to receive(:shell_out_compacted!).with("port", "upgrade", "zsh", "@4.2.7", timeout: 900)
@provider.upgrade_package("zsh", "4.2.7")
expect(@provider).to receive(:shell_out_compacted!).with("port", "-f", "upgrade", "zsh", "@4.2.7", timeout: 900)
stdout = ""
Version: 1.8.4.1 (1.8.4p1)
stderr = ""
Branch: 0.175.0.0.0.2.537
expect(@provider).to receive(:shell_out_compacted!).with("pkg", "install", "-q", "crypto/gnupg@2.0.17", timeout: 900)
expect(@provider).to receive(:shell_out_compacted!).with("pkg", "--no-refresh", "install", "-q", "crypto/gnupg@2.0.17", timeout: 900)
expect(@provider).to receive(:shell_out_compacted!).with("pkg", "install", "-q", "--accept", "crypto/gnupg@2.0.17", timeout: 900).and_return(local_output)
expect(@provider).to receive(:shell_out_compacted!).with("pkg", "uninstall", "-q", "crypto/gnupg@2.0.17", timeout: 900)
expect(@provider).to receive(:shell_out_compacted!).with("pkg", "--no-refresh", "uninstall", "-q", "crypto/gnupg@2.0.17", timeout: 900)
let(:homebrew_uid) { 1001 }
{ "openssl@1.1" =>
{ "name" => "openssl@1.1",
{ "stable" =>
{ "rebuild" => 0,
{ "name" => "kubernetes-cli",
{ "name" => "vim",
{ "full_name" => "lua", "version" => "5.3.5" },
{ "full_name" => "perl", "version" => "5.30.2" },
{ "full_name" => "gdbm", "version" => "1.18.1" },
{ "full_name" => "openssl@1.1", "version" => "1.1.1f" },
{ "full_name" => "readline", "version" => "8.0.4" },
{ "full_name" => "sqlite", "version" => "3.31.1" },
{ "full_name" => "xz", "version" => "5.2.5" },
{ "full_name" => "python", "version" => "3.7.7" },
{ "full_name" => "libyaml", "version" => "0.2.2" },
{ "name" => "curl",
expect(provider.brew_info).to eq("bogus" => {})
let(:new_resource) { Chef::Resource::Package.new("emacs") }
@pkg_info = OpenStruct.new(stdout: "zsh-3.1.7\n")
.with("make", "-DBATCH", "install", "clean", timeout: 1800, cwd: "/usr/ports/shells/zsh", env: nil)
@provider.install_package("zsh", "5.0.5")
.with("make", "deinstall", timeout: 300, cwd: "/usr/ports/shells/zsh", env: nil)
@provider.remove_package("zsh", "5.0.5")
pkg_query = OpenStruct.new(stdout: "5.0.5\n", exitstatus: 0)
expect(@provider).to receive(:shell_out_compacted!).with("pkg", "rquery", "%v", "zsh", env: nil, timeout: 900).and_return(pkg_query)
pkg_query = OpenStruct.new(stdout: "5.0.3\n", exitstatus: 0)
expect(@provider).to receive(:shell_out_compacted!).with("pkg", "rquery", "-r", "LocalMirror", "%v", "zsh", env: nil, timeout: 900).and_return(pkg_query)
.with("pkg", "add", "/nas/pkg/repo/zsh-5.0.1.txz", env: { "LC_ALL" => nil }, timeout: 900)
@provider.install_package("zsh", "5.0.1")
.with("pkg", "add", "http://repo.example.com/zsh-5.0.1.txz", env: { "LC_ALL" => nil }, timeout: 900)
.with("pkg", "install", "-y", "zsh", env: { "LC_ALL" => nil }, timeout: 900).and_return(@install_result)
.with("pkg", "install", "-y", "-r", "LocalMirror", "zsh", env: { "LC_ALL" => nil }, timeout: 900).and_return(@install_result)
.with("pkg", "delete", "-y", "zsh-5.0.1", env: nil, timeout: 900).and_return(@install_result)
@provider.remove_package("zsh", "5.0.1")
let(:package) { "wget" }
let(:source) { "/tmp/wget_1.11.4-1ubuntu1_amd64.deb" }
let(:dpkg_deb_version) { "1.11.4" }
let(:dpkg_deb_status) { status = double(stdout: "#{package}\t#{dpkg_deb_version}", exitstatus: 0) }
let(:dpkg_s_version) { "1.11.4-1ubuntu1" }
Depends: libc6 (>= 2.8~20080505), libssl0.9.8 (>= 0.9.8f-5)
check_version("1.11.4")
check_version("1:1.8.3-2")
describe "when the package name has `-', `+' or `.' characters" do
let(:package) { "f.o.o-pkg++2" }
describe "when the package version has `~', `-', `+' or `.' characters" do
let(:package) { "b.a.r-pkg++1" }
let(:dpkg_s_version) { "1.2.3+3141592-1ubuntu1~lucid" }
exitstatus: 1, stdout: "", stderr: <<~EOF
exitstatus: 0, stderr: "", stdout: <<~EOF
let(:path) { "preseed/wget" }
let(:tmp_path) { "/tmp/preseed/wget" }
let(:package_name) { "wget" }
let(:package_version) { "1.11.4" }
let(:response) { "wget.response" }
let(:tmp_preseed_path) { "/tmp/preseed/wget/wget-1.11.4.seed" }
let(:preseed_path) { "/preseed--wget--wget-1.11.4.seed" }
expect(helper.compare_versions("0:1.8.29-6.el8.x86_64", "0:1.8.29-6.el8_3.1.x86_64")).to eql(-1)
let(:choco_exe) { "#{choco_install_path}\\bin\\choco.exe" }
Git|2.6.1
Git|2.6.2
{ "chocolatey" => "0.9.9.11", "conemu" => "15.10.25.0" }
{ "chocolatey" => "0.9.9.11", "conemu" => "15.10.25.1", "git" => "2.6.2", "munin-node" => "1.6.1.20130823" }
@empty_status = double("Status", stdout: "", exitstatus: 0)
expect(@provider).to receive(:shell_out_compacted).with("installp", "-L", "-d", "/tmp/samba.base", timeout: 900).and_return(status)
status = double("Status", stdout: "", exitstatus: 1, format_for_exception: "")
status = double(stdout: "", exitstatus: -1, format_for_exception: "")
@status = double(stdout: "", exitstatus: 1, format_for_exception: "")
expect(@provider).to receive(:shell_out_compacted!).with("installp", "-aYF", "-d", "/tmp/samba.base", "samba.base", timeout: 900)
expect(@provider).to receive(:shell_out_compacted!).with("installp", "-aYF", "-d", "/tmp/samba.base", "/tmp/samba.base", timeout: 900)
@provider.install_package("/tmp/samba.base", "3.3.12.0")
expect(@provider).to receive(:shell_out_compacted!).with("installp", "-aYF", "-e/tmp/installp.log", "-d", "/tmp/samba.base", "samba.base", timeout: 900)
@provider.remove_package("samba.base", "3.3.12.0")
expect(@provider).to receive(:shell_out_compacted!).with("installp", "-u", "-e/tmp/installp.log", "samba.base", timeout: 900)
@run_context = Chef::RunContext.new(node, {}, events)
@stderr = ""
allow(@provider).to receive(:shell_out).with("dpkg", "--compare-versions", "1.6~beta1", "gt", "1.1.0").and_return(so2)
allow(@provider).to receive(:shell_out).with("dpkg", "--compare-versions", "1.0.1ubuntu2", "gt", "1.1.0").and_return(so2)
allow(@provider).to receive(:shell_out).with("dpkg", "--compare-versions", "1.0.1ubuntu2", "eq", "1.1.0").and_return(so2)
candidate_version: "0.8.12-7",
@new_resource.options('--force-yes -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confnew"')
let(:path) { "preseed/irssi" }
let(:tmp_path) { "/tmp/preseed/irssi" }
let(:package_name) { "irssi" }
let(:package_version) { "1.0.5-1" }
let(:response) { "irssi.response" }
let(:tmp_preseed_path) { "/tmp/preseed/irssi/irssi-1.0.5-1.seed" }
let(:preseed_path) { "/preseed--irssi--irssi-1.0.5-1.seed" }
file = "/tmp/irssi-0.8.12-7.seed"
file = @provider.get_preseed_file("irssi", "0.8.12-7")
@provider.lock_package("irssi", "0.8.12-7")
@provider.unlock_package("irssi", "0.8.12-7")
GUID = "\\\\?\\Volume{578e72b5-6e70-11df-b5c5-000c29d4a7d9}\\".freeze
REMOTE = "\\\\server-name\\path".freeze
@new_resource = Chef::Resource::Mount.new("X:")
@net_use = double("Chef::Util::Windows::NetUse")
@vol = double("Chef::Util::Windows::Volume")
let(:device_type) { :device }
let(:fstype) { "ufs" }
let(:device) { "/dev/dsk/c0t2d0s7" }
let(:fsck_device) { "/dev/rdsk/c0t2d0s7" }
let(:mountpoint) { "/mnt/foo" }
let(:fstype) { ft }
let(:fsck_device) { "-" }
let(:device) { "something_that_is_not_a_file" }
let(:fstype) { "nfs" }
let(:device) { "cartman:/share2" }
let(:mountpoint) { "/cartman" }
let(:target) { "/dev/mapper/target" }
let(:target) { "foo" }
expect(provider).to receive(:shell_out_compacted!).with("mount", "-F", fstype, "-o", "rw", device, mountpoint)
let(:this_mount) { "/dev/dsk/c0t2d0s7\t/dev/rdsk/c0t2d0s7\t/mnt/foo\tufs\t2\tyes\t-\n" }
let(:this_mount) { "/dev/dsk/c0t2d0s7\t/dev/rdsk/c0t2d0s7\t/mnt/foo\tufs\t2\tno\t-\n" }
let(:options) { "noauto" }
let(:options) { "-" }
let(:options) { "-,noauto" }
expect(IO.read(vfstab_file.path)).to eql( "#{this_mount}\n#{other_mount}\n" )
@new_resource = Chef::Resource::Mount.new("/tmp/foo")
allow(::File).to receive(:realpath).with("/dev/sdz1").and_return "/dev/sdz1"
allow(::File).to receive(:realpath).with("/tmp/foo").and_return "/tmp/foo"
allow(::File).to receive(:exist?).with("/etc/fstab").and_return(true)
allow(::File).to receive(:foreach).with("/etc/fstab")
@status = double(stdout: "/dev/sdz1\n", exitstatus: 1)
@stdout_findfs = double("STDOUT", first: "/dev/sdz1")
{ "nfs" => "nfsserver:/vol/path",
allow(@provider).to receive(:shell_out!).and_return(OpenStruct.new(stdout: "#{fs_spec}/ on /tmp/foo type #{type} (rw)\n"))
expect(::File).to receive(:exists?).with("").and_return(false)
target = "xsdz1"
mount = "/dev/sdy1 on #{@new_resource.mount_point} type ext3 (rw)\n"
mount << "#{@new_resource.device} on #{@new_resource.mount_point} type ext3 (rw)\n"
mount = "#{@new_resource.device} on #{@new_resource.mount_point} type ext3 (rw)\n"
mount << "/dev/sdy1 on #{@new_resource.mount_point} type ext3 (rw)\n"
fstab = "#{@new_resource.device} #{@new_resource.mount_point} #{@new_resource.fstype} #{options} 1 2\n"
fstab = "#{target} #{@new_resource.mount_point} #{@new_resource.fstype} #{options} 1 2\n"
expect(@provider).to receive(:shell_out_compacted!).with("mount", "-t", "ext3", "-o", "defaults", "/dev/sdz1", "/tmp/foo")
expect(@provider).to receive(:shell_out_compacted!).with("mount", "-t", "ext3", "-o", "rw,noexec,noauto", "/dev/sdz1", "/tmp/foo")
status = double(stdout: "/dev/sdz1\n", exitstatus: 1)
expect(@provider).to receive(:shell_out!).with("umount", "/tmp/foo")
allow(::File).to receive(:open).with("/etc/fstab", "a").and_yield(@fstab)
expect(@fstab.string).to match(%r{^/dev/sdz1\s+/tmp/foo\s+ext3\s+defaults\s+0\s+2\s*$})
expect(::File).not_to receive(:open).with("/etc/fstab", "a")
expect(::File).to receive(:open).once.with("/etc/fstab", "w").and_yield(@fstab)
allow(::File).to receive(:open).with("/etc/fstab", "w").and_yield(fstab_write)
allow(::File).to receive(:open).with("/etc/fstab", "w").and_yield(@fstab_write)
@new_resource = Chef::Resource::Mount.new("/tmp/bar")
allow(::File).to receive(:realpath).with("/tmp/bar").and_return "/tmp/foo"
expect(@fstab.string).to match(%r{^cephserver:6789:/\s+/tmp/bar\s+cephfs\s+defaults\s+0\s+2\s*$})
allow(::File).to receive(:open).with("/etc/fstab", "a").and_yield(fstab_write)
mount = "#{new_resource.mount_point} /dev/sdy1 type ext3 (rw)\n"
mount << "#{new_resource.mount_point} #{new_resource.device} type ext3 (rw)\n"
mount = "#{new_resource.device} on #{new_resource.mount_point} type ext3 (rw)\n"
mount << "/dev/sdy1 on #{new_resource.mount_point} type ext3 (rw)\n"
losetup = "/dev/loop16 0 0 1 1 /dev/sdz1 \n"
@mounted_output = <<~MOUNT
@test_wrong_output = <<~WRONG
/tmp/abc:
expect(filesystems.string).to match(%r{^\n\n/tmp/foo:\n\tdev\t\t= /dev/sdz1\n\tvfs\t\t= jfs2\n\tmount\t\t= false\n\toptions\t\t= nodev,rw\n$})
/tmp/foo:
expect(filesystems.string).to match(%r{^/tmp/abc:\s+dev\s+= /dev/sdz2\s+vfs\s+= jfs2\s+mount\s+= true\s+options\s+= rw\n$})
expected_command = "yes | mdadm --create /dev/md1 --level 5 --chunk=16 --metadata=0.90 --raid-devices 3 /dev/sdz1 /dev/sdz2 /dev/sdz3"
expected_command = "yes | mdadm --create /dev/md1 --level 5 --chunk=16 --metadata=0.90 --bitmap=grow --raid-devices 3 /dev/sdz1 /dev/sdz2 /dev/sdz3"
expected_command = "yes | mdadm --create /dev/md1 --level 5 --chunk=16 --metadata=0.90 --layout=rs --raid-devices 3 /dev/sdz1 /dev/sdz2 /dev/sdz3"
expected_command = "yes | mdadm --create /dev/md1 --level 1 --metadata=0.90 --raid-devices 3 /dev/sdz1 /dev/sdz2 /dev/sdz3"
expected_mdadm_cmd = "yes | mdadm --stop /dev/md1"
let(:log_str) { "this is my test string to log" }
run_context = Chef::RunContext.new(node, {}, @events)
ChefUtils.windows? ? path.tr("/", "\\") : path
lstat = double("stats", ino: 5)
stat = double("stats", ino: 5)
stat = double("stats", ino: 6)
let(:label) { "call.mom.weekly" }
let(:test_plist) { String.new <<~XML }
\t<key>Label</key>
\t<key>Program</key>
\t<dict>
\t\t<key>Hour</key>
\t\t<key>Weekday</key>
\t</dict>
\t<key>TimeOut</key>
\t<array>
\t\t<dict>
\t\t\t<key>Hour</key>
\t\t\t<key>Weekday</key>
\t\t\t<integer>1</integer>
\t\t</dict>
\t\t\t<integer>2</integer>
\t</array>
allowed = (1..2).collect do |num|
allowed = {
end.to raise_error(/Invalid value.*\(1-2\)/)
@new_resource = Chef::Resource::Ifconfig.new("10.0.0.1", @run_context)
let(:net_tools_version) { StringIO.new <<~EOS }
let(:net_tools_version2) { StringIO.new <<~EOS }
expect(arg).to match(/^\s*DEVICE=eth0\s*$/)
expect(arg).to match(/^\s*IPADDR=10\.0\.0\.1\s*$/)
expect(arg).to match(/^\s*NETMASK=255\.255\.254\.0\s*$/)
expect(arg).to match(/^\s*ETHTOOL_OPTS="-A eth0 autoneg off"\s*$/)
expect(arg).to match(/^\s*MASTER=bond0\s*$/)
expect(arg).to match(/^\s*SLAVE=yes\s*$/)
expect(arg).to match(/^\s*VLAN=yes\s*$/)
let(:current_resource) { Chef::Resource::Ifconfig.new("10.0.0.1", run_context) }
expect(File.read(config_filename_ifcfg)).to match(/^\s+address 10\.0\.0\.1\s*$/)
expect(File.read(config_filename_ifcfg)).to match(/^\s+netmask 255\.255\.254\.0\s*$/)
expect(config_file_ifcfg.string).not_to match(/^\s+address 10\.0\.0\.1\s*$/)
expect(config_file_ifcfg.string).not_to match(/^\s+netmask 255\.255\.254\.0\s*$/)
inet6 ::1%1/0
command = "chdev -l #{@new_resource.device} -a netaddr=#{@new_resource.name}"
command = "chdev -l #{@new_resource.device} -a state=down"
let(:http) do
expect(http).to receive(:get).with("http://www.opscode.com/", {})
expect(http).to receive(:put).with("http://www.opscode.com/", "return", {})
expect(http).to receive(:post).with("http://www.opscode.com/", "return", {})
expect(http).to receive(:delete).with("http://www.opscode.com/", {})
expect(http).to receive(:head).with("http://www.opscode.com/", {}).and_return(nil)
expect(http).to receive(:head).with("http://www.opscode.com/", {}).and_return("")
expect(http).to receive(:head).with("http://www.opscode.com/", { "If-Modified-Since" => if_modified_since }).and_return(false)
@pw_group = double("Struct::Group",
name: "wheel",
gid: 20,
mem: %w{root aj})
platforms = {
expect(@provider).to receive(:shell_out_compacted!).with("groupmod", "-U", "all,your,base", "wheel")
expect(@provider).to receive(:shell_out_compacted!).with("usermod", *flags, "+wheel", "all")
expect(@provider).to receive(:shell_out_compacted!).with("usermod", *flags, "+wheel", "your")
expect(@provider).to receive(:shell_out_compacted!).with("usermod", *flags, "+wheel", "base")
expect(@provider).to receive(:shell_out_compacted!).with("usermod", *flags, "-wheel", "are")
expect(@provider).to receive(:shell_out_compacted!).with("usermod", *flags, "-wheel", "to")
expect(@provider).to receive(:shell_out_compacted!).with("usermod", *flags, "-wheel", "us")
expect(@provider).to receive(:shell_out_compacted!).with("pw", "groupadd", "wheel", "-g", "23", "-M", "root,aj").and_return(true)
expect(@provider).to receive(:shell_out_compacted!).with("pw", "groupmod", "wheel", "-g", "42", "-m", "someone").and_return(true)
expect(@provider).to receive(:shell_out_compacted!).with("pw", "groupmod", "wheel", "-g", "42", "-d", "root,aj").and_return(true)
expect(@provider).to receive(:shell_out_compacted!).with("group", "mod", "-n", "wheel_bak", "wheel")
expect(@provider).to receive(:shell_out_compacted!).with("group", "add", "-g", "123", "-o", "wheel")
expect(@provider).to receive(:shell_out_compacted!).with("user", "mod", "-G", "wheel", "lobster")
expect(@provider).to receive(:shell_out_compacted!).with("group", "add", "-g", "123", "wheel")
expect(@provider).to receive(:shell_out_compacted!).with("user", "mod", "-G", "wheel", "rage")
expect(@provider).to receive(:shell_out_compacted!).with("user", "mod", "-G", "wheel", "fist")
Chef::Resource::Group.new("aj").tap do |r|
gid: "-g",
match_array << "aj"
expect(@provider).to receive(:shell_out_compacted!).with("gpasswd", "-M", "", "wheel")
expect(@provider).to receive(:shell_out_compacted!).with("gpasswd", "-M", "lobster,rage,fist", "wheel")
expect(@provider).to receive(:shell_out_compacted!).with("gpasswd", "-a", "lobster", "wheel")
expect(@provider).to receive(:shell_out_compacted!).with("gpasswd", "-a", "rage", "wheel")
expect(@provider).to receive(:shell_out_compacted!).with("gpasswd", "-a", "fist", "wheel")
@status = double(stdout: "\n", stderr: "", exitstatus: 0)
expect(@provider).to receive(:shell_out_compacted).with("dscl", ".", "-cmd", "/Path", "arg1", "arg2")
@provider.dscl("cmd", "/Path", "arg1", "arg2")
expect(@provider).to receive(:dscl).with(*"cmd /Path args".split(" "))
@provider.safe_dscl(*"cmd /Path args".split(" "))
safe_dscl_retval = @provider.safe_dscl(*"delete /Path args".split(" "))
safe_dscl_retval = @provider.safe_dscl(*"cmd /Path args".split(" "))
expect(@provider).to receive(:safe_dscl).with(*"list /Groups gid".split(" "))
expect(@provider).to receive(:safe_dscl).with("create", "/Groups/aj", "GroupMembers", "").and_return(true)
expect(@provider).to receive(:safe_dscl).with(*"create /Groups/aj Password *".split(" "))
expect(@provider).to receive(:safe_dscl).with(*"create /Groups/aj".split(" "))
@output = <<~EOF
allow(@provider).to receive(:safe_dscl).with(*"read /Groups/aj".split(" ")).and_return(@output)
Chef::Log.level = :info
@resource = Chef::Resource::Git.new("web2.0 app")
expect(::File).to receive(:exist?).with("/my/deploy/dir/.git").and_return(false)
expect(::File).to receive(:exist?).with("/my/deploy/dir/.git").and_return(true)
@stdout = ""
@git_ls_remote = "git ls-remote \"git://github.com/opscode/chef.git\" "
let(:expected_cmd) { 'git clone "git://github.com/opscode/chef.git" "/my/deploy/dir"' }
environment: { "GIT_SSH" => wrapper, "HOME" => "/home/deployNinja" },
let(:seconds) { 10 }
{ "HOME" => "/home/masterNinja" }
environment: { "GIT_SSH" => wrapper, "HOME" => "/home/masterNinja" },
user: 123,
environment: { "HOME" => "/home/deployNinja" },
environment: { "HOME" => "/home/masterNinja" },
environment: { "HOME" => "/home/deployNinja",
expected_cmd = "git clone --depth 5 \"git://github.com/opscode/chef.git\" \"/my/deploy/dir\""
expected_cmd = "git clone --depth 5 --no-single-branch \"git://github.com/opscode/chef.git\" \"/my/deploy/dir\""
expected_cmd = "git clone -o opscode \"git://github.com/opscode/chef.git\" \"/my/deploy/dir\""
user: "whois", group: "thisis",
environment: { "HOME" => "/home/whois" })
cwd: "/my/deploy/dir",
user: "whois",
group: "thisis",
environment: { "HOME" => "/home/whois" },
it "adds a new remote " do
allow(::File).to receive(:exist?).with("/my/deploy/dir/.git").and_return(false)
expect(@provider).not_to receive(:shell_out!).with("huzzah!", cwd: "/my/deploy/dir")
allow(new_resource).to receive(:content).and_return("Do do do do, do do do do, do do do do, do do do do")
let(:opts) do
Chef::Log.level = :warn
.and_return(double(result: { "RebootRequired" => true }))
.and_return(double(stdout: "", result: {}))
{ "Module" => { "Name" => "ModuleName1", "Version" => "1.0.0.0" } },
{ "Module" => { "Name" => "ModuleName1", "Version" => "2.0.0.0" } },
expect(response).to be == "@{ModuleName='my_module';ModuleVersion='1.3.1'}"
let(:tmp_dir) { Dir.mktmpdir }
let(:dir_stat) { File::Stat.new(tmp_dir) }
let(:expected_uid) { dir_stat.uid }
let(:expected_gid) { dir_stat.gid }
let(:expected_mode) { "0%o" % ( dir_stat.mode & 007777 ) }
expect(File.exist?("#{tmp_dir}/foobar")).to be true
0 2 * * * /some/other/command
2 * 1 * * /bin/false
expect(cron.path).to eq("/bin:/foo")
expect(cron.home).to eq("/home/foo")
expect(cron.environment).to eq({ "TEST" => "lol", "FLAG" => "1" })
21 */4 * * * some_prog 1234567
expect(cron.minute).to eq("*")
expect(cron.hour).to eq("5")
expect(cron.day).to eq("*")
expect(cron.month).to eq("1")
expect(cron.weekday).to eq("*")
expect(cron.hour).to eq("*")
expect(cron.month).to eq("*")
30 * * * * /bin/true
30 * * 3 * /bin/true
1 1 1 1 1 /bin/true
@new_resource.hour("1")
@new_resource.day("1")
@new_resource.environment = { "SHELL" => "/bash", "ENV" => "environment" }
@new_resource.environment = { "ENV" => "environment" }
@status = double("Status", exitstatus: 1, stdout: "")
expect(@provider).to receive(:shell_out!).with("crontab -u #{@new_resource.user} -", input: "Foo").and_return(@status)
let(:mailto) { "foo@example.com" }
expect(@provider.send(:duration_str)).to eq("1 * * * *")
expect(@provider.send(:duration_str)).to eq("1 2 3 4 5")
let(:time_out_str_val) { " timeout 10;" }
@new_resource.time_out "duration" => "10"
@new_resource.time_out "duration" => "10", "foreground" => "true", "signal" => "FOO"
expect(@provider.send(:cmd_str)).to eq(" bin/true\n")
expect(@provider.send(:cmd_str)).to eq(" \n")
let(:username) { "root" }
let(:exitstatus) { 0 }
let(:stderr) { "" }
let(:exitstatus) { 1 }
let(:exitstatus) { 2 }
let(:stdout) { "" }
let(:tempfile) { double("foo", path: "/tmp/foo", close: true) }
expect(tempfile).to have_received(:<<).with("Foo\n# wibble\n wah!!")
let(:basepath) { "C:\\Windows\\system32\\" }
let(:interpreter) { File.join(basepath, "cmd.exe") }
expect(command).to eq(%Q{"#{interpreter}" /f /c "#{script_file_path}"})
let(:config_dir) { Dir.mktmpdir("apt_update_apt_conf_d") }
let(:apt_update_cmd) { %w{apt-get -q update} }
expect(File.read(config_file)).to match(/^APT::Update.*#{stamp_dir}/)
describe "#is_key_id?" do
let(:file) { "/tmp/remote-gpg-keyfile" }
.with("gpg", "--with-fingerprint", "--with-colons", file)
expect(provider.keyserver_install_cmd("ABC", "gpg.mit.edu")).to eq("apt-key adv --no-tty --recv --keyserver hkp://gpg.mit.edu:80 ABC")
expect(provider.keyserver_install_cmd("ABC", "hkp://gpg.mit.edu")).to eq("apt-key adv --no-tty --recv --keyserver hkp://gpg.mit.edu ABC")
let(:url) { "https://launchpad.net/api/1.0/~chef/+archive/main" }
it "gets a key" do
allow(simples).to receive(:get).and_return("\"#{key}\"")
expect(provider.build_repo("http://test/uri", "unstable", "main", false, nil)).to eql(target)
expect(provider.build_repo("http://test/uri", nil, "main", false, nil)).to eql(target)
expect(provider.build_repo("http://test/uri", "unstable", "main", false, nil, true)).to eql(target)
expect(provider.build_repo("http://test/uri", "unstable", "main", true, nil)).to eql(target)
let(:pref_dir) { Dir.mktmpdir("apt_pref_d") }
new_resource.pin = "1.0.1"
@i = 0
@current_index += 1
return "<nothing>" if values.size == 0
tags_index = properties.find_index { |p| !p.is_a?(String) }
resource_class.class_eval("property #{property_str}", __FILE__, __LINE__)
it "can be set" do
it "nil does a set" do
it "can be set with =" do
it "can be set to nil with =" do
it "can be updated with =" do
it "y is there" do
expect(subresource.x = "20").to eq "20"
with_property ":x, default: lazy { 10 }" do
it "when x is set, property_is_set?(:x) is true" do
it "when x is set with =, property_is_set?(:x) is true" do
it "when x is set to a lazy value, property_is_set?(:x) is true" do
resource.x lazy { 10 }
it "when x is not set, it returns 10" do
resource.instance_eval { @x = nil }
with_property ":x, default: 1, identity: true", ":y, default: 2, identity: true" do
with_property ":x, default: ''" do
it "when x is not set, it returns ''" do
resource.x << "foo"
expect(resource_class.new("other").x).to eq ""
with_property ":x, default: lazy { '' }" do
with_property ":x, default: {}" do
it "when x is not set, it returns {}" do
expect(resource.x).to eq({})
expect(resource.x).to eq({ "plants" => "zombies" })
expect(resource_class.new("other").x).to eq({})
with_property ":x, default: lazy { {} }" do
expect(value).to eq({})
with_property ":x, default: lazy { blah }" do
with_property ':x, default: lazy { |x| "#{blah}#{x.blah}" }' do
expect(resource.x "hi").to eq "hi"
with_property ":x, default: lazy { Namer.next_index.to_s }, is: proc { |v| Namer.next_index; true }" do
with_property ":x, default: lazy { Namer.next_index.to_s.freeze }, is: proc { |v| Namer.next_index; true }" do
with_property ':x, coerce: proc { |v| "#{v}#{next_index}" }, default: 10' do
expect(resource.x "hi").to eq "hi1"
with_property ':x, coerce: proc { |v| "#{v}#{next_index}".freeze }, default: 10' do
with_property ':x, coerce: proc { |v| "#{v}#{next_index}" }, default: lazy { 10 }' do
with_property ':x, coerce: proc { |v| "#{v}#{next_index}".freeze }, default: lazy { "10" }' do
with_property ':x, proc { |v| Namer.next_index; true }, coerce: proc { |v| "#{v}#{next_index}" }, default: lazy { 10 }' do
with_property ':x, String, coerce: proc { |v| "#{v}#{next_index}" }, default: 10' do
with_property ':x, Integer, coerce: proc { |v| "#{v}#{next_index}" }, default: 10' do
with_property ':x, String, coerce: proc { |v| "#{v}#{next_index}" }, default: lazy { 10 }' do
with_property ':x, Integer, coerce: proc { |v| "#{v}#{next_index}" }, default: lazy { 10 }' do
l = lazy { Namer.next_index }
it 'retrieving lazy { |x| "#{blah}#{x.blah}" } gets the example and instance variables' do
resource.x lazy { |x| "#{blah}#{x.blah}" }
l = lazy { |x| "#{blah}#{x.blah}" }
with_property ':x, coerce: proc { |v| "#{v}#{Namer.next_index}" }' do
with_property ":x, is: proc { |v| Namer.next_index; true }" do
with_property ':x, Integer, coerce: proc { |v| "#{v}#{Namer.next_index}" }' do
with_property ':x, coerce: proc { |v| "#{v}#{Namer.next_index}" }, is: proc { |v| Namer.next_index; true }' do
with_property ':x, String, coerce: proc { |v| "#{v}#{Namer.next_index}" }' do
with_property ":x, coerce: proc { |x| x }" do
with_property ':x, coerce: proc { |x| Namer.next_index; raise "hi" if x == 10; x }, is: proc { |x| Namer.next_index; x != 10 }' do
with_property ":x, is: proc { |v| Namer.next_index; v.is_a?(Integer) }" do
with_property ":x, #{name}: true" do
with_property ":x, #{name}: false" do
with_property ":x, #{name}: nil" do
it "emits an error for property :x, default: 10, #{name}: true" do
it "emits an error for property :x, default: nil, #{name}: true" do
it "emits an error for property :x, #{name}: true, default: 10" do
it "emits an error for property :x, #{name}: true, default: nil" do
property_type(is: %i{a b}, default: :c)
property_type(is: %i{a b}, default: :b)
ABType = property_type(is: %i{a b})
CDType = property_type(is: %i{c d})
expect(resource.x :a).to eq(:a)
expect(resource.x :c).to eq(:c)
resource_class.class_eval(property_str, __FILE__, __LINE__)
with_property ":x, #{validation}", *tags do
it "value #{v.inspect} is valid" do
resource.instance_eval { @x = "default" }
with_property ":x, #{validation}, default: nil" do
expect { resource_class.class_eval("property :x, #{validation}, default: nil", __FILE__, __LINE__) }.not_to raise_error
expect(resource.x "str").to eq "str"
it "set to nil does a set" do
it "set(nil) does a set" do
validation_test ":a, is: :b",
%i{a b},
%i{a b c},
%i{a b c d},
validation_test "is: :a",
%i{a b}
validation_test "is: /abc/",
validation_test "is: Chef::Property.new(is: :a)",
validation_test "is: proc { |x| x }",
validation_test "is: proc { |x| x > blah }",
validation_test 'kind_of: String, equal_to: "a"',
%w{xabcy aza},
%w{xabcy aza ana},
validation_test 'callbacks: { "a" => proc { |x| x > 10 }, "b" => proc { |x| x%2 == 0 } }',
validation_test 'callbacks: { "a" => proc { |x| x%2 == 0 }, "b" => proc { |x| x > 10 } }',
validation_test 'callbacks: { "a" => proc { |x| x.nil? } }',
with_property ":x, required: %i{doit}" do
it "value '1' is valid" do
expect(resource.x "1").to eq "1"
it "value '2' is valid" do
expect(resource.x "2").to eq "2"
with_property ":x, String, default: '1'" do
if _pv_opts_lookup(opts, key) != value
it "value '1' is invalid" do
expect(resource.x "woo").to eq "woo"
expect(subresource.identity).to eq(x: "foo", y: "bar")
it "y is part of state" do
@blarghle ? @blarghle * 3 : nil
@blarghle = x * 2
with_property ":x, identity: true, default: 'xxx'",
expect(resource.identity).to eq(x: "foo", y: "bar", z: "baz")
expect(resource.identity).to eq(x: "xxx", y: "yyy", z: "zzz")
with_property ":x", ":y", ":z" do
with_property ":x", ":y, desired_state: false", ":z, desired_state: true" do
with_property ":x, default: 1" do
@blah * 3
def x=(value)
@blah = value * 2
let(:node_name) { "joe_node" }
let(:ohai_data) { { "platform" => "ubuntu", "platform_version" => "13.04", "fqdn" => "joenode.example.com" } }
let(:json_attribs) { { "custom_attr" => "custom_attr_value" } }
let(:override_runlist) { nil }
let(:api_service) { double("Chef::ServerAPI") }
let(:primary_runlist) { nil }
let(:original_default_attrs) { { "default_key" => "default_value" } }
let(:original_override_attrs) { { "override_key" => "override_value" } }
id: "_policy_node",
{ type: "recipe", name: "test::default", skipped: false, version: nil },
{ type: "recipe", name: "test::other", skipped: false, version: nil },
let(:extra_chef_config) { {} }
let(:node) { Chef::Node.new.tap { |n| n.name(node_name) } }
it "has a node_name" do
let(:json_attribs) { nil }
environment = Chef::Environment.new.tap { |e| e.name("prod") }
let(:chef_http) { double("Chef::ServerAPI") }
let(:node) { base_node }
let(:json_attribs) { {} }
let(:json_attribs) { { "foo" => "bar" } }
let(:json_attribs) { { "policy_name" => "example-policy", "policy_group" => "testing" } }
let(:node) { instance_double("Chef::Node") }
let(:org) { Chef::Org.new("an_org") }
it "is a Chef::Org" do
expect(org.name).to eq("sg1")
let(:json) do
expect(json).to match(/^\{.+\}$/)
expect(json).to include(%q{"name":"black"})
let(:org) do
o = { "name" => "turtle",
r = double("rest")
o = Chef::Org.new("foobar")
let(:response) { { "foobar" => "http://www.example.com/organizations/foobar" } }
let(:inflated_response) { { "foobar" => org } }
expect(rest).to receive(:post).with("organizations", { name: "foobar", full_name: "foo bar bat" }).and_return({})
expect(rest).to receive(:get).with("organizations/foobar").and_return({ "name" => "foobar", "full_name" => "foo bar bat", "private_key" => "private" })
org = Chef::Org.load("foobar")
expect(rest).to receive(:put).with("organizations/foobar", { name: "foobar", full_name: "foo bar bat" }).and_return({})
let(:org) { Chef::Org.new("myorg") }
@rest = double("rest")
.and_return({ anything: "goes" })
node = Chef::Node.build("solo-node")
n1 = Chef::Node.build("alpha")
n2 = Chef::Node.build("beta")
n3 = Chef::Node.build("omega")
n1 = Chef::Node.build("foo")
n2 = Chef::Node.build("foo")
n3 = Chef::Node.build("bar")
expect(n1).to eq(n2)
n = Chef::Node.new
node.attributes.normal = { snoopy: { is_a_puppy: nil } }
node.tag("three", "four")
node.consume_attributes({ "a" => { "r2" => nil } })
expect( node.rm("mysql", "server", "port") ).to eql(3456)
expect( node.rm("mysql", "server") ).to eql( { "port" => 3456 } )
expect( node.rm("no", "such", "thing") ).to be_nil
expect( node.rm("mysql") ).to eql({ "server" => { "port" => 3456 } })
expect( node.rm("mysql", "server", "port") ).to eql(nil)
expect( node.rm("mysql", "server") ).to eql(nil)
expect( node.rm("mysql") ).to eql(true)
expect( node.rm("mysql", "server", 0, "port") ).to eql(3456)
node.rm("mysql", "server", "port")
expect( node.rm_default("mysql", "server", "port") ).to eql(3456)
expect( node.rm_default("mysql", "server", "port") ).to eql(nil)
expect( node.rm_default("mysql", "server") ).to eql(nil)
expect( node.rm_override("mysql", "server", "port") ).to eql(6669)
expect( node.rm_default("no", "such", "thing") ).to be_nil
expect( node.rm_normal("no", "such", "thing") ).to be_nil
expect( node.rm_override("no", "such", "thing") ).to be_nil
seen_attributes = {}
expect(node.exist?("foo", "bar")).to be true
expect(node.exist?("bar", "foo")).to be false
expect(node.read("foo", "bar")).to eql("baz")
expect(node.read("bar", "foo")).to eql(nil)
expect(node.read!("foo", "bar")).to eql("baz")
node.write(:default, "foo", "bar", "baz")
node.write!(:default, "foo", "bar", "baz")
expect(node.unlink(:default, "foo", "bar")).to eql("baz")
expect(node.unlink(:default, "bar", "foo")).to eql(nil)
expect(node.unlink!(:default, "foo", "bar")).to eql("baz")
@ohai_data = { platform: "foo", platform_version: "bar" }
expect(node.consume_run_list(attrs)).to eq({ "foo" => "bar" })
attrs = { "chef_environment" => "foo_environment", "bar" => "baz" }
expect(node.consume_chef_environment(attrs)).to eq({ "bar" => "baz" })
node.consume_run_list "recipes" => %w{one two}
node.run_list << "one"
node.consume_run_list "foo" => "bar"
node.consume_external_attrs(@ohai_data, { "one" => "two", "three" => "four" })
node.attributes.normal = { "tags" => nil }
node.consume_external_attrs(@ohai_data, "one" => { "two" => { "three" => "four" } })
node.consume_external_attrs(@ohai_data, "one" => { "abc" => "123" })
node.consume_external_attrs(@ohai_data, "one" => { "two" => { "foo" => "bar" } })
node.consume_external_attrs(@ohai_data, "one" => { "two" => { "three" => "forty-two" } })
node.consume_ohai_data({ "platform_version" => "6.3" })
@ohai_data = { platform: "foobuntu", platform_version: "23.42" }
node.consume_external_attrs(@ohai_data, { "foo" => "bar" })
e.name("rspec_env")
@expansion.instance_variable_set(:@applied_roles, { "arf" => nil, "countersnark" => nil })
@environment.default_attributes = { default: "from env", d_env: "env only" }
expect(node.role?("one")).to eql(true)
expect(node.role?("two")).to eql(true)
node.default_attrs = { "one" => { "two" => "three", "four" => "five", "eight" => "nine" } }
node.override_attrs = { "one" => { "two" => "three", "four" => "six" } }
node.normal_attrs = { "one" => { "two" => "seven" } }
@example.default_attrs = { "alpha" => { "bravo" => "charlie", "delta" => "echo" } }
@example.override_attrs = { "alpha" => { "bravo" => "foxtrot", "delta" => "golf" } }
@example.normal_attrs = { "alpha" => { "bravo" => "hotel" } }
h = node.to_hash
node.run_list << { "type" => "role", "name" => "Cthulu" }
node.run_list << { "type" => "role", "name" => "Hastur" }
@rest = double("Chef::ServerAPI")
@query = double("Chef::Search::Query")
n1 = double("Chef::Node", name: "one")
allow(n1).to receive(:is_a?).with(Chef::Node) { true }
r = Chef::Node.list(true)
expect(@rest).to receive(:get).and_return({ "one" => "http://foo" })
r = Chef::Node.list
expect(@rest).to receive(:put).with("nodes/monkey", {}).and_return("foo")
exception = double("404 error", code: "404")
expect(@rest).to receive(:post).with("nodes", {})
node.default = {
node.automatic = {}
node.normal = {}
node.override = {}
Net::HTTPResponse.send(:response_class, "400").new("1.0", "400", "Bad Request").tap do |r|
let(:node_map) { Chef::NodeMap.new }
node_map.set(:thing, :foo)
node_map.set(:thing, :bar, os: "linux")
node_map.set(:thing, :foo, os: "!windows")
node_map.set(:thing, :bar, os: "linux", platform_family: "rhel")
node_map.set(:thing, :foo, platform_family: "rhel", platform_version: ">= 7")
expect( node_map.get(node, :thing) ).to eql(nil)
expect( node_map.get(node, :thing) ).to eql(Foo)
expect( node_map.get(node, :thing1) ).to eql(nil)
expect( node_map.get(node, :thing2) ).to eql(Foo)
node_map.set(:thing, :foo, platform_family: "rhel") do |node|
expect(vivid.read("one", "two", "three")).to eql("four")
expect(vivid.read("one", "five", "six")).to eql(nil)
expect(vivid.read("array", 5, "one")).to eql(nil)
expect(vivid.read("array", "one", "two")).to eql(nil)
expect(vivid.read("nil", "one", "two")).to eql(nil)
context "#exist?" do
expect(vivid.exist?("one", "two", "three")).to be true
expect(vivid.exist?("array", 1)).to be true
expect(vivid.exist?("one", "five", "six")).to be false
expect(vivid.exist?("one", "two", "three", "four")).to be false
expect(vivid.exist?("nil", "foo", "bar")).to be false
context "#read!" do
expect(vivid.read!("one", "two", "three")).to eql("four")
expect(vivid.read!("array", 1)).to eql(1)
expect { vivid.read!("one", "five", "six") }.to raise_error(Chef::Exceptions::NoSuchAttribute, "one.five.six")
expect { vivid.read!("one", "two", "three", "four") }.to raise_error(Chef::Exceptions::NoSuchAttribute, "one.two.three.four")
vivid.write("one", "five", "six")
vivid.write("one", "five", "six", "seven", "eight", "nine", "ten")
vivid.write("array", "five", "six")
vivid.write("array", "five", "six", "seven")
vivid.write("one", "two", "three", "four", "five")
vivid.write("one", "two", "three", "four", "five", "six")
vivid.write("nil", "one", "two")
vivid.write("nil", "one", "two", "three")
vivid.write("one", "five") { "six" }
context "#write!" do
vivid.write!("one", "five", "six")
vivid.write!("one", "five", "six", "seven", "eight", "nine", "ten")
expect { vivid.write!("one", "two", "three", "four", "five") }.to raise_error(Chef::Exceptions::AttributeTypeMismatch)
expect { vivid.write!("one", "two", "three", "four", "five", "six") }.to raise_error(Chef::Exceptions::AttributeTypeMismatch)
vivid.write!("one", "five") { "six" }
expect(vivid.unlink("five", "six", "seven", "eight")).to eql(nil)
expect( vivid.unlink("one") ).to eql({ "two" => { "three" => "four" } })
expect(vivid.unlink("array", 2)).to eql(2)
expect(vivid.unlink("nil", "foo")).to eql(nil)
expect( vivid.unlink!("one") ).to eql({ "two" => { "three" => "four" } })
expect(vivid.unlink!("array", 2)).to eql(2)
expect(vivid.unlink!("nil")).to eql(nil)
%w{zero one two},
context "#<<" do
array << { "three" => "four" }
array.push({ "three" => "four" })
array.unshift({ "zero" => "zero2" })
array.insert(1, { "zero" => "zero2" })
array.collect! { |x| { "zero" => "zero2" } }
context "#map!" do
array.map! { |x| { "zero" => "zero2" } }
array.fill({ "one" => "two" })
let(:copy) { @immutable_mash.send(param) }
expect { copy << "m" }.not_to raise_error
@data_in = { "top" => { "second_level" => "some value" },
@mash = Chef::Node::ImmutableMash.new({ test: "foo", "test2" => "bar" })
let(:copy) { @immutable_mash.to_yaml }
%i{
}.each do |mutator|
immutable_mash = Chef::Node::ImmutableMash.new({ "m" => "m" })
<<
{ "dmi" => {},
@default_hash = {
@override_hash = {
@automatic_hash = { "week" => "friday" }
expect { Chef::Node::Attribute.new({}, {}, {}, {}) }.not_to raise_error
it "should set #{accessor}" do
na = Chef::Node::Attribute.new({ normal: true }, { default: true }, { override: true }, { automatic: true })
expect(na.send(accessor)).to eq({ accessor.to_s => true })
@attributes = Chef::Node::Attribute.new({}, {}, {}, {})
@attributes.env_default = { "a" => { "b" => { "default" => "default" } } }
@attributes.normal = { "a" => { "b" => { "normal" => "normal" } } }
@attributes.override = { "a" => { "override" => "role" } }
@attributes.automatic = { "a" => { "automatic" => "auto" } }
expect(hash).to eql({ "bar" => { "baz" => "fizz" } })
expect(hash).to eql({ "bar" => { "baz" => "buzz" } })
expect(hash).to eql({ "bar" => %w{fizz buzz} })
expect(hash).to eql({ "bar" => { "baz" => "fizzbuzz" } })
%i{include? key? member?}.each do |method|
collect << k
collect = {}
@attributes.each do |k, v|
collect << v
@empty = Chef::Node::Attribute.new({}, {}, {}, {})
}.each do |k, v|
expect(@attributes.fetch("lol", "blah")).to eq("blah")
expect(@attributes.fetch("lol") { |x| "#{x}, blah" }).to eq("lol, blah")
describe "index", ruby: "< 3.0.0" do
expect(@attributes.index("six")).to eq("one")
expect(@attributes.select { nil }).to eq({}.select { nil })
%w{hut three},
%w{one six},
expect(attributes.to_s).to eq("{}")
default_hash = {
expect(attributes.to_s).to eq('{"a"=>1, "b"=>3, "c"=>4}')
expect(@attributes.inspect).to match(/@automatic=\{.*\}/)
expect(@attributes.inspect).to match(/@normal=\{.*\}/)
@attributes.normal = {}
@attributes.default = { "arglebargle" => { "foo" => "bar" } }
@attributes.override = { "arglebargle" => { "fizz" => "buzz" } }
@attributes.role_default = { "arglebargle" => { "fizz" => "buzz" } }
it "sets __root__ correctly" do
it "sets __node__ correctly" do
it "sets __path__ correctly" do
expect(@escaper.xml_escape("&")).to eq("&amp;")
it "escapes angle brackets to &lt; or &gt;" do
expect(@escaper.xml_escape("<")).to eq("&lt;")
expect(@escaper.xml_escape(">")).to eq("&gt;")
expect(@escaper.xml_escape("foobarbaz!@\#$%^*()")).to eq("foobarbaz!@\#$%^*()")
expect(@escaper.xml_escape("\x00")).to eq("*")
expect(@escaper.xml_escape("\xC2\xA9")).to eq("&#169;")
expect(@escaper.xml_escape((0x80.chr).to_s)).to eq("&#8364;")
@node_x86_64 = Chef::Node.new
a.assertion { raise "boom1" }
a.failure_message("#{raise "boom2"}")
a.whyrun("#{raise "boom3"}")
let(:test) { TestClass.new }
test_which("finds `foo1` in #{dir} when it is stubbed", "foo1", finds: "#{dir}/foo1")
test_which("finds the first arg", "foo1", "foo2", finds: "/dir2/foo1")
test_which("finds the second arg", "foo1", "foo2", finds: "/dir2/foo2")
test_which("finds it if its true", "foo1", finds: "/dir1/foo1") do |f|
test_which("passes in the filename as the arg", "foo1", finds: "/dir1/foo1") do |f|
raise "bad arg to block" unless f == "/dir1/foo1"
let(:uris) { Chef::UrisTest.new }
it "matches 'scheme://foo.com'" do
expect(uris.uri_scheme?("scheme://foo.com")).to eq(true)
it "does not match 'c:/foo.com'" do
expect(uris.uri_scheme?("c:/foo.com")).to eq(false)
it "does not match '/usr/bin/foo.com'" do
it "does not match 'c:/foo.com://bar.com'" do
expect(uris.uri_scheme?("c:/foo.com://bar.com")).to eq(false)
expect { uris.as_uri("file:///c:/foo bar.txt") }.not_to raise_exception
expect( uris.as_uri("file:///c:/foo bar.txt") ).to be_a(URI)
let(:message) { "Test Message" }
let(:sep) { ChefUtils.windows? ? "\r\n" : "\n" }
output = @context.render_template_from_string("<%= @foo %>")
expect(line).to end_with("\r\n")
expect(line).to end_with("\n")
output = @context.render_template_from_string("<%= @node %>")
output = @template_context.render_template_from_string("before {<%= render '#{tf.path}', :local => true %>} after")
output = @template_context.render_template_from_string("before {<%= render('test.erb', :cookbook => 'openldap').strip %>} after")
output = @template_context.render_template_from_string("before {<%= render 'something', :local => true, :source => '#{tf.path}' %>} after")
output = @template_context.render_template_from_string("before {<%= render 'nested_openldap_partials.erb', :variables => {:hello => 'Hello World!' } %>} after")
output == "before {Hello World!} after"
output = @template_context.render_template_from_string("before {<%= render 'openldap_variable_stuff.conf.erb', :variables => {:secret => 'two' } %>} after <%= @secret %>")
output = @template_context.render_template_from_string("before {<%= render('#{path}', :local => true).strip %>} after")
expect { @context.render_template_from_string("<%= node %>") { |r| r } }.to raise_error(Chef::Mixin::Template::TemplateError)
let(:shell_out_class) { Class.new { include Chef::Mixin::ShellOut } }
let(:retobj) { instance_double(Mixlib::ShellOut, "error!" => false) }
let(:cmd) { "echo '#{rand(1000)}'" }
describe "##{method}" do
options = { environment: { "LC_ALL" => nil, "LANGUAGE" => nil, "LANG" => nil, env_path => nil } }
options = { environment: { "HOME" => "/Users/morty" } }
options = { env: { "LC_ALL" => nil, "LANG" => nil, "LANGUAGE" => nil, env_path => nil } }
options = { env: { "HOME" => "/Users/morty" } }
env: {
options = { user: "morty" }
user: "morty",
options = { environment: { "LC_ALL" => nil } }
options = { environment: { "LC_ALL" => "en_US.UTF-8" } }
options = { env: { "LC_ALL" => nil } }
provider.send(method, "foo", timeout: 1, env: nil)
let(:new_resource) { Chef::Resource::Package.new("foo") }
load File.join(__dir__, "..", "..", "..", "lib", "chef", "mixin", "securable.rb")
it "should not accept group/owner names starting with '-', '+', or '~'" do
let(:host) { "host" }
let(:port) { 7979 }
let(:http_uri) { "http://somehost:1" }
let(:https_uri) { "https://somehost:1" }
let(:no_proxy_spec) { nil }
let(:proxy_uri) { https_uri }
let(:proxy_uri) { http_uri }
property :a, "a", default: "a"
property :ab, %w{a b}, default: "a"
property :ac, %w{a c}, default: "a"
property :d, "d", description: "The d property", introduced: "14.0"
property :b, "b", default: "b"
property :ab, default: "b"
property :bc, %w{b c}, default: "c"
class C < A
property :c, "c", default: "c"
property :ac, default: "c"
property :bc, default: "c"
expect(C.properties.keys).to eq %i{a ab ac d b bc c}
let(:c) { C.new }
expect(c.ab).to eq("b")
expect(c.ac).to eq("c")
expect(c.bc).to eq("c")
expect(test_class.translate_type("foo")).to eq("'foo'")
expect(test_class.translate_type({ "a" => 1, "b" => 1.2, "c" => false, "d" => true
})).to eq("@{a=1;b=1.2;c=$false;d=$true}")
expect(result.stderr).to be == ""
expect { @vo.validate({ one: "two" }, {}) }.not_to raise_error
expect { @vo.validate({ one: "two" }, { one: true }) }.not_to raise_error
expect { @vo.validate({ one: "two" }, { "one" => true }) }.not_to raise_error
expect { @vo.validate({ one: "two" }, { {} => true }) }.to raise_error(ArgumentError)
expect { @vo.validate({}, { one: false }) }.not_to raise_error
{ one: "string" },
one: {
{ two: "string" },
{ one: @vo },
arguments = {}
{ one: "is good" },
regex: /^is good$/,
regex: /^is bad$/,
a == "is good"
{ one: "is bad" },
args = { one: "is good", two: "is bad" }
respond_to: %i{to_s upcase},
regex: /^is good/,
two: {
three: { default: "neato mosquito" },
{ one: "two" },
busted: "check",
@vo.validate({ "one" => "two" }, { one: { regex: /^two$/ } })
{ one: {} },
@vo.validate({ not_blank: "should pass" },
{ not_blank: { cannot_be: %i{nil empty} } })
@vo.validate({ not_blank: "" },
{ not_blank: { cannot_be: %i{nil empty}, validation_message: "my validation message" } })
value = "meow"
expect(@vo.set_or_return(:test, value, {}).object_id).to eq(value.object_id)
expect(@vo.set_or_return(:test, nil, {}).object_id).to eq(value.object_id)
expect(@vo.set_or_return(:test, nil, {}).object_id).not_to eq(value.object_id)
expect(@vo.set_or_return(:test, nil, {})).to eql(value)
@vo.set_or_return(:test, nil, { required: true })
@vo.set_or_return(:test, nil, { required: false })
expect(@vo.set_or_return(:name, value, {}).object_id).to eq(value.object_id)
@vo.set_or_return(:test, value, { kind_of: Numeric })
@vo.set_or_return(:test, nil, { kind_of: Numeric })
@vo.set_or_return(:delayed, @vo.lazy { "test" }, {})
value = "fubar"
@vo.set_or_return(:test, @vo.lazy { value }, {})
expect(@vo.set_or_return(:test, nil, {})).to eq("fubar")
value = "foobar"
expect(@vo.set_or_return(:test, nil, {})).to eq("foobar")
expect(@vo.set_or_return(:test, nil, {})).to eq("fauxbar")
value = lambda { "test" }
@vo.set_or_return(:test, value, {})
expect(@vo.set_or_return(:test, nil, {})).to be_a(Proc)
@dhparam_file.puts("I_am_not_a_key_I_am_a_free_man")
cipher = ::OpenSSL::Cipher.new("des3")
@keyfile.write("I_am_not_a_key_I_am_a_free_man")
@crlfile.write("I_am_not_a_crl_I_am_a_free_man")
instance.encrypt_rsa_key("abcd", "efgh", "des3")
instance.encrypt_ec_key("abcd", "efgh", "des3")
@encrypted_key = instance.encrypt_ec_key(@ec_key, "oink", "des3")
instance.gen_x509_extensions("keyUsage" => { "values" => "keyCertSign", "critical" => true })
@ca_cert.version = 2
@ca_cert.serial = 1
@ca_cert.not_after = @ca_cert.not_before + 365 * 24 * 60 * 60
@ca_cert.sign(@ca_key, OpenSSL::Digest.new("SHA256"))
@info_with_issuer = { "validity" => 365, "issuer" => @ca_cert }
@info_without_issuer = { "validity" => 365 }
it "Get 5" do
expect(@next_crl == 5).to be_truthy
it "get true" do
@info = { "validity" => 8, "issuer" => @ca_cert }
instance.gen_x509_crl(@ca_key, "abc" => "def", "validity" => 8)
instance.gen_x509_crl(@ca_key, "issuer" => "abc", "validity" => 8)
instance.gen_x509_crl(@ca_key, "issuer" => @ca_cert, "validity" => "abc")
@x509_crl = instance.gen_x509_crl(@ca_key, @info)
@crl = @instance.gen_x509_crl(@ca_key, @info)
instance.renew_x509_crl("abc", @ca_key, @info)
instance.renew_x509_crl(@crl, "abc", @info)
instance.renew_x509_crl(@crl, @ca_key, "abc")
instance.renew_x509_crl(@crl, @ca_key, "abc" => "def", "validity" => 8)
instance.renew_x509_crl(@crl, @ca_key, "issuer" => "abc", "validity" => 8)
instance.renew_x509_crl(@crl, @ca_key, "issuer" => @ca_cert, "validity" => "abc")
@renewed_crl = instance.renew_x509_crl(@crl, @ca_key, @info)
@revoke_info = { "serial" => 1, "reason" => 0 }
instance.revoke_x509_crl("abc", @crl, @ca_key, @info)
instance.revoke_x509_crl(@revoke_info, @crl, @ca_key, "abc")
instance.revoke_x509_crl({ "abc" => "def", "ghi" => "jkl" }, @crl, @ca_key, @info)
instance.revoke_x509_crl({ "serial" => 1, "reason" => "abc" }, @crl, @ca_key, @info)
instance.revoke_x509_crl(@revoke_info, @crl, @ca_key, "abc" => "def", "validity" => 8)
instance.revoke_x509_crl(@revoke_info, @crl, @ca_key, "issuer" => "abc", "validity" => 8)
instance.revoke_x509_crl(@revoke_info, @crl, @ca_key, "issuer" => @ca_cert, "validity" => "abc")
@certfile.write("I_am_not_a_cert_I_am_a_free_man")
let(:uid) { 1001 }
let(:user) { "foo" }
let(:user) { nil }
let(:brew_owner) { 2001 }
let(:default_brew_path) { "/usr/local/bin/brew" }
d = double
let(:brew_owner) { 0 }
@resource = Chef::Resource::File.new("#{@tmpdir}/madeup.txt")
uid: 0, gid: 0, dir: "/root",
shell: "/bin/bash")
group_struct = OpenStruct.new(name: "root", passwd: "x", gid: 0)
Chef::Log.init(@log_io)
@ruby_bindir = "/some/ruby/bin"
@gem_bindir = "/some/gem/bin"
env = {}
env = { "PATH" => "" }
env = { "PATH" => "/usr/bin:/sbin:/bin" }
env = { "PATH" => "/usr/bin:/sbin:/bin:/b#{0x81.chr}t".force_encoding("ISO-8859-1") }
ruby_bindir = "/usr/bin"
gem_bindir = "/yo/gabba/gabba"
env = { "PATH" => gem_bindir }
ruby_bindir = 'C:\ruby\bin'
gem_bindir = 'C:\gems\bin'
env = { "PATH" => "C:\\Windows\\system32;C:\\mr\\softie" }
@field_ko_prefix = "!merge"
hash_src = { "id" => "2" }
hash_dst = {}
hash_src = { "region" => { "id" => %w{227 2} } }
hash_src = {}
hash_dst = { "property" => %w{2 4} }
expect(hash_dst).to eq({ "property" => %w{2 4} })
hash_src = { "property" => %w{2 4} }
hash_src = { "name" => "value" }
hash_dst = { "name" => "value1" }
expect(hash_dst).to eq({ "name" => "value" })
hash_src = { "property" => %w{1 3} }
expect(hash_dst).to eq({ "property" => %w{2 4 1 3} })
hash_src = { "property" => "1" }
expect(hash_dst).to eq({ "property" => "1" })
hash_src = { %w{1 2 3} => %w{1 2} }
hash_src = { "action" => "browse", "controller" => "results" }
hash_src = { "valid" => false }
hash_dst = { "valid" => true }
expect(hash_dst).to eq({ "valid" => false })
hash_src = { "valid" => true }
hash_dst = { "valid" => false }
expect(hash_dst).to eq({ "valid" => true })
hash_src = { "item" => " " }
hash_dst = { "item" => "orange" }
expect(hash_dst).to eq({ "item" => " " })
hash_src = { "item" => "orange" }
hash_dst = { "item" => " " }
expect(hash_dst).to eq({ "item" => "orange" })
hash_src = { "item" => nil }
expect(hash_dst).to eq({ "item" => nil })
expect(@dm.merge(hash_dst, hash_src)).to eq({ "name" => "value" })
expect(@dm.merge(hash_dst, hash_src)).to eq({ "property" => %w{2 4 1 3} })
hash_dst = { "property" => { "values" => { "are" => "falling", "can" => "change" } } }
hash_src = { "property" => { "values" => { "are" => "stable", "may" => "rise" } } }
hash_dst = { "property" => %w{1 2 3} }
hash_src = { "property" => %w{4 5 6} }
ret = @dm.merge(hash_dst, hash_src)
expect(hash_dst).to eq({ "property" => %w{1 2 3} })
expect(hash_src).to eq({ "property" => %w{4 5 6} })
expect(ret).to eq({ "property" => %w{1 2 3 4 5 6} })
@dm.deep_merge(nil, 4)
merge_ee_hash = { "top_level_a" => "top-level-a-mergee", "top_level_b" => "top-level-b-merge-ee" }
merge_with_hash = { "top_level_a" => { "1_deep_a" => { "2_deep_a" => { "3_deep_b" => "bar" } } } }
expect(merge_ee_hash).to eq({ "top_level_a" => { "1_deep_a" => { "2_deep_a" => { "3_deep_a" => "foo" } } } })
expect(merge_with_hash).to eq({ "top_level_a" => { "1_deep_a" => { "2_deep_a" => { "3_deep_b" => "bar" } } } })
merge_ee_hash = { "top_level_a" => 1, "top_level_b" => false }
merge_with_hash = { "top_level_a" => 2, "top_level_b" => true }
expect(merged_result).to eq({ "item" => nil })
@stat = double("File::Stat", { mtime: Time.at(0) })
let(:object) { dummy_class.new }
let(:response) { OpenStruct.new(code: "405") }
.to be_nil
let(:response) { OpenStruct.new(code: "406") }
let(:min_server_version) { 2 }
let(:max_server_version) { 4 }
.to be_a_kind_of(Array)
.to eq(0)
Chef::Resource::LWRPBase.class_eval { @loaded_lwrps = {} }
run_context = Chef::RunContext.new(node, {}, nil)
raise "hi"
@lwrp_path = File.join(@tmpdir, "foo.rb")
content = IO.read(File.expand_path("../data/lwrp/resources/foo.rb", __dir__))
content = IO.read(File.expand_path("../data/lwrp_override/resources/foo.rb", __dir__))
attribute :drink, default: lazy { |r| "Drink after #{r.food}!" }
let(:instance) { klass.new("kitchen") }
let(:lwrp) do
Chef::Node.new.tap do |n|
let(:lwrp_cookbook_name) { "lwrp" }
Chef::Provider::LWRPBase.class_eval { @loaded_lwrps = {} }
let(:lwrp_cookbook_name) { "l_w_r_p" }
let(:lwrp_cookbook_name) { "l-w-r-p" }
let(:test_lwrp_class) { @test_lwrp_class }
@tmpdir = File.join(@tmpparent, "lwrp")
lwrp = get_lwrp(:lwrp_once).new("hi")
expect(get_lwrp(:lwrp_once) === lwrp).to be_truthy
lwrp = subclass.new("hi")
expect(lwrp.class === get_lwrp(:lwrp_once))
it "get_lwrp(:lwrp_once).new is *not* a subclass" do
let(:winevt) { Chef::Log::WinEvt.new(evtlog) }
Chef::Log.info("*** Chef 12.4.0.dev.0 ***")
let(:syslog) { Chef::Log::Syslog.new }
expect(syslog).to receive(:add).with(1, "*** Chef 12.4.0.dev.0 ***", nil)
let(:key) { Chef::Key.new("original_actor", "user") }
it "should be a Chef::Key" do
let(:field) { :actor }
let(:valid_input) { "new_field_value" }
let(:field) { :name }
let(:field) { :private_key }
let(:field) { :public_key }
let(:valid_input) { "2020-12-24T21:00:00Z" }
let(:valid_input) { "infinity" }
let(:new_key) { Chef::Key.new("original_actor", "user") }
let(:new_key) { Chef::Key.new("original_actor", "client") }
let(:key) do
o = { "user" => "turtle",
o = { "client" => "turtle",
o = Chef::Key.new("foobar", "user")
o = Chef::Key.new("foobar", "client")
let(:inflated_response) { { "foobar" => user_key } }
let(:inflated_response) { { "foobar" => client_key } }
{ "name" => "12:3e:33:73:0b:f4:ec:72:dc:f0:4c:51:62:27:08:76:96:24:f4:4a",
{ "name" => key.name,
$expected_output = {
actor_type => "foobar",
$expected_input = {
allow(rest).to receive(:post).with(url, $expected_input).and_return({ "private_key" => "this_private_key" })
let(:url) { "users/#{key.actor}/keys" }
let(:key) { user_key }
let(:actor_type) { "user" }
let(:url) { "clients/#{client_key.actor}/keys" }
let(:key) { client_key }
let(:actor_type) { "client" }
let(:url) { "users/#{key.actor}/keys/#{key.name}" }
let(:update_name_url) { "users/#{key.actor}/keys/old_name" }
let(:url) { "clients/#{client_key.actor}/keys/#{key.name}" }
let(:update_name_url) { "clients/#{client_key.actor}/keys/old_name" }
expect(rest).to receive(:get).with(url).and_return({ "user" => "foobar", "name" => "test_key_name", "public_key" => public_key_string, "expiration_date" => "infinity" })
key = Chef::Key.send(load_method, "foobar", "test_key_name")
let(:load_method) { :load_by_user }
let(:url) { "users/foobar/keys/test_key_name" }
let(:load_method) { :load_by_client }
let(:url) { "clients/foobar/keys/test_key_name" }
end # load
let(:json) { %Q{{\n/* comment */\n// comment 2\n"json_class": "Chef::Role"}} }
def to_json(*a)
Chef::JSONCompat.to_json({ "foo" => 1234, "bar" => { "baz" => 5678 } }, *a)
f = Foo.new
let(:jsonable) { Foo.new }
v = 252.times.inject(hash) do |memo, _|
expect(v).to eq("test")
let(:uri) { URI("chefzero://localhost:1") }
subject(:http) { Chef::HTTP.new(uri) }
http = Chef::HTTP.new(uri)
http = Chef::HTTP.new(uri, { nethttp: { "continue_timeout" => 5 } })
http = Chef::HTTP.new("http://www.getchef.com")
http = Chef::HTTP.new("http://www.getchef.com/")
expect { http.create_url("HTTP://www1.chef.io/") }.not_to raise_error
expect(http.create_url("HTTP://www2.chef.io/")).to eql(URI.parse("http://www2.chef.io/"))
http = Chef::HTTP.new("")
expect(http.head("http://www.getchef.com/")).to eql(nil)
resp = Net::HTTPNotModified.new("1.1", 304, "Not Modified")
end # head
let!(:low_level_client) { http.http_client(URI(uri)) }
allow(r).to receive(:read_body).and_return("")
http.get("/")
expect { http.get("/") }.to raise_error(exception.class)
let(:method) { "GET" }
let(:url) { "http://dummy.com" }
let(:headers) { {} }
let(:data) { false }
let(:request) {}
let(:return_value) { "200" }
let(:request_type) { :streaming }
let(:content_length_value) { 23 }
let(:streaming_length) { 23 }
let(:response_body) { "Thanks for checking in." }
chunk_size = data_length > 10 ? 10 : data_length
let(:request_type) { :direct }
let(:response_headers) { {} }
let(:request_type) { req_type.to_sym }
let(:content_length_value) { "-1" }
let(:content_length_value) { 25 }
let(:streaming_length) { 12 }
File.write(bad_cert_file, File.read(__FILE__))
let(:relative_url) { "" }
let(:uri_str) { "chefzero://localhost:1/#{relative_url}" }
let(:uri) { URI(uri_str) }
it "has a host" do
it "has a port" do
let(:method) { :GET }
let(:relative_url) { "clients" }
let(:headers) { { "Accept" => "application/json" } }
let(:body) { false }
let(:expected_body_str) { "" }
let(:rack_req) { zero_client.req_to_rack(method, uri, body, headers) }
let(:method) { :PUT }
let(:relative_url) { "clients/foo" }
let(:body) { "bunch o' JSON" }
let(:expected_body_str) { "bunch o' JSON" }
let(:code) { 200 }
let(:headers) { { "Content-Type" => "Application/JSON" } }
expect(net_http_response.read_body { |chunk| chunk }).to eq("bunch o' JSON")
let(:code) { 404 }
let(:headers) { { "Accept" => "application/json", "X-Ops-Server-API-Version" => "2" } }
let(:response_code) { 200 }
let(:response_headers) { { "Content-Type" => "Application/JSON" } }
let(:url) { URI.parse("http://example.com") }
let(:http_method) { :get }
let(:data) { nil }
let(:http_method) { :put }
let(:data) { { foo: "bar" } }
let(:data) { "some arbitrary bytes" }
expect(headers).to eq({ "content-type" => "application/x-binary" })
expect(headers).to eq({ "Content-Type" => "application/x-binary" })
request = Chef::HTTP::HTTPRequest.new(:GET, URI("http://dummy.com:8000"), "", { "Host" => "yourhost.com:8888" })
uri = URI("http://dummy.com/foo?bar=baz")
expect(uri).to eql(URI("http://dummy.com/foo?bar=baz"))
request = Chef::HTTP::HTTPRequest.new(:GET, URI("http://dummy.com:8000"), "", { "Host" => "myhost.com:80" })
let(:uri) { URI("https://example.com:4443") }
net_http_mock = instance_double(Net::HTTP, proxy_address: nil, "proxy_port=" => nil, "read_timeout=" => nil, "open_timeout=" => nil)
require_relative "../../../lib/chef/win32/registry"
let(:data) { "" }
let(:node_name) { "test" }
cert_name = "chef-#{node_name}"
d = Time.now
end_date = Time.new + (3600 * 24 * 90)
values = { name: "PfxPass", type: :string, data: encrypted_pass }
.to include({ "X-Ops-Server-API-Version" => "2" })
let(:class_instance) { Chef::HTTP::Authenticator.new({ api_version: "-10" }) }
.to include({ "X-Ops-Server-API-Version" => "-10" })
).and_return({})
let(:public_key) { <<~EOH }
let(:url) { "http://localhost:60123" }
let(:return_value) { "406" }
Chef::ServerAPIVersions.instance.set_versions({ "min_version" => 1, "max_version" => 3 })
@end_time = @start_time + 4.2
class << self
let(:resource) { Chef::Resource.new("foo") }
let(:run_context) { Chef::RunContext.new(node, nil, nil) }
@node = Chef::Node.new.tap do |n|
@response = Net::HTTPForbidden.new("1.1", "403", "(response) forbidden")
not_if("/bin/false")
@resource = template("/tmp/foo.txt") do
expect(@inspector.recipe_snippet).to match(/^# In C:\\Windows\\Temp\\packer\\/)
@resource.source_line = "(irb#1):1:in `irb_binding'"
source_line = "#{angry_bash_recipe}:1:in `<main>'"
@response = Net::HTTPBadGateway.new("1.1", "502", "(response) bad gateway")
let(:node_name) { "test-node.example.com" }
let(:stdout) { StringIO.new }
recipe_lines = BAD_RECIPE.split("\n").map { |l| l << "\n" }
let(:path_to_failed_file) { nil }
let(:full_path_to_failed_file) { "C:/opscode/chef#{path_to_failed_file}" }
trace_with_upcase_drive.map { |line| line.gsub(/^C:/, "c:") }
let(:full_path_to_failed_file) { "c:/opscode/chef#{path_to_failed_file}" }
let(:response) { double("response") }
let(:min_version) { "2" }
let(:max_version) { "5" }
let(:request_version) { "30" }
let(:title) { "test title" }
let(:section_heading) { "test heading" }
let(:section_text) { "test text" }
------------
Chef.set_node({ "platform" => "openvms", "platform_version" => "8.4-2L1" })
let(:out) { StringIO.new }
let(:err) { StringIO.new }
cookbook_version = double(name: "apache2", version: "1.2.3")
expect(out.string).to include("- apache2 (1.2.3")
@now = Time.now
allow(Time).to receive(:now).and_return(@now, @now + 10.0)
allow(Time).to receive(:now).and_return(@now, @now + 610.0)
allow(Time).to receive(:now).and_return(@now, @now + 36610.0)
expect(out.string).to eq("")
expect(out.string).to include(" - Progress: 70%")
expect(out.string).to include(" - Progress: 80%")
let(:formatter) { Chef::Formatters::Base.new(out, err) }
let(:tempname) { windows? ? "chef-new_file" : ".chef-new_file" }
let(:target_file_path) { "/etc/my_app.conf" }
let(:empty_dacl) { double("Windows ACL with no dacl ACEs") }
let(:empty_sacl) { double("Windows ACL with no sacl ACEs") }
let(:dacl_inherits?) { false }
let(:sacl_inherits?) { false }
let(:dacl_inherits?) { true }
let(:sacl_inherits?) { true }
let(:target_file_mode) { 0644 }
let(:target_file_uid) { 1001 }
let(:target_file_gid) { 1001 }
let(:target_file_uid) { 0 }
let(:target_file_gid) { 20 }
expect(File).to receive(:open).with(File.join(@file_cache_path, "whiz", "bang"), "w", 416).and_yield(@io)
File.open(File.join(@file_cache_path, "whiz", "bang"), "w") { |f| f.print("borkborkbork") }
expect(File).not_to exist(File.join(@file_cache_path, "whiz", "bang"))
expect(Chef::FileCache.find("snappy/**/*")).to eq(%w{snappy/patter})
load File.join(__dir__, "..", "..", "lib", "chef", "file_access_control.rb")
@resource = Chef::Resource::File.new("/tmp/a_file.txt")
expect(@fac.target_uid).to eq(-2)
let(:num_errors) { 0 }
let(:num_errors) { 1 }
let(:num_errors) { 2 }
subject.on(:foo_bar) {}
subject.on(:run_failed) { "testhook" }
@ivar << 2
run_status = Chef::RunStatus.new({}, {})
expect(@environment.default_attributes({ one: "two" })).to eq({ one: "two" })
expect(@environment.override_attributes({ one: "two" })).to eq({ one: "two" })
@environment.cookbook("apt", "~> 1.2.3")
@environment.cookbook("apt", ">= 1.2.3")
@environment.cookbook_versions({ "apt" => "= 1.2.3" })
@example.cookbook_versions({ "apt" => "= 2.3.4" })
@environment.cookbook_versions({ apt: "= 1.2.3" })
it "should include '#{t}'" do
expect(@json).to match(/"#{t}":#{Regexp.escape(Chef::JSONCompat.to_json(@environment.send(t.to_sym)))}/)
@data = {
it "should match '#{t}'" do
expect(@environment.update_from_params(name: "@$%^&*()")).to be_falsey
params = { name: "superbowl", cookbook_version: { "0" => "apache2 ~> 1.0.0", "1" => "nginx < 2.0.0" } }
expect(@environment.cookbook_versions).to eq({ "apache2" => "~> 1.0.0", "nginx" => "< 2.0.0" })
params = { cookbook_version: { "0" => "apache2 >>> 1.0.0" } }
expect(@environment.default_attributes).to eq({ "fuuu" => "RAGE" })
e1 = double("Chef::Environment", name: "one")
role_dsl = "name \"foo\"\ndescription \"desc\"\n"
let(:plaintext_data) { { "foo" => "bar" } }
let(:key) { "passwd" }
let(:plaintext_data) { 5 }
let(:encryption_key) { "passwd" }
let(:json_wrapped_data) { Chef::JSONCompat.to_json({ "json_wrapper" => plaintext_data }) }
let(:bogus_auth_tag) { "bogus_auth_tag" }
let(:decryption_key) { "wrong-passwd" }
let(:secret) { "abc123SECRET" }
it "doesn't encrypt the 'id' key" do
it "doesn't try to decrypt 'id'" do
let(:secret) { "opensesame" }
expect(tester.encrypted?({ id: "foo" })).to eq(false)
let(:item_name) { "item_name" }
let(:version) { 1 }
let(:version) { 2 }
let(:version) { 3 }
}.each do |m|
it "responds to ##{m}" do
let(:service) { :hashi_vault }
let(:config) { { my_key: "value" } }
dsl.secret(name: "key1", service: :example, config: {})
secret_value = dsl.secret(name: "test1", service: :example, config: { "test1" => "secret value" })
let(:run_context) {
peace secret(name: "test1", service: :example, config: { "test1" => true })
config = { my_config: "value" }
hash = {
echo = "foxtrot"
golf = "hotel"
bravo = 10
juliett = "blue"
- lima
- mike
let(:cookbook_name) { "example_cb" }
let(:recipe_name) { "example_recipe" }
recipe = Chef::Recipe.new(nil, nil, Chef::RunContext.new(Chef::Node.new, {}, nil))
@node = node
:openbsd => { default: "free, functional, secure" },
%i{redhat centos fedora scientific} => { default: '"stable"' },
:ubuntu => { "10.04" => "using upstart more", :default => "using init more" },
:default => "bork da bork",
node = { platform: "ubuntu", platform_version: "10.04" }
node = { platform: "ubuntu", platform_version: "9.10" }
bad_hash = { ubuntu: :foo } # should be :ubuntu => {:default => 'foo'}
:gentoo => "gentoo value",
:default => "default value",
cookbook_repo = File.expand_path(File.join(__dir__, "..", "..", "data", "cookbooks"))
).to be nil
.with("bag_name")
.and_return("item_1" => "http://url_for/item_1", "item_2" => "http://url_for/item_2")
expect( language.data_bag("bag_name").sort ).to eql %w{item_1 item_2}
let(:bag_name) { "bag_name" }
let(:item) do
let(:method_name) { :data_bag_item }
str.split("::").inject(Object) do |mod, class_name|
@a = @r = @w = 1
deprecated_attr :a, "a"
test.a = 10
test.w = 10
expect(test.instance_eval { @w }).to eq 10
let(:message) { "A test message" }
let(:location) { "the location" }
id_map = {}
collisions = id_map.select { |k, v| v.size != 1 }
raise "Found deprecation ID collisions:\n#{collisions.map { |k, v| "* #{k} #{v.map(&:name).join(", ")}" }.join("\n")}"
it "#is_a?(#{klass}) is true" do
it "#is_a?(Chef::Decorator) is true" do
it "#kind_of?(#{klass}) is true" do
it "#kind_of?(Chef::Decorator) is true" do
it "#instance_of?(#{klass}) is false" do
let(:obj) {}
it "#nil? is false" do
it "!! is true" do
let(:obj) { nil }
it "#nil? is true" do
it "!! is false" do
let(:obj) { {} }
expect(FFI_Yajl::Encoder.encode(decorator, pretty: true)).to eql("{\n\n}\n")
let(:obj) { { foo: "bar", baz: "qux" } }
@a = 0
Chef::Decorator::Lazy.new { @a += 1 }
expect(@a).to eql(0)
@foo ||= 1
@bar ||= 2
decorator.each { |i| }
let(:run_list) { node.run_list }
let(:cookbooks) { node.fetch("cookbooks", {}) }
let(:recipe_name) { "atlas" }
let(:node_name) { "spitfire" }
let(:exception) { nil }
let(:expected_node) { node }
keys ||= {
{ "Content-Type" => "application/json" }
it "has a end_time" do
it "has a run_id" do
it "has a run_list" do
it "has a source" do
it "has a status" do
let(:total_resource_count) { 0 }
let(:status) { "failure" }
let(:expected_node) { {} } # no node because that failed
let(:status) { "success" }
let(:total_resource_count) { 1 }
let(:cookbook_name) { "@recipe_files" }
let(:cookbook_version) { nil }
let(:total_resource_count) { 2 }
rec = resource_record_for(new_resource, nil, nil, :create, "failed", "1234")
let(:shift_jis) { "I have no idea what this character is:\n #{0x83.chr}#{0x80.chr}.\n" }
let(:message) { "message" }
let(:err) do
response = double("Net::HTTP response", code: "404")
let(:file_path) { "/tmp/client-runs.txt" }
expect(@data_bag.name("clowns")).to eq("clowns")
expect(@data_bag.name("clown#{char}clown")).to eq("clown#{char}clown")
let(:jsonable) { @data_bag }
exception = double("409 error", code: "409")
expect(@rest).to receive(:post).with("data", @data_bag)
expect(@http_client).to receive(:get).with("data/foo").and_return({ "bar" => "https://myserver.example.com/data/foo/bar" })
data_bag = Chef::DataBag.load("foo")
expect(data_bag).to eq({ "bar" => "https://myserver.example.com/data/foo/bar" })
if path == @paths.first
expect(IO).to receive(:read).with(File.join(@paths.first, "foo/bar.json")).and_return('{"id": "bar", "name": "Bob Bar" }')
expect(IO).to receive(:read).with(File.join(@paths.first, "foo/baz.json")).and_return('{"id": "baz", "name": "John Baz" }')
item_with_different_content = "{\"id\": \"bar\", \"name\": \"Bob Bar\", \"path\": \"#{path}\"}"
item_2_with_different_content = '{"id": "bar", "name": "John Baz"}'
item_with_same_content = '{"id": "bar", "name": "Bob Bar"}'
test_data_bag = { "bar" => { "id" => "bar", "name" => "Bob Bar" } }
test_item_with_same_content = '{"id": "bar", "name": "Bob Bar"}'
test_uniq_item = "{\"id\": \"baz_#{index}\", \"name\": \"John Baz\", \"path\": \"#{path}\"}"
expect(data_bag_list).to eq({ "bar" => "bar", "foo" => "foo" })
msg = "Data bag path '#{windows? ? "C:/var/chef" : "/var/chef"}/data_bags' not found. Please create this directory."
it_should_behave_like "data bag in solo mode", "#{windows? ? "C:/var/chef" : "/var/chef"}/data_bags"
expect { data_bag_item.raw_data = { "id" => "octahedron" } }.not_to raise_error
expect { data_bag_item.raw_data = { id: "octahedron" } }.not_to raise_error
expect { data_bag_item.raw_data = Mash.new({ "id" => "octahedron" }) }.not_to raise_error
expect { data_bag_item.raw_data = { "monkey" => "pants" } }.to raise_error(ArgumentError)
expect { data_bag_item.raw_data = { "id" => "h1-_" } }.not_to raise_error
expect { data_bag_item.raw_data = { "id" => "foo.bar" } }.not_to raise_error
expect { data_bag_item.raw_data = { "id" => ".bozo" } }.not_to raise_error
expect { data_bag_item.raw_data = { "id" => "!@#" } }.to raise_error(ArgumentError)
data_bag_item.raw_data = { "id" => "highway_of_emptiness" }
expect(data_bag_item.raw_data).to eq({ "id" => "highway_of_emptiness" })
data_bag_item.raw_data = { "id" => "the_beatdown" }
data_bag_item.raw_data = { "id" => "the_beatdown", "name" => "Bruce" }
data_bag_item.raw_data = { "id" => "journey", "trials" => "been through" }
Chef::DataBagItem.from_hash({ "raw_data" => { "id" => "whoa", "name" => "Bruce", "i_know" => "kung_fu" } })
Chef::DataBagItem.from_hash({ "id" => "whoa", "name" => "Bruce", "i_know" => "kung_fu" })
data_bag_item.raw_data = { "id" => "whoa", "name" => "Bruce", "i_know" => "kung_fu" }
let(:to_hash) { data_bag_item.to_hash }
data_bag_item.raw_data = { "id" => "octahedron", "name" => "Bruce", "snooze" => { "finally" => :world_will } }
let(:jsonable) { data_bag_item }
raw_data = { "id" => "heart_of_darkness", "author" => "Conrad" }
data_bag_item.raw_data = { "id" => "heart_of_darkness", "author" => "Conrad" }
data_bag_item.raw_data = { "id" => "some_id" }
data_bag_item.raw_data = { "id" => "charlie", "shell" => "zsh", "ssh_keys" => %w{key1 key2} }
let(:http_client) { double("Chef::ServerAPI") }
expect(Chef::DataBag).to receive(:load).with("users").and_return({ "charlie" => data_bag_item.to_hash })
mock_struct = # Struct::Passwd.new(nil, nil, 111, 111)
expect(Dir).to receive(:chdir).with("/").and_return(0)
@pw_user = double("Struct::Passwd", uid: 501)
@pw_group = double("Struct::Group", gid: 20)
let(:cookbook_version) { Chef::CookbookVersion.new("mycb", "/tmp/mycb") }
sm = Chef::CookbookVersion.new("foo", "/tmp/blah")
lg = Chef::CookbookVersion.new("foo", "/tmp/blah")
a = Chef::CookbookVersion.new("foo", "/tmp/blah")
b = Chef::CookbookVersion.new("foo", "/tmp/blah")
a.version = "1.2"
b.version = "1.2.0"
expect(a).to eq(b)
apt = Chef::CookbookVersion.new "apt", "/tmp/blah"
apt.version = "1.0"
god = Chef::CookbookVersion.new "god", "/tmp/blah"
god.version = "2.0"
good_versions = %w{1.2 1.2.3 1000.80.50000 0.300.25}
name: "files/afile.rb",
name: "files/bfile.rb",
path: "files/fakeos-2.0.rc.1/bfile.rb",
let(:policy_mode) { false }
{ "checksums" => sandbox_checksums, "uri" => sandbox_commit_uri }
let(:policy_mode) { true }
COOKBOOK_PATH = File.expand_path(File.join(__dir__, "..", "data", "cookbooks", "openldap"))
@cookbook_repo = File.expand_path(File.join(__dir__, "..", "data", "cookbooks"))
let(:version) { "1.2.3" }
let(:cookbook_root) { "/tmp/blah" }
parts = relative_path.split("/")
}.tap do |fp|
seen = {}
end).not_to eql(nil)
f =~ /\.dotfile$/
end).to match(/\.dotfile$/)
f =~ %r{\.ssh/id_rsa$}
end).to match(%r{\.ssh/id_rsa$})
search_str = "\"openldap\":\""
expect(key_idx).to be > 0
spec/spec_helper.rb }.map { |f| File.join(cookbook_path, f) }
@attr_files = %w{default.rb smokey.rb}.map { |f| File.join(cookbook_path, "attributes", f) }
@libr_files = %w{openldap.rb openldap/version.rb}.map { |f| File.join(cookbook_path, "libraries", f) }
@defn_files = %w{client.rb server.rb}.map { |f| File.join(cookbook_path, "definitions", f) }
@recipes = %w{default.rb gigantor.rb one.rb return.rb}.map { |f| File.join(cookbook_path, "recipes", f) }
@template_files = @basenames.map { |f| File.join(cookbook_path, "templates", "default", f) }
let(:cache_path) { Dir.mktmpdir }
let(:no_lazy_load) { true }
{ "valid1" => {}, "valid2" => {} }
let(:root) { windows? ? "C:/file-cache/cookbooks/cookbook_a" : "/file-cache/cookbooks/cookbook_a" }
.with("#{root}/recipes/default.rb")
let(:server_api) { double("Chef::ServerAPI (mock)") }
let(:file_cache) { double("Chef::FileCache (mock)") }
let(:no_lazy_load) { false }
let(:skip_cookbook_sync) { true }
setter = "#{field}="
duck_type.send("#{field_to_change}=".to_sym, :epic_fail)
it "has no name" do
it "is not valid" do
it "is valid" do
metadata.supports("ubuntu", ">= 8.04")
params = {
license: "Apache v2.0",
version: "0.6.0",
source_url: "http://example.com",
it "should be set-able via #{field}" do
it "should be get-able via #{field}" do
it "should transform an '0.6' version to '0.6.0'" do
expect(metadata.send(:version, "0.6")).to eql("0.6.0")
it "should spit out '0.6.0' after transforming '0.6'" do
metadata.send(:version, "0.6")
dep_types = {
dep_types.sort_by(&:to_s).each do |dep, dep_args|
it "should be set-able via #{dep}" do
it "can be set to a string" do
it "can be set to an array" do
ret << Gem::Dependency.new("chef", *arg)
ret << Gem::Dependency.new("ohai", *arg)
ret << arg
{ name: "recipes/default.rb", path: "recipes/default.rb", checksum: "my_only_friend" },
metadata.depends "bobo", "= 1.0"
metadata.depends "bubu", "=1.0"
metadata.gem "foo", "~> 1.2"
metadata.gem "bar", ">= 2.2", "< 4.0"
metadata.chef_version "< 11.18.10", ">= 11.14.2"
metadata.chef_version "< 12.5.1", ">= 12.2.1"
metadata.ohai_version "< 7.5.0", ">= 7.1.0"
metadata.ohai_version "< 8.6.0", ">= 8.0.1"
json = %q{{ "some_spiffy_new_metadata_field": "stuff its set to" }}
it "with #{segment}" do
),
double(:shell_out, stdout: "")
b = Bundler::Dsl.new
expect(IO).to receive(:read).and_return("")
expect(Chef::Log).to receive(:info).and_return("")
let(:http) { double("Chef::ServerAPI") }
let(:chefignore) { nil }
let(:option) { :log_level }
let(:value) { :debug }
let(:option) { :log_location }
let(:value) { "path/to/log" }
let(:valid_json) { Chef::JSONCompat.to_json({ a: "b" }) }
let(:http) { double("Chef::HTTP::Simple") }
let(:config_location) { "/etc/chef/client.rb" }
let(:config_content) { "# The client.rb content" }
let(:config_location) { "client.rb" }
let(:config_location) { "/etc/chef/first-boot.json" }
expect(fetcher.fetch_json).to eq({ "a" => "b" })
let(:config_location) { "https://example.com/foo.json" }
.with("").and_return(valid_json)
let(:config_location) { nil }
let(:data) { { "ssh-01" => { "expiration_date" => Date.jd(2463810), "justification" => "waived, yo", "run" => false } } }
it "has a path" do
string = <<~EOH
let(:node) { Chef::Node.new(logger: logger) }
r.node = node
r.run_id = "my_run_id"
version: "2.1.0",
name: "ssh",
report = {
node_info: {
{ "status": "passed", "code_desc": "File /tmp should be directory", "run_time": 0.002312, "start_time": "2016-10-19 11:09:43 -0400" },
{ "title": "/tmp directory is owned by the root user",
{ "status": "passed", "code_desc": 'File /tmp should be owned by "root"', "run_time": 1.228845, "start_time": "2016-10-19 11:09:43 -0400" },
{ "status": "skipped", "code_desc": 'File /tmp should be owned by "root"', "run_time": 1.228845, "start_time": "2016-10-19 11:09:43 -0400" },
require "json" # For .to_json
run_time_limit: 1.1,
let(:token) { "fake_token" }
).to_return(
body: {
{ "name": "syslog_pkg", "options": { "default": "rsyslog", "description": "syslog package..." } },
{ "status": "passed", "code_desc": "File /tmp should be directory" },
{ "status": "passed", "code_desc": "File /etc should be directory", "run_time": 0.002314, "start_time": "2016-10-19 11:09:45 -0400" },
{ "status": "passed", "code_desc": "File /opt should be directory", "run_time": 0.002315, "start_time": "2016-10-19 11:09:46 -0400" },
{ "status": "skipped", "code_desc": "No-op", "run_time": 0.002316, "start_time": "2016-10-19 11:09:44 -0400", "skip_message": "4 testing" },
{ "status": "skipped", "code_desc": "No-op", "run_time": 0.002317, "start_time": "2016-10-19 11:09:44 -0400", "skip_message": "4 testing" },
{ "status": "skipped", "code_desc": "No-op", "run_time": 0.002318, "start_time": "2016-10-19 11:09:44 -0400", "skip_message": "4 testing" },
{ "status": "failed", "code_desc": "File /etc/passwd should be directory", "run_time": 0.002313, "start_time": "2016-10-19 11:09:44 -0400" },
{ "id": "tmp-2.1",
{ "status": "passed", "code_desc": 'File /etc should be owned by "root"', "run_time": 1.238845, "start_time": "2016-10-19 11:09:43 -0400" },
expected = {
name: "syslog_pkg",
options: {
id: "tmp-1.0",
id: "tmp-1.1",
code_desc: 'File /tmp should be owned by "root"',
start_time: "2016-10-19 11:09:43 -0400",
version: "0.1.1",
version: "1.2.1",
name: ssh-baseline#{" "}
title: DevSec SSH Baseline#{" "}
copyright_email: hello@dev-sec.io#{" "}
license: Apache-2.0#{" "}
version: 2.6.4#{" "}
version: "1.2.3"
version: "1.2.3",
hash_including("token" => nil)
let(:client_opts) { {} }
c.node = node
let(:logger) { instance_double("Mixlib::Log::Child", trace: nil, debug: nil, warn: nil, info: nil, error: nil, fatal: nil) }
let(:stderr) { StringIO.new }
let(:api_client_exists?) { false }
let(:runner) { instance_double("Chef::Runner") }
.and_return({})
response = Net::HTTPNotFound.new("1.1", "404", "Not Found")
let(:hostname) { "test" }
let(:my_client) { Chef::Client.new }
let(:cert_name) { "chef-#{hostname}" }
let(:node_name) { "#{hostname}" }
if d.month == 10 || d.month == 11 || d.month == 12
end_date = Time.new(d.year + 1, d.month - 9, d.day, d.hour, d.min, d.sec).utc.iso8601
end_date = Time.new(d.year, d.month + 3, d.day, d.hour, d.min, d.sec).utc.iso8601
it "fails" do
allow(Time).to receive(:now).and_return(Time.new(2021, 5, 1, 5))
it "defaults to 1.1" do
it "defaults to 1.3" do
let(:api_client_exists?) { true }
let(:client_opts) { { runlist: new_runlist } }
@run_lock = double("Chef::RunLock", acquire: true)
test_env = { "name" => "A" }
let(:http_response) { Net::HTTPNotFound.new("1.1", "404", "Not Found") }
let(:fqdn) { nil }
let(:machinename) { nil }
let(:hostname) { nil }
expect(Chef::VERSION).to match(/(\d+)\.(\d+)\.(\d+)/)
expect(Chef::ChefFS::PathUtils.join("a", "b", "c")).to eq("a/b/c")
expect(Chef::ChefFS::PathUtils.join("a/", "/b", "/c/")).to eq("a/b/c")
expect(Chef::ChefFS::PathUtils.join("a/", "/b", "///c/")).to eq("a/b/c")
expect(Chef::ChefFS::PathUtils.join("/a/", "/b", "c/")).to eq("/a/b/c")
expect(Chef::ChefFS::PathUtils.join("///a/", "/b", "c/")).to eq("/a/b/c")
let(:good_path) { __dir__ }
it "handles paths with .. and ." do
expect(Chef::ChefFS::PathUtils.realest_path(good_path + "/*/foo")).to eq(File.expand_path(good_path + "/*/foo"))
expect(Chef::ChefFS::PathUtils.realest_path("C:/")).to eq("C:/")
expect(Chef::ChefFS::PathUtils.realest_path("/")).to eq("/")
expect(Chef::ChefFS::PathUtils.descendant_path("C:/ab/b/c", "C:/AB/B")).to eq("c")
expect(Chef::ChefFS::PathUtils.descendant_path("C:/ab/b/c", "c:/ab/B")).to eq("c")
expect(Chef::ChefFS::PathUtils.descendant_path("/D/E/F", "/A/B/C")).to be_nil
expect(Chef::ChefFS::PathUtils.descendant_path("/A/B/D", "/A/B/C")).to be_nil
expect(Chef::ChefFS::PathUtils.descendant_path("/A/B/D", "/A/B/D")).to eq("")
describe Chef::ChefFS::FileSystem, ruby: ">= 3.0" do
let(:fs) { memory_fs("", {}) }
it "/" do
list_should_yield_paths(fs, "/", "/")
it "/a" do
list_should_yield_paths(fs, "/a", "/a")
it "/a/b" do
list_should_yield_paths(fs, "/a/b", "/a/b")
it "/*" do
list_should_yield_paths(fs, "/*", "/")
expect(Chef::ChefFS::FileSystem.resolve_path(fs, "/").path).to eq("/")
expect(Chef::ChefFS::FileSystem.resolve_path(fs, "/a").path).to eq("/a")
expect(Chef::ChefFS::FileSystem.resolve_path(fs, "/a/b").path).to eq("/a/b")
let(:fs) do
memory_fs("", {
a: {
aa: {
c: "",
zz: "",
ab: {
x: "",
y: {},
it "/**" do
list_should_yield_paths(fs, "/*", "/", "/a", "/x", "/y")
it "/*/*" do
list_should_yield_paths(fs, "/*/*", "/a/aa", "/a/ab")
it "/*/*/*" do
list_should_yield_paths(fs, "/*/*/*", "/a/aa/c", "/a/aa/zz", "/a/ab/c")
it "/*/*/?" do
list_should_yield_paths(fs, "/*/*/?", "/a/aa/c", "/a/ab/c")
it "/a/*/c" do
list_should_yield_paths(fs, "/a/*/c", "/a/aa/c", "/a/ab/c")
it "/**b/c" do
list_should_yield_paths(fs, "/**b/c", "/a/ab/c")
it "/a/ab/c" do
list_should_yield_paths(fs, "/a/ab/c", "/a/ab/c")
list_should_yield_paths(fs, "/a/ab/blah", "/a/ab/blah")
list_should_yield_paths(fs, "/a/ab/blah/bjork", "/a/ab/blah/bjork")
it "resolves /" do
it "resolves /x" do
expect(Chef::ChefFS::FileSystem.resolve_path(fs, "/x").path).to eq("/x")
it "resolves /a" do
it "resolves /a/aa" do
expect(Chef::ChefFS::FileSystem.resolve_path(fs, "/a/aa").path).to eq("/a/aa")
it "resolves /a/aa/zz" do
expect(Chef::ChefFS::FileSystem.resolve_path(fs, "/a/aa/zz").path).to eq("/a/aa/zz")
expect(Chef::ChefFS::FileSystem.resolve_path(fs, "/q/x/w").path).to eq("/q/x/w")
it "is not empty /" do
it "is empty /y" do
!is_dir && File.extname(name) == ".json"
let(:root) do
context "#empty?" do
dir = described_class.new(".test", root, tmp_dir)
let(:file) do
let(:content) { '"name": "canteloup"' }
let(:file_path) { File.join(tmp_dir, "test_file.json") }
let(:error_message) { 'HTTP error writing: 400 "Bad Request"' }
def p(str)
let(:pattern) { Chef::ChefFS::FilePattern.new("") }
it "match?" do
expect(pattern.match?("/")).to be_falsey
let(:pattern) { Chef::ChefFS::FilePattern.new("/") }
expect(pattern.match?("/")).to be_truthy
let(:pattern) { Chef::ChefFS::FilePattern.new("abc") }
let(:pattern) { Chef::ChefFS::FilePattern.new("/abc") }
expect(pattern.exact_child_name_under("/")).to eq("abc")
let(:pattern) { Chef::ChefFS::FilePattern.new("abc/def/ghi") }
let(:pattern) { Chef::ChefFS::FilePattern.new("/abc/def/ghi") }
let(:pattern) { Chef::ChefFS::FilePattern.new('a\*\b') }
context 'with star pattern "/abc/*/ghi"' do
let(:pattern) { Chef::ChefFS::FilePattern.new("/abc/*/ghi") }
let(:pattern) { Chef::ChefFS::FilePattern.new("/abc/d*f/ghi") }
context 'with star pattern "/abc/d??f/ghi"' do
let(:pattern) { Chef::ChefFS::FilePattern.new("/abc/d??f/ghi") }
context 'with star pattern "/abc/**/ghi"' do
let(:pattern) { Chef::ChefFS::FilePattern.new("/abc/**/ghi") }
expect(pattern.match?("/abc/d/e/f/ghi")).to be_truthy
context 'with star pattern "/abc**/ghi"' do
let(:pattern) { Chef::ChefFS::FilePattern.new("/abc**/ghi") }
context 'with star pattern "/abc/**ghi"' do
let(:pattern) { Chef::ChefFS::FilePattern.new("/abc/**ghi") }
context 'with star pattern "a**b**c"' do
let(:pattern) { Chef::ChefFS::FilePattern.new("a**b**c") }
expect(pattern.match?("a/x/y/b/z/w/c")).to be_truthy
expect(p("abc/").normalized_pattern).to eq("abc")
expect(p("abc/").exact_path).to eq("abc")
expect(p("abc/").match?("abc")).to be_truthy
expect(p("//").normalized_pattern).to eq("/")
expect(p("//").exact_path).to eq("/")
expect(p("//").match?("/")).to be_truthy
expect(p("/./").normalized_pattern).to eq("/")
expect(p("/./").exact_path).to eq("/")
expect(p("/./").match?("/")).to be_truthy
expect(p("abc//def").exact_path).to eq("abc/def")
expect(p("abc//def").match?("abc/def")).to be_truthy
expect(p("abc//").normalized_pattern).to eq("abc")
expect(p("abc//").exact_path).to eq("abc")
expect(p("abc//").match?("abc")).to be_truthy
expect(p("abc/./def").normalized_pattern).to eq("abc/def")
expect(p("abc/./def").exact_path).to eq("abc/def")
expect(p("abc/./def").match?("abc/def")).to be_truthy
expect(p("./abc/def").normalized_pattern).to eq("abc/def")
expect(p("./abc/def").exact_path).to eq("abc/def")
expect(p("./abc/def").match?("abc/def")).to be_truthy
expect(p("/.").normalized_pattern).to eq("/")
expect(p("/.").exact_path).to eq("/")
expect(p("/.").match?("/")).to be_truthy
expect(p("abc/../def").normalized_pattern).to eq("def")
expect(p("abc/../def").exact_path).to eq("def")
expect(p("abc/../def").match?("def")).to be_truthy
expect(p("abc/def/../..").normalized_pattern).to eq("")
expect(p("abc/def/../..").exact_path).to eq("")
expect(p("abc/def/../..").match?("")).to be_truthy
expect(p("/*/../def").normalized_pattern).to eq("/def")
expect(p("/*/../def").exact_path).to eq("/def")
expect(p("/*/../def").match?("/def")).to be_truthy
expect(p("/*/*/../def").normalized_pattern).to eq("/*/def")
expect(p("/*/*/../def").exact_path).to be_nil
expect(p("/*/*/../def").match?("/abc/def")).to be_truthy
expect(p("/abc/def/../..").normalized_pattern).to eq("/")
expect(p("/abc/def/../..").exact_path).to eq("/")
expect(p("/abc/def/../..").match?("/")).to be_truthy
expect(p("abc/../../def").normalized_pattern).to eq("../def")
expect(p("abc/../../def").exact_path).to eq("../def")
expect(p("abc/../../def").match?("../def")).to be_truthy
expect(p("abc**/def/../ghi").exact_path).to be_nil
expect(p("abc**/def/../ghi").match?("abc/ghi")).to be_truthy
expect(p("abc**/def/../ghi").match?("abc/x/y/z/ghi")).to be_truthy
expect(p("abc**/def/../ghi").match?("ghi")).to be_falsey
expect { Chef::ChefFS::FilePattern.new("abc/**/abc/../../def").exact_path }.to raise_error(ArgumentError)
expect(p("../abc/def").exact_path).to eq("../abc/def")
expect(p("../abc/def").match?("../abc/def")).to be_truthy
expect(p("/../abc/def").exact_path).to eq("/abc/def")
expect(p("/../abc/def").match?("/abc/def")).to be_truthy
expect(p("..").exact_path).to eq("..")
expect(p("..").match?("..")).to be_truthy
expect(p("/..").exact_path).to eq("/")
expect(p("/..").match?("/")).to be_truthy
describe "diff", uses_diff: true, ruby: ">= 3.0" do
let(:a) do
memory_fs("a", {
both_dirs: {
sub_both_dirs: { subsub: nil },
sub_both_dirs_empty: {},
sub_dirs_empty_in_a_filled_in_b: {},
sub_dirs_empty_in_b_filled_in_a: { subsub: nil },
sub_a_only_dir: { subsub: nil },
sub_dir_in_a_file_in_b: {},
sub_file_in_a_dir_in_b: nil,
both_dirs_empty: {},
dirs_empty_in_a_filled_in_b: {},
dirs_empty_in_b_filled_in_a: { subsub: nil },
dirs_in_a_cannot_be_in_b: {},
file_in_a_cannot_be_in_b: nil,
a_only_dir: { subsub: nil },
dir_in_a_file_in_b: {},
file_in_a_dir_in_b: nil,
}, /cannot_be_in_a/)
let(:b) do
memory_fs("b", {
sub_dirs_empty_in_a_filled_in_b: { subsub: nil },
sub_dirs_empty_in_b_filled_in_a: {},
sub_b_only_dir: { subsub: nil },
sub_dir_in_a_file_in_b: nil,
sub_file_in_a_dir_in_b: {},
dirs_empty_in_a_filled_in_b: { subsub: nil },
dirs_empty_in_b_filled_in_a: {},
dirs_in_b_cannot_be_in_a: {},
file_in_b_cannot_be_in_a: nil,
b_only_dir: { subsub: nil },
dir_in_a_file_in_b: nil,
file_in_a_dir_in_b: {},
}, /cannot_be_in_b/)
Chef::ChefFS::CommandLine.diff_print(pattern("/"), a, b, nil, nil) do |diff|
-a
+b
--- a/both_dirs/sub_a_only_file DATE
+++ b/both_dirs/sub_b_only_file DATE
--- a/a_only_file DATE
+++ b/b_only_file DATE
Chef::ChefFS::CommandLine.diff_print(pattern("/both_dirs"), a, b, nil, nil) do |diff|
Chef::ChefFS::CommandLine.diff_print(pattern("/"), a, b, 1, nil) do |diff|
it "Chef::ChefFS::CommandLine.diff_print(/*_*) with depth 0" do
Chef::ChefFS::CommandLine.diff_print(pattern("/*_*"), a, b, 0, nil) do |diff|
Chef::ChefFS::CommandLine.diff_print(pattern("/"), a, b, nil, :name_only) do |diff|
Chef::ChefFS::CommandLine.diff_print(pattern("/"), a, b, nil, :name_status) do |diff|
@name = name
@org = org
{ "name" => "worker_bees",
{ "actors" =>
{ "users" => %w{fizz buzz},
{ "name" => "grizzly",
{ "family" => "ursidae",
@name = bag_name
@name = "#{item_name}.json"
let(:entry) { TestDataBagItem.new("luggage", "bag") }
{ "raw_data" => { "id" => "duffel" } }
{ "raw_data" => { "id" => "bag" } }
let(:entry) { TestDataBagItem.new(bag_name.to_s, "bag") }
it "allows the data bag name '#{bag_name}'" do
base_config = {}
ui = double("ui")
Chef::ChefFS::Config.new(base_config, Dir.pwd, {}, ui)
Mash.new({
node_path: "/base_path/nodes",
role_path: "/base_path/roles",
user_path: "/base_path/users",
chef_repo_path: "/base_path",
chef_repo_path: %w{ /base_path /second_base_path },
expect(cfg.server_path("/base_path/cookbooks")).to eq("/")
let(:cwd) { "/base_path/cookbooks" }
expect(cfg.server_path("../roles/blah")).to eql("/roles/blah")
expect(Chef::ChefFS::PathUtils).to receive(:realest_path).with("../../readme.txt", cwd).and_return("/readme.txt")
expect(cfg.server_path("../../readme.txt")).to be_nil
expect(Chef::ChefFS::PathUtils).to receive(:realest_path).with("*/*ab*", cwd).and_return("/base_path/cookbooks/*/*ab*")
expect(cfg.server_path("*/*ab*")).to eql("/cookbooks/*/*ab*")
let(:path) { "/roles/foo.json" }
let(:entry) { Entry.new(path) }
expect(cfg.format_path(entry)).to eq(".")
cfg = Chef::ChefFS::Config.new(config, "/base_path")
expect(cfg).to receive(:base_path).and_return("/").at_least(:once)
let(:platform) { "debian" }
x = 1
x = 2
expect(x).to eq(2)
expect { Chef.deprecated(:generic, "I'm a little teapot.") }.to raise_error(/I'm a little teapot./)
let(:config_content) { "rspec_ran('true')" }
let(:config_location) { "/etc/chef/default.rb" }
let(:tempfile) { Tempfile.new("default.rb").path }
let(:fatal) { false }
let(:app) { Chef::Application::Solo.new }
let(:json_source) { "https://foo.com/foo.json" }
expect(archive).to receive(:extract).with("#{Dir.tmpdir}/chef-solo", { perms: false, ignore: /^\.$/ })
json_attribs = { "a" => "b" }
let(:dot_d_config_name) { :solo_d_dir }
let(:root_path) { windows? ? "C:/var/chef" : "/var/chef" }
it "deletes --ez" do
expect(ARGV.include?("--ez")).to be_falsey
run_count = 0
run_count += 1
if run_count > 3
let(:app) do
cli_arguments ||= ""
chef_server_url: "http://example", policy_name: "web"
let(:archive) { double }
let(:config_exists) { false }
.with("the_path_to_the_repo", secure: true)
it "sets { recipe_url: 'test_url' }" do
.with("the_path_to_the_repo")
.with("test_url", File.join("the_path_to_the_repo", "recipes.tgz"))
.with(File.join("the_path_to_the_repo", "recipes.tgz"))
.with("the_path_to_the_repo", perms: false, ignore: /^\.$/)
let(:config_exists) { true }
File.join("the_path_to_the_repo", ".chef/config.rb")
let(:daemonize) { true }
let(:wait_secs) { 1 }
let(:daemonize) { wait_secs }
pid = fork do
let(:dot_d_config_name) { :client_d_dir }
let(:app) { Chef::Application::Client.new }
@pipe = IO.pipe
let(:validation_path) { "" }
@recipe_file_name = "foo.rb"
@recipe_file = double("Tempfile (mock)", read: @recipe_text)
expect { @app.run }.to raise_error(SystemExit) { |e| expect(e.status).to eq(1) }
@json = @client.to_json
let(:jsonable) { @client }
client = {
name: "some_name",
let(:rest_v0) { @client.chef_rest_v0 }
let(:rest_v1) { @client.chef_rest_v1 }
expect(rest). to receive(:put).with("clients/some_name", { name: "some_name" }).and_return({ name: "some_name" })
let(:rest) { @client.chef_rest_v1 }
let(:rest) { @client.chef_rest_v0 }
expect(@client.chef_rest_v0).to receive(:put).with("clients/#{@client.name}", payload.merge({ private_key: true })).and_return({})
@api_client_with_key = { "name" => "lost-my-key", "private_key" => "the new private key" }
let(:client_name) { "silent-bob" }
let(:http_mock) { double("Chef::ServerAPI mock") }
let(:response_409) { Net::HTTPConflict.new("1.1", "409", "Conflict") }
{ "name" => client_name,
{ name: client_name, admin: false }
expect(IO.read(key_location)).to eq("--begin rsa key etc--")
@server = nil
def get(path, response_code, data = nil, headers = nil, &block)
def put(path, response_code, data = nil, headers = nil, &block)
@path_spec === uri
HEADERS = { "Content-Type" => "application/json" }.freeze
@block = block_given? ? block : nil
data = @data || @block.call
expect(rest_v1).to receive(:post).with(url, payload.merge({ public_key: "some_public_key" })).and_return({})
expect(rest_v1).to receive(:post).with(url, payload.merge({ create_key: true })).and_return({})
expect(rest_v0).to receive(:post).with(url, payload.merge({ public_key: "some_public_key" })).and_return({})
non_unique: false })
combined_opts << option << "hola"
it "should set -m -d /homedir" do
@stdout = "root P 09/02/2008 0 99999 7 -1"
@stdout = "root N"
@stdout = "root L"
windows? ? normalized_path.tr("\\", "/") : normalized_path
slug = "#{basename}-#{rand(1 << 128)}"
stat_struct = double("::File.stat", mode: 0600, uid: 0, gid: 0, mtime: 10000)
let(:tempfile_name) { "foo-bar-baz" }
t = double("Tempfile", path: "/tmp/#{tempfile_name}", closed?: true)
tempfile = double("Tempfile", path: "/tmp/foo-bar-baz")
let(:tempfile_path) { "/tmp/foo-bar-baz" }
let(:diff_for_reporting) { "+++\n---\n+foo\n-bar\n" }
@platform_hash = {}
%i{rhel fedora} => "redhatty value",
node = {}
it "should not require .0 to match >= 21.0" do
@platform_hash = {
@properties = {
stdout: "",
stderr: "",
it "exits 1" do
def memory_fs_value(value, name = "", parent = nil)
if value.is_a?(Hash)
test_hash = { one: :two }
@resource.cwd("/tmp/")
@resource.environment({ one: :two })
let(:client_d_dir) { nil }
File.join(__dir__, "../../../data/client.d_00")
File.join(__dir__, "../../data/client.d_01")
File.join(__dir__, "../../data/client.d_02")
@config = {
@response = Net::HTTPBadRequest.new("1.1", "400", "(response) bad request")
@response = Net::HTTPNotFound.new("1.1", "404", "(response) not found")
actual && actual == exp_code
(actual.nil? ? " not called" : "(#{actual}) was called")
if args.length == 1
puts "knife: #{args.join(" ")}" if DEBUG
logger.formatter = proc { |severity, datetime, progname, msg| "#{severity}: #{msg}\n" }
Chef::Log.level = ( DEBUG ? :debug : :warn )
exit_code = 0
expected = {}
if arg.is_a?(Hash)
stderr_actual = stderr_actual.gsub("\r\n", "\n")
stdout_actual = stdout_actual.gsub("\r\n", "\n")
context("when the chef repo #{desc}", *tags) do
FileUtils.mkdir_p(dir) unless dir == "."
File.open(filename, "w") do |file|
@old_cwd = Dir.pwd
expected_architecture == :i386 ? "X86" : "AMD64"
let(:guard_architecture) { :x86_64 }
let(:read_access_denied_command) { "::File.read('#{script_file_path}')" }
let(:modify_access_denied_command) { "::File.write('#{script_file_path}', 'stuff')" }
let(:delete_access_denied_command) { "::File.delete('#{script_file_path}')" }
let(:command_template) { "set BUNDLE_GEMFILE=&#{ruby_interpreter_path} -e \"#{ruby_command_template}\"" }
resource.code("chcp > \"#{script_output_path}\"")
File.read("#{script_output_path}#{suffix}")
let(:expected_user_name) { "guest" }
let(:expected_user_name) { "nobody" }
let(:desired_gid) { 1337 }
let(:expected_gid) { 1337 }
let(:set_mode) { "0740" }
let(:expected_mode) { "0740" }
let(:set_mode) { 00740 }
expect(current_resource.mode).to eq("0#{(0666 & ~File.umask).to_s(8)}")
let(:default_create_mode) { 0666 & ~File.umask }
let(:expected_mode) { "0#{default_create_mode.to_s(8)}" }
let(:set_mode) { 0666 & ~File.umask }
let(:expected_mode) { "0#{set_mode.to_s(8)}" }
let(:expected_user_name) { "Guest" }
let(:expected_user_name) { 'domain\user' }
now = Time.now.to_i
File.utime(now - 9000, now - 9000, path)
File.chown(0, 0, path)
hashes << { mask: ace.mask, type: ace.type, flags: ace.flags }
let(:write_flag) { 3 }
ace.mask == mask &&
ace.type == type &&
@mode_string = "776"
it ":read rights" do
allow(Chef::Log).to receive(:warn) { |msg| @warn << msg }
@api.get("/nyan_cat.png", 200) do
@api.get("/nyan_cat.png.gz", 200, nil, { "Content-Type" => "application/gzip", "Content-Encoding" => "gzip" } ) do
@api.get("/nyan_cat_compressed.png", 200, nil, { "Content-Type" => "application/gzip", "Content-Encoding" => "gzip" } ) do
@api.get("/nyan_cat_content_length.png", 200, nil,
}) do
@api.get("/nyan_cat_truncated.png", 200, nil,
@api.get("/forbidden", 403, "Forbidden",
@api.post("/posty", 200, "Hi!")
@server = @api = nil
let(:source) { "http://localhost:9000/nyan_cat.png" }
let(:source) { "http://localhost:9000/nyan_cat.png.gz" }
let(:source) { "http://localhost:9000/forbidden" }
let(:path) do
!symlink?(file_path) && File.file?(file_path)
let(:expect_updated?) { true }
restorecon_test_command = "#{@restorecon_path} -n -v #{path}"
File.open(symlink_target, "wb") { |f| f.print "This is so wrong!!!" }
let(:link1_path) { File.join(CHEF_SPEC_DATA, "points-to-link2") }
let(:link2_path) { File.join(CHEF_SPEC_DATA, "points-to-link1") }
let(:link_path) { File.join(CHEF_SPEC_DATA, "points-to-nothing") }
let(:not_existent_source) { File.join(CHEF_SPEC_DATA, "i-am-not-here") }
let(:not_a_file_path) { File.join(CHEF_SPEC_DATA, "dir-at-end-of-symlink") }
let(:link_path) { File.join(CHEF_SPEC_DATA, "points-to-real-file") }
File.open(path, "wb") { |f| f.write(expected_content) }
File.open(path, "wb") { |f| f.write(wrong_content) }
let(:expect_updated?) { false }
let(:link_to_file_path) { File.join(CHEF_SPEC_DATA, "points-to-real-file") }
let(:link_to_link_path) { File.join(CHEF_SPEC_DATA, "points-to-next-link") }
result = shell_out!("mknod #{path} b 1 2")
result = shell_out!("mknod #{path} c 1 2")
result = shell_out!("mkfifo #{path}")
let(:test_socket_dir) { File.join(Dir.tmpdir, "sockets") }
File.open(path, "wb") { |f| f.print "This is so wrong!!!" }
File.open(path, "wb") { |f| f.print expected_content }
shell_out!("icacls \"#{script_output_dir.tr("/", "\\")}\" /grant \"authenticated users:(F)\"")
let(:powershell_equal_to_alternate_user) { "-eq" }
win32 = Object.send(:const_get, "Win32")
libarchive_paths = Dir.glob("{#{Gem.dir},C:/hab}/**/libarchive.dll").map { |f| File.expand_path(f) }
$stderr.puts <<~EOL
!!!!
$stderr.puts "\nFound the following libarchive paths:\n\n#{libarchive_paths.map { |f| "- #{f}\n" }.join}\n\n"
@node ||= Chef::Node.new.tap do |n|
@run_context ||= Chef::RunContext.new(node, {}, event_dispatch).tap do |rc|
File.open(@test_service_file, "wb") do |f|
::GC.start
end.tap { |l| l.present = present }
(win32_os_version && win32_os_version.start_with?("6.3"))
supports_dsc = !! lcm
windows? && !windows64?
raise "#{__method__}: unrecognized platform '#{platform}', expected one of ':unix' or ':windows'"
def initialize(opts = {})
require File.join(__dir__, "..", "platforms", "prof", "win32")
require File.join(__dir__, "..", "prof", "gc")
@peace = tf
@master = arg
@i_can_count = tf
@action = "sell"
suffix = ""
t = Time.now.strftime("%Y%m%d")
path = "#{prefix}#{t}-#{$$}-#{rand(0x100000000).to_s(36)}"
path << "-#{n}" if n
windows? ? path.tr("/", "\\") : path
File.open(@monkeyfoo, "w") do |file|
file.write("hi")
@path = File.expand_path(File.join(__dir__, "..", "..", "data", "old_home_dir", "my-dot-emacs"))
$LOAD_PATH.unshift File.expand_path("..", __dir__)
$LOAD_PATH.unshift File.expand_path("../chef-config/lib", __dir__)
$LOAD_PATH.unshift File.expand_path("../chef-utils/lib", __dir__)
.grep_v(%r{^spec/support/pedant})
.map { |f| f.gsub(/.rb$/, "") }
.map { |f| f.gsub(%r{spec/}, "") }
.each { |f| require f }
if Process.euid == 0 && Process.uid == 0
if Process.uid != 0
RSpec.configure { |c| c.fail_fast = true }
if Process.euid != 0
let(:chef_dir) { File.join(__dir__, "..", "..", "..") }
let(:cookbook_x_100_metadata_rb) { cb_metadata("x", "1.0.0") }
let(:cookbook_ancient_100_metadata_rb) { cb_metadata("ancient", "1.0.0") }
let(:nodes_dir) { File.join(@repository_dir, "nodes") }
file "config/solo.rb", <<~EOM
result = shell_out("bundle exec #{ChefUtils::Dist::Solo::EXEC} --minimal-ohai --always-dump-stacktrace -c \"#{path_to("config/solo.rb")}\" -l debug", cwd: chef_dir)
cookbook_path "#{path_to("cookbooks")}"
file_cache_path "#{path_to("config/cache")}"
result = shell_out("#{chef_solo} -c \"#{path_to("config/solo.rb")}\" -o 'x::default' -l debug", cwd: chef_dir)
file "config/node.json", <<~E
result = shell_out("#{chef_solo} -c \"#{path_to("config/solo.rb")}\" -j '#{path_to("config/node.json")}' -l debug", cwd: chef_dir)
file "cookbooks/x/metadata.rb", cb_metadata("x", "1.0.0", "\nchef_version '~> 999.0'")
file "cookbooks/x/metadata.rb", cb_metadata("x", "1.0.0", "\nohai_version '~> 999.0'")
file "logs/runs.log", ""
raise "we ran out of retries" if ( retries -= 1 ) <= 0
chef_dir = File.join(__dir__, "..", "..", "..")
s1 = Process.spawn("#{chef_solo} -c \"#{path_to("config/solo.rb")}\" -o 'x::default' -l debug -L #{path_to("logs/runs.log")}", chdir: chef_dir)
s2 = Process.spawn("#{chef_solo} -c \"#{path_to("config/solo.rb")}\" -o 'x::default' -l debug -L #{path_to("logs/runs.log")}", chdir: chef_dir)
run_log = File.read(path_to("logs/runs.log"))
expect(run_log.lines.reject { |l| !l.include? "Run complete in" }.length).to eq(2)
let(:chef_dir) { File.expand_path("../../..", __dir__) }
file "resources/thing.rb", <<-EOM
file "recipes/default.rb", <<~EOM
file "config/client.rb", <<-EOM
result = shell_out("#{chef_client} -c \"#{path_to("config/client.rb")}\" --no-color -F doc -o 'x::default'", cwd: chef_dir)
var = "foo"
puts "\nfirst: \#\{var\}"
var = "bar"
puts "\nsecond: \#\{var\}"
var = "baz"
file "recipes/default.rb", <<-EOM
file "config/client.rb", <<~EOM
result = shell_out("#{chef_client} -c \"#{path_to("config/client.rb")}\" --no-color -F doc -o 'x::default' -l debug", cwd: chef_dir)
puts "\nnotified: \#\{var\}"
puts "\nnotifying: \#\{var\}"
edit_resource(:log, "name") do
find_resource(:log, "name") do
before(:all) { Namer.current_index = 1 }
before { Namer.current_index += 1 }
.select { |name, p| p.is_set?(self) }
.map { |name, p| "#{name}=#{p.get(self)}" }
.join(", ")})"
e = self
r = nil
r = public_send(e.resource_name, "blah") do
def index; @index ||= 1; end
let(:converge_recipe) { "#{resource_name} 'blah'" }
def foo(value = nil)
foo "foo!"
ActionJackson.succeeded += " #{bar}" if respond_to?(:bar)
@foo = "#{value}alope" if value
def bar(value = nil)
@bar = "#{value}alope" if value
ActionJackalope.succeeded = "#{foo} #{blarghle} #{bar}"
bar "bar!"
set_or_return(:group, value, {})
new_resource.x = a + c
expect(r.x).to eq(4)
expect(r.x).to eq(8)
let(:chef_dir) { File.join(__dir__, "..", "..", "..", "bin") }
file "aaa", ""
file "zzz/file", ""
file "aaa/file", ""
file "zzz", ""
let!(:dest_dir) { path_to("dest_dir") }
shell_out!("#{chef_client} -c \"#{path_to("config/client.rb")}\" -o 'test::default'", cwd: chef_dir)
path = path_to(path)
(stat.mode & 0777).to_s(8)
expect(mode_of("dest_dir/sub1")).to eq "754"
expect(mode_of("dest_dir/sub1/aaa")).to eq "777"
expect(mode_of("dest_dir/sub1/zzz")).to eq "754"
expect(mode_of("dest_dir/sub1/zzz/file")).to eq "777"
expect(mode_of("dest_dir/sub2")).to eq "754"
expect(mode_of("dest_dir/sub2/aaa")).to eq "754"
expect(mode_of("dest_dir/sub2/aaa/file")).to eq "777"
expect(mode_of("dest_dir/sub2/zzz")).to eq "777"
base_thingy("blah") {}
base_thingy { ; }
bar_thingy("blah") {}
no_name_thingy("blah") {}
another_no_name_thingy("blah") {}
another_thingy_name("blah") {}
another_no_name_thingy_7("blah") {}
my_supplier("blah") {}
hemlock("blah") {}
thingy3("blah") {}
thingy4("blah") {}
thingy5("blah") {}
thingy6("blah") {}
thingy5_2("blah") {}
thingy7("blah") {}
thingy8("blah") {}
thingy12("blah") {}
twizzle("blah") {}
twizzle2("blah") {}
my_super_thingy("blah") {}
instance_eval("#{temp_two_classes_one_dsl} 'blah' do; end")
let(:my_resource) { :"my_resource#{Namer.current_index}" }
instance_eval("#{dsl_name} 'foo'")
instance_eval("#{temp_my_resource} 'foo'")
before(:all) { Namer.current_index = 0 }
provider_thingy("blah") {}
file "resources/nb_test.rb", <<-EOM
log "bar" do
log "baz" do
log "quux"
log "foo" do
log "baz"
file "resources/foo.rb", <<~EOM
file "providers/foo.rb", <<~EOM
l_w_r_p_foo "me"
result = shell_out("#{chef_client} -c \"#{path_to("config/client.rb")}\" --no-color -F doc -o 'l-w-r-p::default'", cwd: chef_dir)
block { r.ran_a "ran a" }
expect(r.ran_a).to eq "ran a"
ran_a = r.ran_a
block { r.ran_b "ran b: ran_a value was #{ran_a.inspect}" }
expect(r.ran_b).to eq "ran b: ran_a value was \"ran a\""
x_do_nothing 'a'
x_do_nothing 'b'
actual = result.stdout.lines.map(&:chomp).join("\n")
expected = <<EOM
(up to date)
expected = expected.lines.map(&:chomp).join("\n")
path = t.path
file "templates/aliases.erb", <<-EOM.gsub(/^\s+/, "")
<%= pp @aliases %>
let(:ohai) { "bundle exec ohai" }
shell_out!("#{ohai} hostname")
expect(delta).to be < 4
let(:report_file) { path_to("report_file.json") }
file "inspec.yml", <<~FILE
file "my_control.rb", <<~FILE
result = shell_out!("#{chef_client} --local-mode --json-attributes #{path_to("attributes.json")}", cwd: chef_dir)
include_profile ".*::.*"
let(:chef_zero_opts) { { host: "::1" } }
cache_path '#{cache_path}'
let(:chef_client_cmd) { %Q{bundle exec #{ChefUtils::Dist::Infra::CLIENT} --minimal-ohai -c "#{path_to("config/client.rb")}" -lwarn --always-dump-stacktrace} }
cookbook "noop", "1.0.0", {}, "recipes" => { "default.rb" => "#raise 'foo'" }
result = shell_out("#{chef_client_cmd} -o 'noop::default'", cwd: chef_dir)
Chef::Log.error("!" * 80)
data_bag("expect_bag", { "expect_item" => { "expect_key" => "expect_value" } })
cookbook "api-smoke-test", "1.0.0", {}, "recipes" => { "default.rb" => recipe }
result = shell_out("#{chef_client_cmd} -o 'api-smoke-test::default'", cwd: chef_dir)
shell_out!("#{chef_client} -c \"#{path_to("config/client.rb")}\" -o 'x::default'",
@api.get("/recipes.tgz", 200) do
else {
Try {
if ($response) {return $true}
let(:client_name) { "chef-973334" }
let(:hostname) { "973334" }
shell_out!("#{chef_client} -c \"#{path_to("config/client.rb")}\" -K #{@path} ", cwd: chef_dir)
shell_out!("#{chef_client} -c \"#{path_to("config/client.rb")}\" ", cwd: chef_dir)
before { file "cookbooks/x/recipes/default.rb", "" }
shell_out!("#{chef_client} -c \"#{path_to("config/client.rb")}\" -o 'x::default'", cwd: chef_dir)
result = shell_out("#{chef_client} --no-listen -c \"#{path_to("config/client.rb")}\" -o 'x::default'", cwd: chef_dir)
result = shell_out("#{chef_client} -z -r 'x::default' --disable-config", cwd: path_to(""))
result = shell_out("#{chef_client} -z -o 'x::default' --disable-config", cwd: path_to(""))
result = shell_out("#{chef_client} -z -o 'x::default' --disable-config", cwd: path_to("cookbooks/x"))
result = shell_out("#{chef_client} -z -o 'x::default' --disable-config", cwd: File.expand_path("..", path_to("")))
before { file ".chef/knife.rb", "xxx.xxx" }
result = shell_out("#{chef_client} -z -o 'x::default'", cwd: path_to(""), env: { "PWD" => nil })
result = shell_out("#{chef_client} -c \"#{path_to("config/client.rb")}\" -o 'x::default'", cwd: chef_dir)
file "mykey.pem", <<~EOM
file "arbitrary.rb", <<~EOM
file "arbitrary2.rb", <<~EOM
result = shell_out("#{chef_client} -c \"#{path_to("config/client.rb")}\" #{path_to("arbitrary.rb")} #{path_to("arbitrary2.rb")}", cwd: chef_dir)
expect(IO.read(path_to("tempfile.txt"))).to eq("1")
expect(IO.read(path_to("tempfile2.txt"))).to eq("2")
result = shell_out("#{chef_client} -c \"#{path_to("config/client.rb")}\" arbitrary.rb", cwd: path_to(""))
result = shell_out("#{chef_client} -c \"#{path_to("config/client.rb")}\" -o x::constant_definition arbitrary.rb", cwd: path_to(""))
file "config/dna.json", <<~EOM
result = shell_out("#{chef_client} -c \"#{path_to("config/client.rb")}\" -j \"#{path_to("config/dna.json")}\" arbitrary.rb", cwd: path_to(""))
result = shell_out("#{chef_client} -c \"#{path_to("config/client.rb")}\" -o 'x::default' -z", cwd: chef_dir)
result = shell_out("#{chef_client} -c \"#{path_to("config/client.rb")}\" -o 'x::default' --local-mode", cwd: chef_dir)
result = shell_out("#{chef_client} -c \"#{path_to("config/client.rb")}\" -r 'x::default' -z -l info", cwd: chef_dir)
name 'x'
version '0.0.1'
result = shell_out("#{chef_client} -c \"#{path_to("config/client.rb")}\" -o 'x::default' --no-fork", cwd: chef_dir)
expect(result.stdout).to include('COOKBOOKS: {"x"=>{"version"=>"0.0.1"}}')
chef_version '~> 999.99'
command = shell_out("#{chef_client} -c \"#{path_to("config/client.rb")}\" -o 'x::default' --no-fork", cwd: chef_dir)
pos = 0
pos = match.end(0) + 1
result = shell_out!("#{chef_client} -c \"#{path_to("config/client.rb")}\" -o 'x::default'", cwd: chef_dir)
no_lazy_load #{lazy}
result = shell_out("#{chef_client} -l debug -c \"#{path_to("config/client.rb")}\" -o 'x::default' --no-fork", cwd: chef_dir)
expect(IO.read(path_to("tempfile.txt"))).to eq("2014")
let(:tmp_dir) { Dir.mktmpdir("recipe-url") }
chef_repo_path "#{tmp_dir}"
result = shell_out("#{chef_client} -c \"#{path_to("config/client.rb")}\" --recipe-url=http://localhost:9000/recipes.tgz -o 'x::default' -z", cwd: tmp_dir)
result = shell_out("#{chef_client} --recipe-url=#{broken_path}", cwd: tmp_dir)
command = shell_out("#{chef_solo} -c \"#{path_to("config/client.rb")}\" -o 'x::default' --no-fork", cwd: chef_dir)
command = shell_out("#{chef_client} -c \"#{path_to("config/client.rb")}\" -o 'x::default' --no-fork | tee #{path_to("chefrun.out")}", cwd: chef_dir)
command = shell_out("#{chef_solo} -c \"#{path_to("config/client.rb")}\" -o 'x::default' --no-fork | tee #{path_to("chefrun.out")}", cwd: chef_dir)
command = shell_out("#{chef_client} -c \"#{path_to("config/client.rb")}\" -o 'x::default'", cwd: chef_dir)
command = shell_out("#{chef_solo} -c \"#{path_to("config/client.rb")}\" -o 'x::default'", cwd: chef_dir)
command = shell_out("#{chef_client} -c \"#{path_to("config/client.rb")}\" -o 'x::default' --fork", cwd: chef_dir)
command = shell_out("#{chef_solo} -c \"#{path_to("config/client.rb")}\" -o 'x::default' --fork", cwd: chef_dir)
let(:user) { "security_user" }
let(:password) { "Security@123" }
add_user = Mixlib::ShellOut.new("net user #{user} #{password} /ADD")
let(:user_right) { "SeTest" }
@run_context = Chef::RunContext.new(@node, {}, events)
expect(@registry.value_exists?("HKCU\\Software\\Root\\Branch\\Flower", { name: "Petals" })).to eq(true)
expect(@registry.value_exists?("HKCU\\Software\\Root\\Branch\\Flower", { name: "petals" })).to eq(true)
expect(@registry.value_exists?("HKCU\\Software\\Root\\Branch\\Flower", { name: "FOOBAR" })).to eq(false)
expect(@registry.value_exists!("HKCU\\Software\\Root\\Branch\\Flower", { name: "Petals" })).to eq(true)
expect(@registry.value_exists!("HKCU\\Software\\Root\\Branch\\Flower", { name: "petals" })).to eq(true)
expect(@registry.data_exists?("HKCU\\Software\\Root\\Branch\\Flower", { name: "Petals", type: :multi_string, data: %w{Pink Delicate} })).to eq(true)
expect(@registry.data_exists?("HKCU\\Software\\Root\\Branch\\Flower", { name: "petals", type: :multi_string, data: %w{Pink Delicate} })).to eq(true)
expect(@registry.data_exists?("HKCU\\Software\\Root\\Branch\\Flower", { name: "slateP", type: :multi_string, data: %w{Pink Delicate} })).to eq(false)
expect(@registry.data_exists?("HKCU\\Software\\Root\\Branch\\Flower", { name: "Petals", type: :string, data: "Pink" })).to eq(false)
expect(@registry.data_exists?("HKCU\\Software\\Root\\Branch\\Flower", { name: "Petals", type: :multi_string, data: %w{Mauve Delicate} })).to eq(false)
expect(@registry.data_exists!("HKCU\\Software\\Root\\Branch\\Flower", { name: "Petals", type: :multi_string, data: %w{Pink Delicate} })).to eq(true)
expect(@registry.data_exists!("HKCU\\Software\\Root\\Branch\\Flower", { name: "petals", type: :multi_string, data: %w{Pink Delicate} })).to eq(true)
expect(@registry.set_value("HKCU\\Software\\Root\\Branch\\Flower", { name: "Petals", type: :string, data: "Yellow" })).to eq(true)
expect(@registry.data_exists?("HKCU\\Software\\Root\\Branch\\Flower", { name: "Petals", type: :string, data: "Yellow" })).to eq(true)
expect(@registry.set_value("HKCU\\Software\\Root\\Branch\\Flower", { name: "ShouldBe32767", type: :dword, data: "32767" })).to eq(true)
expect(@registry.data_exists?("HKCU\\Software\\Root\\Branch\\Flower", { name: "ShouldBe32767", type: :dword, data: 32767 })).to eq(true)
expect(@registry.data_exists?("HKCU\\Software\\Root\\Branch\\Flower", { name: "ShouldBeZero", type: :dword, data: 0 })).to eq(true)
expect(@registry.set_value("HKCU\\Software\\Root\\Branch\\Flower", { name: "ShouldBePainful", type: :string, data: %w{one two} })).to eq(true)
expect(@registry.data_exists?("HKCU\\Software\\Root\\Branch\\Flower", { name: "ShouldBe65535", type: :string, data: "65535" })).to eq(true)
expect(@registry.delete_value("HKCU\\Software\\Root\\Trunk\\Peck\\Woodpecker", { name: "Peter", type: :string, data: "Tiny" })).to eq(true)
expect(@registry.value_exists?("HKCU\\Software\\Root\\Trunk\\Peck\\Woodpecker", { name: "Peter", type: :string, data: "Tiny" })).to eq(false)
reg.each_key { |name| reg_subkeys << name }
@r = Chef::Win32::Registry.new(@run_context, :i386)
@r = Chef::Win32::Registry.new(@run_context, :x86_64)
expect(@registry.value_exists?("HKLM\\Software\\Root\\Poosh", { name: "Status" })).to eq(true)
expect(@registry.value_exists?("HKLM\\Software\\Root\\Mauve", { name: "Alert" })).to eq(true)
expect(@registry.data_exists?("HKLM\\Software\\Root\\Poosh", { name: "Status", type: :string, data: "Lost" })).to eq(true)
expect(@registry.data_exists?("HKLM\\Software\\Root\\Mauve", { name: "Alert", type: :string, data: "Universal" })).to eq(true)
let(:plaintext) { "p@assword" }
if ($plaintext -ne '#{plaintext}') {
let(:chef_dir) { File.join(__dir__, "..", "..") }
expect(shell_out!("bundle exec #{binary} -v", cwd: chef_dir).stdout.chomp).to match(/.*: #{Chef::VERSION}/)
File.new(File.join(dir, file), "w").close
@api.get("/blargh", 200, "blargh")
@api.get("/foo/bar", 200, "hello foobar")
@api.get("/bar/baz", 200) { block_called = true; "hello barbaz" }
rest = Chef::HTTP.new("http://localhost:9000")
buffer = ""
if Time.new - start > 5
reader, writer, pid = PTY.spawn("bundle exec #{ChefUtils::Dist::Infra::SHELL} --no-multiline --no-singleline --no-colorize -c #{config} #{options}")
read_until(reader, "chef (#{Chef::VERSION})>")
writer.puts('"done"')
output = read_until(reader, '=> "done"')
expect(output).to include("===fatal===")
simple_api_get = "api.get('data')"
expect(output).to include("{}")
def log_event(message, time = Time.now.strftime("%H:%M:%S.%L"))
let!(:p1) { ClientProcess.new(self, "p1") }
let!(:p2) { ClientProcess.new(self, "p2") }
print "#{time} #{message}\n"
before { p1.run_to("created lock") }
expect(IO.read(lockfile)).to eq("")
before { p2.run_to("acquired lock") }
before { p2.run_to("created lock") }
before { p1.run_to("acquired lock") }
before { p1.run_to("saved pid") }
p1 = fork do
p2 = fork do
event, time = line.split("@")
example.log_event("#{name}.last_event got #{event}")
example.log_event("#{name}.run_to(#{to_event.inspect})")
until @last_event == "after #{to_event}"
example.log_event("#{name}.last_event got #{got_event}")
example.log_event("#{name}.wait_for_exit (pid #{pid})")
example.log_event("#{name}.wait_for_exit finished (pid #{pid})")
example.log_event("#{name}.stop (pid #{pid})")
example.log_event("#{name}.stop finished (stopped pid #{pid})")
example.log_event("#{name}.stop finished (pid #{pid} wasn't running)")
write_to_tests.print("after #{event}@#{Time.now.strftime("%H:%M:%S.%L")}\n")
if !@run_to_event || event == @run_to_event
write_to_tests.print("waiting for instructions after #{event}@#{Time.now.strftime("%H:%M:%S.%L")}\n")
write_to_tests.print("told to run to #{@run_to_event} after #{event}@#{Time.now.strftime("%H:%M:%S.%L")}\n")
write_to_tests.print("continuing until #{@run_to_event} after #{event}@#{Time.now.strftime("%H:%M:%S.%L")}\n")
@pid = fork do
exit!(0)
fire_event($!.message.lines.join(" // "))
example.log_event("#{name}.start forked (pid #{pid})")
unless buffer == ""
node.run_list << "simple"
node.run_list << "dup_attr"
node.run_list << "dup_recipe"
File.open("/etc/zypp/repos.d/chef-zypp-localtesting.repo", "w+") do |f|
let(:package_name) { "chef_rpm" }
expect(shell_out("rpm -q --queryformat '%{NAME}-%{VERSION}-%{RELEASE}.%{ARCH}\n' chef_rpm").stdout.chomp).to match("^chef_rpm-1.10-1.#{pkg_arch}$")
preinstall("chef_rpm-1.10-1.#{pkg_arch}.rpm")
preinstall("chef_rpm-1.2-1.#{pkg_arch}.rpm")
expect(shell_out("rpm -q --queryformat '%{NAME}-%{VERSION}-%{RELEASE}.%{ARCH}\n' chef_rpm").stdout.chomp).to match("^chef_rpm-1.2-1.#{pkg_arch}$")
expect(shell_out("rpm -q --queryformat '%{NAME}-%{VERSION}-%{RELEASE}.%{ARCH}\n' chef_rpm").stdout.chomp).to match("^package chef_rpm is not installed$")
it "locks an rpm" do
expect(shell_out("rpm -q --queryformat '%{NAME}-%{VERSION}-%{RELEASE}.%{ARCH}\n' chef_rpm").stdout.chomp).to match(version)
File.open("/etc/yum.repos.d/chef-yum-localtesting.repo", "w+") do |f|
shell_out!("rpm -qa --queryformat '%{NAME}-%{VERSION}-%{RELEASE}.%{ARCH}\n' | grep chef_rpm | xargs -r rpm -e")
%w{1.10 1* 1.10-1 1*-1 1.10-* 1*-* 0:1* *:1.10-* *:1*-* 0:1.10 0:1.10-1}.each do |vstring|
%w{1.2 1* 1.2-1 1*-1 1.2-* 1*-* 0:1* *:1.2-* *:1*-* 0:1.2 0:1.2-1}.each do |vstring|
%w{1.2 1.2-1 1.2-* *:1.2-* 0:1.2-1}.each do |vstring|
%w{1* 1*-1 1*-* 0:1* *:1*-*}.each do |vstring|
yum_package "chef_rpm-0:1.2-1.#{pkg_arch}" do
yum_package "chef_rp*-1*" do
version "1*"
version "1.10-1"
version "0:1.10-1"
version "1.10-1*"
version "0:1.10-1*"
version "1.2-1"
yum_package "chef_rpm >= 1.2" do
yum_package "chef_rpm > 1.2" do
yum_package "chef_rpm = 1.10" do
yum_package "chef_rpm = 1.2" do
yum_package "chef_rpm > 2.0"
yum_package "chef_rpm < 1.10" do
version ">= 1.10"
preinstall("chef_rpm-1.10-1.#{pkg_arch}.rpm", "chef_rpm-1.10-1.i686.rpm")
yum_package "chef_rpm-1.10-1.#{pkg_arch}" do
version "1.2"
expect(shell_out("rpm -q chef_rpm").stdout.chomp).to match("^chef_rpm-1.2-1.#{pkg_arch}")
version("1.2")
let(:principal) { nil }
let(:privilege) { nil }
let(:users) { nil }
let(:sensitive) { true }
let(:principal) { "user_privilege" }
subject.command "#{ChefUtils::Dist::Infra::CLIENT} -W -L 'C:\\chef\\chef-ad-join.log'"
subject.day "1, 2, 3"
it "creates a scheduled task to run monthly on 1, 2, 3, 4, 8, 20, 21, 15, 28, 31 day of the month" do
subject.day "1, 2, 3, 4, 8, 20, 21, 15, 28, 31"
subject.day "1, 2, 3, 4, 8, 20, 21, 30"
subject.months "Jan, Feb, May, Sep, Dec"
subject.day "1, 2"
context "when wild card (*) set as day" do
subject.day "*"
subject.day "1,2,3"
context "when wild card (*) is set as day" do
it "creates task to activate on '09/10/2018' at '15:00' when start_day = '09/10/2018' and start_time = '15:00' provided" do
let(:task_name) { "\\foo\\chef-client-functional-test" }
let(:task_name) { "\\foo\\bar\\chef-client-functional-test" }
let(:share_name) { "fake_share" }
let(:concurrent_user_limit) { 7 }
let(:secvalue) { "30" }
let(:path) { "test_path" }
before { add_path }
let(:c_path) { "c:\\" }
let(:e_path) { "e:\pagefile.sys" }
let(:pkg_name) { nil }
let(:pkg_path) { nil }
let(:pkg_checksum) { nil }
let(:pkg_version) { nil }
let(:pkg_type) { nil }
let(:pkg_options) { nil }
let(:pkg_type) { :custom }
let(:pkg_options) { "/Q" }
let(:pkg_version) { "8.0.59193" }
before { subject.version("8.0.59193") }
let(:pkg_name) { "Ultra Defragmenter" }
let(:pkg_name) { "Mercurial 3.6.1 (64-bit)" }
let(:pkg_name) { "7zip" }
let(:pkg_path) { "http://www.7-zip.org/a/7z938-x64.msi" }
let(:new_hostname) { "New-Hostname" }
let(:local_domain_user) { "'mydomain\\Groucho'" }
let(:local_domain_password) { "'P@ssw0rd'" }
let(:hostname) { "Cucumber" }
let(:hostname) { "Gherkin" }
let(:resource_name) { "Playmaker.ttf" }
let(:rule_name) { "fake_rule" }
let(:remote_port) { "5555" }
let(:enabled) { false }
let(:chef_env_with_delim) { "chef_env_with_delim" }
let(:chef_env_delim) { ";" }
let(:chef_env_test_delim) { "#{value1};#{value2}" }
let(:env_dne_key) { "env_dne_key" }
let(:env_value1) { "value1" }
let(:env_value2) { "value2" }
let(:delim_value) { "#{env_value1};#{env_value2}" }
let(:default_env_user) { "<SYSTEM>" }
let(:env_obj) do
let(:env_value_expandable) { "%SystemRoot%" }
let(:random_name) { Time.now.to_i }
let(:env_val) { "#{env_value_expandable}_#{random_name}" }
test_resource.value("#{path_before};#{env_val}")
New-Item -Path Cert:\\#{store_location}\\#{store_name}
let(:password) { "P@ssw0rd!" }
let(:store) { "Chef-Functional-Test" }
let(:store_name) { "MY" }
let(:cer_path) { File.join(CHEF_SPEC_DATA, "windows_certificates", "test.cer") }
let(:pem_path) { File.join(CHEF_SPEC_DATA, "windows_certificates", "test.pem") }
let(:p7b_path) { File.join(CHEF_SPEC_DATA, "windows_certificates", "test.p7b") }
let(:pfx_path) { File.join(CHEF_SPEC_DATA, "windows_certificates", "test.pfx") }
.to receive(:_pv_equal_to)
.with({ store_name: store }, :store_name, anything)
path = File.join(dir, "test.pem")
let(:password) { "DummyP2ssw0rd!" }
shell_out("net user #{u} /delete")
file_content = <<~EOF
windows_template_path = temp_security_template.path.gsub("/") { "\\" }
metadata = {
shell_out!("/usr/bin/dscl . -delete '/Users/#{username}'")
expect(shell_out("/usr/bin/dscl . -read /Users/#{username}").error?).to be(false)
let(:uid) { nil }
let(:gid) { 20 }
let(:home) { nil }
let(:manage_home) { false }
let(:comment) { "Great Chef" }
let(:shell) { "/bin/bash" }
let(:salt) { nil }
let(:iterations) { nil }
r.uid(uid)
r.gid(gid)
let(:iterations) { 25000 }
let(:groups) { %w{staff operator} }
shell_out!("/usr/bin/dscl . -append '/Groups/#{group}' GroupMembership #{username}")
shell_out("/usr/bin/dscl . -delete '/Groups/#{group}' GroupMembership #{username}")
shell_out!("/usr/sbin/userdel #{username}")
expect(shell_out("grep -q #{username} /etc/passwd").error?).to be(false)
expect(shell_out("grep ^#{user}: /etc/shadow | cut -d: -f2 | grep ^#{pass}$").exitstatus).to eq(0)
let(:gid) do
Etc.enum_for(:group).map(&:gid).last
let(:timezone) { "GMT Standard Time" }
let(:timezone) { nil }
let(:file_base) { "template_spec" }
let(:default_mode) { (0666 & ~File.umask).to_s(8) }
%w{all some no}.each do |test_case|
expect(line).to end_with(ChefUtils.windows? ? "\r\n" : "\n")
!::File.exist?("/opt/mytest/mytest.sh")
@pkg_name = "dummy"
@pkg_version = "1-0"
@pkg_path = "#{Dir.tmpdir}/dummy-1-0.aix6.1.noarch.rpm"
@pkg_name = "mytest"
@pkg_version = "1.0-1"
@pkg_path = "#{Dir.tmpdir}/mytest-1.0-1.noarch.rpm"
shell_out("rpm -qa | grep #{@pkg_name}-#{@pkg_version} | xargs rpm -e")
shell_out("rpm -i #{@pkg_path}")
@pkg_version = "2-0"
@pkg_path = "#{Dir.tmpdir}/dummy-2-0.aix6.1.noarch.rpm"
@pkg_version = "2.0-1"
@pkg_path = "#{Dir.tmpdir}/mytest-2.0-1.noarch.rpm"
let(:file_base) { "remote_file_spec" }
@api.get("/seattle_capo.png", 304, "", { "Etag" => "abcdef" } )
let(:source) { "https://localhost:9000/nyan_cat.png" }
let(:smb_file_local_file_name) { "smb_file.txt" }
let(:smb_share_name) { "chef_smb_test" }
let(:smb_file_content) { "hellofun" }
let(:remote_domain) { nil }
let(:remote_user) { nil }
let(:remote_password) { nil }
shell_out!("net.exe share #{smb_share_name}=\"#{smb_share_root_directory.tr("/", "\\")}\" /grant:\"authenticated users\",read")
shell_out!("icacls #{smb_file_local_path} /grant:r \"authenticated users:(W)\" /grant \"#{windows_current_user_qualified}:(R)\" /inheritance:r")
let(:invalid_chunk_size) { -1 }
shell_out!("icacls #{smb_file_local_path} /grant:r \"authenticated users:(W)\" /deny \"#{windows_current_user_qualified}:(R)\" /inheritance:r")
let(:remote_domain) { "." }
let(:default_mode) { (0777 & ~File.umask).to_s(8) }
File.join(path, "remotesubdir", ".a_dotfile"),
File.join(path, ".a_dotdir", ".a_dotfile_in_a_dotdir"),
File.open(modified_file, "a") { |f| f.puts "santa is real" }
File.open(modified_subdir_file, "a") { |f| f.puts "so is rudolph" }
FileUtils.mkdir_p(File.join(path, "a", "multiply", "nested", "directory"))
@existing1 = File.join(path, "a", "foo.txt")
@existing2 = File.join(path, "a", "multiply", "bar.txt")
@existing3 = File.join(path, "a", "multiply", "nested", "baz.txt")
@existing4 = File.join(path, "a", "multiply", "nested", "directory", "qux.txt")
let(:parent) { "Opscode" }
let(:child) { "Whatever" }
let(:key_parent) { "SOFTWARE\\" + parent }
let(:key_child) { "SOFTWARE\\" + parent + "\\" + child }
let(:reg_parent) { "HKLM\\" + key_parent }
let(:reg_child) { "HKLM\\" + key_child }
allow(@rest_client).to receive(:raw_http_request).and_return({ "result" => "ok" })
allow(@rest_client).to receive(:post_rest).and_return({ "uri" => "https://example.com/reports/nodes/windowsbox/runs/#{@run_id}" })
expect(@registry.data_exists?(reg_child, { name: "Color", type: :string, data: "Orange" })).to eq(true)
expect(@registry.data_exists?(reg_child, { name: "number", type: :dword, data: 12344 })).to eq(true)
expect(@registry.data_exists?(reg_child, { name: "Mango", type: :string, data: "Yellow" })).to eq(true)
expect(@registry.data_exists?(reg_child, { name: "Color", type: :string, data: "Not just Orange - OpscodeOrange!" })).to eq(true)
expect(@registry.value_exists?(reg_child + "\\OpscodeTest", { name: "Chef", type: :multi_string, data: %w{OpscodeOrange Rules} })).to eq(true)
expect(@registry.value_exists?(reg_child + '\Missing1\Missing2', { name: "OC", type: :string, data: "MissingData" })).to eq(true)
@new_resource.key(reg_child + "\\Atraxi" )
expect(@registry.data_exists?(reg_child + "\\Atraxi", { name: "OC", type: :string, data: "Data" })).to eq(true)
expect(@registry.key_exists?(reg_child + "\\Atraxi")).to eq(false)
@new_resource.key(reg_child + "\\Ood")
@new_resource.key(reg_child + "\\Slitheen")
@new_resource.key(reg_child + "\\Pyrovile")
expect(@registry.value_exists?(reg_child + "\\Pyrovile", { name: "Chef", type: :multi_string, data: %w{OpscodeOrange Rules} })).to eq(true)
expect(@registry.value_exists?(reg_child + "\\Sontaran\\Sontar", { name: "OC", type: :string, data: "MissingData" })).to eq(true)
@new_resource.key(reg_child + "\\Adipose")
@new_resource.key(reg_child + "\\Judoon")
@new_resource.key(reg_child + "\\Zygons\\Zygor")
expect(@registry.key_exists?(reg_child + "\\Zygons")).to eq(false)
expect(@registry.key_exists?(reg_child + "\\Zygons\\Zygor")).to eq(false)
@new_resource.key(reg_child + "\\Zygons")
@new_resource.key(reg_parent + "\\Osirian")
expect(@registry.data_exists?(reg_parent + "\\Opscode", { name: "Color", type: :string, data: "Orange" })).to eq(true)
@new_resource.key(reg_parent + "\\Opscode")
expect(@registry.value_exists?(reg_parent + "\\Opscode", { name: "AKA", type: :string, data: "OC" })).to eq(false)
expect(@registry.value_exists?(reg_parent + "\\Opscode", { name: "Opscode", type: :multi_string, data: %w{Seattle Washington} })).to eq(false)
expect(@registry.value_exists?(reg_parent + "\\Opscode", { name: "Color", type: :string, data: "Orange" })).to eq(false)
let(:output_command) { " | out-file -encoding ASCII " }
let(:cmdlet_exit_code_success_content) { "get-item ." }
resource.code(". \"#{file.path}\"")
let(:negative_exit_status) { -27 }
let(:unsigned_exit_status) { (-negative_exit_status ^ 65535) + 1 }
resource.code("if({)")
resource.not_if "cd ."
resource.only_if "cd ."
let(:source_name) { "fake" }
let(:source_location) { "https://www.nuget.org/api/v2" }
let(:trusted) { true }
let(:provider_name) { "NuGet" }
expect(shell_out!("/usr/libexec/PlistBuddy -c 'Print :\"AppleFirstWeekday\":gregorian' \"#{global_prefs}\"").stdout.to_i).to eq(4)
when "aix"
device = "/"
when "debian", "rhel", "amazon"
device = "/dev/ram1"
shell_out("mknod -m 660 #{device} b 1 0")
shell_out("ls -1 /dev/ram*").stdout.each_line do |d|
if shell_out("mount | grep #{d}").exitstatus == "1"
device = d
fstype = "tmpfs"
shell_out!("mkfs -q #{device} 512")
device = "swap"
validation_cmd = "mount | grep #{mount_point} | grep #{device} "
validation_cmd << " | grep #{fstype} " unless fstype.nil?
validation_cmd << " | grep #{options.join(",")} " unless options.nil? || options.empty?
expect(shell_out("cat #{unix_mount_config_file} | grep \"#{mount_point}:\" ").exitstatus).to eq(0)
expect(shell_out("cat #{unix_mount_config_file} | grep \"#{mount_point}\" | grep \"#{device}\" ").exitstatus).to eq(0)
line.split(" ").each do |section|
describe "when device is '/'" do
resource.lc_env({ "LC_TIME" => "en_IN" })
let(:file_base) { "file_spec" }
let(:to) do
puts "Could not remove a file: #{$!}"
system "rmdir '#{path}'"
def link(a, b)
File.link(a, b)
allow(logger).to receive(:info) { |msg| @info << msg }
File.open(to, "w") { |file| file.write("wowzers") }
File.open(to, "w") do |file|
let(:test_user) { "test-link-user" }
File.open(@other_target, "w") { |file| file.write("eek") }
File.open(target_file, "w") { |file| file.write("eek") }
elsif macos? || solaris? || freebsd? || aix?
let(:path) { target_file }
}.each do |prefix, desc|
let(:to) { "#{prefix}#{File.basename(absolute_to)}" }
let(:absolute_to) { File.join(test_file_dir, make_tmpname("to_spec")) }
File.open(target_file, "w") { |file| file.write("tomfoolery") }
resource.owner(windows? ? "Guest" : "nobody")
expect(shell_out!("launchctl list io.chef.testing.fake").stdout).to match('"PID" = \d+')
!Dir.glob("/etc/rc*/**/S*#{service_name}").empty?
Dir.glob("/etc/rc*/**/S*#{service_name}").empty?
expect(File.exist?("#{Dir.tmpdir}/#{file_name}")).to be_truthy
expect(File.exist?("#{Dir.tmpdir}/#{file_name}")).to be_falsey
FileUtils.cp((File.join(__dir__, "/../assets/inittest")).to_s, "/etc/init.d/inittest")
shell_out("ip link list |grep UP|grep -vi loop|head -1|cut -d':' -f 2 |cut -d'@' -f 1").stdout.strip
interface + ":10"
expect(shell_out("ifconfig #{@interface} | grep 10.10.0.1").exitstatus).to eq(0)
expect(shell_out("ifconfig #{@interface} | grep 10.10.0.1").exitstatus).to eq(1)
expect(shell_out("lsattr -E -l #{@interface} | grep 10.10.0.1").exitstatus).to eq(0)
expect(shell_out("lsattr -E -l #{@interface} | grep 10.10.0.1").exitstatus).to eq(1)
expect(current_resource.inet_addr).to match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)
when "mac_os_x"
sid = nil
domain, user = user_name.split("\\")
if user && domain != "."
high_uid += 1
let!(:group_name) do
it "should be no-op" do
let(:tested_action) { :modify }
let(:tested_action) { :manage }
let(:base_dir_path) { Dir.mktmpdir }
let(:origin_repo) { "#{origin_repo_dir}/example" }
shell_out!("git", "clone", git_bundle_repo, "example", cwd: origin_repo_dir)
File.open("#{origin_repo}/.git/config", "a+") do |f|
let(:path_with_spaces) { "#{origin_repo_dir}/path with spaces" }
expect_revision_to_be("v1.0.0", v1_tag)
shell_out!("git", "reset", "--hard", rev_foo, cwd: deploy_directory)
let(:expected_content) { "Don't fear the ruby." }
def create_resource(opts = {})
File.open(path, "w") { |f| f.print expected_content }
let(:guard) { "ruby -e 'exit 0'" }
let(:guard) { %{ruby -e 'exit 1 unless File.exists?("./nested.json")'} }
environment: { "SGCE_SECRET" => "regularsecret" },
environment: { "SAWS_SECRET" => "regularsecret" },
winrm_code = <<-CODE
::FileUtils.rm_rf(@temp_dir) if ::Dir.exist?(@temp_dir)
script_code = data ? code : "Configuration '#{configuration_name}'\n{\n\t#{code}\n}\n"
data_suffix = data ? "_config_data" : ""
extension = data ? "psd1" : "ps1"
::File.open(script_path, "wt") do |script|
shell_out!("net user #{target_user}")
shell_out!("net user #{target_user} /delete")
let(:dsc_env_variable) { "chefenvtest" }
let(:dsc_env_value1) { "value1" }
let(:test_registry_data1) { "LL927" }
let(:test_registry_data2) { "LL928" }
let(:registry_embedded_parameters) { "$#{reg_key_name_param_name} = '#{test_registry_key}';$#{reg_key_value_param_name} = '#{test_registry_value}'" }
Key = $#{reg_key_name_param_name}
let(:dsc_code) { dsc_reg_code }
let(:dsc_user_prefix) { "dsc" }
let(:dsc_user_suffix) { "chefx" }
let(:dsc_user) { "#{dsc_user_prefix}_usr_#{dsc_user_suffix}" }
let(:dsc_user_prefix_env_var_name) { "dsc_user_env_prefix" }
let(:dsc_user_suffix_env_var_name) { "dsc_user_env_suffix" }
let(:dsc_user_prefix_env_code) { "$env:#{dsc_user_prefix_env_var_name}" }
let(:dsc_user_suffix_env_code) { "$env:#{dsc_user_suffix_env_var_name}" }
let(:dsc_user_prefix_param_code) { "$#{dsc_user_prefix_param_name}" }
let(:dsc_user_suffix_param_code) { "$#{dsc_user_suffix_param_name}" }
let(:dsc_user_env_code) { "\"$(#{dsc_user_prefix_env_code})_usr_$(#{dsc_user_suffix_env_code})\"" }
let(:dsc_user_param_code) { "\"$(#{dsc_user_prefix_param_code})_usr_$(#{dsc_user_suffix_param_code})\"" }
let(:config_flags) { nil }
(
let(:config_param_section) { "" }
let(:dsc_user_code) { "'#{dsc_user}'" }
$testuser = #{dsc_user_code}
@{
AllNodes = @(
let(:dsc_environment_env_var_name) { "dsc_test_cwd" }
if (($pwd.path -eq '#{dsc_environment_fail_etc_directory}') -and (test-path('#{dsc_environment_fail_etc_directory}')))
Name = '#{dsc_environment_env_var_name}'
let(:dsc_code) { dsc_reg_script }
let(:dsc_user_code) { dsc_user_param_code }
let(:config_flags) { { "#{dsc_user_prefix_param_name}": (dsc_user_prefix).to_s, "#{dsc_user_suffix_param_name}": (dsc_user_suffix).to_s } }
let(:dsc_user_code) { dsc_user_env_code }
cd c:\\
$cert = ls Cert:\\LocalMachine\\My\\ |
Where-Object {$_.Subject -match "ChefTest"} |
if($cert -eq $null) {
$pfxpath = '#{self_signed_cert_path}'
$password = ''
UserName = '#{dsc_user}'
let(:tmp_file_name) { Dir::Tmpname.create("tmpfile") {} }
contents = File.open(tmp_file_name, "rb:bom|UTF-16LE") do |f|
f.read.encode("UTF-8")
let(:test1_0) { File.join(apt_data, "chef-integration-test_1.0-1_amd64.deb") }
let(:test1_1) { File.join(apt_data, "chef-integration-test_1.1-1_amd64.deb") }
let(:test2_0) { File.join(apt_data, "chef-integration-test2_1.0-1_amd64.deb") }
status = shell_out("dpkg -s #{package}")
if action.nil? || action == :purge
shell_out!("dpkg -i #{test1_0}")
shell_out!("dpkg -i #{test1_0} #{test2_0}")
shell_out!("dpkg -i #{test2_0}")
shell_out!("dpkg -i #{test1_1}")
let(:action) { :purge }
File.open("/etc/yum.repos.d/chef-dnf-localtesting.repo", "w+") do |f|
%w{1.10 1* 1.10-1 1*-1 1.10-* 1*-* 0:1.10 0:1* 0:1.10-1 0:1*-1 *:1.10-* *:1*-*}.each do |vstring|
%w{1.2 1* 1.2-1 1*-1 1.2-* 1*-* 0:1.2 0:1* 0:1.2-1 0:1*-1 *:1.2-* *:1*-*}.each do |vstring|
%w{1.2 1.2-1 1.2-* 0:1.2 0:1.2-1 *:1.2-*}.each do |vstring|
%w{1* 1*-1 1*-* 0:1* 0:1*-1 *:1*-*}.each do |vstring|
dnf_package "chef_rpm-0:1.2-1.#{pkg_arch}" do
dnf_package "chef_rp*-1*" do
it "matches with a vr glob", :rhel_gte_8 do
dnf_package "chef_rpm >= 1.2" do
dnf_package "chef_rpm > 1.2" do
dnf_package "chef_rpm = 1.10" do
dnf_package "chef_rpm = 1.2" do
dnf_package "chef_rpm > 2.0"
dnf_package "chef_rpm < 1.10" do
dnf_package "chef_rpm-1.10-1.#{pkg_arch}" do
when "aix", "solaris2", "omnios"
expect(shell_out("crontab -l #{new_resource.user} | grep \"#{cron_name}\"").exitstatus).to eq(0)
expect(shell_out("crontab -l #{new_resource.user} | grep \"#{cron_name}\"").stdout.lines.to_a.size).to eq(1)
expect(shell_out("crontab -l #{new_resource.user} | grep \"#{command}\"").exitstatus).to eq(0)
expect(shell_out("crontab -l #{new_resource.user} | grep \"#{command}\"").stdout.lines.to_a.size).to eq(1)
expect(shell_out("crontab -l -u #{new_resource.user} | grep \"#{cron_name}\"").exitstatus).to eq(0)
expect(shell_out("crontab -l #{new_resource.user} | grep \"#{cron_name}\"").stdout.lines.to_a.size).to eq(0)
expect(shell_out("crontab -l -u #{new_resource.user} | grep \"#{command}\"").exitstatus).to eq(0)
expect(shell_out("crontab -l #{new_resource.user} | grep \"#{command}\"").stdout.lines.to_a.size).to eq(0)
expect(shell_out("crontab -l #{new_resource.user} | grep \"#{cron_name}\"").exitstatus).to eq(1)
expect(shell_out("crontab -l #{new_resource.user} | grep \"#{new_resource.command}\"").stdout.lines.to_a.size).to eq(0)
expect(shell_out("crontab -l -u #{new_resource.user} | grep \"#{cron_name}\"").exitstatus).to eq(1)
expect(shell_out("crontab -l -u #{new_resource.user} | grep \"#{new_resource.command}\"").stdout.lines.to_a.size).to eq(0)
weekdays = { Mon: 1, tuesday: 2, '3': 3, 'thursday': 4, 'Fri': 5, 6 => 6 }
expect(shell_out("crontab -l -u #{new_resource.user} | grep '#{attribute.upcase}=\"#{value}\"'").exitstatus).to eq(0)
%i{ home mailto path shell }.each do |attr|
let(:file_base) { "cookbook_file_spec" }
let(:source) { "java.response" }
let(:cookbook_name) { "java" }
let(:package_name) { "test-A" }
let(:package_list) { proc { shell_out!("choco list -lo -r #{Array(package_name).join(" ")}").stdout.chomp } }
let(:package_name) { %w{test-A test-B} }
expect(package_list.call).to eq("test-A|2.0\r\ntest-B|1.0")
::File.exist?("/usr/PkgA/bin/acommand")
!::File.exist?("/usr/PkgA/bin/acommand")
@pkg_name = "PkgA.rte"
@pkg_path = "#{Dir.tmpdir}/PkgA.1.0.0.0.bff"
shell_out("installp -u #{@pkg_name}")
shell_out("installp -aYF -d #{@pkg_path} #{@pkg_name}")
@pkg_path = "#{Dir.tmpdir}/PkgA.2.0.0.0.bff"
let(:output_command) { " > " }
let(:code) { "echo hello" }
let(:command) { "wizard racket" }
let(:code) { nil }
let(:tmp_path) { Dir.mktmpdir }
let(:extract_destination) { "#{tmp_path}/extract_here" }
expect(Dir.glob("#{extract_destination}/**/*").length).to eq(4)
expect(Dir.glob("#{extract_destination}/**/*").length).to eq(3)
expect(Dir.glob("#{extract_destination}/**/*").length).to eq(1)
File.open("/etc/apt/sources.list.d/chef-integration-test.list", "w+") do |f|
shell_out!("apt-get update " +
metadata = { unix_only: true,
r.options("--force-yes")
r.version("2.0")
shell_out!("dpkg -i #{v_1_1_package}")
shell_out!("dpkg -i #{v_1_0_package}")
r.version("1.1-1")
directory << "/etc/rc.d/rc#{run_level}.d/#{status}#{priority}#{new_resource.service_name}"
FileUtils.cp((File.join(__dir__, "/../assets/chefinittest")).to_s, "/etc/rc.d/init.d/chefinittest")
expect(shell_out!("lssrc -a | grep #{new_resource.service_name}").stdout.split(" ").last).to eq("active")
expect(shell_out!("lssrc -a | grep #{new_resource.service_name}").stdout.split(" ").last).to eq("inoperative")
args = shell_out!("lssrc -a | grep #{new_resource.service_name}").stdout.split(" ")
if args.length == 3
script_dir = File.join(__dir__, "/../assets/")
shell_out!("mkssys -s ctestsys -p #{script_dir}/testchefsubsys -u #{get_user_id} -S -n 15 -f 9 -R -Q")
shell_out!("mkssys -s ctestsys -p #{script_dir}/testchefsubsys -u #{get_user_id} -S -n 15 -f 9 -R -Q -G ctestgrp")
linux: 'shutdown -r +5 "rebooter spec test" &',
solaris: 'shutdown -i6 -g5 -y "rebooter spec test" &',
let(:uri) { URI.parse("http://www.bing.com/robots.txt") }
let(:mtime) { "Thu, 01 Aug 2013 08:16:32 GMT" }
URI.parse("http://www.bing.com/" + ("0" * 1024))
let(:recipe) { Chef::Recipe.new("notif", "test", run_context) }
r = recipe
t = self
if succeeded == 0 || last_error != 0
let(:test_user) { "chefuserctx3" }
let(:test_password) { "j823jfxK3;2Xe1" }
let(:domain_to_impersonate) { "." }
shell_out("echo %LC_ALL%", default_env: false)
shell_out("echo %LC_ALL%", environment: { "LC_ALL" => "POSIX" }, default_env: false)
shell_out("echo $LC_ALL", environment: { "LC_ALL" => "POSIX" }, default_env: false)
def a(a = nil)
@a = a if a
@a
@debug_log = ""
allow(Chef::Log).to receive(:trace) { |str| @debug_log << str }
let(:source) { "http://localhost:9000" }
( mode_int & 07777).to_s(8)
File.open(path, "w+", 0600) { |f| f.print(staging_file_content) }
random.rand(1 << 32).to_s
let(:elapsed_time) { rand }
e.source == ChefUtils::Dist::Infra::SHORT && e.event_id == 10000 &&
e.source == ChefUtils::Dist::Infra::SHORT && e.event_id == 10001 &&
e.source == ChefUtils::Dist::Infra::SHORT && e.event_id == 10002 &&
e.source == ChefUtils::Dist::Infra::SHORT && e.event_id == 10003 &&
expect(values.include?({ name: "RootType1", type: :string, data: "fibrous" })).to eq(true)
expect(@resource.registry_value_exists?("HKCU\\Software\\Root", { name: "RootType1", type: :string, data: "fibrous" })).to eq(true)
expect(@resource.registry_data_exists?("HKCU\\Software\\Root", { name: "RootType1", type: :string, data: "fibrous" })).to eq(true)
let(:reg_key) { nil }
let(:original_set) { false }
so = if windows?
shell_out("echo %http_proxy%")
chef_repo_path __dir__
run_list "test", "test::one", "test::two"
define :new_cat, :is_pretty => true do
define :new_dog, :is_cute => true do
block { }
version "1.0.0"
version "0.0.1"
a :foo
c :bar
}.each do |os|
@monkey_name = "my monkey's name is '#{new_resource.monkey}'"
block {}
option :scro, :short => '-s SCRO', :long => '--scro SCRO', :description => 'a configurable setting'
@ran = true
define :rico_suave, :rich => "smooth" do
version '0.1.0'
supports 'centos', '>= 6'
supports 'freebsd', '> 10.1-fake-p12'
chef_env ||= nil
(*&(*&(*&(*&(*^%$%^%#^^&(*)(*{}}}}}}}}+++++===))))))
(*&(*&(*&(*&(*^%$%^%#^^&(*)(*{}}}}}}}}+++++===)))))
echo "grant all on *.* to root@'$i' identified by 'a_password'; flush privileges;" | mysql -u root -h 127.0.0.1
1 / 0
puts "re-installing #{gem_name}..."
(base_dirs.length - 1).downto(0) do |i|
source path: "#{project.files_path}/#{name}"
Dir.glob("#{install_dir}/embedded/lib/ruby/gems/*/gems/*/bin/{console,setup}").each do |f|
puts "Deleting #{f}"
Dir.glob("#{install_dir}/**/{.gitkeep,.keep}").each do |f|
target_dir = "#{install_dir}/embedded/lib/ruby/gems/*/gems".tr("\\", "/")
files = %w{
Dir.glob("#{target_dir}/*/{#{files.join(",")}}").each do |f|
next if File.basename(File.expand_path("..", f)).start_with?("chef-")
next if File.basename(File.expand_path("..", f)).start_with?("ruby-prof-")
Dir.glob("#{install_dir}/embedded/lib/ruby/gems/*/gems/*/VERSION".tr("\\", "/")).each do |f|
next if File.basename(File.expand_path("..", f)).start_with?("aws", "jmespath")
next if Dir.exist?(File.join(File.dirname(f), "bin")) && !Dir.empty?(File.join(File.dirname(f), "bin"))
Dir.glob("#{install_dir}/embedded/lib/ruby/gems/*/gems/*/spec".tr("\\", "/")).each do |f|
}.each do |f|
file_path = "#{install_dir}/embedded/bin/#{f}"
source path: "#{project.files_path}/../..",
ruby_version = "3.1.2"
ruby_mmv = "#{ruby_version}.0"
ruby_dir = "#{install_dir}/embedded/lib/ruby/#{ruby_mmv}"
gem_dir = "#{install_dir}/embedded/lib/ruby/gems/#{ruby_mmv}"
bundle "install --without #{bundle_excludes.join(" ")}", env: env
gem "build #{gemspec_name}", env: env
copy "chef*.gem", "pkg"
%w{rubyzip}.each do |gem|
sync "#{project_dir}", "#{install_dir}"
current_file ||= __FILE__
version_file = File.expand_path("../../../../VERSION", current_file)
install_dir "#{default_root}/#{name}"
current_file = __FILE__
chef_project_contents = IO.read(File.expand_path("chef.rb", __dir__))
define_method("#{m}?") do
(self.class.const_get(c) == @sku) &&
(c.to_s =~ /#{m}/i )
windows_10? && build_number >= 15063
os_version.split(".").collect(&:to_i)
length = 0
while last_char != "\000\000"
length += 1
wide_to_utf8(get_bytes(0, num_wchars * 2))
offset = 0
offset += 2 while get_bytes(offset, 2) != "\x00\x00"
def ==(other)
(!domain.nil? && domain.length > 0) ? "#{domain}\\#{name}" : name
SID.from_string_sid("S-1-0")
SID.from_string_sid("S-1-0-0")
SID.from_string_sid("S-1-1")
SID.from_string_sid("S-1-1-0")
SID.from_string_sid("S-1-2")
SID.from_string_sid("S-1-3")
SID.from_string_sid("S-1-3-0")
SID.from_string_sid("S-1-3-1")
SID.from_string_sid("S-1-3-2")
SID.from_string_sid("S-1-3-3")
SID.from_string_sid("S-1-4")
SID.from_string_sid("S-1-5")
SID.from_string_sid("S-1-5-1")
SID.from_string_sid("S-1-5-2")
SID.from_string_sid("S-1-5-3")
SID.from_string_sid("S-1-5-4")
SID.from_string_sid("S-1-5-6")
SID.from_string_sid("S-1-5-7")
SID.from_string_sid("S-1-5-8")
SID.from_string_sid("S-1-5-9")
SID.from_string_sid("S-1-5-10")
SID.from_string_sid("S-1-5-11")
SID.from_string_sid("S-1-5-12")
SID.from_string_sid("S-1-5-13")
SID.from_string_sid("S-1-5-18")
SID.from_string_sid("S-1-5-19")
SID.from_string_sid("S-1-5-20")
SID.from_string_sid("S-1-5-32-544")
SID.from_string_sid("S-1-5-32-545")
SID.from_string_sid("S-1-5-32-546")
SID.from_string_sid("S-1-5-32-547")
SID.from_string_sid("S-1-5-32-548")
SID.from_string_sid("S-1-5-32-549")
SID.from_string_sid("S-1-5-32-550")
SID.from_string_sid("S-1-5-32-551")
SID.from_string_sid("S-1-5-32-552")
@path = path
@type = type
aces_size = aces.inject(0) { |sum, ace| sum + ace.size }
0.upto(length - 1) do |i|
aces.reverse_each { |ace| add_ace(self, ace, index) }
(size + 4 - 1) & 0xfffffffc
type == other.type && flags == other.flags && mask == other.mask && sid == other.sid
if result == 0
account_name = (!domain.nil? && domain.length > 0) ? "#{domain}\\#{name}" : name
Chef::ReservedNames::Win32::Error.raise!("get_named_security_info(#{path}, #{type}, #{info})", hr)
IsValidAcl(acl) != 0
IsValidSid(sid) != 0
use = FFI::Buffer.new(:long).write_long(0)
access = 0
if win32_error != 0
reg.map { |name, type, data| { name: name, type: get_name_from_type(type), data: data } }
key_parent = key_parts.join("\\")
rescue ::Win32::Registry::Error => e
reg.each_key { |key| return true }
reg.each_key { |current_key| subkeys << current_key }
( applied_arch == :x86_64 ) ? 0x0100 : 0x0200
if val_type == type_new
missing_key_arr = key_path.split("\\")
key = missing_key_arr.join("\\")
reg_path = path.split("\\")
key = reg_path.join("\\")
hive = {
@_name_type_map ||= _type_name_map.invert
existing_key_path = existing_key_path << "\\" << intermediate_key
(call_succeeded != 0) && (is_64_bit_process_result.get_int(0) != 0)
{ usri3_name: nil,
}.each do |(k, v)|
s.set(k, v)
server_name, group_name, 0, buf, -1,
args.each do |k, v|
buf.set(k, v)
info.each do |k, v|
ui2_hash.each do |(k, v)|
rc = NetUseAdd(server_name, 2, buf, nil)
if @handle == 0
}.each do |method|
integer.to_s(16).rjust(4, "0")
raise Errno::ENOENT, "(#{old_name}, #{new_name})" unless ::File.exist?(old_name) || ::File.symlink?(old_name)
if ::File.exist?(file_name) || ::File.symlink?(file_name)
if /^\\\?\?\\/.match?(link_dest)
if size == 0
result = FFI::MemoryPointer.new :char, (size + 1) * 2
def self.format_message(message_id = 0, args = {})
if num_chars == 0
formatted_message << "---- Begin Win32 API output ----\n"
formatted_message << "---- End Win32 API output ----\n"
:w_suite_mask, :WORD,
:w_product_type, :BYTE,
:Sbzl, :uchar,
:Mask, :uint32,
val = if val.is_a? String
members.inject({}) do |memo, key|
if !val.nil? && !val.null?
ffi_lib "msi"
if status != 234
if status != 0
(device_type << 16) | (access << 14) | (function << 2) | method
layout :w_lang, :WORD,
:n_file_size_high, :DWORD,
:n_file_size_low, :DWORD,
:Flags, :uint32,
path = ::File.expand_path(path) if path.start_with? "/"
if success == 0
if file_size == 0
layout :cbData, :DWORD, # Count, in bytes, of data
offset = offset + argument.length * 2 + 2
((low & 0xff) | (high & 0xff)) << 8
((low & 0xffff) | (high & 0xffff)) << 16
l & 0xffff
l >> 16
w & 0xff
w >> 8
status >> 31 == 1
sev << 31 | fac << 16 | code
(hr >> 16) & 0x1fff
if x <= 0
(x & 0x0000FFFF) | (7 << 16) | 0x80000000
(hr >> 31) & 0x1
status < 0
status >= 0
low + (high * (2**32))
OPS = %w{< > = <= >= ~>}.freeze
other.class == self.class && @op == other.op && @version == other.version
alias_method :==, :eql?
elsif @op == "="
elsif @op == "~>"
raise "bad op #{@op}"
@op = "="
@op = $1
@raw_version = $2
if @raw_version.split(".").size <= 2
def initialize(str = "")
def <=>(other)
ans = (version <=> other.send(method))
other.is_a?(Version) && self == other
def parse(str = "")
@major, @minor, @patch =
when /^(\d+)\.(\d+)\.(\d+)$/
when /^(\d+)\.(\d+)$/
msg = "'#{str}' does not match 'x.y.z' or 'x.y'"
when /^(\d+)$/
msg = "'#{str}' does not match 'x.y.z', 'x.y' or 'x'"
require_relative "../../win32/api/file"
name += "\\" unless /\\$/.match?(name) # trailing slash required
require_relative "../../win32/net"
args.inject({}) do |memo, (k, v)|
usri3.inject({}) do |memo, (k, v)|
if /System Error Code: 1326/.match?(e.to_s)
args.each do |key, val|
use_info.inject({}) do |memo, (k, v)|
args = {}
ui2_hash.inject({}) do |memo, (k, v)|
@token = nil
def <<(job)
@queue << job
fn = @queue.pop
fn.arity == 1 ? fn.call(@lock) : fn.call
workers.each { |worker| self << Thread.method(:exit) }
@changes = (editor.replace_lines(regex, newline) > 0) || @changes
@changes = (editor.replace(regex, replace) > 0) || @changes
@changes = (editor.remove_lines(regex) > 0) || @changes
@changes = (editor.append_line_after(regex, newline) > 0) || @changes
!!@changes
lines << line
(lines.length - @lines.length).tap { @lines = lines }
count = 0
count = 1
@lines.map! do |line|
count += 1
if found.length == 0
if count == 0
rs.each do |r|
found = rs.find_all do |r|
@sets = sets
ps4_base_command + " -whatif; if (! $?) { exit 1 }"
!! (dsc_exception_output.gsub(/\n+/, "").gsub(/\s+/, " ") =~ /A parameter cannot be found that matches parameter name 'Whatif'/i)
!! (command_output =~ /\sCimException/ &&
Chef::Log.warn("Could not parse LCM output: #{e}")
require_relative "../../log"
lcm_output = String(lcm_output).split("\n")
op_action , op_value = line.strip.split(":")
current_resource = { name: info }
Chef::Log.trace("Ignoring op_action #{op_action}: Read line #{line}")
op_action, op_type = operation.strip.split(" ").map { |m| m.downcase.to_sym }
op_action = op_type = :info
if match = line.match(/^.*?:.*?: \s+(.*)/)
Chef::Log.trace("DSC: DSC code:\n '#{code}'")
parameter_value.gsub(/(`|'|"|#)/, '`\1')
switch_argument = ""
if resources.length == 0 || resources.include?("*")
document_file_name = ::Dir.entries(document_directory).find { |path| path =~ /.*.mof/ }
@diff.join("\\n")
@error = do_diff(old_file, new_file)
diff_str = ""
diff_data = ::Diff::LCS.diff(old_data, new_data)
ft = File.stat(old_file).mtime.localtime.strftime("%Y-%m-%d %H:%M:%S.%N %z")
diff_str << "--- #{old_file}\t#{ft}\n"
ft = File.stat(new_file).mtime.localtime.strftime("%Y-%m-%d %H:%M:%S.%N %z")
diff_str << "+++ #{new_file}\t#{ft}\n"
old_hunk = hunk = nil
diff_str << old_hunk.diff(:unified) << "\n"
Chef::Log.trace("Running: diff -u #{old_file} #{new_file}")
@diff = diff_str.split("\n")
buff = "" if buff.nil?
diff_str.encode!("UTF-8", invalid: :replace, undef: :replace, replace: "?")
@path = path.nil? ? new_resource.path : path
if @new_resource.backup != false && @new_resource.backup > 0 && ::File.exist?(path)
savetime = time.strftime("%Y%m%d%H%M%S.#{nanoseconds}")
backup_filename = "#{path}.chef-#{savetime}"
Chef::Log.info("#{@new_resource} backed up to #{backup_path}")
end.map { |f| ::File.join(::File.dirname(backup_path), f) }
unsorted_backup_files.sort.reverse # faster than sort { |a, b| b <=> a }
@last_name = nil
@email = nil
def email(arg = nil)
payload = {
if e.response.code == "400"
if e.response.code == "409"
payload = to_h.merge({ "private_key" => true })
users.inject({}) do |user_map, (name, _url)|
new_response = {}
@name = ""
def name(arg = nil)
def admin(arg = nil)
chef_rest_v0.delete("users/#{@name}")
payload = { name: name, admin: admin }
reregistered_self = chef_rest_v0.put("users/#{name}", { name: name, admin: admin, private_key: true })
!!@node_built
print "."
msg = success ? "done.\n\n" : "epic fail!\n\n"
puts "#{e.class.name}: #{e.message}"
puts "* " * 40
return all if query.to_s == "all"
objects = @model_class.method(:list).arity == 0 ? @model_class.list : @model_class.list(true)
objects.map { |obj| Array(obj).find { |o| o.is_a?(@model_class) } }
query.map { |key, value| "#{key}:#{value}" }.join(" AND ")
banner << ""
banner << "".ljust(80, "=")
banner << "| " + "Command".ljust(25) + "| " + "Description"
banner << "| " + help_text.cmd.ljust(25) + "| " + help_text.desc
banner << "\n"
banner.join("\n")
help = all_help_descriptions.find { |h| h.cmd.to_s == method_name.to_s }
puts ""
puts "Command: #{method_name}"
puts "".ljust(80, "=")
:on
@desc, @explain = nil, nil
help_descriptions << Help.new("#{mname}.#{subcommand}", text.to_s, nil)
@subcommand_help = {}
when "on"
when "off"
explain(<<~E)
puts "echo is #{conf.echo.to_on_off_str}"
def ohai(key = nil)
filename = "#{ChefUtils::Dist::Infra::SHELL}-edit-#{object.class.name}-"
system("#{Shell.editor} #{tempfile.path}")
clients.search("KEY:VALUE") { |c| c.name }
clients.transform("*:*") do |client|
if client.name =~ /borat/i
nodes.find(:name => "app#") { |node| node.ec2 }
if node.fqdn =~ /.*\\.preprod\\.example\\.com/
show: "load a node by name",
show: "load a role by name",
show: "load a data bag item by id",
@named_databags_wrappers ||= {}
::IRB.setup(nil)
@irb_conf || IRB.conf
m = conf.main
env_string = Shell.env ? " (#{Shell.env})" : ""
puts "run `help' for help, `exit' or ^D to quit."
short: "-h",
long: "--help",
on: :tail,
proc: proc { print_help }
short: "-a",
long: "--standalone",
short: "-s",
long: "--solo",
short: "-z",
long: "--client",
long: "--solo-legacy-mode",
short: "-v",
long: "--version",
proc: lambda { |items| items.split(",").map { |item| Chef::RunList::RunListItem.new(item) } }
unversioned? ? 0 : nil
def raw_request(method, path, headers = {}, data = false)
secret_uri = URI.parse("https://#{vault}.vault.azure.net/secrets/#{name}/#{version}?api-version=7.2")
response = http.get(secret_uri, { "Authorization" => "Bearer #{token}",
if name.include?("/")
name.split("/", 2)
@token_query ||= begin
p = {}
response = http.get(token_uri, { "Metadata" => "true" })
when nil, ""
autoload :URI, "uri"
@url = url
def search(type, query = "*:*", *args, &block)
if type.to_sym == :node
args_h = args_h.reject { |k, v| k == :fuzz }
if !/:/.match?(query)
unless t.is_a?(String) || t.is_a?(Symbol)
msg = "Invalid search object type #{t.inspect} (#{t.class}), must be a String or Symbol." +
args_h = {}
query_param_value = Addressable::URI::CharacterClasses::QUERY + "\\&\\;"
qstr = "search/#{type}?q=#{escape_value(query)}"
qstr += "&start=#{escape_value(start)}" if start
qstr += "&rows=#{escape_value(rows)}" if rows
def call_rest_service(type, query: "*:*", rows: nil, start: 0, filter_result: nil)
@end_time = Time.now
if @start_time && @end_time
@end_time - @start_time
{ node: node,
run_id: run_id }
@exception && "#{@exception.class.name}: #{@exception.message}"
@mutex = nil
@runpid = nil
if time_to_wait > 0.0
@runlock = File.open(runlock_file, "a+")
@mutex = Chef::ReservedNames::Win32::Mutex.new("Global\\#{runlock_file.tr("\\", "/").downcase}")
release # Just to be on the safe side...
@versions = {}
elsif recipe_name.include?("::")
if item.key?("version") || item.key?(:version)
@type = :recipe
@type = :role
@name = item
@type == :role
@type == :recipe
to_s == other.to_s
other.respond_to?(:type) && other.respond_to?(:name) && other.respond_to?(:version) && other.type == @type && other.name == @name && other.version == @version
unless (item.key?("type") || item.key?(:type)) && (item.key?("name") || item.key?(:name))
@applied_roles = {}
@all_missing_roles = {}
@role_errors = {}
seen_items = { recipe: {}, role: {} }
{ type: "recipe", name: item.name, version: item.version, skipped: !!skipped }
Chef::Role.from_hash(rest.get("roles/#{name}"))
if e.message == '404 "Not Found"'
@run_list_items = run_list_items.map { |i| coerce_to_run_list_item(i) }
def <<(run_list_item)
alias :push :<<
alias :add :<<
@run_list_items.join(", ")
to_a.map(&:to_s)
@run_list_items.length == 0 ? true : false
@run_list_items.each { |i| yield(i) }
@run_list_items.each_index { |i| yield(i) }
item.each { |r| self << r }
self << item
@run_list_items.delete_if { |i| i == item }
autoload :Set, "set"
seen_cookbooks = {}
default_file = list_of_attr_files.find { |path| File.basename(path) == "default.rb" }
rc = self
@logger = logger || Chef::Log.with_child
@definitions = {}
@loaded_recipes_hash = {}
@reboot_info = {}
v.select do |n|
(n.resource.is_a?(String) && n.resource == resource.declared_key) ||
loaded_recipes_hash.key?("#{cookbook}::#{recipe}")
}.map(&:to_sym)
@description = ""
@env_run_lists = { "_default" => Chef::RunList.new }
:name,
msg << "(env_run_lists: #{env_run_lists.inspect})"
role = new
response = {}
chef_server_rest.put("roles/#{@name}", self)
roles_files = Dir.glob(File.join(Chef::Util::PathHelper.escape_glob_dir(path), "**", "**"))
js_files = roles_files.select { |file| file.match(%r{/#{name}\.json$}) }
rb_files = roles_files.select { |file| file.match(%r{/#{name}\.rb$}) }
if js_files.count > 1 || rb_files.count > 1
if js_path && File.exist?(js_path)
as_hash = {}
@status = "success"
@expanded_run_list = {}
if !e.response || (code != "404" && code != "406")
exception = "Exception: #{code} "
reason = "Received #{code}. "
if code == "406"
@status = "failure"
run_data = {}
exception_data = {}
Zlib::GzipWriter.wrap(StringIO.new(out)) { |gz| gz << data }
resources.each_with_object({}) do |r, res|
@defines = {}
@name = nil
@params = {}
@recipe = nil
(name).to_s
@position = 0
@position += 1
step while @position < size && !paused?
@resources_by_key = {}
key = key.to_s
resources = rl.merge(rl) { |k, r| Chef::Resource.from_hash(r) }
name = $2
name = ""
ret = @resources.reject! { |r| r.to_s == key }
instance_vars = {}
def insert(resource, opts = {})
if !(resource_type.nil? && instance_name.nil?)
Chef::Log.warn("`push` is deprecated, use `insert`")
alias_method :<<, :insert
{ "@resource_list" => "ResourceList", "@resource_set" => "ResourceSet" }.each_pair do |name, klass|
type 'rpm-md'
coerce: proc { |v| Array(v) },
coerce: proc { |x| x.is_a?(String) ? x.shellsplit : x },
default: "/etc/yum.repos.d/",
property :cost, String, regex: /^\d+$/,
property :timeout, String, regex: /^\d+$/,
yum_package 'netpbm >= 10.35.58-8.el8'
yum_package 'netpbm >= 10'
or:
identity: true, coerce: proc { |x| x.is_a?(Array) ? x.to_a : x }
coerce: proc { |x| x.is_a?(Array) ? x.to_a : x }
default: { before: false, after: false },
coerce: proc { |v|
if v.is_a?(Hash)
elsif v.is_a?(Array)
elsif v.is_a?(TrueClass) || v.is_a?(FalseClass)
{ before: v, after: v }
elsif v == :before
{ before: true, after: false }
elsif v == :after
{ after: true, before: false }
regex: /^\S*$/, # no spaces
coerce: proc { |x| clarify_reboot(x) },
cmd = ""
cmd << " -Force"
coerce: proc { |v| Array(v) }
(users - accounts).each do |user|
notify: 2,
p >= 0 && p <= 22
p > 0 && p < 25
type: :dword,
bool ? 1 : 0
day 'Mon, Thu'
day 'Mon, Fri'
description: "The Months of the year on which the task runs, such as: `JAN, FEB` or `*`. Multiple months should be comma delimited. e.g. `Jan, Feb, Mar, Dec`."
default: 7, callbacks: { "should be in range of 0 to 10" => proc { |v| v >= 0 && v <= 10 } }
introduced: "14.7",
introduced: "17.0", default: 5,
if start_day.nil? && day.nil?
if (frequency_modifier.to_i.between?(2, 12)) && !(months.nil?)
if start_day && frequency == :none
@password_required ||= (!user.nil? && !Chef::ReservedNames::Win32::Security::SID.system_user?(user))
if (%i{on_logon onstart on_idle none}.include?(frequency)) && ( frequency_modifier != 1)
min = 1
raise ArgumentError, "day wild card (*) is only valid with frequency :weekly" if frequency == :monthly && day == "*"
if day.is_a?(String) && day.to_i.to_s != day
days = day.split(",")
days.map! { |day| day.to_s.strip.downcase }
months = months.split(",")
if !idle_time.nil? && frequency != :on_idle
if idle_time.nil? && frequency == :on_idle
unless idle_time.nil? || idle_time > 0 && idle_time <= 999
task = ::Win32::TaskScheduler.new(new_resource.task_name, nil, "\\", false)
pathed_task_name = new_resource.task_name.start_with?("\\") ? new_resource.task_name : "\\#{new_resource.task_name}"
trigger_hash = {
day = day.to_s.split(",")
day.map! { |value| value.strip.upcase }
flag = (task.author != new_resource.user ||
task.author.to_s.casecmp(new_resource.user.to_s) != 0 ||
{ once: nil }
{ months: months_of_year.to_i, days: days_of_month.to_i }
weeks.map! { |week| week.to_s.strip.upcase }
days = new_resource.day.to_s.split(",")
days.map! { |day| day.to_s.strip.upcase }
if days - (1..31).to_a
new_resource.day = "mon, tue, wed, thu, fri, sat, sun" if new_resource.day == "*" && new_resource.frequency == :weekly
new_resource.months = "jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec" if new_resource.months == "*" && new_resource.frequency == :monthly
settings = {
settings = {}
cmd = "schtasks /#{task_action} /TN \"#{new_resource.task_name}\" "
unless option == "TR"
cmd += "/#{option} "
Date.strptime(date, "%m/%d/%Y").strftime("%a").upcase
path 'C:\\foo'
coerce: proc { |p| p.tr("/", "\\") || p }
default: ""
default: "*"
grant_command = "Grant-SmbShareAccess -Name '#{new_resource.share_name}' -AccountName \"#{new_resource.send("#{perm_type}_users").join('","')}\" -Force -AccessRight #{perm_type}"
property_name = "#{type}_users"
revoke_command = "Revoke-SmbShareAccess -Name '#{new_resource.share_name}' -AccountName \"#{users.join('","')}\" -Force"
bool ? "$true" : "$false"
property :display_name, String, regex: /^.{1,256}$/,
coerce: proc { |x|
if x.is_a?(Integer)
introduced: "14.0",
default: false, coerce: proc { |x|
x == 0 ? false : true
coerce: proc { |x| x.downcase }
policy_line = "#{security_option} = \"#{security_value}\""
file_path = file.path.tr("/", "\\")
policy_line = "#{security_option} = #{security_value}"
proc { |v| v.match(Resolv::IPv4::Regex) },
default: lazy { |x| "IP_#{x.ipv4_address}" },
description: "The printer port protocol: 1 (RAW) or 2 (LPR).",
$_.Put()
introduced: "17.3",
windows_path 'C:\\7-Zip' do
env "path" do
value path.tr("/", "\\")
path 'C'
path 'E:\'
path 'f:\'
coerce: proc { |x| x.tr("/", "\\") },
@exists ||= begin
$page_file_name = '#{pagefile}';
$page_file = '#{pagefile}';
{ return $true }
{ return $false }
$page_file = "#{pagefile}"
converge_by("set #{pagefile} to InitialSize=#{min} & MaximumSize=#{max}") do
source 'C:\\7z920.msi'
:path => 'C:\\7zip.msi',
options '/Q'
coerce: (proc do |s|
end),
desired_state: false, coerce: (proc { |c| c.downcase }),
coerce: proc { |x| /^.:.*/.match?(x) ? x.tr("\\", "/").gsub("//", "/") : x }
icmp_type '8'
default: lazy { rule_name },
coerce: proc { |d| d.is_a?(String) ? d.split(/\s*,\s*/).sort : Array(d).sort.map(&:to_s) },
coerce: proc { |d| d.is_a?(String) ? d.downcase.to_sym : d }
default: "TCP",
default: "Any",
coerce: proc { |f| f.is_a?(String) ? f.downcase.to_sym : f }
coerce: proc { |p| Array(p).map(&:downcase).map(&:to_sym).sort },
p.all? { |e| %i{public private domain any notapplicable}.include?(e) }
coerce: proc { |i| i.is_a?(String) ? i.downcase.to_sym : i }
cmd << " -Group '#{new_resource.group}'" if new_resource.group && cmdlet_type == "New"
cmd << " -LocalPort '#{new_resource.local_port.join("', '")}'" if new_resource.local_port
cmd << " -RemoteAddress '#{new_resource.remote_address.join("', '")}'" if new_resource.remote_address
cmd << " -RemotePort '#{new_resource.remote_port.join("', '")}'" if new_resource.remote_port
cmd << " -IcmpType '#{new_resource.icmp_type}'"
cmd << " -Profile '#{new_resource.profile.join("', '")}'" if new_resource.profile
cmd << " -Enabled '#{new_resource.enabled}'"
new_resource.icmp_type.split(":").all? { |type| (0..255).cover?(type.to_i) }
if obj.to_s.downcase == "true"
if ($#{profile_name}.Enabled) {
} else {return $false}
coerce: proc { |x| to_formatted_array(x) },
x = x.split(/\s*,\s*/) if x.is_a?(String) # split multiple forms of a comma separated list
converge_by("remove Windows feature#{"s" if features_to_remove.count > 1} #{features_to_remove.join(",")}") do
@remove ||= begin
raise "The Windows feature#{"s" if removed.count > 1} #{removed.join(",")} #{removed.count > 1 ? "are" : "is"} removed from the host and cannot be installed." unless removed.empty?
install_command = "dism.exe /online /enable-feature #{features_to_install.map { |f| "/featurename:#{f}" }.join(" ")} /norestart"
message = "remove Windows feature#{"s" if features_to_remove.count > 1} #{features_to_remove.join(",")}"
@install ||= begin
source 'd:\\sources\\sxs'
@key_exists ||= !!env_value(new_resource.key_name)
needs_delete = new_values.any? { |v| current_values.include?(v) }
obj = env_obj(key_name)
@env_obj = nil
description: "",
if (!($needs_creating))
paths 'c:\\foo\\bar, d:\\bar\\baz'
coerce: proc { |x| to_consistent_path_array(x) },
fixed = fixed.split(/\s*,\s*/) if fixed.is_a?(String)
fixed.map! { |v| v.gsub(%r{/}, "\\") }
values.transform_values! { |x| Array(x) }
cmd << " -#{flag} #{to_add.join(",")}" unless to_add.empty?
cmd << " -UILockdown #{type_coercion(new_resource.lock_ui)}"
cmd << " -#{flag} #{type_coercion(!new_resource.send(prop))}"
default: lazy { pfx_password ? true : false }, skip_docs: true
hash = "\"#{new_resource.source.gsub(/\s/, "")}\""
code_script = ""
guard_script = ""
if ::File.extname(new_resource.output_path) == ".pfx"
if cert_obj != false && cert_obj != "Certificate Not Found"
if !!out == out
@local_pfx_path = ""
pfx_file = file_name + ".pfx"
f = ::File.open(new_resource.output_path, "w")
::File.file?(source)
result == ( "Certificate Not Found" || "Certificate Has Expired" ) ? false : true
$cert = Get-ChildItem -path cert:\\#{store_location}\\#{store_name} -Recurse | Where { $_.Thumbprint -eq "#{thumbprint.upcase}" }
cert_script << " \"#{file}\""
if ::File.extname(file.downcase) == ".pfx"
cert_script << ", \"#{new_resource.pfx_password}\""
cert_script << "\n"
$hash = #{hash}
Test-Path "Cert:\\#{ps_cert_location}\\#{new_resource.store_name}\\$hash"
set_acl_script = <<-EOH
if ($storeCert -eq $null) { throw 'no key exists.' }
if ($keyname -eq $null) { throw 'no private key exists.' }
set_acl_script << "$uname='#{name}'; icacls $fullpath /grant $uname`:RX\n"
state = uri.is_a?(URI::HTTP) && !uri.host.nil? ? true : false
::File.open(local_path, "wb") do |file|
when ".pfx"
when ".p7b"
out_file = ::File.new(output_path, "w+")
when ".pem"
when ".der"
when ".cer"
when ".crt"
temp = result == ( "Certificate Not Found" || "Certificate Has Expired" ) ? false : true
if temp == true
when ".key"
Chef::Log.info("Supported certificate format .pem, .der, .cer, .crt, and .p7b")
coerce: proc { |x| x.tr("/", "\\") }, # make sure we have windows paths for the registry
data = "\"#{new_resource.path}\""
data << " #{new_resource.args}" if new_resource.args
data: "",
coerce: proc { |p| Array(p) },
s_val = new_resource.success ? "enable" : "disable"
f_val = new_resource.failure ? "enable" : "disable"
converge_by "Update Audit Policy for \"#{subcategory}\" to Success:#{s_val} and Failure:#{f_val}" do
cmd = "auditpol /set "
cmd += "/user:\"#{new_resource.include_user}\" /include " if new_resource.include_user
cmd += "/user:\"#{new_resource.exclude_user}\" /exclude " if new_resource.exclude_user
cmd += "/subcategory:\"#{subcategory}\" /success:#{s_val} /failure:#{f_val}"
if ($auditpol_config | Select-String "#{setting}") { return $true } else { return $false }
setting = option_setting ? "Enabled$" : "Disabled$"
regex: /.\../, # anything.anything
cmd << " -OUPath \"#{new_resource.ou_path}\"" if new_resource.ou_path
cmd << " -NewName \"#{new_resource.new_hostname}\"" if new_resource.new_hostname
coerce: proc { |m| m.end_with?(".conf") ? m : m + ".conf" },
default: lazy { |r| r.username == "*" ? "00_all_limits.conf" : "#{r.username}_limits.conf" }
source ::File.expand_path("support/ulimit.erb", __dir__)
coerce: proc { |n| n && Integer(n) rescue n }
(salt.nil? && password) ? password : nil
provides :user, os: "aix"
introduced: "18.0",
tz_shellout = shell_out("tzutil /g")
when "rhel", "amazon"
else # linux / macos
package suse? ? "timezone" : "tzdata"
only_if { ::File.executable?("/usr/sbin/tzdata-update") }
not_if { ::File.executable?("/usr/sbin/tzdata-update") }
@source = "#{::File.basename(name)}.erb"
@inline_helper_blocks = {}
default: {}
if block_given? && !module_name.nil?
content({ Unit: {
Service: {
Type: 'notify',
Install: {
} })
:mask, :unmask,
:start, :stop,
doc.section(sect, { option_sep: "=" }) do |section|
provides(:sysctl) { true }
coerce: proc { |v| coerce_value(v) },
v.join(" ")
v.to_s
file "#{new_resource.conf_dir}/99-chef-#{new_resource.key.tr("/", ".")}.conf" do
command "sysctl #{"-e " if new_resource.ignore_error}-p"
if ::File.exist?("#{new_resource.conf_dir}/99-chef-#{new_resource.key.tr("/", ".")}.conf")
converge_by "removing sysctl config at #{new_resource.conf_dir}/99-chef-#{new_resource.key.tr("/", ".")}.conf" do
shell_out!("sysctl #{"-e " if new_resource.ignore_error}-w \"#{key}=#{value}\"")
sysctl_lines = Array(new_resource.comment).map { |c| "# #{c.strip}" }
sysctl_lines << "#{new_resource.key} = #{new_resource.value}"
sysctl_lines.join("\n") + "\n"
val = shell_out!("sysctl -n -e #{key}").stdout.tr("\t", " ").strip
raise unless ::File.exist?("/etc/sysctl.d/99-chef-#{key.tr("/", ".")}.conf")
k, v = ::File.read("/etc/sysctl.d/99-chef-#{key.tr("/", ".")}.conf").match(/(.*) = (.*)/).captures
provides(:swap_file) { true }
shell_out!("mkswap -f #{new_resource.path}")
Chef::Log.debug("#{new_resource} fallocate size is #{size}")
command = "fallocate -l #{size} #{new_resource.path}"
command = "dd if=/dev/zero of=#{new_resource.path} bs=#{block_size} count=#{new_resource.size}"
Chef::Log.debug("#{new_resource} dd command is '#{command}'")
command = "df -PT #{parent_directory} | awk 'NR==2 {print $2}'"
fstab = "/etc/fstab"
if contents.any? { |line| line.strip == addition }
Chef::Log.info("#{new_resource} adding entry to #{fstab} for #{new_resource.path}")
contents << "#{addition}\n"
::File.open(fstab, "w") { |f| f.write(contents.join("")) }
provides(:sudo) { true }
coerce: proc { |x| x.is_a?(Array) ? x : x.split(/\s*,\s*/) }
coerce: proc { |x| coerce_groups(x) }
groups = x.is_a?(Array) ? x : x.split(/\s*,\s*/)
source ::File.expand_path("support/sudoer.erb", __dir__)
if ::File.exist?(path)
key 'node.example.com ssh-rsa ...'
key =
comment = key.split("\n").first || ""
keys.any? do |line|
type_map = {
coerce: proc { |x| x.respond_to?(:split) ? x.shellsplit : x }
level 's0'
range 's0'
coerce: proc { |r| Array(r).sort }
users = shell_out!("semanage user -l").stdout.split("\n")
current_user = users.grep(/^#{Regexp.escape(new_resource.user)}\s+/) do |u|
args = ""
args += " -L #{new_resource.level}" if new_resource.level
args += " -r #{new_resource.range}" if new_resource.range
args += " -R '#{new_resource.roles.join(" ")}'" unless new_resource.roles.to_a.empty?
source debian? ? ::File.expand_path("selinux/selinux_debian.erb", __dir__) : ::File.expand_path("selinux/selinux_default.erb", __dir__)
when "rhel", "fedora", "amazon"
regex: /^\d+$/,
equal_to: %w{tcp udp},
seinfo --portcon=#{new_resource.port} | grep 'portcon #{new_resource.protocol}' | \
shell_out!("semanage port -a -t '#{new_resource.secontext}' -p #{new_resource.protocol} #{new_resource.port}")
shell_out!("semanage port -m -t '#{new_resource.secontext}' -p #{new_resource.protocol} #{new_resource.port}")
path.concat(".#{type}") if type
shell_out!("semodule --list-modules").stdout.split("\n").map { |x| x.split(/\s/).first }
%w{fc if pp te}.each do |type|
shell_out!("semodule", "--install", selinux_module_filepath("pp"))
user 'test_u'
logins = shell_out!("semanage login -l").stdout.split("\n")
current_login = logins.grep(/^#{Regexp.escape(new_resource.login)}\s+/) do |l|
args += " -s #{new_resource.user}" if new_resource.user
selinux_fcontext '/var/www/moodle(/.*)?' do
file_type 'l'
default: "a",
equal_to: %w{a f d c b s l p},
file_hash = {
value 'on'
equal_to: %w{on off},
coerce: proc { |p| selinux_bool(p) },
cmd += " -P" if new_resource.persistent
cmd += " #{new_resource.boolean} #{new_resource.value}"
(selinux_disabled? && %i{enforcing permissive}.include?(action)) || ((selinux_enforcing? || selinux_permissive?) && action == :disabled)
use "scm"
coerce: proc { |v| v == false ? nil : v }, # coerce false to nil
default: "--no-auth-cache"
require_relative "../../resource"
environment 'PREFIX' => '/usr/local'
description: "A Hash of environment variables in the form of ({'ENV_VARIABLE' => 'VALUE'}).",
examples <<~'DOC'
data = {
rc = Chef::Util::FileEdit.new('/etc/hosts')
rc.search_file_replace_line(/^127\.0\.0\.1 localhost$/,
cmd = Mixlib::ShellOut.new("subscription-manager list --consumed | grep #{subscription}", env: { LANG: "en_US" })
!cmd.stdout.match(/Pool ID:\s+#{subscription}$/).nil?
serials = {}
pool = nil
cmd = Mixlib::ShellOut.new("subscription-manager list --consumed", env: { LANG: "en_US" })
key, value = line.split(/:\s+/, 2)
if key == "Pool ID"
elsif key == "Serial"
provides(:rhsm_repo) { true }
cmd = Mixlib::ShellOut.new("subscription-manager repos --list-enabled", env: { LANG: "en_US" })
repo == "*" || !cmd.stdout.match(/Repo ID:\s+#{repo}$/).nil?
coerce: proc { |x| Array(x) },
coerce: proc { |x| x.downcase },
nethttp: {
{ callbacks: {
description: <<~'DOCS'
headers({ "Cookie" => "user=some_user; pass=p@ssw0rd!" })
headers({ "Referer" => "#{header}" })
headers( "Authorization"=>"Basic #{ Base64.encode64("#{username}:#{password}").gsub("\n", "") }" )
introduced: "16.2",
introduced: "13.4",
introduced: "17.5",
if specified_user && ((specified_user.include? "\\") || (specified_user.include? "@")) && specified_domain
domain_and_user = user.split("\\")
domain_and_user = user.split("@")
if ( password || domain ) && user.nil?
{ domain: domain, user: user }
regex: /^\d{3,4}$/, default: lazy { 0644 unless Chef::Platform.windows? }
:name => "test",
:type => :binary,
{name: 'ProxyServer', data: "#{proxy.host}:#{proxy.port}"},
{name: 'ProxyOverride', type: :reg_string, data: <local>},
{name: '', type: :string, data: 'test'},
data: ''
v.all? do |value|
command '...'
not_if 'test -e ~/data/nodes.bak'
introduced: "17.6",
if output == "PSRepository" || output == "PackageSource"
if output == "PackageSource" || output == "PSRepository"
logger.warn("*****************************************")
cmd << "#{cmdlet_type}-PSRepository -Name '#{new_resource.source_name}'"
cmd << " -InstallationPolicy '#{install_policy}'"
cmd << " | Out-Null"
cmd << "#{cmdlet_type}-PackageSource -Name '#{new_resource.source_name}'"
cmd << " -NewName '#{new_resource.new_name}'" if new_resource.new_name
(Get-PSRepository -Name '#{source_name}') | Select @{n='source_name';e={$_.Name}}, @{n='source_location';e={$_.SourceLocation}},
@{n='trusted';e={$_.Trusted}}, @{n='provider_name';e={$_.PackageManagementProvider}}, @{n='publish_location';e={$_.PublishLocation}},
@{n='provider_name';e={$_.ProviderName}}, @{n='trusted';e={$_.IsTrusted}}, @{n='publish_location';e={$_.PublishLocation}}
file_type_cmd = shell_out "/usr/bin/file", "--brief", "--mime-encoding", "--preserve-date", new_resource.path
file_owner_cmd = shell_out("/usr/bin/stat", "-f", "%Su", new_resource.path)
file_group_cmd = shell_out("/usr/bin/stat", "-f", "%Sg", new_resource.path)
content({}.to_plist)
converge_by "add entry \"#{new_resource.entry}\" to #{plist_file_name}" do
value.to_i == 1
sep = " "
when "add"
sep = ":"
value.map { |k, v| "#{k} #{type_to_commandline_string(v)}" }
when "set"
value.map { |k, v| "#{k} #{v}" }
plutil_output = shell_out(PLUTIL_EXECUTABLE, "-extract", entry, "xml1", "-o", "-", path).stdout.chomp
coerce: proc { |x| x.is_a?(String) ? x.shellsplit : x }
profile_hash = {
def path(path = nil)
@path ||= path
name_or_identifier.end_with?(".mobileconfig") || !/^\w+(?:(\.| )\w+)+$/.match(name_or_identifier)
if action == :remove
::File.join(
path = ::File.join( get_cache_dir, "#{cookbook_file}.remote")
).to_s
logger.trace("cmd: #{cmd.join(" ")}")
shell_out!(*cmd)
so = shell_out( "/usr/bin/profiles", "-P", "-o", "stdout-xml" )
equal_to: %w{rsa ec}, default: "ec",
@key_file ||=
path + "/" + filename + ".key"
crl_info = {}
revoke_info = {}
org 'Foo Bar'
description: "Hash of X509 Extensions entries, in format `{ 'keyUsage' => { 'values' => %w( keyEncipherment digitalSignature), 'critical' => true } }`.",
equal_to: %w{rsa ec},
ca_info = {}
default: lazy { "des3" },
proc { |v| OpenSSL::Cipher.ciphers.include?(v) },
provides(:ohai_hint) { true }
path << ".json" unless path.end_with?(".json")
return "" if content.nil? || content.empty?
home '/dev/null'
ohai = ::Ohai::System.new
default: lazy { { remount: false } },
coerce: proc { |arg| arg.is_a?(String) ? arg.to_sym : arg },
equal_to: RUBY_PLATFORM.match?(/solaris/i) ? %i{ device } : %i{ device label uuid }
default: "-"
@fstype = nil
(options.is_a?(String) ? options.split(",") : options).collect(&:strip)
mdadm --create /dev/md0 --level=0 --raid-devices=10 /dev/s01.../dev/s10
mdadm '/dev/md0' do
(again, where /dev/s01 .. /dev/s10 represents devices /dev/s01, /dev/s02, /dev/s03, and so on).
mdadm '/dev/sd0' do
default: "0.90",
description: "The RAID5 parity algorithm. Possible values: `left-asymmetric` (or `la`), `left-symmetric` (or ls), `right-asymmetric` (or `ra`), or `right-symmetric` (or `rs`)."
exists = (mdadm.status == 0)
command << " --chunk=#{new_resource.chunk}" unless new_resource.level == 1
command << " --metadata=#{new_resource.metadata}"
command << " --raid-devices #{new_resource.devices.length} #{new_resource.devices.join(" ")}"
command = "yes | mdadm --assemble #{new_resource.raid_device} #{new_resource.devices.join(" ")}"
command = "yes | mdadm --stop #{new_resource.raid_device}"
@loaded_lwrps ||= {}
default: {},
coerce: proc { |h|
if h.respond_to?(:keys)
def lc_all(arg = nil)
a.assertion { which("locale-gen") }
shell_out!("locale-gen #{unavailable_locales.join(" ")}", timeout: 1800)
available = shell_out!("locale -a").stdout.split("\n")
@new_content ||= begin
content = {}
content.sort.map { |t| t.join("=") }.join("\n") + "\n"
introduced: "12.19",
coerce: proc { |type|
array = if type.is_a?(Array)
failed_keys = entry.keys.reject { |k| allowed_keys.include?(k) }.join(", ")
failed_values = entry.values.reject { |val| val.is_a?(Integer) }.join(", ")
if array.size == 1
default: "daemon", coerce: proc { |type|
type = type ? type.downcase : "daemon"
introduced: "12.14",
introduced: "15.1",
callbacks: { "should be a Integer between -20 and 19" => proc { |v| v >= -20 && v <= 19 } }
@interpreter = "ksh"
/^#{new_resource.modname}/.match?(::File.read("/proc/modules"))
re = Regexp.new("\\d{4}-\\d{2}-\\d{2}$").freeze
if re.match?(e)
Date.valid_date?(*e.split("-").map(&:to_i))
e.nil?
control_hash = {}
if %r{(/|C:\\).*(.yaml|.yml)}i.match?(file_name)
if hash == false || hash.nil? || hash == ""
inspec_waiver 'openssh::.*' do
my_hash = { "ssh-01" => {
inspec_input 'openssh::.*' do
source( { ssh_custom_path: '/whatever2' })
introduced: "14.4",
introduced: "16.7",
allowed_actions :get, :patch, :put, :post, :delete, :head, :options
text = IO.read(path).split("\n")
text.reject! { |s| s =~ regex }
content text.join("\n") + "\n"
not_if { IO.read(path).split("\n").include?(string) }
return ""
newline << " #{new_resource.hostname}"
newline << " #{new_resource.aliases.join(" ")}" if new_resource.aliases && !new_resource.aliases.empty?
when ::File.exist?("/usr/bin/hostnamectl") && !docker?
when ::File.exist?("/etc/hostname")
when ::File.exist?("/etc/conf.d/hostname")
when ::File.exist?("/etc/rc.conf")
when ::File.exist?("/usr/sbin/svccfg") # solaris 5.11
shell_out!("#{new_resource.homebrew_path} tap #{new_resource.tap_name} #{new_resource.url || ""}",
tap_dir = name.gsub("/", "/homebrew-")
return true if spec == "*"
return spec >= min && spec <= max
spec.split(%r{\/|-|,}).each do |x|
next if x == "*"
return false unless /^\d+$/.match?(x)
x = x.to_i
return false unless x >= min && x <= max
spec = spec.to_s
spec == "*" ||
validate_numeric(spec, 0, 7) ||
http: {
property :config, Mash, required: true, coerce: proc { |m| m.is_a?(Hash) ? Mash.new(m) : m },
@wmi = ::WIN32OLE.connect("winmgmts://")
Chef::Log.debug("service #{service_name} binds: #{bind}")
http_uri = "http://#{remote_sup_http}"
headers = {}
origin, name, _version, _release = svc_name.split("/")
svcs.find do |s|
options << "--force"
command "hab svc load #{new_resource.service_name} #{options.join(" ")}"
execute "hab svc stop #{new_resource.service_name} #{svc_options.join(" ")}"
opts.push(*new_resource.bind.map { |b| "--bind #{b}" }) if new_resource.bind
opts << "--binding-mode #{new_resource.binding_mode}"
opts << "--url #{new_resource.bldr_url}" if new_resource.bldr_url
hab_version '1.5.50'
if ::File.exist?(hab_path)
not_if { ::Dir.exist?("c:\\habitat") }
user "hab" do
gid "hab"
}.each_with_object({}) do |(var, property), env|
cmd << " -v #{new_resource.hab_version} " if new_resource.hab_version
sc = {}
not_if { ::Win32::Service.exists?("Habitat") }
ExecStop: "/bin/hab sup term",
}.compact,
listen_http '0.0.0.0:9999'
sup_version '1.5.50'
sup_version '1.5.86'
not_if { ::File.exist?("/bin/hab") }
not_if { ::File.exist?("/usr/bin/hab") }
not_if { ::File.exist?("c:/habitat/hab.exe") }
not_if { ::File.exist?("c:/ProgramData/Habitat/hab.exe") }
only_if { ::Dir.exist?("C:/hab") }
source ::File.expand_path("../support/sup.toml.erb", __dir__)
only_if { ::Dir.exist?("C:/hab/sup/default/config") }
only_if { ::Dir.exist?("/hab") }
only_if { ::Dir.exist?("/hab/sup/default/config") }
peer_list << if !/.*:.*/.match?(p)
p + ":9632"
opts << "--org #{new_resource.org}" unless new_resource.org == "default"
opts.push(*new_resource.peer.map { |b| "--peer #{b}" }) if new_resource.peer
opts << "--ring #{new_resource.ring}" if new_resource.ring
opts.join(" ")
version '3.2.3'
coerce: proc { |arg| arg.is_a?(String) ? arg.split(/\s*,\s*/) : arg },
introduced: "14.9",
source '/tmp/loofah-2.7.0.gem'
@provider = if /^ports$/i.match?(source.to_s)
def verify(path, opts = {})
require_relative "../../../mixin/which"
temp = "#{dir}/#{::File.basename(@parent_resource.path)}"
@systemd_analyze_cmd ||= "#{systemd_analyze_path} verify %{path}"
c = descendants.find { |d| d.provides?(name) }
if c.nil?
if @command.include?("%{file}")
command = @command % { path: path }
regex: /^\h{64}$/,
coerce: lambda { |s| s.is_a?(String) ? s.downcase : s },
def verify(command = nil, opts = {}, &block)
environment ({'HOME' => '/home/my_home'})
command 'echo > /proc/.../ipv4/ip_forward'
-j test_rule"
pip_binary = '/usr/bin/pip'
pip_binary = '/usr/local/bin/pip'
not_if { ::File.exist?(pip_binary) }
</div>
search("users", "*:*") do |u|
%w{ conf ovpn }.each do |ext|
(**bash**, **csh**, **perl**, **python**, or **ruby**). For example:
bash 'foo' do
environment ({'HOME' => '/home/vagrant', 'USER' => 'vagrant'})
input File.read(__FILE__)
introduced: "14.2",
introduced: "12.21",
introduced: "17.0",
if specified_user.is_a?(String) && ((specified_user.include? "\\") || (specified_user.include? "@")) && specified_domain
:cwd,
:user,
@imports = {}
def code(arg = nil)
:code,
if arg && code
if args.length == 0
obj_text = if obj.respond_to?(:to_text)
@properties.reduce({}) do |memo, (k, v)|
introduced: "12.6",
which("dnf")
equal_to: %w{app pkg mpkg},
attach_cmd = new_resource.accept_eula ? "yes | " : ""
shell_out!(attach_cmd, env: { "PAGER" => "true" })
when "app"
when "mpkg", "pkg"
@dmg_file ||= if new_resource.file.nil?
/image-path.*#{dmg_file}/.match?(shell_out!("/usr/bin/hdiutil info #{passphrase_cmd}").stdout)
@interpreter = "csh"
cron_d 'noop' do
hour '5'
minute '0'
--thread-max'"
only_if { ::File.exist?('/home/jboss') }
hour '8'
hour '20'
day '*'
month '11'
weekday '1-5'
file "/etc/cron.d/#{sanitized_name}" do
new_resource.cron_name.tr(".", "-")
source ::File.expand_path("../support/cron.d.erb", __dir__)
-v '/usr/local/bin/tomcat-stat --thread-max'"
hour '0'
}.join(' ')
state_attrs :minute, :hour, :day, :month, :weekday, :user
sunday: "0", monday: "1", tuesday: "2", wednesday: "3", thursday: "4", friday: "5", saturday: "6",
sun: "0", mon: "1", tue: "2", wed: "3", thu: "4", fri: "5", sat: "6"
description: "The minute at which the cron entry should run (`0 - 59`).",
default: "*", callbacks: {
description: "The hour at which the cron entry is to run (`0 - 23`).",
description: "The day of month at which the cron entry should run (`1 - 31`).",
description: "The month in the year on which a cron entry is to run (`1 - 12`, `jan-dec`, or `*`).",
description: "The day of the week on which this entry is to run (`0-7`, `mon-sun`, `monday-sunday`, or `*`), where Sunday is both `0` and `7`.",
default: "*", coerce: proc { |day| weekday_in_crontab(day) },
description: "A Hash of timeouts in the form of `({'OPTION' => 'VALUE'})`. Accepted valid options are:
- `preserve-status` (BOOL, default: 'false'),
- `foreground` (BOOL, default: 'false'),
- `kill-after` (in seconds),
- `signal` (a name like 'HUP' or a number)",
introduced: "15.7",
if h.is_a?(Hash)
elsif h.is_a?(Integer) || h.is_a?(String)
{ "duration" => h }
default: lazy { ::File.basename(name) }
@block = nil
Chef::Log.warn "Command '#{@command}' timed out"
@block.call.tap do |rv|
if rv.is_a?(String) && !rv.empty?
(@parent_resource.sensitive ? "" : " If so use '#{@positivity} #{sanitized_rv}' in your code."))
cmd_or_block = @command ? "command `#{@command}`" : "ruby block"
shell_out!(choco_cmd("add"))
if action == "add"
cmd << " --source=\"#{new_resource.source}\" --priority=#{new_resource.priority}"
cmd << " --user=\"#{new_resource.username}\"" if new_resource.username
cmd << " --password=\"#{new_resource.password}\"" if new_resource.password
cmd << " --cert=\"#{new_resource.cert}\"" if new_resource.cert
introduced: "15.3",
value 'C:\\temp\\choco'
shell_out!(choco_cmd("set"))
shell_out!(choco_cmd("unset"))
cmd << " --value #{new_resource.value}" if action == "set"
raw_data({ 'auth' => 'baz' })
search '*:*'
property :search, String, default: "*:*", desired_state: false,
Chef::Log.debug("#{new_resource.id} search query: '#{new_resource.search}'")
Chef::Log.debug("#{new_resource.id} clients: '#{new_resource.clients}'")
Chef::Log.debug("#{new_resource.id} admins (users): '#{new_resource.admins}'")
coerce: proc { |s| Integer(s) },
Chef::Log.info('Cookbooks and versions run: #{cookbooks.map {|x| x.name.to_s + ' ' + x.version }}')
irb(main):002:0> require 'json' => true
irb(main):003:0> require 'chef' => true
_, klass = get_class(class_name)
ancestors = class_full_name.split("::")
path << ".pem" unless path.end_with?(".pem")
introduced: "16.5",
coerce: proc { |x| Integer(x) },
callbacks: { "should be a positive Integer" => proc { |v| v > 0 } }
cmd << " -c #{::File.join(new_resource.config_directory, "client.rb")}"
unit = {
callbacks: { "should be a positive number" => proc { |v| v > 0 } },
default: lazy { frequency == "minute" ? 30 : 1 },
callbacks: { "should be a positive number" => proc { |v| v >= 0 } },
default: lazy { |r| "#{r.config_directory}/log" },
cmd << " -L #{::File.join(new_resource.log_directory, new_resource.log_file_name)}"
cmd << " #{new_resource.daemon_options.join(" ")}" if new_resource.daemon_options.any?
default: "/var/root"
callbacks: { "should be an Integer between -20 and 19" => proc { |v| v >= -20 && v <= 19 } }
cmd << "/bin/sleep #{splay_sleep_time(new_resource.splay)};"
cmd << " #{new_resource.chef_binary_path}"
hour '0,12'
description: "The minute at which #{ChefUtils::Dist::Infra::PRODUCT} is to run (0 - 59) or a cron pattern such as '0,30'.",
default: "0,30", callbacks: {
description: "The hour at which #{ChefUtils::Dist::Infra::PRODUCT} is to run (0 - 23) or a cron pattern such as '0,12'.",
description: "The day of month at which #{ChefUtils::Dist::Infra::PRODUCT} is to run (1 - 31) or a cron pattern such as '1,7,14,21,28'.",
description: "The month in the year on which #{ChefUtils::Dist::Infra::PRODUCT} is to run (1 - 12, jan-dec, or *).",
description: "The day of the week on which #{ChefUtils::Dist::Infra::PRODUCT} is to run (0-7, mon-sun, or *), where Sunday is both 0 and 7.",
default: lazy { platform?("mac_os_x") ? "/Library/Logs/#{ChefUtils::Dist::Infra::DIR_SUFFIX.capitalize}" : "/var/log/#{ChefUtils::Dist::Infra::DIR_SUFFIX}" },
cmd << "/bin/sleep #{splay_sleep_time(new_resource.splay)}; "
cmd << "#{which("nice")} -n #{new_resource.nice} " if new_resource.nice
cmd << "#{new_resource.chef_binary_path} "
cmd << "-c #{::File.join(new_resource.config_directory, "client.rb")} "
cmd << " || echo \"#{ChefUtils::Dist::Infra::PRODUCT} execution failed\"" if new_resource.mailto
linux? ? :cron_d : :cron
if prop_val.is_a?(String) && prop_val.start_with?(":")
default_description: "`/etc/chef/` on *nix-like systems and `C:\\chef\\` on Windows"
default: lazy { node.name },
coerce: proc { |x| string_to_symbol(x) },
p.is_a?(Symbol) ? %i{win_evt syslog}.include?(p) : true
coerce: proc { |x| x.is_a?(Array) ? x.join(",") : x },
coerce: proc { |x| x.map { |v| string_to_symbol(v).capitalize } },
mode dir_path == ::File.dirname(new_resource.log_location.to_s) ? "0755" : "0750"
source ::File.expand_path("support/client.erb", __dir__)
introduced: "15.5",
!shell_out("xcode-select", "-p").error?
cwd '/tmp'
find ./ -name "*.tar.Z" -mtime +180 -exec rm -f {} \\;
tar xzf #{src_filename} -C #{extract_path}
mv #{extract_path}/*/* #{extract_path}/
not_if { ::File.exist?(extract_path) }
not_if { ::File.exist?(install_path) }
(cd Python-#{version} && ./configure #{configure_options})
(cd Python-#{version} && make && make install)
mode '700'
coerce: proc { |f| ::File.expand_path(f) },
Chef::Log.trace("#{pathname} mtime is #{::File.mtime(pathname)} and archive is #{e.mtime}")
converge_by("extract #{src} to #{dest}") do
provides(:apt_update) { true }
::File.exist?("#{STAMP_DIR}/update-success-stamp") &&
content "APT::Update::Post-Invoke-Success {\"touch #{STAMP_DIR}/update-success-stamp 2>/dev/null || true\";};\n"
def is_key_id?(id)
so = shell_out(*cmd)
so.stdout.split(/\n/).map do |t|
if t.match(/^pub:/)
f = t.split(":")
f.slice(0, 6).join(":")
logger.debug "key #{key} #{valid ? "is valid" : "is not valid"}"
if uri.start_with?("http")
tmp_dir = Dir.mktmpdir(".gpg")
verify "gpg --homedir #{tmp_dir} %{path}"
not_if { no_new_keys?(cached_keyfile) }
cmd = "apt-key adv --no-tty --recv"
cmd << " --keyserver "
cmd << if keyserver.start_with?("hkp://")
cmd << " #{key}"
url = "https://launchpad.net/api/1.0/~#{owner}/+archive/#{repo}"
key_id = Chef::HTTP::Simple.new(url).get("signing_key_fingerprint").delete('"')
def is_ppa_url?(url)
url.start_with?("ppa:")
repo ||= "ppa"
uri = make_ppa_url(uri) if is_ppa_url?(uri)
options << "arch=#{arch}" if arch
if is_key_id?(k) && !has_cookbook_file?(k)
name.tr(".", "_").gsub("*", "wildcard")
default: lazy { |n| "/usr/bin/#{n.link_name}" },
coerce: proc { |n| n.to_i },
escaped_path = Regexp.new(Regexp.escape("#{new_resource.path} - priority ") + "(.*)")
map = {}
send(function, resource_data) || {}
function = "#{property}_to_json".to_sym
identity_map = {}
hsh.each do |_, v|
deep_compact!(v) if v.is_a? Hash
end.reject! { |_, v| v.nil? || (v.respond_to?(:empty?) && v.empty?) }
hsh1.merge!(hsh2) { |_, v1, v2| deep_merge!(v1, v2) }
arr = path.split(".")
ret = {}
if arr.count == 1
property :name, String, coerce: proc { |v| v.is_a?(Array) ? v.join(", ") : v.to_s }, desired_state: false, required: true
@before = nil
arg = Array(arg).map(&:to_sym)
{ action: action },
{ action: { kind_of: Symbol, equal_to: allowed_actions } }
@action = arg
def only_if(command = nil, opts = {}, &block)
def not_if(command = nil, opts = {}, &block)
state = {}
result = {}
unless iv == :@source_line || iv == :@action || iv == :@not_if || iv == :@only_if
logger.info("Processing #{self} action #{action} (#{defined_at})")
@elapsed_time = 0 if @elapsed_time < 0
text = "# Declared in #{@source_line}\n\n"
text << "#{resource_name}(\"#{name}\") do\n"
all_props = {}
iv = ivar.to_s.sub(/^@/, "")
elsif (value = instance_variable_get(ivar)) && !(value.respond_to?(:empty?) && value.empty?)
text << "end\n"
ivars.inject("<#{self}") do |str, ivar|
str << " #{ivar}: #{instance_variable_get(ivar).inspect}"
end << ">"
def as_json(*a)
key = iv.to_s.sub(/^@/, "").to_sym
resource.instance_variable_set("@#{k}".to_sym, v)
klass = if arg.is_a?(String) || arg.is_a?(Symbol)
@updated ||= true_or_false
@allowed_actions ||=
@action_class ||=
if partial =~ /^core::(.*)/
partial = $1
basename = ::File.basename(partial, ".rb")
class_eval IO.read(::File.expand_path("resource/#{dirname}/_#{basename}.rb", __dir__))
when /(.+?)::(.+)/
when /^::(.+)/
unless res.is_a?(Hash) && res.key?("resources")
@dll = Pwsh.dll
so = shell_out!("gpg --version")
so = shell_out("/bin/rpm -qa gpg-pubkey*")
logger.trace("GPG key at #{key_path} is known by rpm? #{status ? "true" : "false"}")
if gpg_version >= Gem::Version.new("2.2") # SLES 15+
so = shell_out!("gpg --import-options import-show --dry-run --import --with-colons #{key_path}")
so = shell_out!("gpg --with-fingerprint #{key_path}")
logger.trace("GPG short key ID of key at #{key_path} is #{short_key_id}")
source ::File.expand_path("support/yum_repo.erb", __dir__)
raise Chef::Exceptions::Override, "You must override #{__method__} in #{self}"
logger.trace("#{new_resource} does not exist (#{e.message})")
if !new_val.nil? && new_val != cur_val
@change_desc << "change #{user_attrib} from #{cur_val} to #{new_val}"
shell_out!("passwd", "-l", new_resource.username)
shell_out!("passwd", "-u", new_resource.username)
opts << "-c" << new_resource.comment if should_set?(:comment)
opts << "-g" << new_resource.gid if should_set?(:gid)
opts << "-s" << new_resource.shell if should_set?(:shell)
opts << "-u" << new_resource.uid if should_set?(:uid)
opts << "-d" << new_resource.home if updating_home?
opts << "-o" if new_resource.non_unique
opts << "-m"
opts << "-r" if new_resource.manage_home
opts << "-f" if new_resource.force
opts << "-m" if new_resource.manage_home
buffer = Tempfile.new("shadow", "/etc")
user = entry.split(":").first
mode = s.mode & 0o7777
fields = entry.split(":")
fields.join(":")
(Time.now.to_i / 86400).floor
shell_out!("pw", "useradd", set_options)
shell_out!("pw", "usermod", set_options)
require_relative "../../mixin/shell_out"
require_relative "../../mixin/which"
admin_group_xml = run_dscl("read", "/Groups/admin")
user_xml = run_dscl("read", "/Users/#{new_resource.username}")
return nil if user_xml.nil? || user_xml == ""
shadow_xml_plist = shell_out("plutil", "-convert", "xml1", "-o", "-", "-", input: shadow_binary_plist).stdout
if prop_is_set?(:gid)
desc = "Update #{attr}"
desc << " from #{current_resource.send(attr)} to #{new_resource.send(attr)}"
@change_desc << desc
%i{uid home}.each do |prop|
cmd << new_resource.manage_home ? "-secure" : "-keepHome"
if %i{admin_username admin_password}.all? { |p| prop_is_set?(p) }
uid = nil
users_uids = run_dscl("list", "/Users", "uid")
if users_uids&.match?(Regexp.new("#{Regexp.escape(next_uid_guess.to_s)}\n"))
next_uid_guess += 1
(current_resource.hidden ? 1 : 0) != hidden_value.to_i
if prop_is_set?(:salt)
return true if %i{salt iterations}.any? { |prop| diverged?(prop) }
string.unpack("a2" * (string.size / 2)).collect { |i| i.hex.chr }.join
shell_out("plutil", "-convert", "binary1", "-o", "-", "-",
::File.open(import_file, "w+", 0600) do |f|
run_dscl("create", "/Users/#{new_resource.username}", "Password", "********")
timeout = Time.now + 5
return "" if ( args.first =~ /^delete/ ) && ( result.exitstatus != 0 )
!v.nil? && v != ""
if !new_val.nil? && new_val.to_s != cur_val.to_s
if manage_u.exitstatus == 12 && manage_u.stderr !~ /exists/
shell_out!("usermod", "-L", new_resource.username)
shell_out!("usermod", "-U", new_resource.username)
opts << "-e" << new_resource.expire_date if prop_is_set?(:expire_date)
opts << "-f" << new_resource.inactive if prop_is_set?(:inactive)
opts << "-p" << new_resource.password if should_set?(:password)
opts << "-r" if new_resource.system
@locked = nil
status_line = passwd_s.stdout.split(" ")
provides :user, os: "darwin", platform_version: "<= 10.13"
a.assertion { ::File.exist?("/usr/bin/dscl") }
a.assertion { ::File.exist?("/usr/bin/plutil") }
if new_resource.password && dscl_get(user_info, :password) == "********"
run_dscl("create", "/Users/#{new_resource.username}")
users_uids = run_dscl("list", "/Users", "uid").split("\n")
uid_map = users_uids.each_with_object({}) do |tuid, tmap|
elsif !new_resource.gid.to_s.match(/^\d+$/)
possible_gid = run_dscl("read", "/Groups/#{new_resource.gid}", "PrimaryGroupID").split(" ").last
unless %r{^/}.match?(new_resource.home)
shell_out!("/usr/sbin/createhomedir", "-c", "-u", (new_resource.username).to_s)
run_dscl("create", "/Users/#{new_resource.username}", "UserShell", "/usr/bin/false")
shadow_info = {}
salt = nil
pbkdf_info = {}
run_dscl("list", "/Groups").each_line do |group|
run_dscl("delete", "/Users/#{new_resource.username}")
diverged?(:password) || diverged?(:salt) || diverged?(:iterations)
membership_info = ""
membership_info = run_dscl("read", "/Groups/#{group_name}")
uid: "uid",
gid: "gid",
home: "home",
shell: "shell",
user_plist_info = run_plutil("convert", "xml1", "-o", "-", user_plist_file)
result.stdout.encode("utf-8", "binary", undef: :replace, invalid: :replace, replace: "?")
shell_out("plutil", "-convert", "xml1", "-o", "-", "-", input: binary_plist_string).stdout
opts << "-g" << "system" if new_resource.system
lock_info = shell_out!("lsuser", "-a", "account_locked", new_resource.username)
status = /\S+\s+account_locked=(\S+)/.match(lock_info.stdout)
@locked =
command = "echo '#{new_resource.username}:#{new_resource.password}' | chpasswd -c -e"
if new_resource.gid.is_a?(String) && new_resource.gid.to_i == 0
Time.at(@shadow_info.sp_expire * 60 * 60 * 24).strftime("%Y-%m-%d")
a.assertion { !supports_ruby_shadow? || @shadow_lib_ok }
a.assertion { (!new_resource.expire_date && !new_resource.inactive) || linux? }
logger.info("#{new_resource} altered, #{change_desc.join(", ")}")
logger.info("#{new_resource} managed: #{change_desc.join(", ")}")
logger.info("#{new_resource} modified: #{change_desc.join(", ")}")
obj.map { |value| visitor.call(value) }
s = shell_out(*systemctl_cmd, "show", "-p", "UnitFileState", "-p", "ActiveState", new_resource.unit_name, **systemctl_opts)
status = {}
k, v = line.strip.split("=")
@systemctl_args ||= new_resource.user ? "--user" : "--system"
@systemctl_opts ||=
if ::File.exist?(::File.join(new_resource.destination, ".svn"))
c = scm :export, *args
@revision_int ||= if /^\d+$/.match?(new_resource.revision)
command = scm(:info)
def run_options(run_opts = {})
repo_attrs = svn_info.lines.inject({}) do |attrs, line|
property, value = $1, $2
result << "--password #{new_resource.svn_password} "
binary = "\"#{binary}\"" if /\s/.match?(binary)
(ChefUtils.windows? ? "svn.exe" : "svn")
require_relative "../../win32/error"
new_config = {
}.reject { |k, v| v.nil? || v.length == 0 }
username.sub(/^\.?\\+/, "")
config = {}
when "all"
require_relative "../../util/file_edit"
@job << " #{key}=#{value}"
@upstart_job_dir = "/etc/init"
@upstart_conf_suffix = ".conf"
if ::File.exist?("#{@upstart_job_dir}/#{@new_resource.service_name}#{@upstart_conf_suffix}")
::File.open("#{@upstart_job_dir}/#{@new_resource.service_name}#{@upstart_conf_suffix}", "r") do |file|
when /^start on/
logger.trace("#{@new_resource} enabled: #{line.chomp}")
when /^#start on/
logger.trace("#{@new_resource} disabled: #{line.chomp}")
shell_out!("/sbin/start #{@job}", default_env: false)
shell_out!("/sbin/stop #{@job}", default_env: false)
shell_out!("/sbin/reload #{@job}", default_env: false)
conf.search_file_replace(/^#start on/, "start on")
conf.search_file_replace(/^start on/, "#start on")
command = "/sbin/status #{@job}"
s = shell_out!(systemctl_path, args, "show", "-p", "UnitFileState", "-p", "ActiveState", new_resource.service_name, **options)
options = {
args = "--user"
args = "--system"
@status_command = "/bin/svcs"
key, value = line.strip.split(/\s+/, 2)
(!ps_cmd.nil? && !ps_cmd.empty?)
if ::File.exist?("/sbin/chkconfig")
index = level.split(":").first
status = level.split(":").last
(run_levels.nil? || run_levels.empty?) ? "" : "--level #{run_levels.join("")} "
@init_command = ::File.exist?(rcd_script_path) ? rcd_script_path : nil
update_rcl rc_conf_local + "\n" + "#{builtin_service_enable_variable_name}=\"\"\n"
old_services_list = rc_conf_local.match(/^pkg_scripts="(.*)"/)
if /^pkg_scripts="(.*)"/.match?(rc_conf_local)
new_rcl = rc_conf_local.sub(/^pkg_scripts="(.*)"/, "pkg_scripts=\"#{new_services_list.join(" ")}\"")
new_rcl = rc_conf_local + "\n" + "pkg_scripts=\"#{new_services_list.join(" ")}\"\n"
update_rcl rc_conf_local + "\n" + "#{builtin_service_enable_variable_name}=\"NO\"\n"
old_list = rc_conf_local.match(/^pkg_scripts="(.*)"/)
update_rcl rc_conf_local.sub(/^pkg_scripts="(.*)"/, pkg_scripts = (new_list.join(" ")).to_s)
@bsevn ||= begin
if /^#{Regexp.escape(var_name)}=(.*)/.match?(rc_conf)
if m = rc_conf.match(/^#{Regexp.escape(var_name)}=(.*)/)
if m = rc_conf_local.match(/^#{Regexp.escape(var_name)}=(.*)/)
if m = rc_conf_local.match(/^pkg_scripts="(.*)"/)
Chef::Util::PathHelper.home("Library", "LaunchAgents") { |p| locations << p }
@plist_size = 0
logger.trace("#{new_resource} console_user: '#{@console_user}'")
@base_user_cmd = "su -l #{@console_user} -c"
logger.trace("#{new_resource} base_user_cmd: '#{@base_user_cmd}'")
logger.trace("#{new_resource} Plist: '#{@plist}' service_label: '#{@service_label}'")
a.assertion { @plist_size < 2 }
a.assertion { ::File.exist?(@plist.to_s) }
a.assertion { !@service_label.to_s.empty? }
a.assertion { @plist_size > 0 }
session = @session_type ? "-S #{@session_type} " : ""
cmd = "/bin/launchctl load -w " + session + @plist
cmd = "/bin/launchctl unload -w " + @plist
shell_out("#{@base_user_cmd} '#{cmd}'", default_env: false)
cmd = "/bin/launchctl list #{@service_label}"
when /\s+\"pid\"\s+=\s+(\d+).*/
pid = $1
logger.trace("Current PID for #{@service_label} is #{pid}")
plist_xml = shell_out!(
edir = ::File.expand_path(dir)
if Dir.glob("/etc/rc*/**/S*#{service_name}").empty?
shell_out!("/sbin/insserv -r -f #{new_resource.service_name}")
shell_out!("/sbin/insserv -d -f #{new_resource.service_name}")
@init_command = "/etc/init.d/#{@new_resource.service_name}"
logger.trace "#{@new_resource} exists: #{exists}, readable: #{readable}"
a.assertion { ::File.exist?("/sbin/rc-update") }
if ::File.exist?("/etc/rc.d/#{new_resource.service_name}")
@init_command = "/etc/rc.d/#{new_resource.service_name}"
::File.open("/etc/rc.conf", "r", &:readlines)
::File.open("/etc/rc.conf", "w") do |file|
lines.each { |line| file.puts(line) }
if line =~ /^name="?(\w+)"?/
return $1 + "_enable"
if ::File.exist?("/etc/rc.conf") && var_name
when /^#{Regexp.escape(var_name)}="(\w+)"/
if $1.casecmp?("yes")
elsif $1.casecmp?("no") || $1.casecmp?("none")
lines.delete_if { |line| line =~ /^\#?\s*#{Regexp.escape(service_enable_variable_name)}=/ }
lines << "#{service_enable_variable_name}=\"#{value}\""
update_rcd = "/usr/sbin/update-rc.d"
a.assertion { ::File.exist? update_rcd }
a.assertion { @got_priority == true }
if line =~ /Default-(Start|Stop):\s+(\d.*)/
acc << $2.split(" ")
priority = {}
disable_or_enable = (action == :start ? "enable" : "disable")
@init_command = "/etc/rc.d/#{@new_resource.service_name}"
raise Chef::Exceptions::Service, "No DAEMONS found in /etc/rc.conf" unless /DAEMONS=\((.*)\)/m.match?(::File.read("/etc/rc.conf"))
if ::File.read("/etc/rc.conf") =~ /DAEMONS=\((.*)\)/m
content = ::File.read("/etc/rc.conf").gsub(/DAEMONS=\((.*)\)/m, "DAEMONS=(#{entries.join(" ")})")
::File.open("/etc/rc.conf", "w") do |f|
if daemon == "!#{new_resource.service_name}"
new_daemons << "!#{new_resource.service_name}"
@init_command = "/etc/rc.d/init.d/#{@new_resource.service_name}"
create_symlink(2, "S", "")
create_symlink(2, "K", "")
::File.symlink("/etc/rc.d/init.d/#{@new_resource.service_name}", "/etc/rc.d/rc#{run_level}.d/#{status}#{priority}#{@new_resource.service_name}")
if $1 == "S"
if is_enabled && files.length == 1
if service.split(" ").last == "active"
so = shell_out("lssrc -g #{@new_resource.service_name}")
method_name = "#{action}_command".to_sym
MASK = { "0.0.0.0" => "0",
return nil if hex_ip.length != hex_data.length || hex_ip.length != 8
ip = octets.join(".")
logger.trace("Invalid IP address data: hex=#{hex_ip}, ip=#{ip}")
route_file = ::File.open("/proc/net/route", "r")
_, destination, gateway, _, _, _, _, mask = line.split
running_ip = IPAddr.new("#{destination}/#{mask}")
converge_by("run #{command.join(" ")} to add route") do
converge_by("run #{command.join(" ")} to delete route ") do
if platform_family?("rhel", "amazon", "fedora")
conf = {}
dev = resource.device || "eth0"
conf.each_key do |k|
network_file = ::File.new(network_file_name, "w")
content = ""
content << "\n"
attr_accessor :event_data # e.g., a diff.
autoload :CGI, "cgi"
@uri = uri
host = port ? "#{hostname}:#{port}" : hostname
@sftp ||= Net::SFTP.start(host, user, password: pass)
path = uri.path.sub(%r{\A/}, "%2F") # re-encode the beginning slash because uri library decodes it.
directories = path.split(%r{/}, -1)
if filename.length == 0 || filename.end_with?( "/" )
Chef::Log.trace("#{new_resource} staging #{@source} to #{tempfile.path}")
::File.open(@source, "rb") do |remote_file|
@source_path ||= begin
require_relative "../../http/simple"
require_relative "../../digester"
opts = {}
if /gz$/.match?(uri.to_s)
@ftp ||= Net::FTP.new
ftp.voidcmd("CWD #{cwd}")
when "http", "https"
when "ftp"
require_relative "../../mixin/uris"
logger.warn("#{@new_resource} cannot be downloaded from #{source}: #{e}")
require_relative "../../file_cache"
require_relative "../../json_compat"
uri = uri.dup
@uri = uri.to_s
@etag, @mtime = nil, nil
@managed_files ||= Set.new
Dir.glob(::File.join(Chef::Util::PathHelper.escape_glob_dir(path), "**", "*"), ::File::FNM_DOTMATCH).sort!.reverse!.each do |file|
if dir == path
@name_hash = {}
%Q{"#{interpreter_path}"},
%Q{-File "#{script_file_path}"},
%Q{-Command ". '#{user_script_file.path}'"},
$global:lastcmdlet = $?
other.version == version && other.arch == arch
name == other.name && version == other.version && arch == other.arch
alias eql? ==
resolved_source_array.all? { |s| s && ::File.exist?(s) }
resolved_source_array.select { |s| s.nil? || !::File.exist?(s) }
shell_out!("rpm -qp --queryformat '%{NAME} %{EPOCH} %{VERSION} %{RELEASE} %{ARCH}\n' #{new_resource.source}").stdout.each_line do |line|
when /^(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)$/
return Version.new($1, "#{$2 == "(none)" ? "0" : $2}:#{$3}-#{$4}", $5)
status = shell_out!("zypper", "--non-interactive", "info", package_name)
when /^Version *: (.+) *$/
when /^Installed *: Yes.*$/ # http://rubular.com/r/9StcAMjOn6
when /^Status *: out-of-date \(version (.+) installed\) *$/
search_string = new_version.nil? ? package_name : "#{package_name}=#{new_version}"
so = shell_out!("zypper", "--non-interactive", "search", "-s", "--provides", "--match-exact", "--type=package", search_string)
next unless version == new_version || version.start_with?("#{new_version}-")
names.zip(versions).map do |n, v|
(v.nil? || v.empty?) ? n : "#{n}=#{v}"
@zypper_version ||=
shell_out!("zypper", global_options, gpg_checks, command, *options, "-y", names)
names.all? { |n| locked_packages.include? n }
names.all? { |n| !locked_packages.include? n }
@locked_packages ||=
locked = shell_out!("zypper", "locks")
line.split("|").shift(2).last.strip
require_relative "../../package"
lead = 0
epoch = $1.to_i
lead = $1.length + 1
epoch = 0
lead = 1
if /:?.*-(.*)$/.match(evr) # rubocop:disable Performance/RedundantMatch
release = $1
tail = evr.length - release.length - lead - 1
isalpha(x) || isdigit(x)
v = x.ord
(v >= 65 && v <= 90) || (v >= 97 && v <= 122)
v >= 48 && v <= 57
return 0 if x == y
if x.nil?
x = ""
if y.nil?
y = ""
y_pos = 0
y_seg_pos = 0
y_pos_max = y.length - 1
y_comp = nil
while x_pos <= x_pos_max && y_pos <= y_pos_max
x_pos += 1 # +1 over pos_max if end of string
if (x_pos == x_pos_max + 1) || (y_pos == y_pos_max + 1)
x_seg_pos = x_pos
y_seg_pos = y_pos
x_seg_is_num = true
x_seg_pos += 1
x_seg_is_num = false
if y_pos == y_seg_pos
return x_seg_is_num ? 1 : -1
x_pos += x_comp.length # +1 over pos_max if end of string
y_pos += y_comp.length
x_comp = x_comp.to_i
y_comp = y_comp.to_i
if x_comp > y_comp
if (x_pos == x_pos_max + 1) && (y_pos == y_pos_max + 1)
if (x_pos_max - x_pos) > (y_pos_max - y_pos)
-1
end # self
if args.size == 1
elsif args.size == 3
attr_reader :e, :v, :r
new(*args)
if @r.nil?
@v
x = self
if (x.e.nil? == false && x.e > 0) && y.e.nil?
elsif x.e.nil? && (y.e.nil? == false && y.e > 0)
elsif x.e.nil? == false && y.e.nil? == false
if x.e < y.e
elsif x.e > y.e
if partial && (x.v.nil? || y.v.nil?)
elsif x.v.nil? == false && y.v.nil?
elsif x.v.nil? && y.v.nil? == false
elsif x.v.nil? == false && y.v.nil? == false
return cmp if cmp != 0
if partial && (x.r.nil? || y.r.nil?)
elsif x.r.nil? == false && y.r.nil?
elsif x.r.nil? && y.r.nil? == false
elsif x.r.nil? == false && y.r.nil? == false
if args.size == 4
elsif args.size == 6
@version = RPMVersion.new(e, v, r)
attr_reader :n, :a, :version, :provides
return 0 if x.nevra == y.nevra
if x.n.nil? == false && y.n.nil?
elsif x.n.nil? && y.n.nil? == false
elsif x.n.nil? == false && y.n.nil? == false
if x.n < y.n
elsif x.n > y.n
if x.a.nil? == false && y.a.nil?
elsif x.a.nil? && y.a.nil? == false
elsif x.a.nil? == false && y.a.nil? == false
if x.a < y.a
elsif x.a > y.a
if args.size == 3
elsif args.size == 5
if /^(\S+)\s+(>|>=|=|==|<=|<)\s+(\S+)$/.match(string) # rubocop:disable Performance/RedundantMatch
name = $1
flag = if $2 == "="
:==
:"#{$2}"
version = $3
new(name, nil, nil)
if x.name != y.name
if (sense < 0) && ((x.flag == :> || x.flag == :>=) || (y.flag == :<= || y.flag == :<))
elsif (sense > 0) && ((x.flag == :< || x.flag == :<=) || (y.flag == :>= || y.flag == :>))
elsif sense == 0 && (
(x.flag == :< && y.flag == :<) ||
(x.flag == :> && y.flag == :>)
@rpms = {}
@index = {}
@provides = {}
def <<(*args)
what << pkg
require_relative "../../../mixin/shell_out"
YUM_HELPER = ::File.expand_path(::File.join(::File.dirname(__FILE__), "yum_helper.py")).freeze
@yum_command ||= begin
cmd = which("platform-python", "python", "python2", "python2.7", extra_path: "/usr/libexec") do |f|
shell_out("#{f} -c 'import yum'").exitstatus == 0
@stdin = @stdout = @stderr = @inpipe = @outpipe = @wait_thr = nil
query("close_rpmdb", {})
query_output = query("installonlypkgs", { "package" => name })
if query_output == "False"
options.each_with_object({}) do |opt, h|
if opt =~ /--enablerepo=(.+)/
$1.split(",").each do |repo|
if opt =~ /--disablerepo=(.+)/
raise "provides must have an epoch in the version to deconstruct" unless provides =~ /^(\S+)-(\d+):(\S+)/
epoch = $2
other = $3
ret = { "provides" => name, "epoch" => epoch }
arch = if is_arch?(maybe_arch)
other.delete_suffix!(".#{maybe_arch}")
ret.merge!({ "arch" => arch }) if arch
(version, _, release) = other.rpartition("-")
ret.merge!({ "version" => release }) # yeah, rpartition is just weird
ret.merge!({ "version" => version, "release" => release })
version = if !version.nil? && !version.empty?
arch = if !arch.nil? && !arch.empty?
return { "provides" => "#{provides}.#{arch} #{version}" }
return { "provides" => "#{provides} #{version}" }
provides.delete_suffix!(".#{arch}")
provides = "#{provides}-#{version}" if version
provides = "#{provides}.#{arch}" if arch
{ "provides" => provides }
repo_opts = options_params(options || {})
hash = { "action" => action }
array = output.split.map { |x| x == "nil" ? nil : x }
array.each_slice(3).map { |x| Version.new(*x) }.first
output = ""
fds.each do |fd|
output += fd.sysread(4096) rescue ""
max_retries ||= 5
ret = nil
yum(options, "-y", "remove", resolved_names)
yum("-d0", "-e0", "-y", options, "versionlock", "add", resolved_package_lock_names(names))
yum("-d0", "-e0", "-y", options, "versionlock", "delete", resolved_package_lock_names(names).map { |n| "*:#{n}-*" })
locked = yum("versionlock", "list")
def version_gt?(v1, v2)
return false if v1.nil? || v2.nil?
@yum_binary ||=
yum_binary ||= ::File.exist?("/usr/bin/yum-deprecated") ? "yum-deprecated" : "yum"
reg.each_key do |key, _wtime|
logger.trace("Registry error opening key '#{key}' on node #{desired}: #{ex}")
@hive = hive
@key = key
options ? " #{options}" : ""
uninstall_string = "msiexec /x #{uninstall_string.match(/{.*}/)}"
%{start "" /wait #{uninstall_string} & exit %%%%ERRORLEVEL%%%%}
a.assertion { new_resource.source || msi? }
::Kernel.open(::File.expand_path(source_location), "rb") do |io|
if basename == "setup.exe"
if v1 == "latest" || v2 == "latest"
gem_v1 = Gem::Version.new(v1)
gem_v2 = Gem::Version.new(v2)
gem_v1 <=> gem_v2
return :inno if entry.key.end_with?("_is1")
send(k.to_sym, v)
::File.exist?(new_source) ? new_source : nil
::File.extname(source_location).casecmp(".msi") == 0
status = shell_out("pkginfo", "-l", "-d", new_resource.source, new_resource.package_name)
shell_out!( "pkgrm", "-n", name )
shell_out!( "pkgrm", "-n", options, name )
request = "#{method} #{uri} HTTP/1.0\r\n" +
request.concat("\r\n")
body = ""
body << c
call_snap_api("GET", "/v2/changes/#{id}")
n = 0
when "Do", "Doing", "Undoing", "Undo"
when "Abort", "Hold", "Error"
n += 1
shell_out!("snap", *args)
body = {
}.to_json
snap_options = options.map do |k, v|
--#{snap_name}
request = {
call_snap_api("POST", "/v2/snaps", json)
call_snap_api("POST", "/v2/snaps/#{snap_name}", json)
json = call_snap_api("GET", "/v2/find?name=#{name}")
json = call_snap_api("GET", "/v2/snaps")
json = call_snap_api("GET", "/v2/snaps/#{name}")
json = call_snap_api("GET", "/v2/snaps/#{name}/conf")
response = call_snap_api("PUT", "/v2/snaps/#{name}/conf", value)
name = nil
package = "#{name}-#{version}"
out = shell_out!("/opt/local/bin/pkgin", "-y", "install", package, env: nil)
out = shell_out!("/opt/local/bin/pkgin", "-y", "remove", package, env: nil)
if rubygems_version >= Gem::Version.new("3.1")
if defined?(Gem::Format) && Gem::Package.respond_to?(:open)
rs.specs.find { |s| s.name == gem_dependency.name }
def uninstall(gem_name, gem_version = nil, opts = {})
@gempath_cache ||= {}
@platform_cache ||= {}
@source_index ||= Gem::SourceIndex.from_gems_in(*gem_paths.map { |p| p + "/specifications" })
msg << "in #{new_resource} from #{new_resource.source_line}"
logger.trace("#{new_resource} using gem '#{gem_location}'")
if new_resource.source.is_a?(String) && new_resource.source =~ /\.gem$/i
src << "--clear-sources" if clear_sources?
src += gem_sources.map { |s| "--source=#{s}" }
src_str = src.empty? ? "" : " #{src.join(" ")}"
if !version.nil? && !version.empty?
shell_out!("#{gem_binary_path} install #{name} -q #{rdoc_string} -v \"#{version}\"#{src_str}#{opts}", env: nil)
shell_out!("#{gem_binary_path} install \"#{name}\" -q #{rdoc_string} #{src_str}#{opts}", env: nil)
shell_out!("#{gem_binary_path} uninstall #{name} -q -x -I -v \"#{version}\"#{opts}", env: nil)
shell_out!("#{gem_binary_path} uninstall #{name} -q -x -I -a#{opts}", env: nil)
a.assertion { !@rpm_status.nil? && (@rpm_status.exitstatus == 0 || @rpm_status.exitstatus == 1) }
shell_out!("rpm", "-qp", "--queryformat", "%{NAME} %{VERSION}-%{RELEASE}\n", new_resource.source).stdout.each_line do |line|
when /^(\S+)\s(\S+)$/
@rpm_status = shell_out("rpm", "-q", "--queryformat", "%{NAME} %{VERSION}-%{RELEASE}\n", current_resource.package_name)
logger.trace("#{new_resource} current version is #{$2}")
shell_out!("rpm", options, "-U", "--oldpackage", new_resource.source)
shell_out!("rpm", options, "-U", new_resource.source)
shell_out!("rpm", options, "-i", new_resource.source)
shell_out!("rpm", options, "-e", "#{name}-#{version}")
shell_out!("rpm", options, "-e", name)
version = "0"
command.unshift("(")
command.join(" ")
logger.trace("#{new_resource} current version #{$1}")
if /-r\d+$/.match?(pkginfo.stdout)
@candidate_version = pkginfo.stdout.split(/(?<=-)/).last(2).join
pkg = "=#{name}-#{version}"
if version =~ /^\~(.+)/
pkg = "~#{name}-#{$1}"
shell_out!( "emerge", "-g", "--color", "n", "--nospinner", "--quiet", options, pkg )
shell_out!( "emerge", "--unmerge", "--color", "n", "--nospinner", "--quiet", options, pkg )
res = re.match(line)
shell_out!("cave", "-L", "warning", "resolve", "-x", options, pkg)
shell_out!("cave", "-L", "warning", "uninstall", "-x", options, pkg)
if ::File.exist?("/etc/pacman.conf")
pacman = ::File.read("/etc/pacman.conf")
status = shell_out("pacman", "-Sl")
shell_out!("pacman", "--sync", "--noconfirm", "--noprogressbar", options, *name)
shell_out!("pacman", "--remove", "--noconfirm", "--noprogressbar", options, *name)
if /^(.+?)--(.+)/.match?(new_resource.package_name)
if parts = name.match(/^(.+?)--(.+)/) # use double-dash for stems with flavors, see man page for pkg_add
shell_out!("pkg_add", "-r", package_string(name, version), env: { "PKG_PATH" => pkg_path }).status
if parts = name.match(/^(.+?)--(.+)/)
name = if parts = new_resource.package_name.match(/^(.+?)--(.+)/)
results << if parts = new_resource.package_name.match(/^(.+?)--(.+)/)
xml_files = Dir.glob("#{msu_dir}/*.xml")
doc = ::File.open(xml_files.first.to_s) { |f| REXML::Document.new f }
match = output.match(/^version: (.+)$/)
command << "@#{version}" if version && !version.empty?
shell_out!( "port", options, "upgrade", name, "@#{version}" )
shell_out!("pkg", "info", "-r", new_resource.package_name).stdout.each_line do |line|
command << "#{name}@#{version}"
package_name = "#{name}@#{version}"
shell_out!( "pkg", options, "uninstall", "-q", package_name )
@brew_info ||= begin
logger.trace "Executing 'brew #{command.join(" ")}' as user '#{homebrew_user.name}'"
output = send(shell_out_cmd, "brew", *command, timeout: 1800, user: homebrew_uid, environment: { "HOME" => homebrew_user.dir, "RUBYOPT" => nil, "TMPDIR" => nil })
n = name.squeeze("/").chomp("/").sub(%r{^\/}, "")
@depot_package ||= {}
origin, pkg_name = name.split("/")
url = if new_resource.bldr_url.include?("/v1/")
url << "/latest" unless name_version.count("/") >= 2
@http ||= Chef::HTTP::Simple.new(new_resource.bldr_url.to_s)
nv_parts = new_version.squeeze("/").split("/")
hab_v1 = Mixlib::Versioning.parse(v1.tr("/", "+"))
hab_v2 = Mixlib::Versioning.parse(v2.tr("/", "+"))
hab_v1 <=> hab_v2
shell_out!("make", "-DBATCH", "install", "clean", timeout: 1800, env: nil, cwd: port_dir).status
shell_out!("make", "deinstall", timeout: 300, env: nil, cwd: port_dir).status
when %r{^(http|ftp|/)}
shell_out!("pkg", "add", options, new_resource.source, env: { "LC_ALL" => nil }).status
shell_out!("pkg", "install", "-y", options, name, env: { "LC_ALL" => nil }).status
options_dup = options && options.map { |str| str.sub(repo_regex, "") }.reject!(&:empty?)
shell_out!("pkg", "delete", "-y", options_dup, "#{name}#{version ? "-" + version : ""}", env: nil).status
if options && options.join(" ").match(repo_regex)
options = $1.split(" ")
pkg_query = shell_out!("pkg", "rquery", options, "%v", new_resource.package_name, env: nil)
pkg_query.exitstatus == 0 ? pkg_query.stdout.strip.split('\n').last : nil
/(-r\s?\S+)\b/
require_relative "../../../resource/package"
::File.exist?("/usr/ports/Makefile")
when %r{^/}
when %r{/}
whereis = shell_out!("whereis", "-s", port, env: nil)
options = dir ? { cwd: dir } : {}
make_v = shell_out!("make", "-V", variable, **options)
logger.info("#{new_resource} installing package(s): #{name.join(" ")}")
run_noninteractive("dpkg", "-i", *options, *sources)
logger.info("#{new_resource} removing package(s): #{name.join(" ")}")
run_noninteractive("dpkg", "-r", *options, *name)
logger.info("#{new_resource} purging packages(s): #{name.join(" ")}")
run_noninteractive("dpkg", "-P", *options, *name)
if !shell_out("dpkg", "--compare-versions", v1.to_s, "gt", v2.to_s).error?
elsif !shell_out("dpkg", "--compare-versions", v1.to_s, "eq", v2.to_s).error?
logger.trace("#{new_resource} current version is #{$1}")
@name_pkginfo ||=
status = shell_out!("dpkg-deb", "-W", src)
DNF_HELPER = ::File.expand_path(::File.join(::File.dirname(__FILE__), "dnf_helper.py")).freeze
@dnf_command ||= begin
cmd = which("platform-python", "python", "python3", "python2", "python2.7", extra_path: "/usr/libexec") do |f|
shell_out("#{f} -c 'import dnf'").exitstatus == 0
parameters = { "provides" => provides, "version" => version, "arch" => arch }
if version =~ /(\S+):(\S+)/
epoch = $1
version = $2
if version =~ /(\S+)-(\S+)/
version = $1
release = $2
dnf(options, "-y", "install", new_resource.source)
dnf(options, "-y", "install", resolved_names)
dnf(options, "-y", "remove", resolved_names)
dnf("-d0", "-e0", "-y", options, "versionlock", "add", resolved_package_lock_names(names))
dnf("-d0", "-e0", "-y", options, "versionlock", "delete", resolved_package_lock_names(names).map { |n| "*:#{n}-*" })
locked = dnf("versionlock", "list")
shell_out!("dnf", *args)
cache_seed_to = "#{file_cache_dir}/#{name}-#{version}.seed"
name_nil_versions = name_versions_to_install.select { |n, v| v.nil? }
choco_command("install", "-y", "--version", version, cmd_args, name)
choco_command("install", "-y", cmd_args, *cmd_names)
choco_command("upgrade", "-y", "--version", version, cmd_args, name)
choco_command("upgrade", "-y", cmd_args, *cmd_names)
@choco_exe ||= begin
exe_path = ::File.join(choco_install_path, "bin", "choco.exe")
result = "" if result.empty?
hash = {}
name, version = line.split("|")
key, value = line.split(":") if line.start_with?("Package Identity")
next if key.nil? || value.nil?
package = {}
package_data = {}
if line =~ /Error: (.*)/
errors << $1.strip
elsif section_headers.any? { |header| line =~ /^(#{header})/ }
in_section = $1.downcase.tr(" ", "_")
elsif line =~ /(.*) ?: (.*)/
k = $1.downcase.strip.tr(" ", "_")
@packages ||= begin
ret = shell_out("installp", "-L", "-d", new_resource.source)
fields = line.split(":")
unless ret.exitstatus == 0 || ret.exitstatus == 1
when /\w:#{Regexp.escape(new_resource.package_name)}:(.*)/
shell_out!("installp", "-u", name)
shell_out!("installp", "-u", options, name)
@package_data ||= Hash.new do |hash, key|
locked = shell_out!("apt-mark", "showhold")
package_name = name.zip(version).map do |n, v|
package_name = name.map do |n|
run_noninteractive("apt-get", "-q", "-y", options, "remove", package_name)
run_noninteractive("apt-get", "-q", "-y", options, "purge", package_name)
@supports_allow_downgrade = ( version_compare(apt_version, "1.1.0") >= 0 )
return if Array(options).any? { |opt| opt.include?("--force-conf") }
when /^\s{2}Installed: (.+)$/
current_version = ( $1 != "(none)" ) ? $1 : nil
logger.trace("#{new_resource} installed version for #{pkg} is #{$1}")
when /^\s{2}Candidate: (.+)$/
candidate_version = ( $1 != "(none)" ) ? $1 : nil
logger.trace("#{new_resource} candidate version for #{pkg} is #{$1}")
when /\s+(?:\*\*\* )?(\S+) \d+/
all_versions << $1
if set.size > 1
f.any?
v1 == v2
@source_array ||=
if use_package_name_for_source? && source.nil? && package_name.match(/#{::File::SEPARATOR}/) && ::File.exist?(package_name)
method_sym.to_s.start_with?("action_") || super
if /^action_/.match?(method_sym.to_s)
@mount = nil
a.assertion { !device_should_exist? || ::File.exist?(device) }
unless fsck_device == "-"
a.assertion { ::File.exist?(fsck_device) }
a.assertion { ::File.exist?(mount_point) }
command << "-o"
command << actual_options.join(",")
mount_options = actual_options.empty? ? "" : ",#{actual_options.join(",")}"
shell_out!("mount", "-o", "remount#{mount_options}", mount_point)
shell_out!("mount", "-v").stdout.each_line do |line|
when /^#{device_regex}\s+on\s+#{Regexp.escape(mount_point)}\s+/
options += ",noauto"
logger.trace("Found mount #{device} to #{mount_point} in #{VFSTAB}")
options.nil? || !options.include?("noauto")
f.write(contents.join(""))
autostr = mount_at_boot? ? "yes" : "no"
passstr = pass == 0 ? "-" : pass
optstr = (actual_options.nil? || actual_options.empty?) ? "-" : actual_options.join(",")
if !found && line =~ /^#{device_regex}\s+\S+\s+#{Regexp.escape(mount_point)}/
unless ::File.exist?("/etc/fstab")
::File.foreach("/etc/fstab") do |line|
when /^(#{device_fstab_regex})\s+#{Regexp.escape(@new_resource.mount_point)}\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/
when /^#{device_mount_regex}\s+on\s+#{Regexp.escape(real_mount_point)}\s/
command << @new_resource.options.join(",")
linux? ? "defaults" : "rw"
::File.open("/etc/fstab", "a") do |fstab|
@new_resource.device.include?(":") || @new_resource.device.include?("//")
( @new_resource.device != "none" ) &&
( not network_device? ) &&
@real_device = ""
(@real_device == "/" || @real_device.match?(":/$")) ? @real_device : @real_device.chomp("/")
device_mount_regex.gsub(" ", "\\x20")
Regexp.escape(device_real) + "/?"
if !found && line =~ /^#{device_fstab_regex}\s+#{Regexp.escape(@new_resource.mount_point)}\s/
::File.open("/etc/fstab", "w") do |fstab|
@loop_mount_points ||= shell_out!("losetup -a").stdout
@loop_mount_points = ""
if @new_resource.fstype == "auto"
if regex_arr.size == 2
when /^#\s/
when /^#{Regexp.escape(@new_resource.mount_point)}:#{devicename}:(\S+):#{nodename}:(\S+)?:(\S+):(\S+):(\S+):(\S+)/
when /^#{Regexp.escape(@new_resource.mount_point)}:#{nodename}:(\S+)::(\S+)?:(\S+):(\S+):(\S+):(\S+)/
when /^#{Regexp.escape(@new_resource.mount_point)}:(\S+)?:(\S+):#{devicename}:(\S+)?:(\S+):(\S+):(\S+):(\S+)/
::File.open("/etc/filesystems", "a") do |fstab|
fstab.puts("\n\n#{@new_resource.mount_point}:")
fstab.puts("\tdev\t\t= #{device_fstab}")
fstab.puts("\tvfs\t\t= #{@new_resource.fstype}")
fstab.puts("\tmount\t\t= false")
current_resource_options = @current_resource.options.delete_if { |x| x == "rw" }
::File.open("/etc/filesystems", "r").each_line do |line|
when %r{^/.+:\s*$}
if /#{Regexp.escape(@new_resource.mount_point)}+:/.match?(line)
::File.open("/etc/filesystems", "w") do |fstab|
if (tries -= 1) < 0
if @new_resource.device == "/" || @new_resource.device.match?(":/$")
if ::File.exist?(new_resource.to) &&
(current_resource.link_type == :symbolic || current_resource.to != "")
types = {
if ::File.exists?(path)
only_if { manage_agent?(action) }
root = console_user == "root"
agent = type == "agent"
lltstype = ""
if root && agent && invalid_action && invalid_type
) do |a|
a.assertion { %w{daemon agent}.include?(type.to_s) }
}.each_with_object({}) do |(key, val), memo|
@path ||= new_resource.path || gen_path_from_type
@config_template = %{
<% if new_resource.device -%>
DEVICE=<%= new_resource.device %>
<% end -%>
<% if new_resource.onboot == "yes" -%>
ONBOOT=<%= new_resource.onboot %>
<% if new_resource.bootproto -%>
<% if new_resource.target -%>
IPADDR=<%= new_resource.target %>
<% if new_resource.mask -%>
<% if new_resource.network -%>
<% if new_resource.bcast -%>
<% if new_resource.onparent -%>
<% if new_resource.hwaddr -%>
HWADDR=<%= new_resource.hwaddr %>
<% if new_resource.metric -%>
METRIC=<%= new_resource.metric %>
<% if new_resource.mtu -%>
MTU=<%= new_resource.mtu %>
<% if new_resource.ethtool_opts -%>
<% if new_resource.bonding_opts -%>
<% if new_resource.master -%>
MASTER=<%= new_resource.master %>
<% if new_resource.slave -%>
SLAVE=<%= new_resource.slave %>
<% if new_resource.vlan -%>
VLAN=<%= new_resource.vlan %>
<% if new_resource.gateway -%>
<% if new_resource.bridge -%>
BRIDGE=<%= new_resource.bridge %>
auto <%= new_resource.device %>
when "dhcp" -%>
iface <%= new_resource.device %> <%= new_resource.family %> dhcp
<% when "bootp" -%>
iface <%= new_resource.device %> <%= new_resource.family %> bootp
<% else -%>
iface <%= new_resource.device %> <%= new_resource.family %> static
netmask <%= new_resource.mask %>
metric <%= new_resource.metric %>
mtu <%= new_resource.mtu %>
interfaces_dot_d_for_regexp = INTERFACES_DOT_D_DIR.gsub(/\./, "\\.") # escape dots for the regexp
regexp = %r{^\s*source\s+#{interfaces_dot_d_for_regexp}/\*\s*$}
interface = {}
@status = shell_out("ifconfig", "-a")
if line =~ /^(\S+):\sflags=(\S+)/
elsif line =~ /^(\S+):\sflags=(\S+)/
current_resource.inet_addr(Regexp.last_match(1)) if line =~ /inet\s(\S+)\s/
autoload :ERB, "erb"
@interfaces = {}
@net_tools_version = shell_out("ifconfig", "--version")
if /^net-tools (\d+\.\d+)/.match?(line)
addr_regex = /^((\w|-)+):?(\d*):?\ .+$/
@int_name = "nil"
a.assertion { @status.exitstatus == 0 }
converge_by("run #{command.join(" ")} to add #{new_resource}") do
converge_by("run #{command.join(" ")} to enable #{new_resource}") do
converge_by("run #{command.join(" ")} to delete #{new_resource}") do
converge_by("run #{command.join(" ")} to disable #{new_resource}") do
!@config_template.nil? && !@config_path.nil?
template = ::ERB.new(@config_template, nil, "-")
@http ||= Chef::HTTP::Simple.new(new_resource.url)
converge_by("#{new_resource} GET to #{new_resource.url}") do
body = http.get(
converge_by("#{new_resource} PUT to #{new_resource.url}") do
body = http.put(
a.assertion { ::File.exist?("/usr/sbin/usermod") }
a.assertion { ::File.exist?("/usr/sbin/usermod") && ::File.exist?("/usr/sbin/groupmod") }
shell_out!("groupmod", "-U", members.join(","), new_resource.group_name)
shell_out!("usermod", "-G", "+#{new_resource.group_name}", member)
shell_out!("usermod", "-G", "-#{new_resource.group_name}", member)
a.assertion { ::File.exist?("/usr/sbin/pw") }
shell_out!("pw", "groupmod", set_options)
shell_out!("pw", "groupmod", set_options, option)
opts << "-g"
logger.debug("#{new_resource} adding group members: #{members_to_be_added.join(",")}")
shell_out!("group", "add", set_options)
shell_out!("user", "mod", "-G", new_resource.group_name, user)
shell_out!("group", "mod", "-n", "#{new_resource.group_name}_bak", new_resource.group_name)
shell_out!("group", "add", set_options(overwrite_gid: true))
shell_out!("group", "del", "#{new_resource.group_name}_bak")
opts << "-o"
logger.trace("#{new_resource} set #{field} to #{new_resource.send(field)}")
opts << "-r" if new_resource.system && !node.platform?("solaris2")
a.assertion { ::File.exist?("/usr/bin/gpasswd") }
shell_out!("gpasswd", "-M", "", new_resource.group_name)
shell_out!("gpasswd", "-M", members.join(","), new_resource.group_name)
shell_out!("gpasswd", "-a", member, new_resource.group_name)
shell_out!("gpasswd", "-d", member, new_resource.group_name)
stdout_result = ""
stderr_result = ""
result = dscl(*args)
group_info = safe_dscl("read", "/Groups/#{new_resource.group_name}")
key, val = line.split(": ")
gid = nil; next_gid_guess = 200
groups_gids = safe_dscl("list", "/Groups", "gid")
next_gid_guess += 1
search_gids = safe_dscl("search", "/Groups", "PrimaryGroupID", gid.to_s)
!!(search_gids =~ /\b#{gid}\b/)
safe_dscl("create", "/Groups/#{new_resource.group_name}", "GroupMembers", "") # clear guid list
safe_dscl("create", "/Groups/#{new_resource.group_name}", "GroupMembership", "") # clear user list
safe_dscl("create", "/Groups/#{new_resource.group_name}", "Password", "*")
shell_out!("chgrpmem", "-m", "+", member, new_resource.group_name)
shell_out!("chgrpmem", "-m", "=", members.join(","), new_resource.group_name)
shell_out!("chgrpmem", "-m", "-", member, new_resource.group_name)
opts << "#{option}=#{new_resource.send(field)}"
@change_desc << "add missing member(s): #{missing_members.join(", ")}"
@change_desc << "remove existing member(s): #{members_to_be_removed.join(", ")}"
logger.info("#{new_resource} altered: #{change_desc.join(", ")}")
a.assertion { !(new_resource.revision =~ %r{^origin/}) }
FileUtils.rm_rf(::File.join(cwd, ".git"))
@git_has_single_branch_option ||= !git_gem_version.nil? && git_gem_version >= Gem::Version.new("1.7.10")
output = git("--version").stdout
::File.exist?(::File.join(cwd, ".git"))
if ::File.exist?(::File.join(cwd, ".git"))
sha_hash?(result) ? result : nil
converge_by("clone from #{repo_url} into #{cwd}") do
clone_cmd << "-o #{remote}" unless remote == "origin"
clone_cmd << "\"#{new_resource.repository}\""
clone_cmd << "\"#{cwd}\""
logger.info "#{new_resource} cloning repo #{repo_url} to #{cwd}"
git("reset", "--hard", target_revision, cwd: cwd)
git("branch", "-u", "#{new_resource.remote}/#{new_resource.revision}", cwd: cwd)
git("submodule", "sync", cwd: cwd)
git("submodule", "update", "--init", "--recursive", cwd: cwd)
git("fetch", "--prune", new_resource.remote, cwd: cwd)
git("fetch", new_resource.remote, "--tags", cwd: cwd)
when 0, 2
git("config", "--replace-all", "remote.#{remote_name}.url", %{"#{remote_url}"}, cwd: cwd)
git("remote", "add", remote_name, remote_url, cwd: cwd)
@target_revision ||=
refs = @resolved_reference.split("\n").map { |line| line.split("\t") }
found = refs_search(refs, "HEAD")
@is_tag = true
git("ls-remote", "\"#{new_resource.repository}\"", "\"#{rev_pattern}\"").stdout
!!@is_branch
!!@is_tag
def git(*args, **run_opts)
a.assertion { error.nil? }
if !l_exist?(path)
@content ||= begin
when ::File.pipe?(path)
!file_class.symlink?(path) && ::File.file?(path)
::File.exist?(path) || file_class.symlink?(path)
@diff ||= Chef::Util::Diff.new
if creates && creates_relative? && !cwd
if (logger.info? || live_stream?) && !sensitive?
( cwd && creates_relative? ) ? ::File.join(cwd, creates) : creates
@operations = {
end }
cwd = @dsc_resource.cwd || Dir.pwd
!(!@module_name && @module_version)
@module_name ||= begin
@converge_description << "\n\n"
@module_version.nil? ? module_name : "@{ModuleName='#{module_name}';ModuleVersion='#{@module_version}'}"
switches = "-Method #{method} -Name #{new_resource.resource}"\
).tap do |r|
if ::File.exist?(base_dir)
require_relative "../../provider"
crontab = shell_out(%w{/usr/bin/crontab -l}, user: @new_resource.user)
if status > 1
crontab.stdout.chomp << "\n"
error_message = ""
provides :cron, os: "aix"
newcron = "# Chef Name: #{new_resource.name}\n"
newcron << "#{@new_resource.minute} #{@new_resource.hour} #{@new_resource.day} #{@new_resource.month} #{@new_resource.weekday}"
newcron << " #{@new_resource.command}\n"
@new_resource.environment.length > 0 || !@new_resource.mailto.nil? || !@new_resource.path.nil? || !@new_resource.shell.nil? || !@new_resource.home.nil?
when "# Chef Name: #{new_resource.name}"
crontab = ""
newcron = ""
current_resource.send(attr_name.downcase.to_sym, attr_value.gsub(/^"|"$/, ""))
so = shell_out!("crontab -u #{new_resource.user} -", input: crontab)
str << "#{v.to_s.upcase}=\"#{new_resource.send(v)}\"" if new_resource.send(v)
new_resource.send(name.downcase.to_sym, value.gsub(/^"|"$/, ""))
str << "#{name.to_s.upcase}=\"#{value}\""
str << "#{name}=#{value}"
str.join("\n")
str = " timeout"
newcron << "# Chef Name: #{new_resource.name}"
newcron.join("\n")
@action_descriptions ||= {}
send("action_#{@action}")
end.join(", ")
modified.map! do |p|
property_size = properties.map(&:name).map(&:to_sym).map(&:size).max
def self.provides(short_name, opts = {}, &block)
resource.class.properties.keys.map { |k| "#{k}=".to_sym } -
def #{from}=(value)
obj.each { |value| visitor.call(value) }
:"@#{name}"
if !value.frozen? && !value.nil?
if !value.nil? || has_default?
resource.validate({ name => value }, { name => validation_options })
def #{name}=(value)
options.key?(:coerce) ||
timeout = -1 if timeout == 0 || timeout.nil?
{ type: "recipe", name: r, skipped: false, version: nil }
to_h.to_json(*opts)
@node = nil
rel_url = "cookbooks/#{cookbook_name}/#{xyz_version}"
message = "Error loading cookbook #{cookbook_name} at version #{xyz_version} from #{rel_url}: #{e.class} - #{e.message}"
node.expand!("disk")
cookbook_hash = cookbook_hash.inject({}) do |memo, (key, value)|
@node =
cmd = case
supports_dsc?(node) &&
@full_name = ""
@guid = nil
def guid(arg = nil)
payload = { name: name, full_name: full_name }
request_body = { user: username }
orgs.inject({}) do |org_map, (name, _url)|
def <<(message); end
new_matcher = { klass: klass }
if cmp && cmp <= 0
deleted = {}
method = "#{m}?".to_sym
blocklist, allowlist = filter_values.partition { |v| v.is_a?(String) && v.start_with?("!") }
allowlist.empty? || allowlist.any? { |v| v == :all || v == value || platform_family_query_helper?(node, v) }
allowlist.empty? || allowlist.any? { |v| v == :all || v == value }
return 1 if !a && b
return -1 if !b && a
return 0 if !a && !b
a_negated = Array(a).any? { |f| f.is_a?(String) && f.start_with?("!") }
b_negated = Array(b).any? { |f| f.is_a?(String) && f.start_with?("!") }
return -1 if b_negated && !a_negated
a <=> b
@map ||= {}
attr_reader :__path__
attr_reader :__root__
attr_reader :__node__
def initialize(data = nil, root = self, node = nil, precedence = nil)
data.nil? ? super() : super(data)
@__root__ = root
@__node__ = node
def __path__=(path)
@__path__ = path
def __root__=(root)
def __node__=(node)
if __node__ && __node__.run_context && __node__.run_context.events
def send_reset_cache(path = nil, key = nil)
__root__.reset_cache(next_path.first) if !__root__.nil? && __root__.respond_to?(:reset_cache) && !next_path.nil?
ret.__path__ = next_path
ret.__root__ = __root__
ret.__node__ = __node__
ret.__precedence__ = __precedence__
def <<(obj)
objs = objs.map { |obj| convert_value(obj) }
map! { |x| convert_value(x) }
def map!(&block)
super { |x| convert_value(x) }
def fill(*args, &block)
<
<=
>
>=
&
+
-
|
ret = if deep_merge_cache.key?(key.to_s)
ImmutableMash.new(value, __root__, __node__, __precedence__)
ImmutableArray.new(value, __root__, __node__, __precedence__)
Array.new(map { |e| safe_dup(e) })
Array.new(map do |v|
v.to_a
v.to_h
to_a.to_yaml(*opts)
def initialize(mash_data = {})
h = Mash.new
each_pair do |k, v|
h = {}
to_h.to_yaml(*opts)
obj.is_a?(Hash) || (obj.is_a?(Array) && key.is_a?(Integer))
value = block_given? ? yield : args.pop
prev_memo = prev_key = nil
chain = args.inject(self) do |memo, key|
def write!(*args, &block)
obj = args.inject(self) do |memo, key|
if memo.is_a?(Hash)
read!(*path)
def read!(*path)
hash = path.empty? ? self : read(*path)
return nil unless hash.is_a?(Hash) || hash.is_a?(Array)
ret = super(*args, &block)
send_reset_cache(__path__, key)
map! { |e| convert_value(e) }
VividMash.new(value, __root__, __node__, __precedence__)
AttrArray.new(value, __root__, __node__, __precedence__)
super(*args, &block)
def initialize(data = {})
if !key?(key)
value = self.class.new({}, __root__)
@default = VividMash.new(new_data, self, __node__, :default)
@role_default = VividMash.new(new_data, self, __node__, :role_default)
@env_default = VividMash.new(new_data, self, __node__, :env_default)
@normal = VividMash.new(new_data, self, __node__, :normal)
@override = VividMash.new(new_data, self, __node__, :override)
@env_override = VividMash.new(new_data, self, __node__, :env_override)
def rm(*args)
hash = obj.read(*path)
ret == NIL ? nil : ret
def write!(level, *args, &block)
send(level).write!(*args, &block)
alias :key? :has_key?
end.join(", ") << ">"
if !val.respond_to?(:has_key?)
key.is_a?(Symbol) ? key.to_s : key
if merge_onto.is_a?(Hash) && merge_with.is_a?(Hash)
elsif merge_onto.is_a?(Array) && merge_with.is_a?(Array)
def_delegators :attributes, :keys, :each_key, :each_value, :key?, :has_key?
def_delegators :attributes, :read, :read!, :write, :write!, :unlink, :unlink!
@logger = logger || Chef::Log.with_child(subsystem: "node")
@attributes = Chef::Node::Attribute.new({}, {}, {}, {}, self)
@run_state = {}
if !arg.nil?
{ name: arg },
{ name: { kind_of: String,
@name = arg
fully_qualified_recipe = "#{cookbook}::#{recipe}"
args.length > 0 ? rl.reset!(args) : rl
rl = list
run_list.detect { |r| r == item } ? true : false
attrs = attrs ? attrs.dup : {}
if new_run_list = attrs.delete("recipes") || attrs.delete("run_list")
if attrs.key?("recipes") || attrs.key?("run_list")
Chef::Environment.new.tap { |e| e.name("_default") }
display = {}
return o if o.is_a? Chef::Node
node = new
if o.key?("attributes")
if o.key?("run_list")
elsif o.key?("recipes")
n = Chef::Node.from_hash(n)
if e.response.code == "404"
name <=> other.name
res.each do |ai|
rescue => ex
CP1252 = {
128 => 8364, # euro sign
134 => 8224, # dagger
135 => 8225, # double dagger
137 => 8240, # per mille sign
149 => 8226, # bullet
150 => 8211, # en dash
151 => 8212, # em dash
152 => 732, # small tilde
153 => 8482, # trade mark sign
38 => "&amp;", # ampersand
62 => "&gt;", # right angle bracket
unescaped_str.unpack("U*").map { |char| xml_escape_char!(char) }.join
unescaped_str.unpack("C*").map { |char| xml_escape_char!(char) }.join
).address, flags, 5000, nil) == 0
buf = 0.chr * 32 * 1024
node ||= begin
{}.tap do |n|
( node_windows_architecture(node) == :x86_64 ) || ( desired_architecture == :i386 )
( architecture == :x86_64 ) || ( architecture == :i386 )
if ( node_windows_architecture(node) == :x86_64) && ::ChefUtils.windows?
if str.nil? || str.encoding == Encoding::UTF_16LE
ustring = (ustring + "").force_encoding("UTF-8")
.max_by { |a| a.send(:minimum_api_version) }
line_no = __LINE__; str = %{
def self.#{method}(*args, &block)
versioned_api_class.__send__(:#{method}, *args, &block)
module_eval(str, __FILE__, line_no)
output = output.gsub(/\r?\n/, "\r\n")
$1.to_i if original_exception.backtrace.find { |line| line =~ /\(erubis\):(\d+)/ }
lines = @template.split(/\n/)
line_number = (index + beginning_line + 1).to_s.rjust(3)
output << "#{line_number}: #{line}"
output.join("\n")
instance_variable_set(:"@#{sym}", true)
!!instance_variable_get(:"@#{sym}")
define_method :"#{sym}?" do
self.class.send(:"#{sym}?")
def owner(arg = nil)
def group(arg = nil)
def mode(arg = nil)
:mode,
if m.is_a?(String)
m =~ /^0/ || m = "0#{m}"
Integer(m) <= 0777 && Integer(m) >= 0
Integer(m) <= 07777 && Integer(m) >= 0
rights = instance_variable_get("@#{name}".to_sym)
input = {
if permission < 0 || permission > 1 << 32
def provides(short_name, opts = {})
@properties ||= {}
elsif type.is_a?(Property) || (type.is_a?(Class) && type <= Property)
names = names.map(&:to_sym).uniq
names = names.map(&:to_sym)
p = properties.find { |n, p| p.name_property? }
p ? p.first : nil
memo << "#{k}=#{translate_type(v)}"
translated = x.map do |v|
if unsafe?(s)
options ||= {}
@validation_message ||= {}
unless key.is_a?(Symbol) || key.is_a?(String)
check_method = "_pv_#{check}"
if opts.key?(key.to_s)
def _pv_equal_to(opts, key, to_be)
to_be = Array(to_be)
to_be.each do |tb|
def _pv_kind_of(opts, key, to_be)
predicate_method = :"#{method_name}?"
def _pv_is(opts, key, to_be)
return true if !opts.key?(key.to_s) && !opts.key?(key.to_sym)
passed = to_be.any? do |tb|
raise if to_be.size == 1
errors << $!
tb === value
message << " Errors:\n#{errors.map { |m| "- #{m}" }.join("\n")}"
cert_file_path + ::File::SEPARATOR + cert_filename + ".key"
number >= 1024 && ( number & (number - 1) == 0 )
key_content = ::File.exist?(key_file) ? File.read(key_file) : key_file
::OpenSSL::X509::CRL.new ::File.read(crl_file)
key_content = ::File.exist?(priv_key) ? File.read(priv_key) : priv_key
::OpenSSL::PKey::EC.send(:alias_method, :private?, :private_key?)
crlnum = 1
crlnum = e.value if e.oid == "crlNumber"
crlnum.to_i + 1
::File
@@direct_descendants = {}
descendants(klass).first { |c| c.name == name }
@deprecated_constants ||= {}
KEEPERS = %w{__id__ __send__ instance_eval == equal? initialize object_id}.freeze
@level ||= :warn
called_from.each { |l| log(l) }
instance_variable_get("@#{name}")
define_method("#{name}=") do |value|
instance_variable_set("@#{name}", value)
if dest.is_a?(Hash)
if dest.is_a?(Array)
unless file_path.is_a?(String) || file_path.is_a?(Array)
regexp = /^(.+?)(_(.+))?$/
str = str.dup
str.sub!(/^#{namespace}(\:\:)?/, "") if namespace
str.sub!(/^\_/, "")
str.gsub!(/^(_+)?/, "")
with_namespace.split("::").last.sub(/^_/, "")
str = base.to_s + (file_base == "default" ? "" : "_#{file_base}")
def __log
chef_gem_path = File.expand_path("..", __dir__)
server_options = {}
parts = port.split(",")
if parts.size == 1
a.to_i.upto(b.to_i)
array += parse_port(part).to_a
@rest ||= if @actor_field_name == "user"
@api_base ||= if @actor_field_name == "user"
def actor(arg = nil)
regex: /^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z|infinity)$/)
@actor_field_name => @actor,
if @public_key.nil? && !@create_key
if @name.nil?
payload = { "name" => @name }
result = chef_rest.post("#{api_base}/#{@actor}/keys", payload)
new_key = to_h
if @name.nil? && put_name.nil?
put_name = @name if put_name.nil?
new_key = chef_rest.put("#{api_base}/#{@actor}/keys/#{put_name}", to_h)
chef_rest.delete("#{api_base}/#{@actor}/keys/#{@name}")
if key_hash.key?("user")
Chef::Key.from_hash(response.merge({ "user" => actor }))
Chef::Key.from_hash(response.merge({ "client" => actor }))
OpenSSL::Digest.hexdigest("SHA1", data_string.to_der).scan(/../).join(":")
keys.inject({}) do |key_map, result|
def parse(source, opts = {})
def from_json(source, opts = {})
unless obj.is_a?(Hash) || obj.is_a?(Array)
def to_json(obj, opts = nil)
options_map = { pretty: true }
def initialize(opts = {}); end
def handle_request(method, url, headers = {}, data = false)
def read_body(dest = nil, &block)
100 => "Continue",
200 => "OK",
201 => "Created",
202 => "Accepted",
204 => "No Content",
205 => "Reset Content",
206 => "Partial Content",
207 => "Multi-Status",
300 => "Multiple Choices",
302 => "Found",
303 => "See Other",
304 => "Not Modified",
305 => "Use Proxy",
400 => "Bad Request",
401 => "Unauthorized",
402 => "Payment Required",
403 => "Forbidden",
404 => "Not Found",
405 => "Method Not Allowed",
406 => "Not Acceptable",
408 => "Request Timeout",
409 => "Conflict",
410 => "Gone",
411 => "Length Required",
414 => "Request-URI Too Large",
423 => "Locked",
426 => "Upgrade Required",
429 => "Too Many Requests",
501 => "Not Implemented",
502 => "Bad Gateway",
504 => "Gateway Timeout",
@url = base_url
body_str = body || ""
body = chunked_body.join("")
value.each { |v| response.add_field(name, v) }
options.reject { |name, _| KNOWN_OPTIONS.include?(name) }.map do |name, value|
@opts = opts
headers.delete_if { |key, _value| key.casecmp("content-type") == 0 }
json_opts = {}
requested_content_type = headers.find { |k, v| k.casecmp("content-type") == 0 }
@user_agent = ua
@method, @url = method, url
@url.path.empty? ? SLASH : @url.path
if /#{Regexp.escape(%q{undefined method `closed?' for nil:NilClass})}/.match?(e.to_s)
Chef::Log.trace("#{e.class.name}: #{e}")
Chef::Log.trace(e.backtrace.join("\n"))
req_path << "?#{query}" if query
@host, @port = url.host, url.port
if @cookies.key?("#{@host}:#{@port}")
def request(method, url, req_body, base_headers = {})
Chef::Log.trace("Initiating #{method} to #{url}")
Chef::Log.trace("---- HTTP Request Header Data: ----")
Chef::Log.trace("#{name}: #{value}")
Chef::Log.trace("---- End HTTP Request Header Data ----")
Chef::Log.trace("---- HTTP Status and Header Data: ----")
Chef::Log.trace("#{header}: #{value}")
Chef::Log.trace("---- End HTTP Status/Header Data ----")
if !response.code || !response.code.start_with?("2")
Chef::Log.trace("---- HTTP Response Body ----")
Chef::Log.trace("---- End HTTP Response Body -----")
Chef::Log.trace("---- HTTP Request Body ----")
Chef::Log.trace("---- End HTTP Request Body ----")
http_client.send(:"#{key}=", value)
Chef::Log.trace("Using #{proxy_uri.host}:#{proxy_uri.port} for proxy")
@raw_key = nil
elsif key_file == nil? && raw_key == nil?
Chef::Log.warn "Failed to read the private key #{key_file}: #{e.inspect}"
$aes.Key = $KeyBytes
password = ""
corrected_store = (store == "CurrentUser" ? "HKCU" : "HKLM")
size = 14
{ name: "PfxPass", type: :string, data: encrypted_password },
{ name: "PfxKey", type: :string, data: key },
{ name: "PfxIV", type: :string, data: vector },
future.mjd - today.mjd <= 7
$cert = Get-ChildItem -path cert:\\#{store}\\My -Recurse | Where-Object { $_.Subject -match "chef-#{client_name}$" } -ErrorAction Stop;
Get-ChildItem -path cert:\\#{store}\\My -Recurse | Where-Object { $_.Subject -match "chef-#{client_name}$" } | Remove-Item -ErrorAction Stop;
host: "#{url.host}:#{url.port}",
!!key
signed = sign_obj.sign(key, use_ssh_agent: @use_ssh_agent).merge({ host: host })
def initialize(options = {}); end
if http_response.code == "406"
def initialize(url, options = {})
def head(path, headers = {})
def get(path, headers = {})
def put(path, json, headers = {})
def post(path, json, headers = {})
def delete(path, headers = {})
def request(method, path, headers = {}, data = false)
http_attempts ||= 0
data = nil
base_url ||= url
@http_client ||= {}
if %r{^(http|https|chefzero)://}i.match?(path)
elsif path.nil? || path.empty?
URI.parse(@url.gsub(%r{/+$}, "") + "/" + path.gsub(%r{^/+}, ""))
return_value ||= {}
sleep_time = 1 + (2**http_attempts) + rand(2**http_attempts)
def build_headers(method, url, headers = {}, json_body = false)
if tf.nil?
@amount ||= 10
puts "\nTop #{count} slowest #{count == 1 ? "resource" : "resources"}:\n\n"
puts "\n"
num > amount ? amount : num
savetime = Time.now.strftime("%Y%m%d%H%M%S")
Array(e.backtrace).each { |line| Chef::Log.error(line) }
@output = "STDOUT: #{result.stdout}\nSTDERR: #{result.stderr}\n"
@group ||= {}
body_hash = {
groupname: "#{groupname}",
actors: {
puts "done."
puts "* #{resource}"
print "S"
print "U"
@out, @err = out, err
@indent = 0
@pastel ||= begin
print_line("", options)
@out.puts ""
@out.print " " * indent
headline = "Recipe Compile Error" + ( path ? " in #{path}" : "" )
original_run_list = node.run_list.map { |item| "* #{item}" }.join("\n")
end.join("\n")
@snippet ||= if (file = parse_source) && (line = parse_line(file))
current_line = line - 1
break if current_line >= (line + 50)
filters = Array(Chef::Config.cookbook_path).map { |p| /^#{Regexp.escape(p)}/ }
exception.backtrace.select { |line| filters.any? { |filter| line =~ filter } }
line_nr_string = (line_nr + 1).to_s.rjust(3) + ": "
explanation = ""
explanation << "* #{cookbook}\n"
explanation << "\n"
explanation << <<~EOM
@expanded_run_list.map { |i| "* #{i}" }.join("\n")
error_description.section("Additional information:", msg.gsub(/^ {6}/, ""))
context_lines << "#{culprit_file}:\n\n"
line_nr = (i + 1).to_s.rjust(3)
lower = (culprit_line - 8)
lower = 0 if lower < 0
upper = (culprit_line + 8)
@culprit_line ||= begin
filters = Array(Chef::Config.cookbook_path).map { |p| /^#{Regexp.escape(p)}/i }
r = exception.backtrace.select { |line| filters.any? { |filter| line =~ filter } }
Chef::Log.trace("Filtered backtrace of compile error: #{r.join(",")}")
@sections << { heading => (text || "") }
out.puts "=" * 80
out.puts "\n"
out.puts "-" * heading.size
context_info.map { |k, v| "#{k}=#{v}" }.join("\n")
@end_time = @start_time
@progress = {}
if time < 60
puts_line ""
puts_line "#{prefix}#{line}"
puts_line "- #{cookbook.name} (#{cookbook.version})"
puts_line "- Installing #{gem} #{version}", :green
puts_line "- Using #{gem} #{version}"
percent_complete = (current.to_f / total.to_f * 100).to_i unless total.to_f == 0.0
start_line " - Progress: #{percent_complete}%", :green
@up_to_date_resources += 1
start_line "- #{prefix}#{line}", :green
puts_line "- #{handler.class.name}"
start_line("* #{line}", :yellow)
start_line("* #{line}", color)
indent_by(-2)
@deprecations ||= {}
@formatters_by_name ||= {}
puts("")
tf = nil
i = b.index(".")
apply_dacl = ACL.create(dst_sd.dacl.select { |ace| !ace.inherited? })
apply_sacl = ACL.create(dst_sd.sacl.select { |ace| !ace.inherited? })
stat = ::File.stat(dst)
Chef::Log.trace("Applying mode = #{mode.to_s(8)}, uid = #{uid}, gid = #{gid} to #{src}")
::File.chown(uid, nil, src)
Chef::Log.warn("Could not set uid = #{uid} on #{src}, file modes not preserved")
::File.chown(nil, gid, src)
Chef::Log.warn("Could not set gid = #{gid} on #{src}, file modes not preserved")
::File.chmod(mode, src)
path: { kind_of: String },
contents: { kind_of: String },
File.open(File.join(cache_path, file_name), "w", perm) do |io|
file: { kind_of: String },
raise "Cannot move #{file} to #{path}!"
find("**#{File::Separator}*")
if File.file?(f)
alias_method :has_key?, :key?
actual_acl = actual_acl.select { |ace| !ace.inherited? }
return true unless ::File.exist?(file) || ::File.symlink?(file)
( ! inherits.nil? && inherits != existing_descriptor.dacl_inherits? ) || ( dacl && !acls_equal(dacl, existing_dacl) )
if dacl.nil? && !existing_dacl.nil?
Chef::Log.info("#{log_string} group changed to #{group}")
Chef::Log.info("#{log_string} owner changed to #{owner}")
mask = 0
flags = 0
acls = nil
acls += mode_ace(owner, (mode & 0700) >> 6)
elsif mode & 0700 != 0
acls += mode_ace(group, (mode & 070) >> 3)
elsif mode & 070 != 0
acls += mode_ace(SID.Everyone, (mode & 07))
changes << "change mode from '#{mode_to_s(current_mode)}' to '#{mode_to_s(target_mode)}'" if should_update_mode?
Chef::Log.info("#{log_string} owner changed to #{target_uid}")
Chef::Log.info("#{log_string} group changed to #{target_gid}")
return nil if res.nil? || res.mode.nil?
(res.mode.respond_to?(:oct) ? res.mode.oct : res.mode.to_i) & 007777
mode.nil? ? "" : "0#{mode.to_s(8)}"
Chef::Log.info("#{log_string} mode changed to #{target_mode.to_s(8)}")
@stat ||= File.lstat(file)
@stat ||= File.stat(file)
target_mode & 04000 > 0
@resource || @file
message << "* #{error.class} occurred in #{location}: #{error.message}\n"
if @all_failures.size == 1
super "Checksum on resource (#{res_cksum}...) does not match checksum on content (#{cont_cksum}...)"
backtrace << "" unless i == wrapped_errors.length - 1
constraint_str = constraints.map { |c| c.requirement.as_list.to_s }.join(", ")
data =
@event_loggers_by_name ||= {}
def <<(str)
subscribers.reject! { |x| x == subscriber }
def #{method_name}(*args)
subscribers.any? { |s| s.respond_to?(:is_formatter?) && s.is_formatter? }
@in_call = true
if mth.arity < args.size && mth.arity >= 0
@in_call = false
@cookbook_versions = {}
}, {
version: {
@invalid_fields ||= {}
if name.nil? || name.size == 0
@iv = iv && Base64.decode64(iv)
@iv
@hmac ||= begin
super + %w{ hmac }
@auth_tag = nil
super + %w{ auth_tag }
@decrypted_data ||=
d.iv = iv
expected_bytes.zip(candidate_hmac_bytes) { |x, y| valid |= x ^ y.to_i }
valid == 0
d = super
d.auth_data = ""
data = raw_data.reject { |k, _| k == "id" } # Remove the "id" key.
data.empty? ? false : data.reject { |_, v| !looks_like_encrypted?(v) } == data
return false unless data.is_a?(Hash) && data.key?("version")
@enc_hash = enc_hash
if key == "id" || value.nil?
plain_hash.inject({}) do |h, (key, val)|
when %r{^\w+://}
raise Errno::ENOENT, "file not found '#{path}'"
@toml_str = ""
if prefix.any? && (simple_pairs.any? || hash.empty?)
elsif val.is_a?(Array) && val.first.is_a?(Hash)
@toml_str << "#{key} = #{to_toml(val)}\n"
new_prefix = prefix.join(".")
if obj.is_a?(Time) || obj.is_a?(DateTime)
obj.strftime("%Y-%m-%dT%H:%M:%SZ")
obj.strftime("%Y-%m-%d")
def #{dsl_name}(args = nil, &block)
JSON.pretty_generate(hash) + "\n"
yaml_content.gsub!(" :", " ")
when ".toml"
when ".yaml", ".yml"
when ".json"
@values = {}
keys.each do |k|
key_matches << k
if platforms.to_s == "default"
hash.inject({}) do |h, key_value|
msg << "you gave a value #{value.inspect} for platform(s) #{platforms}"
if match = file_spec.match(/(.+?)::(.+)/)
def #{dsl_name}(*args, &block)
Chef.autoload :DataBag, File.expand_path("../data_bag", __dir__)
Chef.autoload :DataBagItem, File.expand_path("../data_bag_item", __dir__)
if Kernel.block_given? || args.length >= 4
results << o
}.each do |method_name|
def #{method_name}(*args, &block)
self.#{method_name}(*args, &block)
if ::ChefVault::Item.vault?(bag, id)
File.open(file, "rb") { |f| checksum_io(f, digest) }
while chunk = io.read(1024 * 8)
message = "Method '#{name}' of '#{self.class}' is deprecated. It will be removed in #{ChefUtils::Dist::Infra::PRODUCT} #{Chef::VERSION.to_i.next}."
return true if location =~ /^(.*?):(\d+):in/ && begin
line_no = $2.to_i
location_file = ::File.open($1)
def target(id, page = nil)
@doc_page = page || deprecation_key.to_s
attr_accessor :__path__
__path__.push(key)
@delegate_sd_obj.public_send(__method__, *__path__, value)
def __getobj__
__getobj__.nil?
def is_a?(klass)
__getobj__.is_a?(klass) || super
def __setobj__(obj)
r = true
target = __getobj__ { r = false }
if r && target.respond_to?(m)
target.__send__(m, *args, &block)
@__defined_methods__.push(m)
super(m, *args, &block)
@__defined_methods__.each do |m|
message = {
action = "up-to-date" if action == "up_to_date"
@error_description ||= {}
when (want_mode != :both) && running_mode != want_mode
hash.is_a?(Hash) && keys.any? { |k| hash.key?(k) }
code = e&.response&.code.to_s
if code == "404"
msg << " (This is normal if you do not have #{ChefUtils::Dist::Automate::PRODUCT})"
File.open(File.expand_path(file_name), "a") do |fh|
headers = { "Content-Type" => "application/json" }
if id_str.nil? || ( id_str !~ VALID_ID )
@data_bag = nil
@raw_data = Mash.new
@raw_data = new_data
def data_bag(arg = nil)
:data_bag,
item = new
item.data_bag(h.delete("data_bag")) if h.key?("data_bag")
if h.key?("raw_data")
r.put("data/#{data_bag}/#{item_id}", self)
r.post("data/#{data_bag}", self)
other.respond_to?(:to_h) &&
other.respond_to?(:data_bag) &&
(other.to_h == to_h) &&
(other.data_bag.to_s == data_bag.to_s)
pretty_printer.pp({ "data_bag_item('#{data_bag}', '#{id}')" => to_hash })
bag = new
)).map { |f| File.basename(f) }.sort
list(false).inject({}) do |response, bag_and_uri|
data_bag = {}
Dir.glob(File.join(Chef::Util::PathHelper.escape_glob_dir(path, name.to_s), "*.json")).inject({}) do |bag, f|
chef_server_rest.delete("data/#{@name}")
Chef::Log.info("Forked, in #{Process.pid}. Privileges: #{Process.euid} #{Process.egid}")
$stdin.reopen("/dev/null")
$stdout.reopen("/dev/null", "a")
Dir.chdir("/")
if (uid != target_uid) || (gid != target_gid)
Chef::Application.fatal!("Permission denied when trying to change #{uid}:#{gid} to #{target_uid}:#{target_gid}. #{e.message}")
rname = File.basename(rname, ".rb")
memo << "#{name}::#{rname}"
filenames_by_pref = {}
records_by_pref = {}
if segment.to_sym == :files || segment.to_sym == :templates
parts = version.to_s.split(".")
search_versions << parts.join(".")
search_path << File.join("#{platform}-#{v}", path)
def self.load(name, version = "_latest")
version = "_latest" if version == "latest"
if /^404/.match?(e.to_s)
json_file = "#{path}/metadata.json"
rb_file = "#{path}/metadata.rb"
f = File.open(json_file, "w")
result = yml_files.inject({}) do |acc, record|
checksum_files = {}
Chef::Log.info("Saving #{cb.name}")
if e.message =~ /^400/ && (retries += 1) <= 5
when "409"
headers = { "content-type" => "application/x-binary", "content-md5" => checksum64, "accept" => "application/json" }
error_message = "Failed to upload #{file} (#{checksum}) to #{url} : #{e.message}"
error_message << "\n#{e.response.body}" if e.respond_to?(:response)
result = to_h
part.to_s == seg
parent = if parts.length == 1
name.nil? || segment == "root_files"
@checksums = {}
if !root_paths || root_paths.size == 0
rs = Mash.new({
@metadata ||= Mash.new
@chefignores ||= {}
@all_files_in_repo_paths ||=
Chef::Log.trace("Testing #{ruby_file} for syntax errors...")
error_message.each_line { |l| Chef::Log.fatal(l.chomp) }
@valid_cache_entries = {}
cache.find(File.join(%w{cookbooks ** {*,.*}})).each do |cache_filename|
@cookbook_full_file_paths = {}
@lazy_files = {}
queue << lambda do |lock|
cache.find(File.join(%w{cookbooks ** {*,.*}})).each do |cache_file|
@rest = rest
segment = $1
@long_description = ""
@maintainer = ""
@maintainer_email = ""
@version = Version.new("0.0.0")
@source_url = ""
@issues_url = ""
equal_so_far && other.respond_to?(field) && (other.send(field) == send(field))
if /::default$/.match?(recipe_name)
cm = new
deps.any? { |dep| dep.match?(what, version) }
Called by: #{caller_name} '#{dep_name}', #{version_constraints.map(&:inspect).join(", ")}
longer use "<<" and ">>" for 'less than' and 'greater than'; use '<' and
Called by: #{caller_name} '#{dep_name}', '#{constraint_str}'
if arry.is_a?(Array)
validate( { choice: choice }, { choice: { kind_of: String } } )
validate( { choice: choice }, { choice: { kind_of: validator } } )
memo << file
result.merge({ "frozen?" => manifest.frozen_version?, "chef_type" => "cookbook_version" })
args << {} unless args.last.is_a?(Hash)
File.open("#{dir}/Gemfile", "w+") do |tf|
tf.puts "source '#{s}'"
env = {
so = shell_out!(cmd, cwd: dir, env: env)
@relative_path = %r{#{Regexp.escape(cookbook_path)}/(.+)$}
all_files: {},
when /\.rb$/
when /\.json$/
if !empty? && !metadata.valid?
next if File.directory?(top_path) && top_filename.start_with?(".")
super() do |hash, key|
@ignores.any? { |glob| File.fnmatch?(glob, file_name) }
File.exist?(path) && File.readable?(path) &&
(File.file?(path) || File.symlink?(path))
http.get("")
!!(config_location =~ %r{^(http|https)://})
evt_loggers << :win_evt
select(&:enabled?).each_with_object({}) { |waiver, hash| hash.merge!(waiver.inspec_data) }
(cookbook_name, waiver_name) = arg.split("::")
waivers = select { |waiver| /^#{cookbook_name}$/.match?(waiver.cookbook_name) && /^#{waiver_name}$/.match?(waiver.pathname) }
@data = data
!!@enabled
logger.debug("#{self.class}##{__method__}: #{Inspec::Dist::PRODUCT_NAME} profiles? #{inspec_profiles.any?}")
logger.debug("#{self.class}##{__method__}: audit cookbook? #{audit_cookbook_present}")
logger.debug("#{self.class}##{__method__}: enabling Compliance Phase")
values = deprecated_config_values.sort.map { |v| "'#{v}'" }.join(", ")
unless profiles.respond_to?(:map) && profiles.all? { |_, p| p.respond_to?(:transform_keys) && p.respond_to?(:update) }
runlist_roles = node.run_list.select { |item| item.type == :role }.map(&:name)
runlist_recipes = node.run_list.select { |item| item.type == :recipe }.map(&:name)
os: {
policy_name: node.policy_name || "",
policy_group: node.policy_group || "",
organization_name: chef_server_uri.path.split("/").last || "",
source_fqdn: chef_server_uri.host || "",
run_id: run_id,
path = node.dig("audit", "json_file", "location")
when "cli"
u.path = ""
@reporters = {}
@interval_time ||= node.read("audit", "interval", "time")
@interval_enabled ||= node.read("audit", "interval", "enabled")
@path = opts.fetch(:file)
if @path.nil? || @path.class != String || @path.empty?
output << "\n"
puts output.join("\n")
output << pastel.red("#{" " * 12}#{m}")
output << pastel.red("#{" " * 9}#{m}")
when /404/
when /413/
when /429/
msg = "Received HTTP error #{code}"
unless @url && @token
headers = {
Chef::Log.info "Report to #{ChefUtils::Dist::Automate::PRODUCT}: #{@url}"
Chef::Log.error "send_report: POST to #{@url} returned: #{e.message}"
truncated = { failed: 0, skipped: 0, passed: 0 }
(max_results..res.length - 1).each do |i|
meta_url = URI(@url)
response_str = http_client(meta_url.to_s).post(nil, "{\"sha256\": #{report_shas}}", headers)
any?(&:enabled?)
(cookbook_name, profile_name) = arg.split("::")
profiles = select { |profile| /^#{cookbook_name}$/.match?(profile.cookbook_name) && /^#{profile_name}$/.match?(profile.pathname) }
{ name: name, path: File.dirname(path) }
select(&:enabled?).each_with_object({}) { |input, hash| hash.merge!(input.inspec_data) }
(cookbook_name, input_name) = arg.split("::")
inputs = select { |input| /^#{cookbook_name}$/.match?(input.cookbook_name) && /^#{input_name}$/.match?(input.pathname) }
CONFIG = { "insecure" => true }.freeze
path_parts << "owners"
path_parts << "tar"
rescue URI::Error => _e
@archive_type = ".tar.gz"
path = @target.respond_to?(:path) ? @target.path : path
if target.respond_to?(:key?) && target.key?(:url)
owner, id = profile.split("/")
profile_path = if target.respond_to?(:key?) && target.key?(:version)
URI("compliance://#{profile}")
uri.to_s.sub(%r{^compliance:\/\/}, "")
def initialize(json_attribs = nil, args = {})
@json_attribs = json_attribs || {}
if Time.now > Time.new(eol_year, 5, 01)
io = File.open(output_path, "a+")
@rest_clean ||=
cert_name = "chef-#{client_name}"
if result.rassoc("#{cert_name}")
subject = "CN=#{cert_name}"
public_key: "",
file_path = File.join(@tmpdir, "#{node}.pem")
File.open(file_path, "w") { |f| f.write expiring_cert.key.to_pem }
cert_list = client.get(base_url + "/clients/#{node}/keys")
client.post(base_url + "/clients/#{node}/keys", payload)
cert_hash = cert_list.reduce({}, :merge!)
File.open(file_path, "w") { |f| f.write new_key }
client.delete(base_url + "/clients/#{node}/keys/#{old_cert_name}")
File.open(tempfile, "wb") { |f| f.print new_pfx.to_der }
File.open(path, "w+") do |file|
!File.exists?(path) || (Dir.entries(path).size <= 2)
object.is_a?(Array) ? index == object.size - 1 : true
logger.trace "Loading from cookbook_path: #{cookbook_paths.map { |path| File.expand_path(path) }.join(", ")}"
return "" if parts.length == 0
parts = parts.map { |part| part.gsub(/^#{regexp_path_separator}+|#{regexp_path_separator}+$/, "") }
result = parts.select { |part| part != "" }.join("/")
absolute ? "/#{result}" : result
!!(path =~ /^#{regexp_path_separator}/)
ChefUtils.windows? ? left.casecmp(right) == 0 : left == right
@cache = {}
if @cache.key?(path)
if !parent.nil? && @cache.key?(parent)
!is_dir && name.include?("-")
require_relative "../../path_utils"
@file_path = file_path || "#{parent.file_path}/#{name}"
Chef::Log.error("Could not read #{path_for_printing} into a Chef object: #{$!}")
!name.start_with?(".")
.map { |child_name| make_child_entry(child_name) }
.select { |new_child| new_child.fs_entry_valid? && can_have_child?(new_child.name, new_child.dir?) }
File.exist?(file_path) && (parent.nil? || parent.can_have_child?(name, dir?))
if file_contents && write_pretty_json && File.extname(name) == ".json"
File.open(file_path, "wb") do |file|
Dir.entries(file_path).select { |p| !p.start_with?(".") }
is_dir && !name.start_with?(".")
super("", nil)
@children ||= begin
result += CHILDREN.map { |name| make_child_entry(name) }
result.select { |c| c && c.exists? }.sort_by(&:name)
result = "repository at #{repo_paths.join(", ")}"
result << " (One version per cookbook)"
if paths.any? { |path| !repo_paths.include?(File.dirname(path)) }
if paths.size == 0
dirs = paths.map { |path| AclsDir.new(name, self, path) }
dirs = paths.map { |path| ClientKeysDir.new(name, self, path) }
dirs = paths.map { |path| ClientsDir.new(name, self, path) }
dirs = paths.map { |path| ContainersDir.new(name, self, path) }
dirs = paths.map { |path| CookbooksDir.new(name, self, path) }
dirs = paths.map { |path| DataBagsDir.new(name, self, path) }
dirs = paths.map { |path| GroupsDir.new(name, self, path) }
dirs = paths.map { |path| NodesDir.new(name, self, path) }
dirs = paths.map { |path| PoliciesDir.new(name, self, path) }
dirs = paths.map { |path| RolesDir.new(name, self, path) }
dirs = paths.map { |path| UsersDir.new(name, self, path) }
.select { |child| child && can_have_child?(child.name, child.dir?) }
entries.select { |entry| !(entry.dir? && entry.children.size == 0 ) }
return recursive && name != "." && name != ".."
File.open(file_path, "rb", &:read)
if can_have_child?(name, true) || can_have_child?(name, false)
Chef::ChefFS::FileSystem.copy_to(Chef::ChefFS::FilePattern.new("/#{cookbook_path}"), from_fs, self, nil, { purge: true })
Chef::Log.error("Could not read #{path_for_printing} into a Chef object: #{e}")
Chef::Log.error(e.backtrace.join("\n"))
super.select { |entry| !(entry.dir? && entry.children.size == 0 ) }
if is_dir && !%w{ root_files .. . }.include?(name)
if %w{ .rb .json }.include? File.extname(name)
name = File.basename(name, ".*")
file_path = "#{parent.file_path}/#{name}"
ext = File.exist?(file_path + ".rb") ? ".rb" : ".json"
name += ext
file_path += ext
Chef::Log.trace "BaseFile: got a file path of #{file_path} for #{name}"
File.basename(name, ".*")
File.extname(file_path) == ".json"
File.extname(file_path) == ".rb"
!name.start_with?(".") && (is_json_file? || is_ruby_file?)
name_valid? && exists?
def delete(_)
if name == "organization" && parent.is_a?(AclDir)
@children.find { |child| child.name == name }
root.cannot_be_in_regex ? (name !~ root.cannot_be_in_regex) : true
path_parts = path.split("/")
dir = self
if cause && cause.is_a?(Net::HTTPExceptions) && cause.response.code == "400"
reason ||=
result = @children.find { |child| child.name == name } if @children
@cookbook_name = $1
@version = $2
require_relative "../../../role"
require_relative "../../../node"
require_relative "../../../json_compat"
pth = api_path.start_with?("/") ? api_path : "/#{api_path}"
File.extname(pth).empty? ? pth + ".json" : pth
if $!.response.code == "404"
@api_path = api_path || (parent.api_path == "" ? name : "#{parent.api_path}/#{name}")
@children ||= root.get_json(api_path).keys.sort.map do |key|
elsif $!.response.code == "409"
@children.find { |child| child.name == name } if @children
def api_path(options = {})
policy_datas = {}
get_data =
rest.put("#{api_path}/policies/#{policy_name}", policy_data)
rest.delete("#{api_path}/policies/#{policy_name}")
@children = names.uniq.map { |name| make_child_entry(name, true) }
rest.post(api_path, { "user" => invite })
if File.basename(name, ".*") == "_default"
@children ||= root.get_json(api_path).keys.sort.map { |entry| make_child_entry(entry, true) }
rest.post(api_path, { "name" => name })
pth = "/data_bags/#{parent.name}/#{name}"
@exists = nil
@exists = parent.children.any? { |child| child.name == name }
require_relative "../../../mixin/file_class"
return false if @ruby_only && name !~ /\.rb$/
require_relative "../../../http/simple"
@file = file
require_relative "../../../cookbook_version"
require_relative "../../../cookbook_uploader"
children.find { |child| child.name == name }
def copy_from(other, options = {})
if e.response.code == "500"
is_dir && name.include?("-")
@cookbook_name, dash, @version = name.rpartition("-")
require_relative "../../../server_api"
result = children.find { |child| child.name == name }
result && !!result.dir? == !!is_dir
@org ||= begin
DataBagsDir.new("data_bags", self, "data"),
AclsDir.new("acls", self),
pth = if parent.name == "acls"
names = parent.parent.child(name).children.map { |child| child.dir? ? "#{child.name}.json" : child.name }
@children = names.map { |name| make_child_entry(name, true) }
if name != ""
@path = "/"
if parent_path == "."
@root = root
@a_root = a_root
@b_root = b_root
are_same, a_value, b_value = a.compare_to(b)
are_same, b_value, a_value = b.compare_to(a)
a_value = a.read if a_value.nil?
a_value = :none
b_value = b.read if b_value.nil?
b_value = :none
are_same = (a_value == b_value)
failure = { "src_path" => src_path, "reason" => "Entry #{dest_path} does not exist" }
failure = { "src_path" => src_path, "reason" => e.reason }
ui.warn "#{format_path.call(e.entry)} #{e.reason}." if ui
ui.error "#{format_path.call(e.entry)} failed to #{e.operation}: #{e.message}" if ui
ui.error "#{format_path.call(e.entry)} #{e.reason}." if ui
return false if path == "" # Empty string is not a path
if exact == ".."
@regexp_parts << Regexp.new("^#{regexp}$")
regexp = ""
exact = ""
when "**"
regexp << ".*"
when "*"
when "?"
regexp << "."
regexp << "\\#{part}"
key == "name"
require_relative "../../role"
defaults = {
name, revision_id = $1, $2
revision_id ||= "0.0.0"
require_relative "../../node"
require_relative "../../api_client"
result << "cookbook #{name.inspect}, #{version.inspect}"
def remove_file_extension(name, ext = ".*")
if %w{ .rb .json }.include?(File.extname(name))
normalize({}, entry)
r.to_h
result = ""
result << key
result << " " * key.length
result << " #{k.inspect} => #{v.inspect}\n"
result << ", "
result << "\n"
require_relative "../../data_bag_item"
key == "id"
if entry.respond_to?(:org) && entry.org
def initialize(chef_config = Chef::Config, cwd = Dir.pwd, options = {}, ui = nil)
@chef_fs ||= create_chef_fs
@local_fs ||= create_local_fs
return "/"
@base_path ||= server_path(@cwd)
return "."
@object_paths ||= begin
get_content = (output_mode != :name_only && output_mode != :name_status)
if output_mode != :name_only && output_mode != :name_status
next if diff_filter && diff_filter !~ /T/
yield "#{new_path}\n"
yield "T\t#{new_path}\n"
next if diff_filter && diff_filter !~ /D/
yield "D\t#{new_path}\n"
result = "diff --knife #{old_path} #{new_path}\n"
result << "deleted file\n"
result << diff_text(old_path, "/dev/null", old_value, "")
next if diff_filter && diff_filter !~ /A/
yield "A\t#{new_path}\n"
result << "new file\n"
result << diff_text("/dev/null", new_path, "", new_value)
next if diff_filter && diff_filter !~ /M/
yield "M\t#{new_path}\n"
ui.error "#{format_path.call(error.entry)} #{error.reason}." if ui
if old_value == :none
if new_value == :none
if old_value == :none || (old_value.nil? && !old_entry.exists?)
json_object.map { |o| sort_keys(o) }
new_hash = {}
result = result.gsub(/^--- #{old_tempfile.path}/, "--- #{old_path}")
result = result.gsub(/^\+\+\+ #{new_tempfile.path}/, "+++ #{new_path}")
@chef_fs = chef_fs
members << { "user" => { "username" => name } }
invitations << { "username" => name }
if file.is_a?(Hash) && file.key?("checksum")
(value == {} && !%w{dependencies attributes recipes}.include?(key)) ||
(value == "" && %w{source_url issues_url}.include?(key)) ||
(value == false && key == "privacy")
raise "set only works with strings: #{path} = #{data.inspect}"
.map { |name, version| version }
name_version = entry_name.split("-")
_to_chef_fs_path(path).join("/")
if path.length >= 3
if path.length == 2
if path.length == 3 || path == %w{acls organization}
if path.size == 2
path << "keys"
if path.length >= 2
path = _to_chef_fs_path(path)
elsif create || path.size == 1
Chef::Log.warn("Removing item #{item}")
parts = item.split("/")
new_data = {}
require_relative "../../chef"
short: "-d",
long: "--daemonize",
proc: lambda { |p| true }
if !Chef::Config.key?(:cookbook_path) && !Chef::Config.key?(:chef_repo_path)
proc: lambda { |wait| /^\d+$/.match?(wait) ? wait.to_i : true }
proc: lambda { |items|
items = items.split(",")
if Chef::Config.local_mode && !Chef::Config.key?(:cookbook_path) && !Chef::Config.key?(:chef_repo_path)
long: "--once",
long: "--force-logger",
long: "--force-formatter",
long: "--log_level LEVEL",
proc: lambda { |l| l.to_sym }
long: "--user USER",
proc: lambda { |s| s.to_i }
short: "-f",
short: "-W",
long: "--why-run",
long: "--minimal-ohai",
long: "--ez",
proc: lambda { |target|
long: "--disable-config",
short: "-A",
long: "--legacy-mode",
short: "-R",
long: "--local-mode",
long: "--chef-zero-host HOST",
long: "--chef-zero-port PORT",
trap("USR1") do
Chef::Application.fatal!("#{e.class}: #{e.message}", e)
uri = URI.parse(url)
elsif uri.scheme == "s3"
File.open(path, "wb") do |f|
URI.open(url) do |r|
Chef::Log.error("#{e.class}: #{e}")
Chef::Log.trace("#{e.class}: #{e}\n#{e.backtrace.join("\n")}")
long: "--stdin",
long: "--yaml",
recipe = Chef::Recipe.new("(#{ChefUtils::Dist::Apply::EXEC} cookbook)", "(#{ChefUtils::Dist::Apply::EXEC} recipe)", run_context)
if cli_arguments.is_a?(Array) &&
(cli_arguments.empty? || cli_arguments.all? { |file| File.file?(file) } )
cli_arguments.select { |file| !File.file?(file) }.join('", "') + '"')
when :win_evt, "win_evt"
$0 = "#{client_solo} worker: ppid=#{Process.ppid};start=#{Time.new.strftime("%R:%S")};"
message = "#{e.class}: #{e}\n#{e.backtrace.join("\n")}"
cause = e.cause if e.respond_to?(:cause)
message << "\n\n>>>> Caused by #{cause.class}: #{cause}\n#{cause.backtrace.join("\n")}"
cause = cause.respond_to?(:cause) ? cause.cause : nil
def fatal!(msg, err = nil)
msg << "\n#{err.backtrace.join("\n")}"
def exit!(msg, err = nil)
n = from_hash(n) if n.instance_of?(Hash)
response = http_api.get("clients/#{name}")
chef_rest_v1.delete("clients/#{@name}")
payload = { name: name }
retries -= 1
Chef::Log.warn("Response: HTTP #{e.response.code} - #{e}")
if (File.exist?(abs_path) && !File.writable?(abs_path)) || !File.writable?(File.dirname(abs_path))
response = http_api.put("clients/#{name}", put_data)
base_put_data = { name: name, admin: false }
post_data = { name: name, admin: false }
api_version: "0",
n = json_create(n) if n.instance_of?(Hash)
http_api.delete("clients/#{@name}")
http_api.put("clients/#{name}", { name: name, admin: admin, validator: validator })
( max_nesting.nil? || rec.nesting_level <= max_nesting ) &&
( rec.status == :up_to_date && up_to_date ||
rec.status == :skipped && skipped ||
rec.status == :updated && updated ||
rec.status == :failed && failed ||
let(:knife) { Chef::Knife.new }
let(:config_location) { File.expand_path("~/.chef/config.rb") }
chef_config_dir: "/etc/chef")
{ "Accept" => "application/json",
let(:request_id) { "1234" }
let(:request_mock) { {} }
let(:url) { URI.parse("https://api.opscode.piab") }
http_response = Net::HTTPSuccess.new("1.1", "200", "successful rest req")
let(:body) { "ninja" }
extra_opts = {}
default: "/usr/bin/vim" }
expect { Chef::Knife.run(%w{fuuu uuuu fuuuu}) }.to raise_error(SystemExit) { |e| expect(e.status).not_to eq(0) }
deps { other_deps_loaded = true }
let(:fake_config) { "/does/not/exist/knife.rb" }
knife.ui = Chef::Knife::UI.new(stdout, stderr, stdin, {})
let(:stdin) { StringIO.new }
let(:ui) { Chef::Knife::UI.new(stdout, stderr, stdin, disable_editing: true) }
cmd.ui = ui
let(:knife) {
let(:ui) { Chef::Knife::UI.new(stdout, stderr, stdin, {}) }
knife.ui = ui
response = Net::HTTPForbidden.new("1.1", "403", "Forbidden")
response = Net::HTTPBadRequest.new("1.1", "400", "Bad Request")
response = Net::HTTPBadGateway.new("1.1", "502", "Bad Gateway")
expect(stderr.string).to match(/ERROR: Network Error: .* - y u no shut up/)
let(:knife) { Chef::Knife::UserShow.new }
let(:user_mock) { double("user_mock") }
let(:root_rest) { double("Chef::ServerAPI") }
@user_name = "foobar"
@password = "abc123"
@user = double("Chef::User")
@org_name = "abc_org"
knife.name_args << @user_name << @org_name
@org = double("Chef::Org")
let(:orgs) do
let(:user_mock) { double("user_mock", private_key: "private_key") }
@knife.name_args << @user_name << @password
expect(@user.root_rest).to receive(:put).with("users/#{@user_name}", result)
let(:knife) { Chef::Knife::UserList.new }
let(:knife) { Chef::Knife::UserEdit.new }
data = { "username" => "my_user2" }
edited_data = { "username" => "edit_user2" }
let(:non_admin_member_org) { Chef::Org.new("non-admin-member") }
let(:solo_admin_member_org) { Chef::Org.new("solo-admin-member") }
let(:username) { "test_user" }
let(:knife) { Chef::Knife::UserDelete.new }
{ "organization" => { "name" => "solo-admin-member" } },
{ "organization" => { "name" => "shared-admin-member" } },
let(:knife) { Chef::Knife::UserCreate.new }
let(:chef_root_rest_v0) { double("Chef::ServerAPI") }
let(:fieldname) { "username" }
let(:name_args) { %w{some_user some_display_name} }
let(:fieldname) { "first name" }
let(:fieldname) { "last name" }
let(:fieldname) { "email" }
@username = "Created #{name_args.first}"
@uri = "http://www.example.com/1"
let(:request_body) {
{ user: "some_user" }
let(:name_args) { %w{some_user} }
@node.tags << "sadtag" << "happytag"
exception = double('403 "Forbidden"', code: "403")
if File.exist?("/usr/bin/gnutar") || File.exist?("/bin/gnutar")
expect(args.to_s).to match(/tar -czf/)
@knife.config = { dry_run: true }
expect(@knife).to receive(:shell_out!).with("footar -czf #{@cookbook.name}.tgz #{@cookbook.name}", { cwd: "/var/tmp/dummy" })
expect(@knife).to receive(:shell_out!).with("footar -tzf #{@cookbook.name}.tgz", { cwd: "/var/tmp/dummy" })
let(:noauth_rest) { double("no auth rest") }
{ "cookbook_name" => "mw_mysql", "cookbook_maintainer" => "car", "cookbook_description" => "Installs/Configures mw_mysql", "cookbook" => "https://supermarket.chef.io/api/v1/cookbooks/mw_mysql" },
expect(stdout.string).to eq("\n")
{ "cookbook_name" => "301", "cookbook_maintainer" => "markhuge", "cookbook_description" => "Installs/Configures 301", "cookbook" => "https://supermarket.chef.io/api/v1/cookbooks/301" },
{ "cookbook_name" => "3cx", "cookbook_maintainer" => "obay", "cookbook_description" => "Installs/Configures 3cx", "cookbook" => "https://supermarket.chef.io/api/v1/cookbooks/3cx" },
describe "with -w or --with-uri" do
let(:downloader) { {} }
let(:repo) do
knife.config = {}
knife.name_args = %w{foo bar baz}
end # end of run
.with("#{@cookbook_api_url}/apache2")
.with(/use --force.+download.+/i)
@cookbook_data = { "version" => @version,
context "with -f or --file" do
.with("#{@cookbook_api_url}/apache2/versions/#{@version_us}")
node = Chef::Node.new.tap do |n|
expect(@query).to receive(:search).with(:node, "*:*", opts)
expect(@query).to receive(:search).with(:node, "*:*", {})
expect(@stdout.string.match(/\e.*ago/)).to be_nil
let(:stdout_io) { StringIO.new }
let(:stderr_io) { StringIO.new }
let(:name_args) { %w{https://example.test:10443/foo} }
let(:name_args) { %w{foo.test} }
expected_stdout = <<~E
expected_stderr = <<~E
let(:name_args) { %w{ftp://lkj\\blah:example.com/blah} }
it "normalizes '*' to 'wildcard'" do
describe "#cn_of" do
let(:name_args) { %w{https://foo.example.com:8443} }
puts "OUT: #{stdout_io.string}"
puts "ERR: #{stderr_io.string}"
let(:name_args) { %w{http://foo.example.com} }
let(:store) { OpenSSL::X509::Store.new }
let(:trusted_certs_dir) { File.join(CHEF_SPEC_DATA.tr("/", "\\"), "trusted_certs") }
.with("foo.example.com", 8443)
trap(:INT, @old_signal)
.with("foo.example.com") # no error
@knife = Chef::Knife::Ssh.new
@node_foo = {}
@node_bar = {}
expect(@knife.get_ssh_attribute({ "fqdn" => "fqdn" })).to eq("fqdn")
ssh_config = { timeout: 50, user: "locutus", port: 23, keepalive: true, keepalive_interval: 60 }
@knife.config = {}
let(:session) { double(:session, loop: nil, close: nil) }
let(:command) { "false" }
let(:exit_status) { 0 }
let(:exit_status2) { 0 }
let(:exit_status) { 1 }
let(:exit_status2) { 2 }
let(:exit_code) { 1 }
let(:exit_code) { 0 }
let(:role) { "base" }
let(:role_mock) { double("role_mock") }
fake_role_contents = { "foo" => "bar", "baz" => "qux" }
let(:role) {}
@knife.config = {
@role.name("will")
@list = {
@knife.name_args = %w{will QA}
expect(@role.active_run_list_for("QA")).to eq("QA")
@roles = {}
k = Chef::Knife::Raw.new
{ "Content-Type" => "application/json",
let(:org) { double("Chef::Org") }
@org_name = "foobar"
@knife.name_args << @org_name
let(:knife) { Chef::Knife::OrgEdit.new }
original_data = { "org_name" => "my_org" }
data = { "org_name" => "my_org1" }
@org_name = "ss"
name: @org_name,
@knife.name_args << @org_name << @org_full_name
@knife.name_args = %w{adam blork}
let(:bootstrap_cli_options) { %w{ } }
let(:bootstrap_cli_options) { %w{ adam staging my-app } }
let(:bootstrap_cli_options) { %w{ adam staging } }
let(:bootstrap_cli_options) { %w{ adam my-app } }
@knife.name_args = %w{adam bar}
editor: "cat",
@node.automatic_attrs = { go: :away }
@node.default_attrs = { hide: :me }
@node.override_attrs = { dont: :show }
@node.normal_attrs = { do_show: :these }
@knife.name_args = %w{ adam ben }
@ben_node = Chef::Node.new
@nodes = {}
expected = @nodes.inject({}) do |inflatedish, (name, uri)|
let(:actor) { "charmander" }
let(:keyname) { "charmander" }
let(:ui) { instance_double("Chef::Knife::UI") }
let(:actor_field_name) { "user" }
let(:list_method) { :list_by_user }
{ "uri" => "https://api.opscode.piab/users/charmander/keys/non-expired1", "name" => "non-expired1", "expired" => false },
{ "uri" => "https://api.opscode.piab/users/charmander/keys/non-expired2", "name" => "non-expired2", "expired" => false },
let(:list_method) { :list_by_client }
{ "uri" => "https://api.opscode.piab/organizations/pokemon/clients/charmander/keys/non-expired1", "name" => "non-expired1", "expired" => false },
{ "uri" => "https://api.opscode.piab/organizations/pokemon/clients/charmander/keys/non-expired2", "name" => "non-expired2", "expired" => false },
let(:keyname) { "charmander-key" }
let(:new_keyname) { "charizard-key" }
let(:actor_field_name) { "client" }
let(:key_name) { "charmander-key" }
allow(@knife).to receive(:config).and_return({ all: true })
@constraints = {
@cookbooks = { "foo" => "= 1.0.1", "bar" => "= 0.0.1" }
@rest_double = double("rest")
@cookbook_data = {}
expect(@stdout.string).to(match(/#{item}/)) && expect(@stdout.string.lines.count).to(be 4)
describe "with -a or --all" do
let(:bag_name) { "sudoing_admins" }
let(:item_name) { "ME" }
{ "id" => "id", "baz" => "http://localhost:4000/data/bag_o_data/baz",
let(:config) { { format: "json" } }
let(:db_folder) { File.join(tmp_dir, data_bags_path, bag_name) }
let(:db_folder2) { File.join(tmp_dir, data_bags_path, bag_name2) }
def new_bag_expects(b = bag_name, d = plain_data)
let(:loader) { double("Knife::Core::ObjectLoader") }
let(:data_bags_path) { "data_bags" }
let(:bag_name2) { "sudoing_admins2" }
let(:raw_hash) { { "login_name" => "alphaomega", "id" => "item_name" } }
let(:db) { Chef::DataBagItem.from_hash(raw_hash) }
let(:raw_edited_hash) { { "login_name" => "rho", "id" => "item_name", "new_key" => "new_value" } }
let(:is_encrypted?) { false }
let(:data_to_edit) { db.raw_data }
let(:config) { { print_after: true } }
let(:is_encrypted?) { true }
let(:data_to_edit) { raw_hash }
let(:raw_hash) { { "login_name" => "alphaomega", "id" => item_name } }
expect(rest).to receive(:get).with("data/#{bag_name}")
expect(rest).to_not receive(:post).with("data", { "name" => bag_name })
.with("data/#{bag_name}")
.with("data/sudoing_#{name}_admins")
expect(rest).to receive(:post).with("data", { "name" => bag_name })
let(:bag_name) { name }
it "creates a data bag named '#{name}'" do
expect(rest).to receive(:post).with("data", { "name" => bag_name }).ordered
let(:chef_config) { Chef::Config.save } # "dup" to a hash
let(:mock_cert_dir) { ::File.absolute_path(::File.join("spec", "assets", "fake_trusted_certs")) }
let(:crt_files) { ::Dir.glob(::File.join(mock_cert_dir, "*.crt")) }
let(:pem_files) { ::Dir.glob(::File.join(mock_cert_dir, "*.pem")) }
let(:other_files) { ::Dir.glob(::File.join(mock_cert_dir, "*")) - crt_files - pem_files }
echo_file = ::File.read(f).gsub(/^/, "echo.")
expect(bootstrap_context.get_log_location).to eq("\"C:\\chef\\chef.log\"\n")
cache_options: ({ path: "c:/chef/cache/checksums", skip_expires: true })
chef-client -c C:\\chef\\client.rb -j C:\\chef\\first-boot.json
let(:config) { { channel: "stable" } }
let(:config) { { channel: "current" } }
let(:custom_url) { "file://something" }
let(:config) { { msi_url: custom_url, install: true } }
yes: nil,
field_separator: ".",
@ui = Chef::Knife::UI.new(@out, @err, @in, @config)
ruby_for_json = { "foo" => "bar" }
ruby_from_editor = TestObject.from_hash({ "bar" => "foo" })
my_editor = "veeeye"
temp_path = "/tmp/bar/baz"
let(:parse_output) { false }
let(:klass) { nil }
let(:parse_output) { true }
let(:klass) { TestObject }
@mock = double("Tempfile")
expect(@ui).to receive(:system).with("#{my_editor} #{temp_path}").and_return(true)
expect(@ui).to receive(:system).with("#{my_editor} #{temp_path}").and_return(nil)
expect(@ui).to receive(:system).with("#{my_editor} #{temp_path}").and_return(false)
expect(@ui).to receive(:system).with("#{my_editor} #{@tempfile.path}").and_return(true)
expect(@ui.format_list_for_display({ marcy: :playground })).to eq({ marcy: :playground })
expect { @ui.send(method, "hi") }.to raise_error(Errno::EIO)
expect { @ui.send(method, "hi") }.to raise_error(SystemExit)
expect { @ui.send(method, "hi") }.to raise_error(Errno::EPIPE)
@ui.output("hi")
expect(@out.string).to eq("hi\n")
@ui.output({ "hi" => "a", "lo" => "b" })
expect(@out.string).to eq <<~EOM
hi: a
lo: b
@ui.output({})
expect(@out.string).to eq("\n")
@ui.output(%w{a b})
expect(@out.string).to eq("a\n")
a: b
c: d
x: y
m: n
o: p
a:
b: c
a: foo
@ui.output({ "a" => %w{foo bar}, "b" => "c" })
@ui.output({ "a" => { "aa" => "bb", "cc" => "dd" }, "b" => "c" })
aa: bb
cc: dd
@ui.output({ "a" => {}, "b" => "c" })
input = { gi: :go }
input = { "gi" => { "go" => "ge" }, "id" => "sample-data-bag-item" }
expect(@ui.format_for_display(input)).to eq({ "sample-data-bag-item" => { "gi.go" => "ge" } })
input = { "gi" => "go", "hi" => "ho", "id" => "sample-data-bag-item" }
expect(@ui.format_for_display(input)).to eq({ "sample-data-bag-item" => { "gi" => "go", "hi" => "ho" } })
input = { "keys" => "values", "hi" => "ho", "id" => "sample-data-bag-item" }
expect(@ui.format_for_display(input)).to eq({ "sample-data-bag-item" => { "keys" => "values" } })
input = { "keys" => { "keys" => "values" }, "hi" => "ho", "id" => "sample-data-bag-item" }
expect(@ui.format_for_display(input)).to eq({ "sample-data-bag-item" => { "keys.keys" => "values" } })
expect(@ui.format_for_display(input)).to eq( { "chef.localdomain" => { "name" => "chef.localdomain" } })
expect(@ui.format_for_display(input)).to eq( { nil => { "class" => "classy!" } } )
expect(@ui.format_for_display(input)).to eq( { nil => { "array.1" => "one" } } )
expect(@ui.format_for_display(input)).to eq({ "sample-data-bag-item" => { non_existing_path => nil } })
input = { "keys" => { "with spaces" => { "open" => { "doors" => { "with many.dots" => "when asked" } } } } }
expect(@ui.format_for_display(input)).to eq({ nil => { "keys;with spaces;open;doors;with many.dots" => "when asked" } })
@item = {
{ "version" => "3.0.0", "url" => "http://url/cookbooks/3.0.0" },
{ "version" => "2.0.0", "url" => "http://url/cookbooks/2.0.0" },
{ "version" => "1.0.0", "url" => "http://url/cookbooks/1.0.0" },
response = {
stdout = double("StringIO", tty?: true)
context "when ui.color? => true" do
context "when ui.color? => false" do
expect(@ui.color("a_bus_is", :yellow)).to eql("a_bus_is")
let(:output) { stdout.string }
let(:question) { "monkeys rule" }
let(:answer) { "y" }
let(:default_choice) { nil }
end.to raise_error(SystemExit) { |e| expect(e.status).to eq(3) }
let(:default_choice) { true }
let(:answer) { "" }
let(:answer) { "N" }
let(:default_choice) { false }
let(:answer) { "Y" }
%w{Y y}.each do |answer|
let(:answer) { answer }
%w{N n}.each do |answer|
describe "with --y or --yes passed" do
expect(output).to eq("")
allow(@ui).to receive(:stdin).and_return(StringIO.new(" \n"))
let(:plugin_dir) { File.join(home, ".chef", "plugins", "knife") }
allow(File).to receive(:read).with(File.join(home, ".chef", "plugin_manifest.json")).and_return("{ \"_autogenerated_command_paths\": {}}")
{ "name" => "test_node",
let(:node) { Chef::Node.from_hash(node_data) }
let(:ui) { double "ui" }
let(:base_config) { { editor: "cat" } }
data = subject.view.merge("name" => "foo_new_name_node")
data = updated_data.merge("bad_property" => "bad_value")
let(:env_home) { "/home/alice" }
let(:manifest_path) { env_home + "/.chef/plugin_manifest.json" }
files_count = Dir.glob(File.join(@cookbook_repo, cookbook.name.to_s, "**", "*"), File::FNM_DOTMATCH).count { |file| File.file?(file) }
response = Net::HTTPResponse.new("1.0", "200", "OK")
post = Net::HTTP::Post.new(@uri, {})
put = Net::HTTP::Put.new(@uri, {})
subject.make_request(:put, @uri, "bill", @secret_filename, {
content = @file.read(4)
@str = "What a boring string"
@string1 = "stream1"
@string2 = "stream2"
dst_buf = ""
@ui = Chef::Knife::UI.new(@stdout, @stderr, @stdin, {})
allow(::File).to receive(:directory?).with(/.*\.git/).and_return(false)
@nobranches = Mixlib::ShellOut.new.tap { |s| s.stdout.replace "\n" }
@clean_status = Mixlib::ShellOut.new.tap { |s| s.stdout.replace("\n") }
expect(@cookbook_repo).to receive(:shell_out!).with("git commit -m \"Import apache2 version 1.2.3\" -- apache2", cwd: @repo_path)
let(:config) { { foo: :bar, color: true } }
let(:secret) { nil }
let(:config) { { verbosity: 2, color: true } }
it "adds '-l debug' when verbosity is >= 2" do
let(:config) { { color: false } }
it "adds '--no-color' when color is false" do
let(:chef_config) { { chef_license: "accept-no-persist" } }
let(:chef_config) { { unix_bootstrap_file_cache_path: "/home/opscode/cache" } }
let(:chef_config) { { chef_client_path: "/usr/local/bin/chef-client" } }
let(:chef_config) { { validation_key: "~/my.key" } }
let(:config) { { chef_node_name: "foobar.example.com" } }
let(:config) { { environment: "prodtastic", color: true } }
let(:config) { { first_boot_attributes: { baz: :quux } } }
let(:config) { { policy_name: "my_app_server", policy_group: "staging" } }
let(:secret) { "supersekret" }
let(:config) { { node_ssl_verify_mode: "none" } }
let(:config) { { node_verify_api_cert: true } }
let(:chef_config) { { config_log_location: nil } }
let(:chef_config) { { config_log_location: "" } }
let(:chef_config) { { config_log_location: :win_evt } }
let(:chef_config) { { config_log_location: :syslog } }
let(:chef_config) { { config_log_location: STDOUT } }
let(:chef_config) { { config_log_location: STDERR } }
let(:chef_config) { { config_log_location: "/tmp/ChefLogFile" } }
let(:config) { { bootstrap_version: "awesome" } }
let(:config) { { channel: "unstable" } }
{ cookbook.name => cookbook }
let(:output) { StringIO.new }
.with( kind_of(Array), { force: nil, concurrency: 3 })
{ "test_cookbook" => cookbook,
knife.ui = Chef::Knife::UI.new(@stdout, @stderr, @stdin, {})
expect(@stderr.string).not_to include("'dependency' version '>= 0.0.0'")
expect(@stderr.string).not_to include("'dependency2' version '>= 0.0.0'")
expect(@stderr.string).to include("'dependency' version '>= 0.0.0'")
expect(@stderr.string).to include("'dependency2' version '>= 0.0.0'")
end # run
let(:cb) do
let(:rest) { double(Chef::ServerAPI) }
let(:content) { "Example recipe text" }
{ "version" => "0.10.0", "url" => "http://url/cookbooks/cookbook_name/0.10.0" },
{ "version" => "0.9.0", "url" => "http://url/cookbookx/cookbook_name/0.9.0" },
{ "version" => "0.8.0", "url" => "http://url/cookbooks/cookbook_name/0.8.0" },
knife.name_args << "0.1.0"
{ "cookbook_name" => "cookbook_name",
cb.manifest = {
Dir.mkdir("#{cookbook_dir}/#{name}")
File.open("#{cookbook_dir}/#{name}/metadata.rb", "w+") do |f|
f.puts "#{key} #{value.map { |v| "\"#{v}\"" }.join(", ")}"
f.puts "#{key} \"#{value}\""
File.open("#{cookbook_dir}/#{name}/metadata.json", "w+") do |f|
File.open("#{cookbook_dir}/foobar/metadata.json", "w+") do |f|
{ "version": "1.0.0", {ImInvalid}}
create_metadata_rb(name: "foo", version: "1.0.0")
create_metadata_rb(name: "bar", version: "2.0.0")
create_metadata_rb(name: "foobar", version: "1.0.0")
create_metadata_json(name: "foobar", version: "1.0.0", dependencies: { "foo:bar" => ">> 0.2" })
create_metadata_rb(name: "sounders", version: "2.0.0", beats: "toronto")
if File.exist?(@tgt)
expect(File).to receive(:open).with(@tgt, "w")
@rest_mock = double("rest")
expect(@stdout.string).to match(/#{item}\s+1\.0\.1/)
expect(@stdout.string).to match(/#{item}\s+1\.0\.1\s+1\.0\.0/)
cb.version = "1.0.0"
@knife.name_args << "1.0.0"
@files_mocks = {}
@files.map { |f| File.basename(f) }.flatten.uniq.each do |f|
expect(@knife.ui).to receive(:fatal).with(%r{/var/tmp/chef/foobar-1\.0\.0 exists}i)
@files.map { |f| File.dirname(f) }.flatten.uniq.each do |dir|
expect(FileUtils).to receive(:mkdir_p).with("/var/tmp/chef/foobar-1.0.0/#{dir}")
.at_least(:once)
@files.each do |f|
.with("/var/tmp/#{File.basename(f)}", "/var/tmp/chef/foobar-1.0.0/#{f}")
describe "with -f or --force" do
expect(@knife.version).to eq("1.0.0")
describe "with -N or --latest" do
expect(@knife.version.to_s).to eq("2.0.0")
.with("foobar")
Chef::Version.new("1.1.0"),
prompt = /Which version do you want to download\?.+1\. foobar 1\.0\.0.+2\. foobar 1\.1\.0.+3\. foobar 2\.0\.0.+/m
describe "with -p or --purge" do
.with(/.+Are you sure you want to purge files.+/)
@knife.version = "1.0.0"
{ "version" => "1.1.0" },
prompt = /Which version\(s\) do you want to delete\?.+1\. foobar 1\.0\.0.+2\. foobar 1\.1\.0.+3\. foobar 2\.0\.0.+4\. All versions.+/m
object = ""
@knife.config = { print_after: nil }
@cookbooks = {}
{ "cheezburger" => "1.0.0", "pizza" => "2.0.0", "lasagna" => "3.0.0" }.each do |cookbook_name, version|
@rest_client = double("null rest client", post: { result: :true })
@in = StringIO.new("\n" * 7)
let(:fqdn) { "foo.example.org" }
let(:ohai) do
o = {}
let(:default_admin_key) { "/etc/chef-server/admin.pem" }
let(:default_server_url) { "https://#{fqdn}/organizations/myorg" }
expect(@out.string).to match(/\s*/)
allow(File).to receive(:expand_path).with("/home/you/.chef/#{Etc.getlogin}.pem").and_return("/home/you/.chef/#{Etc.getlogin}.pem")
expect(config_file.string).to match(/^client_name\s+=\s+'#{Etc.getlogin}'$/)
expect(config_file.string).to match(%r{^client_key\s+=\s+'/home/you/.chef/#{Etc.getlogin}.pem'$})
expect(config_file.string).to match(/^chef_server_url\s+=\s+'#{default_server_url}'$/)
expect(::File).to receive(:open).with("/home/you/.chef/credentials", "w")
expect(File).to receive(:open).with("/home/bob/.chef/client.rb", "w")
fake_client_contents = { "foo" => "bar", "baz" => "qux" }
@client_mock = double("client_mock", private_key: "foo_key")
let(:data) do
let(:clients) { %w{ adam ben charlie } }
let(:tmpdir) { Dir.mktmpdir }
let(:file_path) { File.join(tmpdir, "client.pem") }
let(:dir_path) { File.dirname(file_path) }
let(:fieldname) { "client name" }
describe "with -f or --file" do
let(:stdout) { stdout_io.string }
let(:stderr) { stderr_io.string }
let(:option_args) { {} }
let(:knife_confirm) { true }
clients = {}
let(:option_args) { { delete_validators: true } }
let(:linux_test) { true }
let(:windows_test) { false }
let(:linux_test) { false }
let(:unix_test) { false }
let(:ssh_test) { false }
let(:builtin_template_path) { File.expand_path(File.join(__dir__, "../../../lib/chef/knife/bootstrap/templates", "example.erb")) }
File.open(file.path, "w") { |f| f.puts '{"foo":{"bar":"baz"}}' }
it "should have foo => {bar => baz} in the first_boot from cli" do
it "should have foo => {bar => baz} in the first_boot from file" do
allow(::File).to receive(:read).and_return('{ "foo" : "bar" }')
expect(knife.render_template).to match(/\{\"foo\":\"bar\"\}/)
let(:setting) { "api.opscode.com" }
let(:setting) { "api.opscode.com,172.16.10.*" }
expect(rendered_template).to match(/.*no_proxy\s*"api.opscode.com,172.16.10.\*".*/)
File.join(__dir__, "../../data/client.d_00")
expect(rendered_template).to match("something '\\\\''/foo/bar'\\\\''")
expect(rendered_template).to match("cat > /etc/chef/client.d/00-foo.rb <<'EOP'")
let(:host_descriptor) { "example.com" }
let(:host_descriptor) { "winrm://myhost" }
let(:config) { { connection_protocol: "winrm" } }
let(:host_descriptor) { "ssh://example.com" }
it "falls back to 'ssh'" do
let(:connection_protocol) { "ssh" }
it "returns true for #{proto}" do
let(:bootstrap_cli_options) { %w{ --policy-name my-app-server } }
let(:bootstrap_cli_options) { %w{ --policy-group staging } }
let(:bootstrap_cli_options) { %w{ --policy-name my-app --policy-group staging } }
{ base_opts: true,
ca_trust_path: "trust.me",
user: "winbob",
ssl: true,
ca_trust_path: "no trust",
port: 12,
user: "clippy",
user: "sshbob",
user: "sshalice", # cli
password: "feta cheese", # cli
sudo: true, # ccli
port: 12, # cli
user: "sshroot",
bastion_user: "me",
sudo_options: "-H",
end # ssh
port: 250,
user: "test",
expect(knife.host_verify_opts).to eq( { verify_host_key: "always" } )
expect(knife.sudo_opts).to eq({})
expect(knife.sudo_opts).to eq( { sudo: true } )
expect(knife.sudo_opts).to eq( { sudo: false } )
expect(knife.ssh_opts).to eq({})
expected.merge({ ssl: true })
expected.merge({ ca_trust_path: "/trust.me" })
let(:node_name) { nil }
.with("/path.sh")
.and_return("sh /path.sh")
.with("sh /path.sh")
.and_yield("output here", nil)
.and_return("su - USER -c 'sh /path.sh'")
.with("su - USER -c 'sh /path.sh'")
expect(knife).to receive(:do_connect).with( { opts: "here" } )
let(:expected_error) { Train::Error.new("fingerprint AA:BB is unknown for \"blah,127.0.0.1\"") }
.with(/.*host 'blah \(127.0.0.1\)'.*AA:BB.*Are you sure you want to continue.*/m)
e = Train::Error.new
let(:windows_test) { true }
let(:temp_dir) { "C:/Temp/bootstrap" }
let(:temp_dir) { "/tmp/bootstrap" }
it "is chef-full" do
knife.do_connect({})
expect { knife.do_connect({}) }.not_to raise_error
let(:session_timeout) { 60 }
let(:session_timeout) { nil }
let(:session_timeout) { 16 }
let(:session_timeout) { 15 }
let(:protocol) { "mock" }
let(:family) { "unknown" }
let(:release) { "unknown" } # version
let(:name) { "unknown" }
let(:arch) { "x86_64" }
let(:connection_opts) { {} } # connection opts
let(:host_url) { "mock://user1@example.com" }
let(:mock_connection) { true }
let(:family) { "debian" }
let(:name) { "ubuntu" }
let(:family) { "os" }
let(:name) { "mac_os_x" }
let(:family) { "windows" }
let(:name) { "windows" }
let(:protocol) { "ssh" }
let(:host_url) { "mock://user1@localhost:2200" }
let(:connection_opts) { { user: "user2", host: "example.com", port: 15 } }
let(:host_url) { "localhost" }
let(:connection_opts) { { port: 15, user: "user2" } }
let(:host_url) { "127.0.0.1" }
.and_return double("result", stdout: "C:/a/path")
let(:random) { "wScHX6" }
let(:dir) { "/tmp/chef_#{random}" }
expected_command1 = "mkdir -p '#{dir}'"
expected_command2 = "chown user1 '#{dir}'"
.and_return double("result", stdout: "\r\n")
expected_command = "mkdir -p '#{dir}'"
.and_return double("result", stdout: "sudo: unable to resolve host hostname.localhost\r\n" + "#{dir}\r\n")
expect(cmd).to match(/Test-Path "deleteme\.txt".*/)
expect(cmd).to match(/rm -f "deleteme\.txt".*/)
command_result = double("results", stdout: "", stderr: "failed", exit_status: 1)
expect { subject.run_command!("test") }.to raise_error do |e|
expect(e.stdout).to eq ""
let(:chef_config) { {} }
let(:node_name) { "bevell.wat" }
let(:response_404) { OpenStruct.new(code: "404") }
expect(rest).to receive(:get).with("nodes/#{node_name}")
let(:client) { Chef::ApiClient.new }
let(:client_rest) { double("Chef::ServerAPI (client)") }
expect(node).to receive(:normal_attrs=).with({ baz: :quux })
setup_file_contents('{ "vault": "item1" }')
expect { @knife.run }.to raise_error(SystemExit) { |e| expect(e.status).to eq(1) }
with_argv("--user", "adam") do
expect { @knife.run }.to raise_error(SystemExit) { |e| expect(e.status).to eq(2) }
home_path = "~/.chef/client.pem"
with_argv(*%W{noop knife command -k #{home_path}}) do
with_argv(*%W{noop knife command -k #{full_path}}) do
with_argv(*%W{noop knife command -c #{config_file}}) do
$LOAD_PATH.unshift File.expand_path("../../chef-config/lib", __dir__)
$LOAD_PATH.unshift File.expand_path("../../chef-utils/lib", __dir__)
.map { |f| f.gsub("lib/", "") }
.map { |f| f.gsub(/\.rb$/, "") }
client "x", {}
cookbook "x", "1.0.0"
data_bag "x", { "y" => {} }
environment "x", {}
node "x", {}
role "x", {}
user "x", {}
knife("upload /").should_succeed ""
knife("diff --name-status /").should_succeed <<~EOM
file "clients/chef-validator.json", { "validator" => true, "public_key" => ChefZero::PUBLIC_KEY }
file "clients/chef-webui.json", { "admin" => true, "public_key" => ChefZero::PUBLIC_KEY }
file "clients/x.json", { "public_key" => ChefZero::PUBLIC_KEY }
file "cookbooks/x/metadata.rb", cb_metadata("x", "1.0.0")
file "data_bags/x/y.json", {}
file "environments/x.json", {}
file "roles/x.json", {}
file "users/admin.json", { "admin" => true, "public_key" => ChefZero::PUBLIC_KEY }
file "users/x.json", { "public_key" => ChefZero::PUBLIC_KEY }
knife("diff --name-status /").should_succeed ""
knife("upload --purge /").should_succeed ""
file "roles/x.json", { "description" => "blarghle" }
knife("upload --no-diff /").should_succeed ""
knife("diff --name-status /").should_succeed "M\t/roles/x.json\n"
file "roles/x.json", <<~EOM
file "roles/x.rb", <<~EOM
name "x"
knife("diff --name-status /").should_succeed "M\t/roles/x.rb\n"
file "cookbooks/x/metadata.rb", "name 'x'; version '1.0.0'; depends 'x'"
file "clients/y.json", { "public_key" => ChefZero::PUBLIC_KEY }
file "cookbooks/x/blah.rb", ""
file "cookbooks/y/metadata.rb", cb_metadata("y", "1.0.0")
file "data_bags/x/z.json", {}
file "data_bags/y/zz.json", {}
file "environments/y.json", {}
file "nodes/y.json", {}
file "roles/y.json", {}
file "users/y.json", { "public_key" => ChefZero::PUBLIC_KEY }
knife("upload /").should_succeed <<~EOM
knife("upload --no-diff /").should_succeed <<~EOM
knife("upload --purge /").should_fail <<~EOM
cwd "."
file "data_bags/x/y.json", { "foo" => "bar" }
file "data_bags/x/y.json", { "chef_type" => "aaa", "data_bag" => "bbb" }
data_bag "x", { "deleted" => {}, "modified" => {}, "unmodified" => {} }
file "data_bags/x/added.json", {}
file "data_bags/x/modified.json", { "foo" => "bar" }
knife("upload --purge .").should_succeed <<~EOM
knife("upload --purge *").should_succeed <<~EOM
cookbook "x", "1.0.0", { "z.rb" => "" }
file "cookbooks/x/y.rb", "hi"
file "cookbooks/x/metadata.rb", cb_metadata("x", "1.0.0", "#modified")
file "cookbooks/x/z.rb", ""
file "cookbooks/x/metadata.rb", 'name "x"; version "1.0.0"#different'
cookbook "frozencook", "1.0.0", {}, frozen: true
file "cookbooks/x/metadata.json", { name: "x", version: "1.0.0" }
cookbook "x", "1.0.0", { "onlyin1.0.0.rb" => "" }
cookbook "x", "1.0.1", { "onlyin1.0.1.rb" => "hi" }
cookbook "x", "0.9.9", { "onlyin0.9.9.rb" => "hi" }
file "environments/x.json", "{"
error1 = <<~EOH
(right here) ------^
file "environments/x.json", { "name" => "y" }
file "environments/x.json", { "description" => "hi" }
file "data_bags/bag/x.json", { "foo" => "bar" }
file "cookbooks/x-1.0.0/metadata.rb", cb_metadata("x", "1.0.0")
file "cookbooks/x-1.0.0/blah.rb", ""
file "cookbooks/x-2.0.0/metadata.rb", cb_metadata("x", "2.0.0")
file "cookbooks/y-1.0.0/metadata.rb", cb_metadata("y", "1.0.0")
file "cookbooks/x-1.0.0/metadata.rb", cb_metadata("x", "1.0.0", "#modified")
file "cookbooks/x-1.0.0/y.rb", "hi"
knife("upload --purge /cookbooks/x-1.0.0/z.rb").should_fail "ERROR: /cookbooks/x-1.0.0/z.rb cannot be deleted.\n"
file "cookbooks/x-1.0.0/z.rb", ""
file "cookbooks/x-1.0.0/onlyin1.0.0.rb", "old_text"
file "cookbooks/x-1.0.0/metadata.rb", cb_metadata("x", "1.0.0", "\nchef_version '~> 999.0'")
file "users/x.json", { "admin" => true, "json_class" => "Chef::WebUIUser" }
user "foo", {}
user "bar", {}
user "foobar", {}
organization "foo", { "full_name" => "Something" }
group "blah", {}
file "acls/groups/blah.json", {}
file "containers/x.json", {}
file "cookbook_artifacts/x-1x1/metadata.rb", cb_metadata("x", "1.0.0")
file "groups/x.json", {}
file "org.json", { "full_name" => "wootles" }
knife("diff --name-status --diff-filter=AMT /").should_succeed ""
file "org.json", { "full_name" => "Something" }
cookbook_artifact "x", "1x1", "metadata.rb" => cb_metadata("x", "1.0.0")
container "x", {}
group "x", {}
policy "x", "1.0.0", {}
policy "blah", "1.0.0", {}
policy_group "x", {
cookbook_artifact "x", "1x1", { "recipes" => { "default.rb" => "" } }
client "x", { "validator" => true }
cookbook "x", "1.0.0", { "recipes" => { "default.rb" => "" } }
cookbook_artifact "x", "1x1", { "metadata.rb" => cb_metadata("x", "1.0.0") }
data_bag "x", { "y" => { "a" => "b" } }
environment "x", { "description" => "foo" }
file "org.json", { "full_name" => "Something Else" }
org_invite "bar", "foo"
org_member "bar", "foo"
file "members.json", %w{foo bar}
client "x", "{}"
data_bag "x", { "y" => "{}" }
environment "x", "{}"
node "x", "{}"
role "x", "{}"
user "x", "{}"
file "clients/x.json", { "foo" => "bar" }
file "environments/_default.json", { "foo" => "bar" }
file "environments/x.json", { "foo" => "bar" }
file "nodes/x.json", { "foo" => "bar" }
file "roles/x.json", { "foo" => "bar" }
file "users/x.json", { "foo" => "bar" }
name "x"; version "1.0.0"
/data_bags/x/y.json:
knife("show --local /data_bags/x/y.json").should_succeed <<~EOM
knife("show --local /data_bags/x").should_fail "ERROR: /data_bags/x: is a directory\n"
environment "x", {
before { file "environments/x.json", "{" }
exception = $!
file "nodes/a_node_in_json.json", { "foo" => "bar" }
file "nodes/a_node_in_ruby.rb", "name 'a_node_in_ruby'"
file "roles/a_role_in_json.json", { "foo" => "bar" }
file "roles/a_role_in_ruby.rb", "name 'a_role_in_ruby'"
%w{a_node_in_json a_node_in_ruby}.each do |file_type|
%w{a_role_in_json a_role_in_ruby}.each do |file_type|
knife("search node name:snoc").should_fail("", stderr: "0 items found\n\n", exit_code: 1)
role "cons", {}
role "car", {}
role "cdr", {}
role "cat", {}
let(:role_dir) { "#{@repository_dir}/roles" }
file "roles/cons.json", <<~EOM
file "roles/car.json", <<~EOM
file "roles/cdr.json", <<~EOM
knife("role delete car", input: "Y").should_succeed <<~EOM
knife("role bulk delete ^ca.*", input: "Y").should_succeed <<~EOM
@api.get("/roles", 302, nil, { "Content-Type" => "text", "Location" => "#{real_chef_server_url}/roles" }) do
before { role "x", {} }
knife("raw /nodes/x").should_succeed <<~EOM
knife("raw -m DELETE /roles/x").should_succeed <<~EOM
knife("raw -m PUT -i #{file.path} /roles/x").should_succeed <<~EOM
knife("raw -m POST -i #{file.path} /roles").should_succeed <<~EOM
@api.get("/blah", 200, nil, { "Content-Type" => "application/json" }) do
knife("raw /blah").should_succeed <<~EOM
knife("raw --no-pretty /blah").should_succeed <<~EOM
{ "x": "y", "a": "b" }
@api.get("/blah", 200, nil, { "Content-Type" => "text" }) do
knife("raw /blah").should_succeed(<<~EOM)
knife("raw --no-pretty /blah").should_succeed(<<~EOM)
node "cons", {}
node "car", {}
node "cdr", {}
node "cat", {}
let(:node_dir) { "#{@repository_dir}/nodes" }
file "nodes/cons.json", <<~EOM
,
environment "lisp", {}
knife("node delete car", input: "Y").should_succeed <<~EOM
knife("node bulk delete ^ca.*", input: "Y").should_succeed <<~EOM
knife("list /").should_succeed <<~EOM
knife("list -R /").should_succeed <<~EOM
/:
client "client1", {}
client "client2", {}
cookbook "cookbook1", "1.0.0"
cookbook "cookbook2", "1.0.1", { "recipes" => { "default.rb" => "" } }
data_bag "bag1", { "item1" => {}, "item2" => {} }
data_bag "bag2", { "item1" => {}, "item2" => {} }
node "node1", {}
node "node2", {}
policy "policy1", "1.2.3", {}
policy "policy2", "1.2.3", {}
policy "policy2", "1.3.5", {}
role "role1", {}
role "role2", {}
user "user1", {}
user "user2", {}
knife("list -R --flat /").should_succeed <<~EOM
knife("list -Rfp /").should_succeed <<~EOM
it "knife list /cookbooks/*2/*/*.rb returns the one file" do
knife("list /**.rb").should_succeed <<~EOM
knife("list /cookbooks/**.rb").should_succeed <<~EOM
knife("list /**.json").should_succeed <<~EOM
knife("list /data**.json").should_succeed <<~EOM
before { cwd "." }
knife("list -Rfp").should_succeed <<~EOM
before { cwd "cookbooks" }
./
knife("list -Rfp ..").should_succeed <<~EOM
before { cwd "symlinked" }
context "--local" do
knife("list --local /").should_succeed ""
file "metadata.rb", cb_metadata("cookbook1", "1.0.0")
file "metadata.rb", cb_metadata("cookbook2", "2.0.0")
file "recipes/default.rb", ""
file "item1.json", {}
file "item2.json", {}
file "nodes/node1.json", {}
file "nodes/node2.json", {}
file "roles/role1.json", {}
file "roles/role2.json", {}
file "users/user1.json", {}
file "users/user2.json", {}
knife("list -Rp --local --flat /").should_succeed <<~EOM
/acls:
cookbook_artifact "cookbook_artifact2", "2x2", { "recipes" => { "default.rb" => "" } }
group "group1", {}
group "group2", {}
policy_group "policy_group1", { "policies" => { "policy1" => { "revision_id" => "1.2.3" } } }
policy_group "policy_group2", { "policies" => { "policy2" => { "revision_id" => "1.3.5" } } }
/acls/
environment "b", {
b:
environment "b", {}
environment "y", {}
let(:env_dir) { "#{@repository_dir}/environments" }
cwd(".")
let(:out) { "Created bah\n" }
cookbook "blah", "1.0.1"
cookbook "blah", "1.1.1"
cookbook "krad", "1.1.1"
environment "y", {
knife("download --purge /").should_succeed ""
knife("download --no-diff /").should_succeed ""
file "cookbooks/y/metadata.rb", cb_metadata("x", "1.0.0")
knife("download --purge /").should_succeed <<~EOM
knife("download --no-diff /").should_succeed <<~EOM
data_bag "x", { "y" => {}, "z" => {} }
file "data_bags/x/deleted.json", <<~EOM
file "data_bags/x/modified.json", <<~EOM
data_bag "x", {
knife("download --purge .").should_succeed <<~EOM
knife("download --purge *").should_succeed <<~EOM
cookbook "x", "1.0.0", { "metadata.rb" => cb_metadata("x", "1.0.0", "#extra content"), "y.rb" => "hi" }
warning = <<~EOH
file "cookbooks/x-2.0.0/metadata.rb", 'version "2.0.0"'
file "cookbooks/y-1.0.0/metadata.rb", 'version "1.0.0"'
file "cookbooks/x-1.0.0/metadata.rb", 'name "x"; version "1.0.0"#unmodified'
cookbook "x", "1.0.0", { "y.rb" => "hi" }
D\t/cookbooks/x-1.0.0/y.rb
A\t/cookbooks/x-1.0.0/z.rb
}.at_least(:once)
file "clients/x.json", { "validator" => true }
file "cookbooks/x/metadata.rb", cb_metadata("x", "1.0.1")
file "cookbook_artifacts/x-1x1/metadata.rb", cb_metadata("x", "1.0.1")
file "data_bags/x/y.json", { "a" => "b" }
file "environments/x.json", { "description" => "foo" }
file "groups/x.json", { "description" => "foo" }
file "org.json", { "full_name" => "Something Else " }
file "policy_groups/x.json", {
knife("diff /").should_succeed ""
before { cwd "data_bags" }
knife("diff --name-status *").should_succeed <<~EOM
file "cookbooks/x/onlyin1.0.0.rb", ""
cookbook "x", "1.0.1", { "onlyin1.0.1.rb" => "" }
cookbook "x", "0.9.9", { "onlyin0.9.9.rb" => "" }
before { environment "x", {} }
before { environment "x", { "description" => "hi" } }
/)
environment "x", { "description" => "hi" }
environment "x", { "description" => "lo" }
file "clients/y.json", {}
file "users/y.json", {}
file "cookbooks/x-1.0.0/onlyin1.0.0.rb", ""
before { file "environments/x.json", {} }
before { file "roles/starring.json", {} }
file "roles/minor.json", {}
before { file "nodes/mort.json", {} }
file "nodes/mort.json", { "chef_environment" => "desert" }
before { file "data_bags/bag/item.json", {} }
before { file "environments/desert.json", {} }
knife("deps /nodes/*").should_succeed <<~EOM
knife("deps --tree /nodes/*").should_succeed <<~EOM
knife("deps --tree --no-recurse /nodes/*").should_succeed <<~EOM
exit_code: 2,
stdout: "/blah\n",
stdout: "/roles/x.json\n",
stdout: "/nodes/x.json\n",
stdout: "/cookbooks/x\n",
knife("deps /").should_succeed("/\n")
stdout: "/roles\n"
before { file "data_bags/bag/item.json", "" }
before { file "cookbooks/blah/metadata.rb", 'name "blah"' }
before { role "starring", {} }
role "minor", {}
cookbook "quiche", "1.0.0", { "metadata.rb" => %Q{name "quiche"\nversion "1.0.0"\n}, "recipes" => { "default.rb" => "" } }
cookbook "soup", "1.0.0", { "metadata.rb" => %Q{name "soup"\nversion "1.0.0"\n}, "recipes" => { "chicken.rb" => "" } }
before { node "mort", {} }
node "mort", { "chef_environment" => "desert" }
cookbook "kettle", "1.0.0", { "metadata.rb" => %Q{name "kettle"\nversion "1.0.0"\n} }
cookbook "quiche", "1.0.0", { "metadata.rb" => 'name "quiche"
depends "kettle"', "recipes" => { "default.rb" => "" } }
before { data_bag "bag", { "item" => {} } }
before { environment "desert", {} }
knife("deps --remote /nodes/*").should_succeed <<~EOM
knife("deps --remote --tree /nodes/*").should_succeed <<~EOM
knife("deps --remote --tree --no-recurse /nodes/*").should_succeed <<~EOM
cookbook "foo", "1.0.0", { "metadata.rb" => 'name "foo"
depends "bar"' }
cookbook "bar", "1.0.0", { "metadata.rb" => 'name "bar"
depends "baz"' }
cookbook "baz", "1.0.0", { "metadata.rb" => 'name "baz"
depends "foo"' }
cookbook "self", "1.0.0", { "metadata.rb" => 'name "self"
depends "self"' }
knife("deps --remote /").should_succeed("/\n")
knife("deps --remote /roles").should_succeed("/roles\n")
cookbook "blah", "1.0.0", { "metadata.rb" => 'name "blah"' }
knife("deps --no-recurse /").should_fail("ERROR: --no-recurse requires --tree\n")
file "clients/x.json", {}
file "nodes/x.json", {}
file "users/x.json", {}
knife("list -Rf /").should_succeed <<~EOM
knife("list -Rf --local /").should_succeed <<~EOM
data_bag "empty", {}
knife("delete --both /data_bags/x").should_fail <<~EOM
it "knife delete --both -r /data_bags/x deletes x" do
it "knife delete --both / fails" do
knife("delete --both /").should_fail <<~EOM
it "knife delete --both -r /* fails" do
knife("delete --both -r /*").should_fail <<~EOM
knife("delete --both /").should_fail "ERROR: / (remote) cannot be deleted.\nERROR: / (local) cannot be deleted.\n"
file "cookbooks/x/metadata.rb", 'version "1.0.0"'
knife("raw /cookbooks/x").should_succeed(/1.0.0/)
knife("raw /cookbooks/x").should_succeed(/0.9.9/)
before { cookbook "x", "1.0.1", { "onlyin1.0.1.rb" => "hi" } }
before { cookbook "x", "0.9.9", { "onlyin0.9.9.rb" => "hi" } }
cookbook "x", "2.0.11"
cookbook "x", "11.0.0"
knife("raw /cookbooks/x").should_succeed( /2.0.11/ )
policy "x", "1.2.3", {}
policy_group "x", { "policies" => { "x" => { "revision_id" => "1.2.3" } } }
knife("raw /groups/x.json").should_fail(/404/)
let(:right_secret) { "abc" }
let(:wrong_secret) { "ab" }
data_bag "x", {}
data_bag "canteloupe", {}
data_bag "rocket", { "falcon9" => { heavy: "true" }, "atlas" => {}, "ariane" => {} }
data_bag "rocket", {}
let(:db_dir) { "#{@repository_dir}/data_bags" }
data_bag "foo", {}
data_bag "bar", {}
file "data_bags/foo/bar.json", { "id" => "bar", "foo" => "bar " }
file "data_bags/foo/bzr.json", { "id" => "bzr", "foo" => "bar " }
file "data_bags/foo/cat.json", { "id" => "cat", "foo" => "bar " }
file "data_bags/foo/dog.json", { "id" => "dog", "foo" => "bar " }
knife("data bag from file foo #{db_dir}/foo")
let(:secret) { "abc" }
data_bag "bag", { "box" => {} }
pretty_json = Chef::JSONCompat.to_json_pretty({ id: "box", foo: "bar" })
pretty_json = Chef::JSONCompat.to_json_pretty({ id: "box", ab: "abc" })
let(:exists) { "Data bag foo already exists\n" }
pretty_json = Chef::JSONCompat.to_json_pretty({ id: "bar", test: "pass" })
expect(knife("data bag show foo bar --secret #{secret}").stdout).to eq("id: bar\n")
expect(knife("data bag show foo").stderr).to eq("")
expect(knife("data bag show foo").stdout).to eq("bar\n")
expect(knife("data bag show rocket bar --secret #{secret}").stdout).to eq("id: bar\n")
let(:cb_dir) { "#{@repository_dir}/cookbooks" }
knife("cookbook upload x -o #{cb_dir}").should_succeed stderr: <<~EOM
knife("cookbook upload x -o #{cb_dir} --freeze").should_succeed stderr: <<~EOM
knife("cookbook upload x -o #{cb_dir} --freeze").should_fail stderr: <<~EOM
file "cookbooks/x/metadata.rb", cb_metadata("x", "1.0.0", "\ndepends 'y'")
knife("cookbook upload x -o #{cb_dir}").should_fail stderr: <<~EOM
ERROR: The missing cookbook(s) are: 'y' version '>= 0.0.0'
knife("cookbook upload -a -o #{cb_dir}").should_succeed stderr: <<~EOM
file "test_cookbooks/y/metadata.rb", cb_metadata("y", "1.0.0")
cookbook "x", "1.0.0", { "recipes" => { "default.rb" => "file 'n'", "x.rb" => "" } }
cookbook "x", "0.6.5"
x::x: >= 0.0.0
x:
x::x:
cookbook "x", "0.6.0"
cookbook "y", "0.6.5"
cookbook "y", "0.6.0"
cookbook "z", "0.6.5"
cookbook "x", "1.0.1"
knife("cookbook download -d #{tmpdir} x", input: "2\n").should_succeed(stderr: <<~EOM, stdout: "Which version do you want to download?\n1. x 1.0.0\n2. x 1.0.1\n\n"
cookbook "foo", "1.0.0"
cookbook "foo", "0.6.5"
cookbook "fox", "0.6.0"
cookbook "fox", "0.6.5"
cookbook "fax", "0.6.0"
cookbook "zfa", "0.6.5"
stdout = <<~EOM
stderr = <<~EOM
let(:chef_dir) { File.join(__dir__, "..", "..", "..", "knife", "bin") }
let(:knife) { "ruby '#{chef_dir}/knife'" }
let(:knife_config_flag) { "-c '#{path_to("config/knife.rb")}'" }
knife("config", "use", *cmd_args, instance_filter: lambda { |instance|
old_wd = Dir.pwd
Dir.chdir(path_to("repo"))
it { is_expected.to eq "default\n" }
let(:cmd_args) { %w{--profile production} }
it { is_expected.to eq "production\n" }
it { is_expected.to eq "staging\n" }
before { file(".chef/context", "development\n") }
it { is_expected.to eq "development\n" }
it { is_expected.to eq "other\n" }
let(:cmd_args) { %w{production} }
before { file(".chef/credentials", <<~EOH) }
it { is_expected.to eq "FATAL: No profiles found, #{path_to(".chef/credentials")} does not exist or is empty\n" }
before { file(".chef/credentials", "") }
let(:cmd_args) { %w{staging} }
let(:cmd_args) { %w{development} }
cmd = knife("config", "show", *cmd_args, instance_filter: lambda { |instance|
before { file(".chef/knife.rb", "node_name 'one'\n") }
it { is_expected.to match(%r{^Loading from configuration file .*/#{File.basename(path_to("."))}/.chef/knife.rb$}) }
it { is_expected.to match(/^node_name:\s+one$/) }
before { file("repo/.chef/knife.rb", "node_name 'two'\n") }
it { is_expected.to match(%r{^Loading from configuration file .*/#{File.basename(path_to("."))}/repo/.chef/knife.rb$}) }
it { is_expected.to match(/^node_name:\s+two$/) }
file(".chef/knife.rb", "node_name 'one'\n")
file("repo/.chef/knife.rb", "node_name 'two'\n")
it { is_expected.to match(%r{^Loading from credentials file .*/#{File.basename(path_to("."))}/.chef/credentials$}) }
it { is_expected.to match(/^node_name:\s+three$/) }
before { file(".chef/config.d/abc.rb", "node_name 'one'\n") }
it { is_expected.to match(%r{^Loading from .d/ configuration file .*/#{File.basename(path_to("."))}/.chef/config.d/abc.rb$}) }
it { is_expected.to match(%r{^Loading from credentials file .*/#{File.basename(path_to("."))}/foo/.chef/credentials$}) }
it { is_expected.to match(/^node_name:\s+four$/) }
it { is_expected.to match(%r{^Loading from credentials file .*/#{File.basename(path_to("."))}/bar/.chef/credentials$}) }
let(:cmd_args) { %w{node_name} }
it { is_expected.to match(/^node_name:\s+three\Z/) }
let(:cmd_args) { %w{node_name client_key} }
it { is_expected.to match(%r{^client_key:\s+\S*/.chef/three.pem\nnode_name:\s+three\Z}) }
let(:cmd_args) { %w{knife.ssh_user} }
it { is_expected.to match(/^knife.ssh_user:\s+foo\Z/) }
let(:cmd_args) { %w{/name/} }
context "with --all" do
let(:cmd_args) { %w{-a /key_contents/} }
context "with --raw" do
let(:cmd_args) { %w{-r node_name} }
it { is_expected.to eq("three\n") }
let(:cmd_args) { %w{--format=json node_name} }
it { expect(JSON.parse(subject)).to eq({ "node_name" => "three" }) }
it { is_expected.to eq <<~EOH.delete("#") }
client_key = "~/src/qauser.pem"
let(:cmd_args) { %w{--profile prod} }
context "with -i" do
let(:cmd_args) { %w{-i} }
it {
let(:local_listen_warning) { /\Awarn:.*local.*listen.*$/im }
before { file "nodes/x.json", {} }
knife("raw /nodes/x").should_succeed( /"name": "x"/ )
knife("raw --listen /nodes/x").should_succeed( /"name": "x"/, stderr: local_listen_warning )
before(:each) { Chef::Config.chef_zero.port = 9999 }
before(:each) { Chef::Config.chef_zero.host = "0.0.0.0" }
knife("raw -z /nodes/x").should_succeed( /"name": "x"/ )
knife("raw -z --listen /nodes/x").should_succeed( /"name": "x"/, stderr: local_listen_warning )
knife("raw --local-mode --listen /nodes/x").should_succeed( /"name": "x"/, stderr: local_listen_warning )
knife("raw -z --chef-zero-port=9999 --listen /nodes/x").should_succeed( /"name": "x"/, stderr: local_listen_warning )
knife("raw -z --chef-zero-port=9999-20000 --listen /nodes/x").should_succeed( /"name": "x"/, stderr: local_listen_warning )
knife("raw -z --chef-zero-port=9999-9999,19423 --listen /nodes/x").should_succeed( /"name": "x"/, stderr: local_listen_warning )
command_name = command.gsub("_", " ")
when /(role|node|env) (env )?run list(.*)/
env_part = $2.nil? ? "" : "env_"
client "cons", {}
client "car", {}
client "cdr", {}
client "cat", {}
let(:now) { DateTime.now }
let(:last_month) { (now << 1).strftime("%FT%TZ") }
let(:next_month) { (now >> 1).strftime("%FT%TZ") }
let(:out) { "Created key: new" }
client "bah", {}
knife("client key create -k new bah").should_succeed stderr: /^#{out}/, stdout: /.*BEGIN RSA PRIVATE KEY/
date = "2017-12-31T23:59:59Z"
knife("client key create -k new -e #{date} bah").should_succeed stderr: /^#{out}/, stdout: /.*BEGIN RSA PRIVATE KEY/
knife("client key create -f #{tgt}/bah.pem -k new bah").should_succeed stderr: /^#{out}/
expect(File).to exist("#{tgt}/bah.pem")
File.open("#{tgt}/public.pem", "w") { |pub| pub.write(key.public_key.to_pem) }
knife("client key create -p #{tgt}/public.pem -k new bah").should_succeed stderr: /^#{out}/
knife("client delete car", input: "Y").should_succeed <<~EOM
client "concat", {}
knife("client bulk delete ^ca.*", input: "Y").should_succeed <<~EOM
knife("client bulk delete ca.*", input: "Y").should_succeed <<~EOM
knife("client bulk delete ^ca.* -D", input: "Y\nY").should_succeed <<~EOM
file "data_bags/bag1/x.json", {}
knife("list --local -Rfp /").should_succeed <<~EOM
before { file "cookbooks/chefignore", "x.json\n" }
file "cookbooks/chefignore", "x.*\n"
file "cookbooks/chefignore", "\n\n # blah\n#\nx.json\n\n"
it "knife list --local -Rfp / returns them" do
it "knife list --local / returns it" do
knife("list --local /").should_succeed "/data_bags\n"
it "knife list --local -Rfp / does not return it" do
file "_default.json", {}
knife("list --local -Rfp /").should_succeed ""
file "item2.xml", ""
file "role1.json", {}
file "role2.xml", ""
file "subdir/role.json", {}
before { file "cookbooks/file", "" }
before { file "data_bags/file", "" }
file "cookbooks/a.b/metadata.rb", ""
file "data_bags/.svn/x.json", {}
file "data_bags/a.b/x.json", {}
knife("list --local -fp /data_bags").should_succeed "/data_bags/a.b/\n"
file "data_bags/bag/item.json", {}
file "nodes2/node2.json", {}
file "roles2/role2.json", {}
file "users2/user2.json", {}
file "data_bags/bag3/item3.json", {}
file "nodes/node3.json", {}
file "roles/role3.json", {}
file "users/user3.json", {}
knife("list --local -Rfp --chef-repo-path #{path_to("chef_repo2")} /").should_succeed <<~EOM
knife("list --local -Rfp --chef-repo-path #{path_to("chef_r~1")} /").should_succeed <<~EOM
knife("list -z -Rfp --chef-repo-path #{path_to("chef_r~1")} /").should_succeed <<~EOM
before { cwd "chef_repo2" }
knife("list --local -Rfp").should_succeed <<~EOM
before { cwd "data_bags2" }
it "knife list --local -Rfp ../roles lists roles" do
knife("list --local -Rfp ../roles").should_succeed "/roles/role2.json\n"
file "clients2/blah.json", {}
file "cookbooks/blah", ""
file "data_bags/blah", ""
file "data_bags2/blah/item.json", ""
knife("list --local -Rfp /data_bags").should_succeed <<~EOM
file "data_bags/blah/item1.json", ""
file "nodes2/blah.json", {}
file "roles2/blah.json", {}
file "users2/blah.json", {}
it "knife list --local -Rfp / lists data bags" do
it "knife list --local -Rfp / fails" do
let(:cookbook_z_100_metadata_rb) { cb_metadata("z", "1.0.0") }
file "policies/x-111.json", {}
file "policy_groups/x.json", {}
knife("list -z -Rfp /").should_succeed <<~EOM
/data_bags/x/
knife("list -z -Rfp /clients").should_succeed ""
knife("list -z -Rfp /cookbooks").should_succeed ""
it "knife delete -z -r /data_bags/x works" do
knife("list -z -Rfp /data_bags").should_succeed ""
knife("list -z -Rfp /data_bags").should_succeed "/data_bags/x/\n"
knife("list -z -Rfp /nodes").should_succeed ""
knife("list -z -Rfp /roles").should_succeed ""
knife("show -z /clients/x.json").should_succeed( /"x"/ )
knife("show -z /data_bags/x/y.json").should_succeed( /"y"/ )
knife("show -z /environments/x.json").should_succeed( /"x"/ )
knife("show -z /nodes/x.json").should_succeed( /"x"/ )
knife("show -z /roles/x.json").should_succeed( /"x"/ )
file "empty.json", {}
file "rolestuff.json", '{"description":"hi there","name":"x"}'
it "knife raw -z -i empty.json -m PUT /clients/x" do
knife("raw -z -i #{path_to("empty.json")} -m PUT /clients/x").should_succeed( /"x"/ )
it "knife raw -z -i empty.json -m PUT /data/x/y" do
knife("raw -z -i #{path_to("empty.json")} -m PUT /data/x/y").should_succeed( /"y"/ )
knife("list --local -Rfp /data_bags").should_succeed "/data_bags/x/\n/data_bags/x/y.json\n"
knife("raw -z -i #{path_to("empty.json")} -m PUT /environments/x").should_succeed( /"x"/ )
it "knife raw -z -i dummynode.json -m PUT /nodes/x" do
knife("raw -z -i #{path_to("dummynode.json")} -m PUT /nodes/x").should_succeed( /"x"/ )
knife("show -z /nodes/x.json --verbose").should_succeed(/"bar"/)
it "knife raw -z -i empty.json -m PUT /roles/x" do
knife("raw -z -i #{path_to("empty.json")} -m PUT /roles/x").should_succeed( /"x"/ )
knife("raw -z -i #{path_to("rolestuff.json")} -m PUT /roles/x").should_succeed( /"x"/ )
expect(IO.read(path_to("roles/x.json"))).to eq <<~EOM.strip
file "empty.json", { "name" => "z" }
file "empty_x.json", { "name" => "x" }
file "empty_id.json", { "id" => "z" }
it "knife raw -z -i empty.json -m POST /clients" do
knife("raw -z -i #{path_to("empty.json")} -m POST /clients").should_succeed( /uri/ )
it "knife raw -z -i empty.json -m POST /data" do
knife("raw -z -i #{path_to("empty.json")} -m POST /data").should_succeed( /uri/ )
knife("list --local -Rfp /data_bags").should_succeed "/data_bags/z/\n"
it "knife raw -z -i empty.json -m POST /data/x" do
knife("raw -z -i #{path_to("empty_x.json")} -m POST /data").should_succeed( /uri/ )
knife("raw -z -i #{path_to("empty_id.json")} -m POST /data/x").should_succeed( /"z"/ )
knife("list --local -Rfp /data_bags").should_succeed "/data_bags/x/\n/data_bags/x/z.json\n"
knife("raw -z -i #{path_to("empty.json")} -m POST /environments").should_succeed( /uri/ )
it "knife raw -z -i dummynode.json -m POST /nodes" do
knife("raw -z -i #{path_to("dummynode.json")} -m POST /nodes").should_succeed( /uri/ )
knife("show -z /nodes/z.json").should_succeed(/"bar"/)
it "knife raw -z -i empty.json -m POST /roles" do
knife("raw -z -i #{path_to("empty.json")} -m POST /roles").should_succeed( /uri/ )
knife("raw -z -i #{path_to("rolestuff.json")} -m POST /roles").should_succeed( /uri/ )
knife("raw -z -i #{path_to("empty.json")} -m PUT /clients/x").should_fail( /404/ )
it "knife raw -z -i empty.json -m PUT /data/x/y fails with 404" do
knife("raw -z -i #{path_to("empty.json")} -m PUT /data/x/y").should_fail( /404/ )
knife("raw -z -i #{path_to("empty.json")} -m PUT /environments/x").should_fail( /404/ )
it "knife raw -z -i empty.json -m PUT /nodes/x fails with 404" do
knife("raw -z -i #{path_to("empty.json")} -m PUT /nodes/x").should_fail( /404/ )
it "knife raw -z -i empty.json -m PUT /roles/x fails with 404" do
knife("raw -z -i #{path_to("empty.json")} -m PUT /roles/x").should_fail( /404/ )
knife("list -z -Rfp /users").should_succeed ""
knife("show -z /users/x.json").should_succeed( /"x"/ )
it "knife raw -z -i empty.json -m PUT /users/x" do
knife("raw -z -i #{path_to("empty.json")} -m PUT /users/x").should_succeed( /"x"/ )
it "knife raw -z -i empty.json -m POST /users" do
knife("raw -z -i #{path_to("empty.json")} -m POST /users").should_succeed( /uri/ )
it "knife raw -z -i empty.json -m PUT /users/x fails with 404" do
knife("raw -z -i #{path_to("empty.json")} -m PUT /users/x").should_fail( /404/ )
let(:knife_dir) { File.join(__dir__, "..", "..", "..", "knife") }
expect(shell_out!("bundle exec knife -v", cwd: knife_dir).stdout.chomp).to match(/.*: #{Chef::Knife::VERSION}/)
let(:ssh_config) { {} }
expect(@knife.get_ssh_attribute({ "target" => "ec2.public_hostname" })).to eq("ec2.public_hostname")
expect(@knife.get_prefix_attribute({ "prefix" => "name" })).to eq("name")
allow(@knife).to receive(:ssh_command) { 0 }
@api.post("/search/node?q=*:*&start=0&rows=1000", 200) do
knife_cmd = Mixlib::ShellOut.new("#{knife_path} -v")
knife_cmd = Mixlib::ShellOut.new("#{knife_path} --help")
@server = TinyServer::Manager.new # (:debug => true)
@knife = Chef::Knife::Exec.new
api.get("/cookbooks/no-such-cookbook", 404, Chef::JSONCompat.to_json({ "error" => "dear Tim, no. -Sent from my iPad" }))
with_version = lambda { |version| { "version" => version } }
@cookbook_list = { "obsolete-cookbook" => { "versions" => versions.map(&with_version) } }
stdin << "1\n"
unless ::File.exist?(yaml_file) && ::File.readable?(yaml_file)
if ::File.extname(yaml_file) == ".yml" || ::File.extname(yaml_file) == ".yaml"
yaml_file.gsub(/\.(yml|yaml)$/, ".rb")
unless yaml_hash.is_a?(Hash) && yaml_hash.key?("resources")
::File.open(ruby_file, "w") do |file|
ui.info("Converted '#{yaml_file}' to '#{ruby_file}'")
type = r.delete("type")
name = r.delete("name")
ruby_contents << "#{type} \"#{name}\" do"
r.each do |k, v|
ruby_contents << "end\n"
long: "--local",
long: "--dry-run",
short: "-t",
short: "-0",
ui.warn "#{format_path(result)}: is a directory. Will not run #{command} on it."
ran = true
stdin.read.split(/\s+/)
command = name_args.join(" ")
tempfiles = {}
paths = tempfiles.keys.map(&:path).join(" ")
final_command = "#{command} #{paths}"
ui.error "#{format_path(e.entry)}: #{e.reason}."
command_output = `#{command}`
diff = `diff -u #{old_file.path} #{tempfile.path}`
long: "--with-orgs",
short: "-l"
results = root_rest.get("users/#{@user_name}")
long: "--file FILE",
short: "-e",
result = root_rest.get("users/#{user_name}")
root_rest.put("users/#{user_name}", result)
short: "-w",
long: "--with-uri",
@service_object ||= Chef::Knife::KeyShow.new(@name, @actor, load_method, ui)
long: "--all",
if (name_args.length < 1) && ! config.key?(:all)
@invites = {}
@invites.each do |u, i|
if @invites.key?(u)
body = { user: u }
original_user = root_rest.get("users/#{@user_name}")
result = root_rest.put("users/#{@user_name}", edited_user)
ui.msg("Saved #{@user_name}.")
File.open(file, "w") do |f|
f.sync = true
api_endpoint = "users/#{u}"
admin_of << org
admin_of.each { |org| message << "- #{org.name}\n" }
message << <<~EOM
message = <<~EOM
only_admin_of.each { |org| message << "- #{org.name}\n" }
short: "-k",
long: "--prevent-keygen",
long: "--prompt-for-password",
short: "-p",
@user_field ||= Chef::UserV1.new
if @name_args.size > 1
user_hash = {
display_name: "#{user.first_name} #{user.last_name}",
short: "-n",
if name.nil? || tags.nil? || tags.empty?
(node.tags << tag).uniq!
ui.info("Created tags #{tags.join(", ")} for node #{name}.")
def get_cookbook_list(items = 10, start = 0, cookbook_collection = {})
proc: lambda { |o| Chef::Config.cookbook_path = o.split(":") }
shell_out!("#{tar_cmd} -czf #{cookbook_name}.tgz #{cookbook_name}", cwd: tmp_cookbook_dir)
Chef::Log.trace("\n#{e.backtrace.join("\n")}")
result = shell_out!("#{tar_cmd} -tzf #{cookbook_name}.tgz", cwd: tmp_cookbook_dir)
return "Other" if e.is_a?(Net::HTTPClientException) && e.response.code == "404"
if http_resp.code.to_i != 201
@tar_cmd = "tar"
@tar_cmd = "gnutar"
long: "--sort-by SORT",
long: "--owned-by USER",
short: "-D",
proc: lambda { |o| o.split(":") }
short: "-b",
long: "--use-current-branch",
unless name_args.last.match(/^(\d+)(\.\d+){1,2}$/) && name_args.size == 2
json = IO.read(json)
long: "--force",
uri = if @name_args.length == 1
short: "-r",
long: "--run-list",
long: "--sort-reverse",
long: "--hide-by-mins MINS",
@query << " AND " unless @query.empty?
@query << term
opts = { filter_result:
@query ||= ""
time = Time.now.to_i
@query << " " unless @query.empty?
@query = @query.empty? ? "*:*" : @query
Chef::Log.info("Sending query: #{@query}")
q.search(:node, @query, opts) do |node|
@uri = nil
@uri ||= begin
ui.error("Given URI: `#{given_uri}' is invalid")
cn = cn_of(cert)
filename = cn.nil? ? "#{host}_#{Time.new.to_i}" : normalize_cn(cn)
if uri.scheme == "http"
https_uri = uri.to_s.sub(/^http/, "https")
ui.error("Perhaps you meant to connect to '#{https_uri}'?")
@host = nil
cert_debug_msg = ""
cert_debug_msg << File.expand_path(cert_name) + ": " + message + "\n"
true # Maybe the bad certs won't hurt...
ui.msg("Connecting to host #{host}:#{port}")
ui.msg("\n#{ui.color("Configuration Info:", :bold)}\n\n")
Dir.glob(File.join(glob_dir, "*.{crt,pem}"))
long: "--concurrency NUM",
proc: lambda { |o| o.to_i }
long: "--attribute ATTR",
short: "-m",
long: "--manual-list",
long: "--ssh-port PORT",
proc: Proc.new { |key| key.strip }
proc: Proc.new { |key| key.strip.to_i },
long: "--forward-agent",
long: "--exit-on-error",
proc: Proc.new { |key| key.strip.to_sym },
long: "--tmux-split",
ui.warn "Failed to connect to #{server.host} -- #{$!.class.name}: #{$!.message}"
$!.backtrace.each { |l| Chef::Log.debug(l) }
gw_host, gw_port = gw_host.split(":")
prompt = "Enter the password for #{user}@#{gw_host}: "
if list.length == 0
if @search_count == 0
ui.fatal("#{@search_count} #{@search_count > 1 ? "nodes" : "node"} found, " +
msg = "Using node attribute '%s' as the prefix: %s"
msg = "Using node attribute '%s' as the ssh target: %s"
@search_count += 1
ssh_port = item.dig("cloud", "public_ssh_port")
{}.tap do |opts|
Chef::Log.debug("Adding #{host}")
command.sub(/^sudo/, "sudo -p 'knife sudo password: '")
@buffers ||= {}
if newline_index = data.index("\n")
str = ui.color(host, :cyan) + (" " * (padding + 1)) + data
if /^knife sudo password: /.match?(data)
ch.on_extended_data do |_, _type, data|
command = reader.readline("#{ui.color("knife-ssh>", :bold)} ", true)
command = "exit"
puts "Connected to #{ui.list(session.servers_for.collect { |s| ui.color(s.host, :cyan) }, :inline, " and ")}"
when "quit!"
puts "Bye!"
when /^on (.+?); (.+)$/
raw_list = $1.split(" ")
command = $2
tf.puts("caption always '%-Lw%{= BW}%50>%n%f* %t%{-}%+Lw%<'")
window = 0
tf.print("screen -t \"#{server.host}\" #{window} ssh ")
server.user ? tf.puts("#{server.user}@#{server.host}") : tf.puts(server.host)
window += 1
exec("screen -c #{tf.path}")
prefix = server.user ? "#{server.user}@" : ""
end.join(" \\; ")
exec("tmux attach-session -t #{tmux_name}")
(session.servers_for.size - 1).times do |i|
%w{csshX cssh}.each do |cmd|
cssh_cmd = shell_out!("which #{cmd}").stdout.strip
cssh_cmd << " #{server.user ? "#{server.user}@#{server.host}" : server.host}"
@longest = 0
if exit_status && exit_status != 0
output "#{format_path(entry)}:"
long: "--repo-mode MODE",
long: "--chef-repo-path PATH",
long: "--chef-zero-host IP",
short: "-b ROW",
long: "--start ROW",
proc: lambda { |i| i.to_i }
long: "--rows INT",
short: "-i",
long: "--id-only",
if @type == "node"
search_args = {}
q.search(@type, @query, search_args) do |item|
formatted_item = {}
ui.error("knife search failed: #{msg}")
ui.log("\n")
ui.msg("\n")
@type = "node"
final_filter = {}
filter_string.delete!(" ")
return_id, attr_path = f.split("=")
entries.each { |e| nlist << e }
if @name_args.size < 1
entry.split(",").map(&:strip)
if @name_args.size > 2
long: "--after ITEM",
if @name_args.size < 2
roles_to_delete = {}
ui.msg("")
ui.msg("Deleted role #{name}")
default: "GET",
long: "--input FILE",
long: "--proxy-auth",
ui.error "Error Body: #{e.response.body}" if e.response.body && e.response.body != ""
@org_name, @username = @name_args
if !org_name || !username
org = Chef::Org.new(@org_name)
elsif e.response.code == "403"
long: "--admin",
long: "--all-orgs",
ui.msg("Saved #{org_name}.")
@org_name, @org_full_name = @name_args
if !org_name || !org_full_name
org = Chef::Org.from_hash({ "name" => org_name,
ui.info("Created #{org_name}")
short: "-E",
long: "--environment",
entries.each { |e| node.run_list << e }
if node.run_list.find { |rli| e == rli.to_s }
ui.warn "#{e} is not in the run list"
long: "--before ITEM",
ui.info "Saving updated #{updated_values.join(", ")} on node #{node.name}"
@node ||= Chef::Node.load(node_name)
if @name_args.length == 0
nodes_to_delete = {}
ui.msg("Deleted node #{name}")
long: "--flat",
short: "-1",
if results.length == 0 && dir_results.length == 1
output ""
output "#{format_path(result)}:"
print_space = results.map(&:length).max + 2
current_line = ""
current_line << (" " * (print_space - result.length))
@ui = ui
key = Chef::Key.send(@load_method, @actor, @name)
long: "--with-details",
long: "--only-expired",
long: "--only-non-expired",
keys = Chef::Key.send(@list_method, @actor)
short: "-c",
long: "--create-key",
long: "--key-name NAME",
key = Chef::Key.new(@actor, @actor_field_name)
to_display = "Updated key: #{key.name}"
to_display << " (formally #{@original_name})" if key.name != @original_name
@ui.confirm("Do you really want to delete the key named #{@name} for the #{@actor_field_name} named #{@actor}")
@ui.info("Deleted key named #{@name} for the #{@actor_field_name} named #{@actor}")
display_info("Created key: #{key.name}")
group = rest.get_rest("groups/#{group_name}")
groups.select { |gname| !is_usag?(gname) }
ui.msg "Creating '#{group_name}' group"
long: "--exec CODE",
puts "1. To run the script, use 'Ctrl D'"
puts "2. To exit, use 'Ctrl/Shift C'"
puts "Type here a script..."
test = File.join(path, x)
Chef::Log.trace("Testing: #{test}")
Chef::Log.trace("Found: #{test}")
ui.error("\"#{x}\" not found in current directory or script_path, giving up.")
long: "--mismatch",
unless @name_args.nil? || @name_args.empty?
@name_args.each { |name| environments << name }
constraints = {}
unless env == "_default"
constraints.each_key { |e| environments << e.to_s }
environments.each { |env| rows << ui.color(env, :bold) }
rows << ui.color(c, :bold)
rows << ui.color(tag, color)
long: "--name-only",
long: "--name-status",
ui.error "Failed on #{format_path(e.entry)} in #{e.operation}: #{e.message}"
long: "--tree",
long: "--remote",
long: "--both",
root = entry.root == chef_fs ? " (remote)" : " (local)"
ui.error "#{format_path_with_root(e.entry)} #{e.reason}."
long: "--encrypt",
@data_bag_path ||= "data_bags"
loader.find_all_object_dirs("./#{data_bags_path}")
loader.find_all_objects("./#{data_bags_path}/#{data_bag}")
paths << path
if @name_args.length != 2
if @name_args.length == 2
rest.get("data/#{@data_bag_name}")
raise unless /^404/.match?(e.to_s)
rest.post("data", { "name" => @data_bag_name })
rest.post("data/#{@data_bag_name}", item)
client_rb << "# Using default node name (fqdn)\n"
client_rb << %Q{verify_api_cert #{value}\n}
client_rb << %Q{ssl_verify_mode :#{value}\n}
client_rb << "\n"
client_rb << "fips true\n"
start_chef << "#{ChefUtils::Dist::Infra::CLIENT} -c #{client_rb} -j #{first_boot}#{bootstrap_environment_option}\n"
If InStr(url, "file://") = 1 Then
If InStr(url, "file:///") = 1 Then
sourcePath = Mid(url, Len("file:///") + 1)
sourcePath = Mid(url, Len("file:") + 1)
sourcePath = Replace(sourcePath, "/", "\\")
if ($ProxyUrl -ne '') {
install_command('"') + "\n" + fallback_install_task_command
url += "&pv=#{machine_os}" unless machine_os.nil?
url += "&m=#{machine_arch}" unless machine_arch.nil?
url += "&v=#{version_to_install}"
content << "> #{bootstrap_directory}/trusted_certs/#{File.basename(cert)} (\n" +
escape_and_echo(IO.read(File.expand_path(cert))) + "\n)\n"
root.find do |f|
if f != root
file_on_node = "#{bootstrap_directory}/client.d/#{relative}".tr("/", "\\")
content << "mkdir #{file_on_node}\n"
content << "> #{file_on_node} (\n" +
escape_and_echo(IO.read(File.expand_path(f))) + "\n)\n"
command = install_command("'")
) else (
@highline ||= begin
@prompt ||= begin
lines = message.split("\n")
prefix, = first_line.split(":", 2)
padding = " " * prefix_len
stderr.puts "#{padding}#{line}"
log("#{color("DEBUG:", :blue, :bold)} #{message}")
log("#{color("WARNING:", :yellow, :bold)} #{message}")
log("#{color("ERROR:", :red, :bold)} #{message}")
log("#{color("FATAL:", :red, :bold)} #{message}")
def ask(*args, **options, &block)
prompt.ask(*args, **options, &block)
msg("Saved #{output}")
when "Y", "y"
when "N", "n"
msg("You said no, so I'm done here.")
when ""
msg("I have no idea what to do with '#{answer}'")
msg("Just say Y or N, please.")
justify_width = data.keys.map { |k| k.to_s.size }.max.to_i + 1
justified_key = ui.color("#{key}:".ljust(justify_width), :cyan)
buffer << "#{justified_key} #{value}\n"
buffer << ui.color("#{key}:\n", :cyan)
lines = text_format(value).split("\n")
buffer << "#{data}\n"
!(value.is_a?(Array) || value.respond_to?(:keys))
File.open(plugin_manifest_path, "w") do |f|
category_words.map! { |w| w.split("-") }.flatten!
category_words, " ")
version_file_match = /#{Regexp.escape(File.join('chef', 'knife', 'version.rb'))}/
def find_longest_key(hash, words, sep = "_")
candidate = words.join(sep).tr("-", "_")
ChefConfig::PathHelper.home(".chef", "plugins", "knife") do |p|
summarized = ""
hours_text = "#{hours} hour#{hours == 1 ? " " : "s"}"
minutes_text = "#{minutes} minute#{minutes == 1 ? " " : "s"}"
seconds_text = "#{seconds} second#{seconds == 1 ? " " : "s"}"
if hours > 24
color = :red
elsif hours >= 1
line_parts << @ui.color(text, color) + " ago" << name
line_parts << "Node #{name} has not yet converged"
line_parts << ip if ip
summarized = summarized + line_parts.join(", ") + ".\n"
hours = (difference / 3600).to_i
minutes = (difference / 60).to_i
path << ".{json,rb}"
objects.map { |o| File.basename(o) }
objects.delete_if { |o| !File.directory?(o) }
when /\.(js|json)$/
r = klass.new
ui.fatal("File must end in .js, .json, or .rb")
if data.is_a?(Chef::Node)
summarized << <<~ENV
summarized += <<~MORE
summarized += <<~MOST
@node, @ui, @config = node, ui, config
}.reject do |key|
errors = {}
commands.collect { |k, v| v }.flatten.each do |command|
if paths && paths.is_a?(Array)
if paths.all? { |sc| !File.exist?(sc) }
Chef::Log.error "Missing files:\n\t#{errors.values.flatten.join("\n\t")}"
if paths.nil? || paths.empty? || (! paths.is_a? Array)
@ui, @config = ui, config
PP.pp(data, out)
when "summary", /^s/, nil
when "text", /^t/
when "json", /^j/
when "yaml", /^y/
when "pp", /^p/
:pp
{ "run_list" => run_list }
{ name_or_id_for(data) => subset }
if data.is_a?(Array)
( !data.is_a?(Array) && data.respond_to?(:to_hash) ) ? data.to_hash : data
version_file_match = /#{Regexp.escape(File.join('chef', 'knife', 'version'))}$/
long: "--medium",
short: "-l",
long: "--long",
Chef::Log.trace("Staging #{on_disk_path} to #{dest}")
def post(to_url, user_id, secret_key_filename, params = {}, headers = {})
def put(to_url, user_id, secret_key_filename, params = {}, headers = {})
def make_request(http_verb, to_url, user_id, secret_key_filename, params = {}, headers = {})
boundary = "----RubyMultipartClient" + rand(1000000).to_s + "ZZZZZ"
if value.is_a?(File)
parts << StringPart.new( "--" + boundary + "\r\n" +
parts << StringPart.new("\r\n")
parts << StringPart.new(value.to_s + "\r\n")
parts << StringPart.new("--" + boundary + "--\r\n")
url = URI.parse(to_url)
Chef::Log.logger.debug("Signing: method: #{http_verb}, url: #{url}, file: #{content_file}, User-id: #{user_id}, Timestamp: #{timestamp}")
content_body = parts.inject("") { |result, part| result + part.read(0, part.size) }
class << res
@stream, @size = stream, size
@str = str
@part_no = 0
@part_offset = 0
@parts.inject(0) { |size, part| size + part.size }
def read(how_much, dst_buf = nil)
if @part_no >= @parts.size
dst_buf.replace("") if dst_buf
@part_no += 1
result = current_part + (next_part || "")
dst_buf ? dst_buf.replace(result || "") : result
def initialize(repo_path, ui, opts = {})
cmd = git("status --porcelain")
git("checkout #{branch}")
git("checkout -b #{branch}")
git("add #{cookbook_name}")
git("commit -m \"Import #{cookbook_name} version #{version}\" -- #{cookbook_name}")
if system("git merge #{branch}")
ui.info("Merge status (cd #{repo_path}; git status):")
update_count == 0 ? nil : update_count
git("branch --no-color").stdout.lines.any? { |l| l =~ /\s#{Regexp.escape(branch_name)}(?:\s|$)/ }
shell_out!("git #{command}", cwd: repo_path)
@client_d ||= client_d_content
s = "#{client_path} -j /etc/chef/first-boot.json"
s << " -l trace"
s << " -l debug"
content << "cat > /etc/chef/trusted_certs/#{File.basename(cert)} <<'EOP'\n" +
IO.read(File.expand_path(cert)) + "\nEOP\n"
file_on_node = "/etc/chef/client.d/#{relative}"
content << "cat > #{file_on_node} <<'EOP'\n" +
f.read.gsub("'", "'\\\\''") + "\nEOP\n"
long: "--freeze",
upload_ok = 0
upload_ok += 1
ui.info "Uploaded #{upload_ok} cookbook#{upload_ok == 1 ? "" : "s"}."
elsif upload_failures > 0 && upload_ok > 0
ui.warn "Uploaded #{upload_ok} cookbook#{upload_ok == 1 ? "" : "s"} ok but #{upload_failures} " +
elsif upload_failures > 0 && upload_ok == 0
ui.error "Failed to upload #{upload_failures} cookbook#{upload_failures == 1 ? "" : "s"}."
@justify_width ||= server_side_cookbooks.map(&:size).max.to_i + 2
upload_set = {}
if e.response.code.to_s == "404"
ui.error "The broken file(s) are: #{broken_filenames.join(" ")}"
ui.error "The missing cookbook(s) are: #{missing_cookbook_names.join(", ")}"
long: "--fqdn FQDN",
class << node
key?(name)
File.open(json_file, "w") do |f|
ui.stderr.puts "in #{file}:"
ui.stderr.puts "in #{json_file}:"
api_endpoint = env ? "/environments/#{env}/cookbooks?#{num_versions}" : "/cookbooks?#{num_versions}"
short: "-N",
long: "--latest",
valid_responses = {}
question << "#{index + 1}. #{@cookbook_name} #{version}\n"
question += "\n"
ui.error("'#{response}' is not a valid value.")
option :all, short: "-a", long: "--all", boolean: true, description: "Delete all versions of the cookbook."
question << "#{available_versions.size + 1}. All versions\n\n"
if version == :all
ui.msg ""
File.open(File.join(@config_dir, "client.rb"), "w") do |file|
long: "--repository REPO",
long: "--initial",
long: "--admin-client-name NAME",
long: "--admin-client-key PATH",
long: "--validation-key PATH",
::File.open(config_file_path, "w") do |f|
chef_server_url = '#{chef_server}'
ui.msg("*****")
o = Ohai::System.new
IO.write(context_file, "#{profile}\n")
long: "--raw",
output_data = {}
if filter =~ %r{^/(.*)/(i?)$}
filter_parts = filter.split(".")
ui.msg(ui.color("Loading from #{type_of_file} file #{path}", :yellow))
long: "--ignore-knife-rb",
separator ->(row) { (row + 1) % TABLE_HEADER.size == 0 }
if col_index == 1 || (row_index) % TABLE_HEADER.size == 0
mid "-"
ui.msg("Saved #{client}.")
long: "--validator",
long: "--public-key",
ui.fatal "#{dir} exists, but is not a directory. Please update your file path (--file #{file}) or re-create #{dir} as a directory."
if File.exist?(file) && !File.writable?(file)
clients_to_delete = {}
ui.msg("Deleted client #{name}")
@host_url = host_url
@opts_in = opts
@config ||= begin
@tmpdir ||= if windows?
run_command!("mkdir -p '#{dir}'")
t << content
run_command!("If (Test-Path \"#{path}\") { Remove-Item -Force -Path \"#{path}\" }")
run_command!("rm -f \"#{path}\"")
path.tr("\\", "/")
opts = { target: host_url,
opts_out = {}
opts_in.select do |key, _v|
valid_opts.key?(key) && !config.key?(key)
host_cfg.each do |key, _value|
def initialize(config: {}, knife_config: nil, chef_config: {}, ui: nil)
@client_path ||=
File.join(@tmpdir, "#{node_name}.pem")
run_list.split(/\s*,\s*/)
@node ||=
node.tags << tag
rest.delete("nodes/#{node_name}")
@vault_json ||=
@require_chef_vault ||=
long: "--winrm-no-verify-cert",
long: "--winrm-ssl",
long: "--winrm-basic-auth-only",
long: "--ssh-forward-agent",
long: "--ssh-verify-host-key VALUE",
proc: Proc.new { |v|
raise "Invalid value '#{v}' for --node-ssl-verify-mode. Valid values are: #{valid_values.join(", ")}"
long: "--sudo",
long: "--sudo-preserve-home",
long: "--use-sudo-password",
long: "--su-user NAME",
long: "--node-name NAME",
long: "--tags TAGS",
long: "--json-attributes",
proc: lambda { |o| Chef::JSONCompat.parse(o) },
proc: lambda { |o| Chef::JSONCompat.parse(File.read(o)) },
accumulator ||= {}
name, path = hint.split("=", 2)
long: "--bootstrap-url URL",
short: "-m URL",
long: "--msi-url URL",
proc: Proc.new { |i, accumulator|
(vault, item) = i.split(":")
value_mapper: Proc.new { |verify| verify ? "always" : "never" }
long: "--prerelease",
long: "--winrm-port PORT"
value_mapper: Proc.new { |value| value == "ssl" }
ui: ui
bootstrap_files << File.join(__dir__, "bootstrap/templates", "#{template}.erb")
ChefConfig::PathHelper.home(".chef", "bootstrap", "#{template}.erb") { |p| bootstrap_files << p }
bootstrap_files << Gem.find_files(File.join("chef", "knife", "bootstrap", "#{template}.erb"))
if r.exit_status != 0
ui.error("#{r.stdout} #{r.stderr}".strip)
limit ||= 0
if e.reason == :bad_su_user_password && limit < 3
limit += 1
if e.message =~ /fingerprint (\S+) is unknown for "(.+)"/ # Train::Transports::SSHFailed
hostname, ip = $2.split(",")
elsif (ssh? && e.cause && e.cause.class == Net::SSH::AuthenticationFailed) || (ssh? && e.class == Train::ClientError && e.reason == :no_ssh_password_or_key_available)
from_url = host_descriptor =~ %r{^(.*)://} ? $1 : nil
@connection_protocol = from_url || from_knife || "ssh"
limit ||= 1
if !conn_options.key?(:pty) && e.reason == :sudo_no_tty
ui.warn("#{e.message} - trying with pty request")
if winrm_auth_method == "plaintext" &&
ui.error <<~EOM
@connection_opts = {}
if split.length == 1
gw_host, gw_port = gw_host.split(":", 2)
return {} if winrm?
opts = { sudo: false }
cmd = "sh #{remote_path}"
if option == :port
return unless opts.is_a?(Hash) || !opts.empty?
if member_name == "pivotal" && %w{client user}.include?(member_type)
if member_name == "admins" && member_type == "group" && perms.to_s.split(",").include?("grant")
object_name_matcher = /#{regex}/
ui.info "No #{object_type} match the expression /#{regex}/"
ui.fatal "Invalid name: #{name}"
ui.fatal "Unknown member type \"#{type}\". The following types are permitted: #{MEMBER_TYPES.join(", ")}"
perms.split(",").each do |perm|
true if rest.get_rest("#{member_type}s/#{member_name}")
ui.fatal "#{member_type} '#{member_name}' does not exist"
ui.msg "Adding '#{member_name}' to '#{perm}' ACE of '#{object_name}'"
when "client", "user"
key = "#{member_type}s"
ui.msg "Removing '#{member_name}' from '#{perm}' ACE of '#{object_name}'"
rest.put_rest("#{object_type}/#{object_name}/_acl/#{ace_type}", ace_type => ace)
ui.msg "Adding '#{member_name}' to '#{group_name}' group"
new_group = {
ui.msg "Removing '#{member_name}' from '#{group_name}' group"
def self.msg(msg = "")
@@chef_config_dir = nil
@@subcommands = {}
snake_case_name.split("_").join(" ")
name.nil? || name.empty?
@@subcommands ||= {}
def self.run(args, options = {})
category_desc = preferred_category ? preferred_category + " " : ""
caller_line.split(/:\d+/).first
ui.fatal("Cannot find subcommand for: '#{args.join(" ")}'")
@name_args.reject! { |name_arg| command_name_joined == name_arg }
puts "Error: " + e.to_s
stdout.puts("USAGE: " + opt_parser.to_s)
ui.info ""
ui.error "#{e.class.name}: #{e.message}"
msg("Created #{pretty_name}")
msg("Deleted #{obj_name}")
@rest ||= begin
@root_rest ||= begin
args.map { |arg| pattern_arg_from(arg) }
ui.warn("Consider writing '#{possible_server_path}' instead of '#{arg}'")
ui.warn("Using '#{inferred_path}' as the path instead of '#{arg}'.")
if parent && parent != dir
proc: lambda { |path| File.expand_path(path, Dir.pwd) }
short: "-V",
long: "--verbose",
proc: Proc.new { verbosity_level += 1 },
long: "--disable-editing",
short: "-k KEY",
long: "--key KEY",
short: "-s URL",
long: "--server-url URL",
short: "-y",
long: "--yes",
long: "--defaults",
long: "--print-after",
if want_help? || want_version?
puts "#{e}\n"
describe file("C:\\habitat\\hab.exe") do
it { should exist }
describe command("C:\\habitat\\hab.exe sup -h") do
its(:stdout) { should match(/Running/) }
restart_script = <<-EOH
its(:exit_status) { should eq(0) }
its("content") { should match(/bldr_url.*willem.habitat.sh/) }
it { should_not exist }
its(%w{cfg id}) { should eq "hab-sensu-agent" }
describe command("C:\\habitat\\hab.exe -V") do
its("stdout") { should match(%r{^hab.*/}) }
its("exit_status") { should eq 0 }
its("stdout") { should match(/C:\\hab\\pkgs\\skylerto\\splunkforwarder/) }
nginx_content = <<-EOF
its(%w{http listen port}) { should eq 80 }
describe send("#{svc_manager}_service", "hab-sup") do
its("content") { should_not match("LimitNOFILE = 65536") }
its("content") { should_not match("env HAB_AUTH_TOKEN=test") }
its("content") { should match(/peer.*127.0.0.2:9632.*127.0.0.3:9632/) }
its(:content) { should match(%r{ident = "core/vault/1.1.5"}) }
its(:content) { should match(%r{ident = "core/consul"}) }
its(:content) { should match(/desired_state = "up"/) }
its(:content) { should match(/channel = "stable"/) }
its(:content) { should match(/^desired_state = "up"$/) }
its("stdout") { should match(%r{/hab/pkgs/core/redis}) }
its("stdout") { should match(%r{/hab/pkgs/lamont-granquist/ruby/2.3.1}) }
its(:link_path) { should match(%r{/hab/pkgs/core/htop}) }
its("stdout") { should match(%r{^hab 1.5.71/}) }
its("stdout") { should match /my_signed_cert.*OK/ }
its("stderr") { should be_empty }
its("content") { should match(%r{chef_server_url "https://localhost"}) }
its("content") { should match(/chef_license "accept"/) }
its("content") { should match(%r{rubygems_url "https://rubygems.org/"}) }
its("content") { should match(/require 'aws-sdk'/) }
command "git --version & git --exec-path"
$possibleInstalledPaths = @("C:/Program Files/Git/", "C:/Program Files (x64)/Git/", "c:/git/")
code "Start-Sleep -s 1"
%w{001 002 003}.each do |control|
only_if { debian? }
uid "8019"
users_from_databag = search("users", "*:*")
if platform_family?("rhel", "fedora", "amazon")
level "s0"
range "s0"
user "se_map_test_u"
hour "0,12"
only_if { systemd? }
if ::File.exist?("/etc/systemd/system")
only_if { File.exist?("/etc/yum.conf") && File.readlines("/etc/yum.conf").grep(/http_caching=packages/).empty? }
only_if { rhel? }
sudo "bob" do
user "bob"
sudo "~bob" do
sudo "git" do
user "git"
file "#{base}/private_key.pem" do
key_file "#{base}/mycert.key"
openssl_x509 "#{base}/my_ca.crt" do
ca_key_file "#{base}/my_ca.key"
ca_cert_file "#{base}/my_ca.crt"
path "#{base}/my_ca2.csr"
key_file "#{base}/my_ca2.key"
csr_file "#{base}/my_ca2.csr"
ca_key_file "#{base}/my_ca2.key"
ca_cert_file "#{base}/my_ca2.crt"
openssl_x509_crl "#{base}/my_ca2.crl" do
key_file "#{base}/my_ec_request.key"
mount "/proc" do
mount "/mnt" do
device "/tmp"
device "/etc"
value "1"
type "int"
value "20"
mode "644"
listen_http "0.0.0.0:9999"
version "2.3.1"
version "1.15.2"
hab_version "1.5.71"
cron_d "noop" do
hour "5"
minute "0"
hour "8"
hour "20"
day "*"
month "11"
weekday "1-5"
log_location windows? ? "C:\\chef\\log_test\\client.log" : "/var/log/chef/log_test/client.log"
raw_data("auth" => "1234")
search "*:*"
raw_data("auth" => "4321")
content '#!/bin/bash
mode "500"
mode "550"
chef_repo_path "{{pkg.svc_data_path}}/chef"
file_backup_path "{{pkg.svc_data_path}}/{{cfg.file_backup_path}}"
pid_file "{{pkg.svc_data_path}}/{{cfg.pid_file}}"
local_mode "{{cfg.local_mode}}"
{{#if cfg.chef-client.node_name ~}}
node_name "{{cfg.node_name}}"
{{/if ~}}
splay "{{cfg.splay}}"
log_level "{{cfg.log_level}}".to_sym
{{#if cfg.use_member_id_as_uuid ~}}
chef_guid "{{svc.me.member_id}}"
val = threads + 1
(1..val).parallel_map do |i|
if val == i
ret << i
val -= 1
if Time.now - start > 30
expected = (1..threads + 1).to_a.reverse
(1..val).parallel_each do |i|
expect { (0..10).parallel_map { |i| raise "boom" } }.to raise_error(RuntimeError)
expect { (0..10).parallel_each { |i| raise "boom" } }.to raise_error(RuntimeError)
(1..10).parallel_map { |i| i }
expect(ans).to eql((1..10).to_a)
(1..10).parallel_each { |i| i }
(1..2).parallel_map { |i| (1..2).parallel_map { |i| i } }
(1..2).parallel_each { |i| (1..2).parallel_each { |i| i } }
(1..).lazy.parallel_map { |i| i }.first(5)
expect(ans).to eql((1..5).to_a)
(1..).lazy.parallel_each { |i| i }.first(5)
let(:threads) { 10 }
let(:threads) { 0 }
let(:threads) { 1 }
data = { x: "one", y: "two", z: "three" }
@copy = @orig.dup
let(:node) { { "kernel" => { "server_core" => true } } }
let(:node) { { "kernel" => { "product_type" => "Workstation" } } }
let(:node) { { "kernel" => { "product_type" => "Server" } } }
let(:node) { { "os_version" => "6.3.9600" } }
let(:node) { { "languages" => { "powershell" => { "version" => "4.0" } } } }
virtualization_reports_true_for(:hypervisor?, :physical?, :kvm_host?, node: { "virtualization" => { "system" => "kvm", "role" => "host" } })
virtualization_reports_true_for(:guest?, :virtual?, :lxc?, node: { "virtualization" => { "system" => "lxc", "role" => "guest" } })
virtualization_reports_true_for(:hypervisor?, :physical?, :lxc_host?, node: { "virtualization" => { "system" => "lxc", "role" => "host" } })
virtualization_reports_true_for(:guest?, :virtual?, :parallels?, node: { "virtualization" => { "system" => "parallels", "role" => "guest" } })
virtualization_reports_true_for(:hypervisor?, :physical?, :parallels_host?, node: { "virtualization" => { "system" => "parallels", "role" => "host" } })
virtualization_reports_true_for(:guest?, :virtual?, :virtualbox?, :vbox?, node: { "virtualization" => { "system" => "vbox", "role" => "guest" } })
virtualization_reports_true_for(:hypervisor?, :physical?, :vbox_host?, node: { "virtualization" => { "system" => "vbox", "role" => "host" } })
virtualization_reports_true_for(:guest?, :virtual?, :vmware?, node: { "virtualization" => { "system" => "vmware", "role" => "guest" } })
virtualization_reports_true_for(:hypervisor?, :physical?, :vmware_host?, node: { "virtualization" => { "system" => "vmware", "role" => "host" } })
virtualization_reports_true_for(:guest?, :virtual?, :openvz?, node: { "virtualization" => { "system" => "openvz", "role" => "guest" } })
virtualization_reports_true_for(:hypervisor?, :physical?, :openvz_host?, node: { "virtualization" => { "system" => "openvz", "role" => "host" } })
let(:options) { { platform: "ubuntu" } }
let(:options) { { platform: "raspbian" } }
let(:options) { { platform: "linuxmint" } }
let(:options) { { platform: "debian" } }
let(:options) { { platform: "aix" } }
let(:options) { { platform: "amazon" } }
let(:options) { { platform: "arch" } }
let(:options) { { platform: "centos" } }
let(:options) { { platform: "clearos" } }
let(:options) { { platform: "dragonfly4" } }
let(:options) { { platform: "fedora" } }
let(:options) { { platform: "freebsd" } }
let(:options) { { platform: "gentoo" } }
let(:options) { { platform: "mac_os_x" } }
let(:options) { { platform: "openbsd" } }
let(:options) { { platform: "oracle" } }
let(:options) { { platform: "redhat" } }
let(:options) { { platform: "smartos" } }
let(:options) { { platform: "solaris2" } }
let(:options) { { platform: "suse" } }
let(:options) { { platform: "windows" } }
let(:node) { { "platform" => "opensuseleap", "platform_version" => "15.1", "platform_family" => "suse", "os" => "linux" } }
let(:node) { { "platform" => "opensuse", "platform_version" => "11.0", "platform_family" => "suse", "os" => "linux" } }
let(:options) { { platform: "centos", version: "6" } }
pf_reports_true_for(:rhel?, :rpm_based?, :fedora_derived?, :redhat_based?, :el?, :rhel6?)
let(:options) { { platform: "centos", version: "7" } }
pf_reports_true_for(:rhel?, :rpm_based?, :fedora_derived?, :redhat_based?, :el?, :rhel7?)
let(:options) { { platform: "centos", version: "8" } }
pf_reports_true_for(:rhel?, :rpm_based?, :fedora_derived?, :redhat_based?, :el?, :rhel8?)
let(:options) { { platform: "clearos", version: "7" } }
pf_reports_true_for(:mac_os_x?, :mac?, :osx?, :macos?)
let(:options) { { platform: "opensuse" } }
pf_reports_true_for(:suse?, :rpm_based?)
let(:options) { { platform: "oracle", version: "6" } }
let(:options) { { platform: "oracle", version: "7" } }
let(:options) { { platform: "redhat", version: "6" } }
let(:options) { { platform: "redhat", version: "7" } }
let(:options) { { platform: "redhat", version: "8" } }
env = { "PATH" => nil }
env = { "PATH" => "/bin:/opt/app/bin:/sbin" }
env = { "PATH" => "%SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem;%SYSTEMROOT%\\System32\\WindowsPowerShell\\v1.0\\" }
let(:node) { double("node") }
context "#ci?" do
%w{ /etc /usr/lib /lib /run }.each do |base|
it "finds a unit in #{base}" do
it "finds a template in #{base}" do
cloud_reports_true_for(:cloud?, :alibaba?, node: { "alibaba" => {}, "cloud" => {} })
cloud_reports_true_for(:cloud?, :ec2?, node: { "ec2" => {}, "cloud" => {} })
cloud_reports_true_for(:cloud?, :gce?, node: { "gce" => {}, "cloud" => {} })
cloud_reports_true_for(:cloud?, :rackspace?, node: { "rackspace" => {}, "cloud" => {} })
cloud_reports_true_for(:cloud?, :eucalyptus?, :euca?, node: { "eucalyptus" => {}, "cloud" => {} })
cloud_reports_true_for(:cloud?, :linode?, node: { "linode" => {}, "cloud" => {} })
cloud_reports_true_for(:cloud?, :openstack?, node: { "openstack" => {}, "cloud" => {} })
cloud_reports_true_for(:cloud?, :azure?, node: { "azure" => {}, "cloud" => {} })
cloud_reports_true_for(:cloud?, :digital_ocean?, :digitalocean?, node: { "digital_ocean" => {}, "cloud" => {} })
cloud_reports_true_for(:cloud?, :softlayer?, node: { "softlayer" => {}, "cloud" => {} })
expect(described_class.cloud?({ "virtualbox" => {}, "cloud" => nil })).to be false
let(:node) { { "kernel" => { "machine" => arch } } }
arch_reports_true_for(:intel?, :_64_bit?)
let(:arch) { "amd64" }
let(:arch) { "ppc64" }
arch_reports_true_for(:ppc64?, :_64_bit?)
let(:arch) { "ppc64le" }
arch_reports_true_for(:ppc64le?, :_64_bit?)
let(:arch) { "s390x" }
arch_reports_true_for(:s390x?, :_64_bit?)
let(:arch) { "ia64" }
let(:arch) { "sparc64" }
let(:arch) { "aarch64" }
arch_reports_true_for(:_64_bit?, :arm?)
let(:arch) { "arch64" }
let(:arch) { "arm64" }
let(:arch) { "sun4v" }
arch_reports_true_for(:sparc?, :_64_bit?)
let(:arch) { "sun4u" }
let(:arch) { "i86pc" }
arch_reports_true_for(:i386?, :intel?, :_32_bit?)
let(:arch) { "i386" }
let(:arch) { "i686" }
let(:arch) { "powerpc" }
arch_reports_true_for(:powerpc?, :_32_bit?)
let(:arch) { "armhf" }
arch_reports_true_for(:armhf?, :_32_bit?, :arm?)
let(:arch) { "armv6l" }
let(:arch) { "armv7l" }
let(:arch) { "s390" }
arch_reports_true_for(:s390?, :_32_bit?)
val ||= ""
def +(other)
to_s + other
def *(other)
to_s * other
(self <=> other) == 0
def !=(other)
(self <=> other) != 0
def <(other)
(self <=> other) < 0
def <=(other)
(self <=> other) < 1
def >(other)
(self <=> other) > 0
def >=(other)
(self <=> other) > -1
def =~(other)
futures = map do |item|
max_queue: 0,
each do |k, v|
if v.is_a?(Mash) || v.is_a?(Array)
if key.is_a?(Symbol) && include?(key = key.to_s)
def key?(key)
super(*keys.map { |k| convert_key(k) })
value.collect { |e| convert_value(e) }
extra_path ||= __extra_path
exts.unshift("")
filename = File.join(path, "#{cmd}#{ext}")
def kvm?(node = __getnode)
node.dig("virtualization", "system") == "kvm" && node.dig("virtualization", "role") == "guest"
def kvm_host?(node = __getnode)
node.dig("virtualization", "system") == "kvm" && node.dig("virtualization", "role") == "host"
def lxc?(node = __getnode)
node.dig("virtualization", "system") == "lxc" && node.dig("virtualization", "role") == "guest"
def lxc_host?(node = __getnode)
node.dig("virtualization", "system") == "lxc" && node.dig("virtualization", "role") == "host"
node.dig("virtualization", "system") == "parallels" && node.dig("virtualization", "role") == "guest"
node.dig("virtualization", "system") == "parallels" && node.dig("virtualization", "role") == "host"
def vbox?(node = __getnode)
node.dig("virtualization", "system") == "vbox" && node.dig("virtualization", "role") == "guest"
def vbox_host?(node = __getnode)
node.dig("virtualization", "system") == "vbox" && node.dig("virtualization", "role") == "host"
def vmware?(node = __getnode)
node.dig("virtualization", "system") == "vmware" && node.dig("virtualization", "role") == "guest"
node.dig("virtualization", "system") == "vmware" && node.dig("virtualization", "role") == "host"
node.dig("virtualization", "system") == "vmware" && node.dig("vmware", "host", "type") == "vmware_desktop"
node.dig("virtualization", "system") == "vmware" && node.dig("vmware", "host", "type") == "vmware_vsphere"
def openvz?(node = __getnode)
node.dig("virtualization", "system") == "openvz" && node.dig("virtualization", "role") == "guest"
node.dig("virtualization", "system") == "openvz" && node.dig("virtualization", "role") == "host"
def guest?(node = __getnode)
node.dig("virtualization", "role") == "guest"
node.dig("virtualization", "role") == "host"
def vagrant?(node = __getnode)
vagrant_key?(node) || vagrant_domain?(node) || vagrant_user?(node)
node.key?("vagrant")
file_exist?("/usr/sbin/update-rc.d")
file_exist?("/usr/sbin/invoke-rc.d")
file_exist?("/etc/init.d/#{script}")
file_exist?("/etc/init/#{script}.conf")
file_exist?("/etc/xinetd.d/#{script}")
file_exist?("/etc/rc.d/#{script}")
file_exist?("/etc/init.d/#{script}") ||
def arch?(node = __getnode)
def aix?(node = __getnode)
def debian?(node = __getnode)
def fedora?(node = __getnode)
def macos?(node = __getnode)
alias_method :mac_os_x?, :macos?
def rhel?(node = __getnode)
alias_method :el?, :rhel?
def rhel6?(node = __getnode)
def rhel7?(node = __getnode)
def rhel8?(node = __getnode)
def amazon?(node = __getnode)
def smartos?(node = __getnode)
def suse?(node = __getnode)
def gentoo?(node = __getnode)
def freebsd?(node = __getnode)
def openbsd?(node = __getnode)
def netbsd?(node = __getnode)
def windows?(node = __getnode(true))
def rpm_based?(node = __getnode)
def bsd_based?(node = __getnode)
node.dig("os_release", "name") == "CentOS Stream"
node.dig("lsb", "id") == "CentOSStream"
def linux?(node = __getnode)
def darwin?(node = __getnode)
!!(node && node.read("chef_packages", "chef", "chef_effortless"))
def docker?(node = __getnode)
!!(node && node.read("virtualization", "systems", "docker") == "guest")
def systemd?(node = __getnode)
file_exist?("/proc/1/comm") && file_open("/proc/1/comm").gets.chomp == "systemd"
def kitchen?(node = __getnode)
def ci?(node = __getnode)
%w{ /etc /usr/lib /lib /run }.any? do |load_path|
file_exist?("#{load_path}/systemd/system/#{svc_name}")
env_path = "" if env_path.nil?
path_separator = ChefUtils.windows? ? ";" : ":"
ChefUtils.windows? ? %w{} : %w{/usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin}
def cloud?(node = __getnode)
def alibaba?(node = __getnode)
node.key?("alibaba")
def ec2?(node = __getnode)
node.key?("ec2")
def gce?(node = __getnode)
node.key?("gce")
def linode?(node = __getnode)
node.key?("linode")
def azure?(node = __getnode)
node.key?("azure")
def _64_bit?(node = __getnode)
def _32_bit?(node = __getnode)
!_64_bit?(node)
def i386?(node = __getnode)
_32_bit?(node) && intel?(node)
def intel?(node = __getnode)
def sparc?(node = __getnode)
def ppc64?(node = __getnode)
def ppc64le?(node = __getnode)
def powerpc?(node = __getnode)
def arm?(node = __getnode)
def armhf?(node = __getnode)
def s390x?(node = __getnode)
def s390?(node = __getnode)
GEM = "chef-cli"
let(:env) { {} }
let(:home) { "/Users/example.user" }
let(:env_pwd) { "/path/to/cwd" }
allow(File).to receive(:exist?).with("#{env_pwd}/.chef").and_return(true)
let(:cwd) { Dir.pwd }
let(:knife_home) { "/path/to/knife/home" }
let(:config_content) { "" }
let(:config_content) { "{{{{{:{{" }
let(:config_content) { ":foo\n:bar\nraise 'oops'\n:baz\n" }
let!(:confd_file) do
let(:syntax_error_content) { "{{{{{:{{" }
let(:home) { "C:/Users/example.user" }
let(:credentials_file) { "#{home}/.chef/credentials" }
let(:context_file) { "#{home}/.chef/context" }
content = <<~EOH
node_name = 'barney'
knife = {
client_key = """
stub_const("ENV", env)
let(:content) { "<<<<<" }
expect(path_helper.join("", "a", "b")).to eq("#{path_helper.path_separator}a#{path_helper.path_separator}b")
it "joins ending with '' add a / to the end" do
expect(path_helper.join("a", "b", "")).to eq("a#{path_helper.path_separator}b#{path_helper.path_separator}")
it "dirname('abc') is '.'" do
expect(path_helper.dirname("abc")).to eq(".")
it "dirname('/') is '/'" do
it "dirname('a/b/c') is 'a/b'" do
expect(path_helper.dirname(path_helper.join("a", "b", "c"))).to eq(path_helper.join("a", "b"))
it "dirname('a/b/c/') is 'a/b'" do
expect(path_helper.dirname(path_helper.join("a", "b", "c", ""))).to eq(path_helper.join("a", "b"))
it "dirname('/a/b/c') is '/a/b'" do
expect(path_helper.dirname(path_helper.join("", "a", "b", "c"))).to eq(path_helper.join("", "a", "b"))
it "path_separator is \\" do
expected = "C:\\foo\\bar\\baz"
expect(path_helper.join("C:\\foo/", "bar", "baz", windows: true)).to eq(expected)
expect(path_helper.join("C:\\foo\\", "bar", "baz", windows: true)).to eq(expected)
expect(path_helper.join("C:\\foo\\", "bar/", "/baz", windows: true)).to eq(expected)
expect(path_helper.join("C:\\foo", "bar", "baz", windows: true)).to eq(expected)
expect(path_helper.cleanpath("/a/b\\c/d/", windows: true)).to eq("\\a\\b\\c\\d")
expect(path_helper.cleanpath("\\\\a/b\\c/d/", windows: true)).to eq("\\\\a\\b\\c\\d")
expect(path_helper.cleanpath("/a///b/c/d/", windows: false)).to eq("/a/b/c/d")
expected = "/foo/bar/baz"
expect(path_helper.join("/foo/", "bar", "baz", windows: false)).to eq(expected)
expect(path_helper.join("/foo/", "bar/", "/baz", windows: false)).to eq(expected)
expect(path_helper.join("/foo", "bar", "baz", windows: false)).to eq(expected)
expect(path_helper.cleanpath("/a/b\\c/d/", windows: false)).to eq("/a/b/c/d")
expect(path_helper.cleanpath("\\\\a/b\\c/d/", windows: false)).to eq("//a/b/c/d")
expect(path_helper.join("C:\\foo/", "bar", "baz")).to eq(expected)
expect(path_helper.join("C:\\foo\\", "bar", "baz")).to eq(expected)
expect(path_helper.join("C:\\foo\\", "bar/", "/baz")).to eq(expected)
expect(path_helper.join("C:\\foo", "bar", "baz")).to eq(expected)
expect(path_helper.cleanpath("/a/b\\c/d/")).to eq("\\a\\b\\c\\d")
expect(path_helper.cleanpath("\\\\a/b\\c/d/")).to eq("\\\\a\\b\\c\\d")
expect(path_helper.cleanpath("/a///b/c/d/")).to eq("/a/b/c/d")
expect(path_helper.join("/foo/", "bar", "baz")).to eq(expected)
expect(path_helper.join("/foo/", "bar/", "/baz")).to eq(expected)
expect(path_helper.join("/foo", "bar", "baz")).to eq(expected)
expect(path_helper.cleanpath("\\\\a/b\\c/d/")).to eq("//a/b/c/d")
it "Adds the \\\\?\\ prefix if the path exceeds MAX_LENGTH and does not have it" do
long_path = "C:\\" + "a" * 250 + "\\" + "b" * 250
prefixed_long_path = "\\\\?\\" + long_path
expect(path_helper.windows_max_length_exceeded?("C:\\" + "a" * 250 + "\\" + "b" * 6)).to be_truthy
expect(path_helper.windows_max_length_exceeded?("C:\\" + "a" * 250 + "\\" + "b" * 5)).to be_falsey
expect(path_helper.windows_max_length_exceeded?("\\\\?\\C:\\" + "a" * 250 + "\\" + "b" * 250)).to be_falsey
expect(path_helper.printable?("\tThere's no way,\n\t *no* way,\n\t that you came from my loins.\n")).to be_falsey
expect(path_helper.canonical_path("\\\\?\\C:/windows/win.ini")).to eq("\\\\?\\c:\\windows\\win.ini")
it "adds the \\\\?\\ prefix if it is missing" do
expect(path_helper.canonical_path("C:/windows/win.ini")).to eq("\\\\?\\c:\\windows\\win.ini")
expect(path_helper.canonical_path("\\\\?\\C:\\CASE\\INSENSITIVE")).to eq("\\\\?\\c:\\case\\insensitive")
let(:is_windows) { true }
let(:is_windows) { false }
let(:enabled) { "0" }
context "on *nix" do
let(:fips_path) { "/proc/sys/crypto/fips_enabled" }
let(:enabled) { "1" }
let(:win_reg_entry) { { "Enabled" => enabled } }
let(:enabled) { 1 }
let(:enabled) { 0 }
let(:arch) { Win32::Registry::KEY_READ | 0x100 }
before { stub_const("::RbConfig::CONFIG", { "target_cpu" => "i386" } ) }
let(:arch) { Win32::Registry::KEY_READ | 0x200 }
before { stub_const("::RbConfig::CONFIG", { "target_cpu" => "x86_64" } ) }
before { stub_const("::RbConfig::CONFIG", { "target_cpu" => nil } ) }
it "var_chef_dir is /var/chef" do
it "var_root_dir is /var" do
it "etc_chef_dir is /etc/chef" do
it "var_chef_dir is C:\\chef" do
it "var_root_dir is C:\\" do
it "etc_chef_dir is C:\\chef" do
context "On #{is_windows ? "Windows" : "Unix"}" do
allow(ChefConfig::Config).to receive(:env).and_return({ "SYSTEMDRIVE" => "C:" })
let(:fips_enabled) { false }
let(:fips_enabled) { true }
let(:target_mode_primary_cache_path) { ChefUtils.windows? ? "#{primary_cache_path}\\#{target_mode_host}" : "#{primary_cache_path}/#{target_mode_host}" }
context "and config_dir is /a/b/c/" do
backup_path = is_windows ? "#{primary_cache_path}\\backup" : "#{primary_cache_path}/backup"
data_bag_path = is_windows ? "#{primary_cache_path}\\data_bags" : "#{primary_cache_path}/data_bags"
let(:secret_exists) { true }
let(:secret_exists) { false }
let(:locales) { locale_array.join("\n") }
let(:expected_locale) { "C.UTF-8" }
let(:expected_locale) { "en_US.UTF-8" }
let(:expected_locale) { "en.UTF-8" }
let(:expected_locale) { "en_AU.UTF-8" }
it "should default to 'en_US.UTF-8'" do
let(:http_proxy) { "http://localhost:7979" }
let(:https_proxy) { "https://localhost:7979" }
let(:ftp_proxy) { "ftp://localhost:7979" }
let(:proxy_user) { "http_user" }
let(:proxy_pass) { "http_pass" }
let(:scheme) { "http" }
let(:host) { "test.example.com" }
let(:port) { 8080 }
let(:proxy) { "#{proxy_prefix}#{proxy_host}:#{proxy_port}" }
let(:proxy_prefix) { "http://" }
let(:proxy_host) { "proxy.mycorp.com" }
let(:proxy_port) { 8080 }
let(:proxy_prefix) { "" }
let(:env) do
let(:scheme) { "https" }
it { is_expected.to eq nil }
(full_path.length - 1).downto(0) do |i|
end || Dir.pwd
if creds.key?("node_name") && creds.key?("client_name")
message = ""
message << "#{e.class.name}: #{e.message}\n"
IO.readlines(file).each_with_index { |l, i| config_file_lines << "#{(i + 1).to_s.rjust(3)}: #{l.chomp}" }
if line == 1
return end_slash == path.size ? "." : path_separator(windows: windows)
elsif slash == end_slash - 1
ChefConfig.logger.trace("Path '#{path}' is longer than #{WIN_MAX_PATH}, prefixing with'\\\\?\\'")
path.insert(0, "\\\\?\\")
unless /^\\\\?\\/.match?(path)
if add_prefix && abs_path !~ /^\\\\?\\/
abs_path.insert(0, "\\\\?\\")
@@home_dir = nil
@@home_dir ||= all_homes { |p| break p }
if @@home_dir
path = File.join(@@home_dir, *args)
block_given? ? (yield path) : path
valid_paths = paths.select { |home_path| home_path && Dir.exist?(home_path.force_encoding("utf-8")) }
joined_paths.each { |p| yield p }
field = ""
field << (word || esc.gsub(/\\(.)/, "\\1"))
fqdn.split(".").reduce(hash) do |h, k|
if Hash === v
train_config = {}
return matches.to_s.split(/\s*,\s*/).compact.any? do |m|
match = "*" + match unless match.start_with?("*")
def <<(_msg); end
def add(_severity, _message = nil, _progname = nil); end
def trace(_progname = nil, &block); end
def debug(_progname = nil, &block); end
def info(_progname = nil, &block); end
def warn(_progname = nil, &block); end
def error(_progname = nil, &block); end
def fatal(_progname = nil, &block); end
reg_type =
when "x86_64"
File.exist?(fips_path) && File.read(fips_path).chomp != "0"
@etc_chef_dir ||= {}
path = windows ? "C:\\" : "/var"
if option.empty? || !option.include?("=")
key, value = option.split(/\s*=\s*/, 2)
url = uri.to_s.strip
%r{^http://} =~ url || %r{^https://} =~ url || /^chefzero:/ =~ url
Array(path).map { |path| File.expand_path(path) }
File.expand_path("..", path)
path = cwd
new_path = File.expand_path("..", path)
if new_path == path
File.exist?(path) && File.readable?(path) && File.writable?(path)
default(:solo_d_dir) { PathHelper.join(config_dir, "solo.d") }
if chef_server_url.to_s =~ %r{/organizations/(.*)$}
default :hints, {}
default( :user_home ) { PathHelper.home || Dir.pwd }
default :watchdog_timeout, 2 * (60 * 60) # 2 hours
export_no_proxy(no_proxy) if key?(:no_proxy) && no_proxy
password_class = user_class + "\\:"
path = "#{scheme}://#{path}" unless path.include?("://")
if user && !user.empty?
path = uri.to_s
if %r{^.*://}.match?(proxy_env_var)
URI.parse("#{scheme}://#{proxy_env_var}")
guesses = locales.grep(/^en_.*UTF-?8$/i)
guessed_locale.gsub(/UTF-?8$/i, "UTF-8")
File.expand_path(__FILE__)
FRAMEWORK_NAMES = Hash.new { |h, k| k.split(/(?<=active|action)/).map(&:capitalize).join(" ") }
npm_version = version.gsub(/\./).with_index { |s, i| i >= 2 ? "-" : s }
if framework == "rails"
glob << "/version.rb"
glob << "/#{framework}/lib/*"
glob << "/gem_version.rb"
major, minor, tiny, pre = version.split(".", 4)
pre = pre ? pre.inspect : "nil"
ruby.gsub!(/^(\s*)MAJOR(\s*)= .*?$/, "\\1MAJOR = #{major}")
ruby.gsub!(/^(\s*)MINOR(\s*)= .*?$/, "\\1MINOR = #{minor}")
File.open(file, "w") { |f| f.write ruby }
Dir.chdir("#{framework}") do
cmd += "cd #{framework} && " unless framework == "rails"
cmd += "bundle exec rake package && " unless framework == "rails"
cmd += "gem build #{gemspec} && mv #{framework}-#{version}.gem #{root}/pkg/"
sh "gem install --pre #{gem}"
otp = ""
otp = " --otp " + `ykman oath accounts code -s rubygems.org`.chomp
sh "gem push #{gem}#{otp}"
npm_otp = ""
npm_otp = " --otp " + `ykman oath accounts code -s npmjs.com`.chomp
npm_tag = ""
npm_tag = " --tag pre"
npm_tag = remote_major_version <= local_major_version ? " --tag latest" : " --tag v#{local_major_version}"
sh "npm publish#{npm_tag}#{npm_otp}"
header = "## Rails #{version} (#{Date.today.strftime('%B %d, %Y')}) ##\n\n"
replace = "## Rails #{version} (#{Date.today.strftime('%B %d, %Y')}) ##\n"
contents = File.read(fname).sub(/^(## Rails .*)\n/, replace)
until contents.first =~ /^## Rails #{release_regexp}.*$/ ||
contents.first =~ /^Please check.*for previous changes\.$/ ||
app_name = "verify-#{version}-#{Time.now.to_i}"
sh "rails _#{version}_ new #{app_name} --skip-bundle" # Generate with the right version.
substitute.call("Gemfile", /^gem 'rails.*/, "gem 'rails', '#{version}'")
substitute.call("app/models/user.rb", /end\n\z/, <<~CODE)
<div class="field">
Avatar: <%= form.file_field :avatar %>
substitute.call("app/views/users/show.html.erb", /description %>\n<\/p>/, <<~CODE)
description %>\n</p>
<p>
<% if @user.avatar.attached? -%>
</p>
puts "- Viewing /users"
File.open("pkg/commit_message.txt", "w") do |f|
sh "git tag -s -m '#{tag} release' #{tag}"
sh "git push --tags"
@version.include?("rc")
Dir.chdir("pkg/") do
if versions.any?(&:rc?)
example_test = <<~RUBY
expected_map = {
10 => 10, # test_oneline
12 => 14, # declarative
16 => 19, # declarative w/parens
@output.stub(:tty?, true) do
st.time = 10
class Foo < Rails::Railtie ; config.to_prepare { $to_prepare = true } ; end
get "/"
Rails.env = "foo"
@plugin = engine "blog"
app_file "config/routes.rb", <<-RUBY
mount Weblog::Engine, :at => '/', :as => 'weblog'
scope "/:user", :user => "anonymous" do
mount Blog::Engine => "/blog"
root :to => 'main#index'
get '/weblog' => "weblogs#index", as: 'weblogs'
render inline: "<%= blog.post_path(1) -%>"
@plugin.write "lib/blog.rb", <<-RUBY
action: "index",
render inline: "<%= main_app.root_path %>"
render inline: "<%= asset_path 'images/foo.png', skip_pipeline: true %>"
render inline: "<%= file_field_tag :image, direct_upload: true %>"
render inline: "<%= blog.posts_path %>"
render inline: "<%= weblog.weblogs_path %>"
@app ||= begin
get "/john/blog/posts", {}, { "SCRIPT_NAME" => "/foo" }
get "/engine_route", {}, { "SCRIPT_NAME" => "/foo" }
get "/url_for_engine_route", {}, { "SCRIPT_NAME" => "/foo" }
get "/metrics/generate_blog_route", {}, { "SCRIPT_NAME" => "/foo" }
get "/metrics/generate_blog_route_in_view", {}, { "SCRIPT_NAME" => "/foo" }
get "/someone/blog/generate_application_route", {}, { "SCRIPT_NAME" => "/foo" }
post "posts", to: "posts#create"
post "/posts", TestInput.new("foo=bar")
tmp_path("foo_bar")
mountable = is_mountable ? "--mountable" : ""
rails("plugin new #{engine_path} --full #{mountable}")
File.open("Gemfile", "w") do |f|
f.write <<-GEMFILE.gsub(/^ {12}/, "")
path = "#{app_path}/tmp"
file_name = "#{path}/v0.1.4~alpha+nightly"
@plugin.write "app/assets/javascripts/engine.js.erb", "<%= :alert %>();"
@plugin.write "Rakefile", <<-RUBY
assert_no_match(/\d+_create_users/, output.join("\n"))
@blog = engine "blog" do |plugin|
plugin.write "lib/blog.rb", <<-RUBY
@api = engine "api" do |plugin|
plugin.write "lib/api.rb", <<-RUBY
@core = engine "core" do |plugin|
plugin.write "lib/core.rb", <<-RUBY
@api.write "db/migrate/2_create_keys.rb", <<-RUBY
@plugin.write "lib/bukkits.rb", <<-RUBY
@plugin.write "app/views/bukkit/index.html.erb", "Hello <%= bukkits %>"
get "/sprokkit", :to => Sprokkit
controller "foo", <<-RUBY
get 'foo', :to => 'foo#index'
get 'foo', to: 'bar#index'
get 'bar', to: 'bar#index'
get "/foo"
get "/bar"
@plugin.write "lib/tasks/foo.rake", <<-RUBY
en:
foo: "1"
bar: "1"
baz: "1"
).map { |path| File.expand_path(path) }
app_file "app/locales/en.yml", <<-YAML
foo: "2"
bar: "2"
foo: "3"
assert_equal "2", I18n.t(:foo)
assert_equal "1", I18n.t(:bar)
get "bar", to: "bar#index"
get "/admin/foo/bar"
@app = app
mount(Bukkits::Engine => "/bukkits")
get("/bukkits")
root to: "foo#index"
mount(Bukkits::Engine => "/:username")
get("/arunagw")
get("/bukkits/foo")
env = Rack::MockRequest.env_for("/")
get "/bar" => "bar#index", as: "bar"
mount Bukkits::Engine => "/bukkits", as: "bukkits"
get "/foo" => "foo#index", as: "foo"
get "/foo/show" => "foo#show"
get "/from_app" => "foo#from_app"
render inline: "<%= help_the_engine %>"
render inline: "<%= (self.respond_to?(:bar_path) || self.respond_to?(:something)) %>"
render inline: "<%= foo_path %>, <%= main_app.bar_path %>"
controller "bar", <<-RUBY
get("/bar")
<%= form_for(Bukkits::Post.new) do |f| %>
<%= f.text_field :title %>
<% end %>
mount Bukkits::Awesome::Engine => "/bukkits", :as => "bukkits"
get "/foo" => "foo#index"
@plugin.write "db/seeds.rb", <<-RUBY
app_file "db/seeds.rb", <<-RUBY
get("/foo")
get("/bukkits/bar")
engine_dir = @plugin.path.chomp("/").split("/").last
engine_path = File.join(@plugin.path, "..", engine_dir)
controller "main", <<-RUBY
render inline: '<%= render partial: "shared/foo" %>'
render inline: '<%= render partial: "shared/bar" %>'
get "/foo" => "main#foo"
get "/bar" => "main#bar"
app_file "app/views/shared/_foo.html.erb", <<-RUBY
@blog.write "app/views/shared/_bar.html.erb", <<-RUBY
app_file "app/views/shared/_bar.html.erb", <<-RUBY
// Bukkit's foo js
// App's foo js
// Blog's bar js
// App's bar js
get("/assets/foo.js")
get("/assets/bar.js")
assert_equal <<~EXPECTED, Rails.application.send(:ordered_railties).flatten.map(&:class).map(&:name).join("\n") << "\n"
path: \#{request.path}
mount Bukkits::Engine => "/"
path: /
get("/")
last_response.body.split("\n").map(&:strip)
get '/bar' => 'bar#index', :as => 'bar'
mount Bukkits::Engine => "/bukkits", :as => "bukkits"
get '/bukkit' => 'bukkit#index'
get("/bukkits/bukkit", {}, { "SCRIPT_NAME" => "/foo" })
main_app.bar_path: \#{main_app.bar_path}
frameworks = <<~RUBY
File.open("#{app_path}/config/application.rb", "w") { |f| f.puts frameworks + "\n" + environment }
output = `#{command}`
assert_predicate $?, :success?, "Command did not succeed: #{command}\n#{output}"
property("Bogus") { raise }
property("Goodbye") { "World" }
get :routes, params: { query: "rails_info_" }
get :routes, params: { query: "" }
get :routes, params: { query: "rails/info/route" }
get :routes, params: { query: "/rails/info/routes" }
get :routes, params: { query: "rails/info/routes" }
get :routes, params: { query: "rails/info/routes.html" }
get :routes, params: { query: "test/nested_route" }
get :routes, params: { query: "GE" }
get :routes, params: { query: "get" }
get :routes, params: { query: "GET" }
get :routes, params: { query: "rails_info" }
get :routes, params: { query: "rails/:test" }
get "/up" => "rails/health#show", as: :rails_health_check
gemspec = File.read(gemspec_path).gsub(/"TODO.*"/, "http://example.com".inspect)
gem "rails", path: #{File.expand_path("../..", __dir__).inspect}
@root = Rails::Paths::Root.new("/foo/bar")
root = Rails::Paths::Root.new("/fiz/baz")
root.path = "/root"
@root.add "app"
@root.add "app", with: "/foo/bar"
@root.add "app/models", with: "/foo/bar/baz"
@root.add "app/models", with: "baz"
@root.add "app", with: "/app"
@root.add "app", with: "/app", autoload_once: true
@root.add "app", with: "/app", eager_load: true
@root.add "app", with: "/app", eager_load: true, autoload_once: true
@root.add "app", with: "/app", glob: "*.rb"
@root.add "app", glob: "*.rb"
@root.add "app", with: "/app", load_path: true
@root.add "app", with: "/app", autoload: true
root = Rails::Paths::Root.new("foo")
path ||= uri_or_host.path
body.each { |part| new_body << part }
app = self
@routes = TestSet.new ->(c) { app.controller = c }
url = URI("http://example.org/blogs")
send_request(url, "GET", nil, "/FOO")
send_request(url, "GET", nil)
@output = StringIO.new("".encode("UTF-8"))
def self.name; "Foo"; end
app = ->(env) {
assert_nil app.call(make_env("t" => nil))
assert_nil app.call(make_env("t" => data))
(+"").tap do |body|
def build_app(options = {})
routes = File.read("#{app_path}/config/routes.rb")
if routes =~ /(\n\s*end\s*)\z/
File.open("#{app_path}/config/routes.rb", "w") do |f|
f.puts $` + "\nActionDispatch.deprecator.silence { match ':controller(/:action(/:id))(.:format)', via: :all }\n" + $1
File.open("#{app_path}/config/database.yml", "w") do |f|
config.hosts << proc { true }
<<: *default
@app.config.hosts << proc { true }
get "/" => "omg#index"
path = "#{@path}/#{file}"
File.open(path, "w") { |f| f.puts string }
File.delete("#{@path}/#{file}")
dir = "#{app_path}/random/#{name}"
app.insert(4, "$:.unshift(\"#{dir}/lib\")")
app.insert(5, "require #{name.inspect}")
File.open("#{app_path}/config/application.rb", "r+") do |f|
command = "bin/rails #{Shellwords.join args}#{' 2>&1' unless stderr}"
fork = false if args.first == "t" || args.grep(/\Atest(:|\z)/).any?
$stdin.reopen(File::NULL, "r")
case $!
exit! $!.status
err_write.puts "#{$!.class}: #{$!}"
$-v = $-w = false
load "./bin/rails"
output = `cd #{app_path}; #{command}`
raise "rails command failed (#{$?.exitstatus}): #{command}\n#{output}" unless allow_failure || $?.success?
if environment =~ /(Rails::Application\s*)/
File.open("#{app_path}/config/application.rb", "w") do |f|
f.puts $` + $1 + "\n#{str}\n" + $'
if environment =~ /(\n\s*end\s*end\s*)\z/
f.puts $` + "\n#{str}\n" + $1
if environment =~ /(\n\s*end\s*)\z/
File.open("#{app_path}/config/environments/#{env}.rb", "w") do |f|
contents.sub!(/#{str}/, "")
def app_file(path, contents, mode = "w")
file_name = "#{app_path}/#{path}"
File.open(file_name, mode) do |f|
FileUtils.mkdir_p("#{app_path}/#{path}")
FileUtils.rm_rf "#{app_path}/#{path}"
$:.reject! { |path| path =~ %r'/(#{to_remove.join('|')})/' }
output = `#{cmd}`
File.open("#{app_template_path}/config/boot.rb", "w") do |f|
contents.sub!(/^Bundler\.require.*/, "%w(sprockets/railtie importmap-rails).each { |r| require r }")
@foo ||= 0
@foo += 1
@bar ||= 0
@bar += 1
$arr << 1
$arr << 2
$arr << 3
$arr << 4
$arr << 5
$with_arg = arg
$arr << two
foo = Foo.new
bar = Bar.new
$with_arg = nil
@path = File.expand_path("lib", Rails.root)
name = :tas
self.class.class_eval(<<-end_eval, __FILE__, __LINE__ + 1)
template = File.join(Rails.root, "lib", "templates", "active_record", "model", "model.rb")
File.open(template, "w") { |f| f.write "empty" }
assert_match(/:: 2 ::/, output)
switch_env("BUNDLE_GEMFILE", "") { `bin/rails test #{arguments}` }
assert_file "bin/rails", /#!foo\/bar\/baz/
assert_file "bin/rails", /#!\/usr\/bin\/env/
apply_stub = -> (path, *) { applied = path }
rails_path = File.expand_path("../../..", Rails.root)
Rails.stub(:gem_version, Gem::Version.new("2.1.0")) do
Rails.stub(:gem_version, Gem::Version.new("2.1.0.alpha")) do
@bundle_command_stub ||= -> (command, *) { @bundle_commands << command }
option_args, positional_args = args.partition { |arg| arg.start_with?("--") }
@bundle_command_stub = -> (command, *) do
/, #{constraint}/
%w(index show).each do |view|
%w(edit new).each do |view|
assert_match(/post product_lines_url, params: \{ product_line: \{ product_id: @product_line\.product_id, title: @product_line\.title, user_id: @product_line\.user_id \} \}/, test)
assert_match(/@admin_roles = Admin::Role\.all/, m)
assert_match(/@admin_role = Admin::Role\.new/, m)
assert_match(/@admin_role = Admin::Role\.new\(admin_role_params\)/, m)
assert_match(/@admin_role\.save/, m)
assert_match(/@admin_role\.destroy!/, m)
content = File.read(route_path).gsub(/\.routes\.draw do/) do |match|
assert_file "config/routes.rb", /\.routes\.draw do\s*\|map\|\s*$/
content.gsub!(/^\n/, "")
assert_file "config/routes.rb", /\.routes\.draw do\nend\n\z/
assert_match(/t\.string :title/, up)
assert_match(/t\.text :body/, up)
assert_match(/t\.string :name/, up)
assert_match(/permit\(:name, :currency_id, :user_id\)/, m)
assert_match(/^\W{4}<%= form\.text_field :name %>/, content)
assert_match(/^\W{4}<%= form\.text_field :currency_id %>/, content)
assert_match(/^\W{2}<%= @accounts.each do |account| %>/, content)
assert_match(/^\W{4}<%= render account %>/, content)
assert_match(/<%= link_to "Show this account", account %>/, content)
assert_match(/<%= render @account %>/, content)
assert_match(/^\W{4}<%= form\.file_field :video %>/, content)
assert_match(/^\W{4}<%= form\.file_field :photos, multiple: true %>/, content)
assert_match(/^\W{4}<%= link_to message\.video\.filename, message\.video if message\.video\.attached\? %>/, content)
assert_match(/^\W{6}<div><%= link_to photo\.filename, photo %>/, content)
assert_match(/permit\(:content\)/, m)
assert_match(/^\W{4}<%= form\.rich_text_area :content %>/, content)
assert_match(/<%= form\.password_field :password %>/, content)
assert_match(/password_digest: <%= BCrypt::Password.create\("secret"\) %>/, content)
with_new_plugin(engine_path, "--mountable", "--api") do
with_new_plugin(engine_path, "--full", "--api") do
assert_match(/@users = User\.all/, m)
assert_match(/@user = User\.new/, m)
assert_match(/@user = User\.new\(user_params\)/, m)
assert_match(/@user\.save/, m)
assert_match(/@user\.update\(user_params\)/, m)
assert_match(/@user\.destroy/, m)
assert_match(/params\.require\(:user\)\.permit\(:name, :age\)/, content)
assert_match(/params\.fetch\(:user, \{\}\)/, content)
assert_match(/params\.require\(:line_item\)\.permit\(:product_id, :cart_id\)/, content)
assert_match(/post users_url, params: \{ user: \{ age: @user\.age, name: @user\.name, organization_id: @user\.organization_id, organization_type: @user\.organization_type \} \}/, content)
assert_match(/@users = User\.find\(:all\)/, m)
assert_no_match(/@users = User\.all/, m)
assert_match("@users = User.all", m)
assert_no_match %r/\b(new_|edit_)?users?_(path|url)/, content
assert_match(/@user\.errors/, m)
%w(
).each { |path| assert_file path }
plugin_file "test/post_test.rb", <<-RUBY
capture(:stderr) { run_test_command("test/post_test.rb --fail-fast") })
a = 1
plugin_file "test/#{name}_test.rb", <<-RUBY
assert #{pass}, 'wups!'
File.open("#{plugin_path}/#{path}", mode) do |f|
filled_in = File.read(gemspec_path).gsub(/"TODO.*"/, "http://example.com".inspect)
repository_path = File.expand_path("../../..", __dir__)
File.write(gemfile_path, "gem 'rails', path: #{repository_path.inspect}\n", mode: "a")
assert_file ".git/HEAD", /main/
assert_file ".git/HEAD", /master/
assert_file "Gemfile", /# gem "debug"/
output = `bin/rails db:migrate 2>&1`
assert $?.success?, "Command failed: #{output}"
assert_match "<%= csrf_meta_tags %>", contents
assert_match "<%= csp_meta_tag %>", contents
assert_match "<%= yield %>", contents
folders_with_keep = %w(
assert_file("#{folder}/.keep")
rails_version = "1.2.3.4.pre5"
assert_file "bin/rails", /ENGINE_PATH = File\.expand_path\("\.\.\/lib\/bukkits\/engine", __dir__\)/
assert_file "bin/rails", /ENGINE_ROOT = File\.expand_path\("\.\.", __dir__\)/
assert_file "bin/rails", %r|APP_PATH = File\.expand_path\("\.\./test/dummy/config/application", __dir__\)|
assert_file "bin/rails", /#!\/usr\/bin\/env ruby/
output = `bin/test 2>&1`
assert_no_match(/#{year}/, contents)
name = "TODO: Write your name"
assert_match(/<%= yield %>/, view)
assert_match(%r|APP_PATH = File\.expand_path\("\.\./test/dummy/config/application", __dir__\)|, content)
silence(:stdout) { generator.send(*args, &block) }
assert_file "config/routes.rb", /get 'account\/foo'/, /get 'account\/bar'/
content.split("\n").each do |line|
assert_no_match(/^\s+$/, line, "Don't indent blank lines")
assert_match(/test "foo"/, test)
assert_match(/test "bar"/, test)
assert_match(/<%= @greeting %>/, view)
assert_name g, "Admin::Foo", :class_name
assert_name g, "Admin::Foo", :name
assert_file "app/models/admin.rb", /"admin_"/
assert_match(/t\.integer :user_id/, up)
assert_match(/t\.string :order_id/, up)
assert_match(/t.string :title, limit: 40/, up)
assert_match(/t.decimal :price, precision: 5, scale: 2/, up)
expected_file = <<~FILE
assert_match(/t\.references :user,.*\snull: false/, up)
assert_match(/t\.belongs_to :user,.*\snull: false/, up)
assert_match(/t\.belongs_to :user/, up)
assert_match(/^\s*$/, change)
assert_migration "db2/migrate/#{migration}.rb", /.*/
assert_match(/mail to: "to@example\.org"/, foo)
assert_match(/@greeting = "Hi"/, foo)
assert_match(/mail to: "to@example\.org"/, bar)
assert_match(/@greeting = "Hi"/, bar)
destination File.expand_path("../fixtures/tmp", __dir__)
setup { Rails.application.config.root = Pathname("../fixtures").expand_path(__dir__) }
test: {
erb = ERB.new(File.read(file), trim_mode: "-", eoutvar: "@output_buffer")
assert_match 'gem "pg", "~> 1.1"', content
assert_match 'gem "mysql2", "~> 0.5"', content
assert_match 'gem "sqlite3", "~> 1.4"', content
x.report("before") { }
x.report("after") { }
x.report("with_patch") { }
x.report("without_patch") { }
define_method(:puts) { |string| output = string }
define_method(:exit) { |code| exit_code = code }
define_method(:puts) { |msg| message = msg }
file.puts "--hello --world"
define_method(:puts) { |msg| }
file.puts "--hello"
file.puts "--world"
quietly { system "#{File.expand_path("../../exe/rails", __dir__)} new test --no-rc" }
output = `#{File.expand_path("../../exe/rails", __dir__)} new mysecondapp`
assert_file "Gemfile", /^# gem "image_processing"/
File.open(absolute, "r") do |f|
assert_gem "sqlite3", '"~> 1.4"'
assert_gem "mysql2", '"~> 0.5"'
assert_gem "pg", '"~> 1.1"'
assert_gem "puma", /"\W+ \d/
assert_file "Gemfile", /^# gem "redis"/
assert_file ".gitattributes", /\.enc diff=/
assert_no_match %r/\.enc diff=/, content
quietly { `./bin/rails g scaffold User` }
action :file, "lib/test_file.rb", "here's test data"
mock_original_env = -> do
ensure_environment_is_set = -> *_args do
command_check = -> command, *_ do
assert_match(/\d+\.\d+\.\d+/, content)
assert_match(/ruby "#{Gem::Version.new(Gem::VERSION) >= Gem::Version.new("3.3.13") ? Gem.ruby_version : RUBY_VERSION}"/, content)
Gem.stub(:ruby_version, Gem::Version.new("2.7.0")) do
option_args << "--no-skip-bundle"
gemfile_contents.sub!(/^(gem "rails").*/, "\\1, path: #{File.expand_path("../../..", __dir__).inspect}")
quietly { system({ "BUNDLE_GEMFILE" => "Gemfile" }, "yes | bin/rails app:update", exception: true) }
capture(:stdout) { generator.send(*args, &block) }
assert_match(/# gem "rack-cors"/, content)
{ api: true, update: true }, { destination_root: destination_root, shell: @shell }
action(:create_file, "lib/test_file.rb") { "here's block data" }
assert_file "Gemfile", /source "http:\/\/gems\.github\.com"\n/
action :gem, "rspec", ">= 2.0.0.a5"
action :gem, "RedCloth", ">= 4.1.0", "< 4.2.0"
action :gem, "nokogiri", version: ">= 1.4.2"
assert_match(/gem "rspec", ">= 2\.0\.0\.a5"/, content)
assert_match(/gem "RedCloth", ">= 4\.1\.0", "< 4\.2\.0"/, content)
assert_match(/gem "nokogiri", ">= 1\.4\.2"/, content)
assert_match(/gem "faker", ">= 0\.1\.0", "< 0\.3\.0"/, content)
File.open("Gemfile", "a") { |f| f.write("# Some content...") }
action :gem, "rspec"
assert_file "Gemfile", /^gem "rspec"$/
assert_file "Gemfile", /^gem "rspec-rails"$/
action :gem, "rspec", github: "dchelimsky/rspec", tag: "1.2.9.rc1"
assert_file "Gemfile", /gem "rspec", github: "dchelimsky\/rspec", tag: "1\.2\.9\.rc1"/
action :gem, "rspec", comment: "Use RSpec"
assert_file "Gemfile", /# Use RSpec\ngem "rspec"/
assert_file "Gemfile", /^gem "rspec", require: false$/
action :gem, "rspec", ">=2.0.0"
assert_file "Gemfile", /^gem "rspec", ">=2\.0\.0"$/
action :gem, -"frozen_gem", -"1.0.0"
assert_file "Gemfile", /^gem "frozen_gem", "1\.0\.0"$/
gem "foo"
gem "bar"
gem "baz"
action :github, "user/repo", a: "correct", other: true do
github "user/repo", a: "correct", other: true do
github "user/repo2", a: "correct", other: true do
action :github, "user/repo2", a: "correct", other: true do
File.open("Gemfile", "a") { |f| f.write('gem "rspec-rails"') }
action :git, rm: "README", add: "."
action :vendor, "vendor_file.rb", "# vendor data"
puts "one"
puts "two"
action(:vendor, "vendor_file.rb") { code }
action(:lib, "my_library.rb") { code }
action(:rakefile, "myapp.rake") { code }
assert_runs "rake log:clear", env: { "RAILS_ENV" => "development" } do
assert_runs "rake log:clear", env: { "RAILS_ENV" => "production" } do
assert_runs "rails log:clear", env: { "RAILS_ENV" => "development" } do
assert_runs "rails log:clear", env: { "RAILS_ENV" => "production" } do
action :route, "get 'foo'\nget 'bar'", namespace: :baz
get 'foo'
get 'bar'
get 'foo2'
get 'bar2'
get 'foo3'
get 'bar3'
get 'foo1'
get 'bar1'
assert_equal("YES\n", action(:log, "YES"))
assert_equal("", action(:log, "YES"))
assert_equal("", action(:log, :yes, "YES"))
def action(...)
capture(:stdout) { generator.send(...) }
def revoke(...)
action(...)
def assert_runs(commands, config = {}, &block)
command_matcher = command_matcher.sub(/^sudo\\ /, '\A\1.*')
%r{
}x
assert_match %r"^#{Regexp.escape 'import "trix"'}", content
run_command_stub = -> (command, *) { @run_commands << command }
@routes = nil
@hello = "world"
in_plugin_context(plugin_path) { `bin/rails --help` }
in_plugin_context(plugin_path) { system({ "RAILS_ENV" => "test" }, "bin/rails runner 'puts Rails.env'") }
Process.spawn("bin/rails #{command}", in: fd, out: fd, err: fd)
output = +""
output << io.read(1)
defined?(PTY) && PTY.respond_to?(:open)
get "/", to: "my#index", as: :my_route
<h1>Hello world</h1>
get "/one", to: "action#one"
get "/two", to: "action#two"
get "/one", to: "posts#one"
get "/two", to: "users#two"
app_file "test/some_test.rb", ""
run_test_command("test", "./test/*_test.rb")
run_test_command("test", "--seed", "1234", "-e", "development")
run_test_command("test", "-n", "test_some_code")
run_test_command("test", "-n", "/some_code/")
run_test_command("test", "-n", "some code")
run_test_command("test", "--name", "test_some_code")
run_test_command("test", "--name=test_some_code")
app_file "Rakefile", ""
run_test_command("test:all", "-n", "test_some_code")
run_test_command("test:models", "-n", "test_some_code")
app_file "Rakefile", <<~RUBY, "a"
output = run_command("--using", "tin")
output = run_command("--using", "t")
switch_env "PORT", "1234" do
switch_env "PORT", "3001" do
Dir.chdir("..") do
args = %w(-p 4567 -b 127.0.0.1 -c dummy_config.ru -d -e test -P tmp/server.pid -C)
expected = "bin/rails server -p 4567 -b 127.0.0.1 -c dummy_config.ru -d -e test -P tmp/server.pid -C --restart"
args = %w(-u webrick -b 127.0.0.1 -p 4567)
command_output = `echo "puts 'Hello world'" | #{app_path}/bin/rails runner -`
app_file "lib/foo.rb", "# Lib file"
app_file "foo.rb", <<-RUBY
get '/cart', to: 'cart#show'
post '/cart', to: 'cart#create'
app_file "db/some_seeds.rb", "# FIXME: note in db directory"
app_file "lib/some_file.rb", "# TODO: note in lib directory"
app_file "test/some_test.rb", "\n" * 100 + "# FIXME: note in test directory"
app_file "spec/spec_helper.rb", "# TODO: note in spec"
add_to_config %q{ config.annotations.register_extensions("scss", "sass") { |annotation| /\/\/\s*(#{annotation}):?\s*(.*)$/ } }
app_file "app/models/profile.rb", '"# TODO: do something"'
lambda { |n, &b| dependencies.each { |m, *ds| ds.each(&b) if m == n } })
add_to_config "config.hosts = IPAddr.new('0.0.0.0/0')"
add_to_config "config.ssl_options = { redirect: { host: 'example.com' } }"
render plain: ""
get "/?nothing=true"
env = ::Rack::MockRequest.env_for("/foo/?something")
add_to_config "config.active_record.shard_resolver = ->(*) { }"
app_file ".gitignore", ""
def run_edit_command(file = @encrypted_file, key: nil, editor: "cat", **options)
args.push("--key", key) if key
app_file("tmp/restart.txt", "")
app_file("tmp/caching-dev.txt", "")
username: "foo",
password: "bar",
}.sort
app_db_config({}) do
setup { build_app }
content = "foo: #{content_path}"
if %r"config/credentials(?:/.*)?\.yml\.enc$".match?(content_path)
app = build_app(nil)
def bar(*paths); end
def perform(*); end
def foo(*); end
self.bin = "FOO"
raise "not populated" if ARGV.empty? || ARGV != args
ARGV << "isolate this"
@tmp_path = File.expand_path("fixtures/tmp", __dir__)
File.write File.join(@tmp_path, ".example.rb"), <<-CODE
puts 'foo'
temp_file "stats.rb", code do |path|
temp_file "foo_test.rb", code do |path|
class A < B
function foo(x, y, z) {
doX();
$(function () {
bar();
var baz = function ( x ) {
alert('foo');
// var b = 2;
var a = 1;
/*
1 / 2;
// call();
//
<!-- This is an HTML comment -->
<%# This is a great comment! %>
<div>
<%= hello %>
square = (x) -> x * x
math =
cube: (x) -> x * square x
fill = (container, liquid = "coffee") ->
$('.shopping_cart').bind 'click', (event) =>
constructor: (@name) ->
move: (meters) ->
alert @name + " moved #{meters}m."
move: ->
dir = File.expand_path "fixtures/tmp", __dir__
path = "#{dir}/#{name}"
add_to_env_config "development", <<~'RUBY'
app_file "extras0/x.rb", "X = 0"
app_file "extras1/y.rb", "Y = 0"
engine("blog") do |bukkit|
app_dir "lib"
extras = %w(e1 e2 e3)
add_to_config %(config.autoload_once_paths << "\#{Rails.root}/#{extra}")
extras = extras.map { |extra| "#{app_path}/#{extra}" }
app_file "app/models/child.rb", <<~RUBY
logger = ->(_msg) { }
add_to_config %(config.autoload_once_paths << "\#{Rails.root}/extras")
out, _err = capture_io { boot }
get 'pages/:id', to: 'pages#show'
get "/pages/foo"
output = rails("-v")
get "/" => "omg#index", as: :omg
relative_url = "/hello"
app_file "test/unit/foo_test.rb", <<-RUBY
get '/posts'
app_file "db/schema.rb", ""
app_file "db/schema.rb", <<-RUBY
app_file "db/structure.sql", ""
app_file "db/structure.sql", <<-SQL
User.create! name: "Jon", email: "jon@doe.com"
app_file "lib/tasks/hooks.rake", <<-RUBY
puts "before: " + has_user_table.to_s
puts "after: " + has_user_table.to_s
assert_not_equal 0, $?.to_i
assert_equal 0, $?.to_i, result
rails "test", "#{app_path}/test/#{name}", allow_failure: true
assert_match "FooTest", rails("test:all", "--verbose")
suites.each { |suite| create_test_file suite, "foo_#{suite}" }
run_test_command("") .tap do |output|
app_file "test/unit/chu_2_koi_test.rb", <<-RUBY
Dir.chdir(app_path) { FileUtils.rm_r "test/#{directory}" }
run_test_command("test\\\\models").tap do |output|
pos_cases = {
assert_match "PostTest:FirstFilter", output, "for #{cmd} (#{name})"
assert_match "PostTest:SecondFilter", output, "for #{cmd} (#{name})"
assert_match "2 runs, 2 assertions", output, "for #{cmd} (#{name})"
test "foo" do
app_file "config/boot.rb", <<-RUBY
10.times do |n|
matches = @test_output.match(/(\d+) runs, (\d+) assertions, (\d+) failures/)
file = app_file "test/fail_test.rb", <<-RUBY
@proc = ->{ }
output = Dir.chdir(app_path) { `echo ".tables" | rails dbconsole` }
rails "db:drop:all", "db:create:all", "db:migrate"
output = Dir.chdir(app_path) { `bin/rake test TESTOPTS=-v` }
filter_map { |line| JSON.parse(line) if line.start_with?("{") }
output = Dir.chdir(app_path) { `bin/rake test TESTOPTS='-v --seed=1234'` }
output = Dir.chdir(app_path) { `bin/rake db:migrate test:models TESTOPTS='-v' && echo ".tables" | rails dbconsole` }
output = Dir.chdir(app_path) { `bin/rake test echo` }
run_test_command("").tap do |output|
output = Dir.chdir(app_path) { `bin/rake test` }
output = Dir.chdir(app_path) { `DEFAULT_TEST_EXCLUDE="test/smoke/**/*_test.rb" bin/rake test` }
rails "generate", "model", "user", "name:string"
id: 1
id: 2
id: 3
def create_fixture_test(path = :unit, name = "test")
app_file "test/#{path}/#{name}_test.rb", <<-RUBY
puts "\#{User.count} users (\#{__FILE__})"
def create_test_file(path = :unit, name = "test", pass: true, print: true)
puts "#{name.camelize}Test" if #{print}
test "one" do
WR2.write "y" # Allow two to run
test "two" do
WR1.write "x" # Allow one to run
Q2 << "y"
Q1 << "x"
file_content = ERB.new(<<-ERB, trim_mode: "-").result_with_hash(with: with.to_s)
parallelize(workers: 2, with: :<%= with %>, threshold: #{threshold})
app_file "test/unit/env_test.rb", <<-RUBY
rails "generate", "scaffold", "user", "name:string"
get 'foo', to: 'foo#index', as: 'test_foo'
app("test")
File.open("#{app_path}/config/boot.rb", "w") do |f|
pid = nil
add_to_config(<<~CODE)
app_file "app/models/user.rb", <<-MODEL
assert_match "/rails runner", rails("runner", "--help")
assert_match "42", rails("runner", "puts User.count")
output = rails("runner", "puts ARGV.join(',')", "--foo", "a1", "-b", "a2", "a3", "--moo")
assert_equal "--foo,a1,-b,a2,a3,--moo", output.chomp
app_file "bin/count_users.rb", <<-SCRIPT
assert_match "42", rails("runner", "bin/count_users.rb")
app_file "bin/dollar0.rb", <<-SCRIPT
assert_match %w( a b ).to_s, rails("runner", "bin/program_name.rb", "a", "b")
assert_match "42", Dir.chdir(app_path) { `cat bin/count_users.rb | bin/rails runner -` }
assert_match "production", rails("runner", "-e", "production", "puts Rails.env")
assert_match "production", rails("runner", "-e", "prod", "puts Rails.env")
app_file "app/models/task.rb", <<-MODEL
assert_match "42", rails("runner", "puts Task.count")
get '*foo', to: 'foo#index'
assert_welcome get("/")
get "/", to: "foo#index"
get "up" => "rails/health#show", as: :rails_health_check
get "/up"
render inline: "<%= foo_or_bar? %>"
get '/foo' => 'foo#index'
get 'admin/foo', to: 'admin/foo#index'
get 'foo', to: 'foo#index'
get "/admin/foo"
add_to_config <<-R
get "/win"
app_file "config/routes.rb", <<-R
get 'lol' => 'hello#index'
app_file "app/models/user.rb", <<-RUBY
@_model_name ||= ActiveModel::Name.new(self.class, nil, "User")
get 'custom', to: 'foo#custom'
get 'mapping', to: 'foo#mapping'
direct(:custom) { "http://www.microsoft.com" }
resolve("User") { "/profile" }
get 'foo', to: 'foo#bar'
get "/custom"
direct(:custom) { "http://www.apple.com" }
resolve("User") { "/dashboard" }
get 'foo', to: 'foo#baz'
root :to => 'foo#index'
direct(:custom) { 'http://www.apple.com' }
resolve('User') { '/profile' }
get ':locale/foo', to: 'foo#index', as: 'foo'
get 'users', to: 'foo#users', as: 'users'
direct(:microsoft) { 'http://www.microsoft.com' }
get "/en/foo"
get ':locale/bar', to: 'bar#index', as: 'foo'
direct(:apple) { 'http://www.apple.com' }
get "/en/bar"
get '/url', to: 'url#index'
controller "url", <<-RUBY
get "/url"
get '/bar', to: 'foo#index', as: 'foo'
get "/pages/foo.bar"
app_file "lib/tasks/app.rake", <<-RUBY
backtrace = rails("boom", allow_failure: true).lines.grep(/:\d+:in /)
rails "generate", "model", "product", "name:string"
output = rails("db:test:prepare", "test")
app_file "app/models/hello.rb", <<-RUBY
puts "Answer: " + Hello::TEST.to_s
output = rails("test")
with_rails_env("test") { rails("db:migrate") }
rails "generate", "model", "Product"
rails "generate", "model", "Cart"
output = rails("db:test:prepare", "--trace")
rails "g", "model", "post", "title:string"
output = rails("db:migrate:redo", "--trace")
assert_no_match(/^\*\* Invoke db:structure:dump\s+$/, output)
rails "generate", "model", "post", "title:string"
assert File.exist?(File.join(app_path, "lib", "templates", "erb", dir))
assert File.exist?(File.join(app_path, "lib", "templates", "rails", dir))
app_file "template.rb", ""
output = rails("db:drop")
output = rails("db:create:#{namespace}")
output = rails("db:drop:#{namespace}")
if schema_format == "ruby"
rails "db:migrate:#{database}", "db:schema:dump:#{database}"
rails("db:migrate:#{name}")
if name == "primary"
rails("db:migrate:#{name}", "db:schema:dump:#{name}")
output = rails("db:test:prepare:#{name}", "--trace")
ar_tables = lambda { rails("runner", "-e", "test", "p ActiveRecord::Base.connection.tables").strip }
output = rails("db:setup")
output = rails("db:setup:#{namespace}")
output = rails("db:reset")
output = rails("db:reset:#{namespace}")
down_output = rails("db:migrate:down:#{namespace}", "VERSION=#{version}")
up_output = rails("db:migrate:up:#{namespace}", "VERSION=#{version}")
down_output = rails("db:migrate:down", "VERSION=#{version}")
up_output = rails("db:migrate:up", "VERSION=#{version}")
if db_config.name == "primary"
FileUtils.mv(Dir.glob("#{app_path}/db/migrate/**/*dogs.rb").first, "db/animals_migrate/") unless Dir.glob("#{app_path}/db/animals_migrate/**/*dogs.rb").first
FileUtils.rm(Dir.glob("#{app_path}/db/migrate/**/*dogs.rb").first) if Dir.glob("#{app_path}/db/migrate/**/*dogs.rb").first
app_path("/app/models/dog.rb") do |file_name|
file = File.read("#{app_path}/app/models/dog.rb")
File.open("#{app_path}/app/models/animals_base.rb", "w") do |file|
file.write(<<~EOS)
rails "generate", "model", "book", "title:string"
rails "generate", "model", "dog", "name:string"
rails("db:drop:all")
dummy_task = <<~RUBY
app_file("Rakefile", dummy_task, "a+")
rails("db:migrate", "foo")
entries = output.scan(/^== (\d+).+migrated/).map(&:first).map(&:to_i)
db_up_and_down "01"
db_up_and_down "01", "primary"
db_up_and_down "02", "animals"
rails "generate", "model", "recipe", "title:string"
output = rails("db:seed")
database: <%=
%>
<% else %>
<% 5.times do |i| %>
shard_<%= i %>:
<<: *development
File.open("test/models/book_test.rb", "w") do |file|
test "a book" do
assert_no_match(/add_column\(:users, :email, :string\)/, output)
output = rails("db:migrate", "VERSION=0")
assert_match(/add_column\(:users, :email, :string\)/, output)
output = rails("db:rollback", "STEP=2")
assert_match(/up\s+\d{14}\s+Create users/, output)
assert_match(/up\s+\d{14}\s+Add email to users/, output)
rails "db:rollback", "STEP=1"
assert_match(/up\s+\d{3,}\s+Create users/, output)
assert_match(/up\s+\d{3,}\s+Add email to users/, output)
assert_match(/down\s+\d{3,}\s+Add email to users/, output)
rails "db:rollback", "STEP=2"
rails "db:forward", "STEP=2"
assert_match(/up\s+\d{14}\s+\** NO FILE \**/, output)
output = rails("db:migrate", "VERSION='0 '", allow_failure: true)
output = rails("db:migrate", "VERSION=1.", allow_failure: true)
output = rails("db:migrate", "VERSION=1_", allow_failure: true)
assert_match(/down\s+\d{3,}\s+Create users/, output)
output = rails("generate", "model", "author", "name:string")
rails "db:migrate:up", "db:migrate:down", "VERSION=#{version}"
rails "generate", "model", "reviews", "book_id:integer"
assert_match(/execute\("SELECT 1"\)/, output)
File.write("log/test.log", "test")
File.write("log/dummy.log", "dummy")
File.write("#{app_path}/config/database.yml", <<~YAML)
<% 1 %>
FileUtils.chmod("-w", "db")
FileUtils.chmod("+w", "db")
output = rails("db:drop:_unsafe", "--trace")
assert_match(/up\s+\d{14}\s+Create books/, output)
rails "db:drop", "db:create"
rails "runner", <<~RUBY
t.virtual :pages_plus_1, type: :integer, as: "pages + 1", stored: true
rails "generate", "model", "admin::book", "title:string"
rails("db:prepare", "db:drop", "db:create")
app_file "db/schema.rb", "# Not touched"
app, _ = Rack::Builder.parse_file("#{app_path}/config.ru")
@app = rackup
@logs ||= Rails.logger.logged(:info).join("\n")
get "/blah"
head "/blah"
post "/", _method: "put"
assert_match 'Started PUT "/"', logs
post "/", _method: "head"
assert_match 'Started GET "/" for 1.2.3.4', logs
rails("generate", "scaffold", "Pet", "name:string", "--database=animals")
app_file "app/jobs/user_job.rb", <<-RUBY
get "/", to: "users#index"
assert_match(/pid='\d+'/, comment)
assert_match(/\/\*action='index',controller='users',pid='\d+'\*\//, comment)
assert_match(/\/\*action='index',namespaced_controller='users',pid='\d+'\*\//, comment)
assert_match(/\/\*job='UserJob',pid='\d+'\*\//, comment)
render html: "<h1>Welcome to Rails!</h1>"
<% cache customer do %>
<%= customer.name %>
config.root = "#{app_path}"
app_path(*path).to_s
@output = rails("generate", "scaffold", "Pet", "name:string", "--database=animals")
output = rails("destroy", "scaffold", "Pet", "--database=animals")
output = rails("generate", "scaffold", "Dog", "name:string", "--database=animals")
get "foo"
get "/?flash=true"
cipher = "aes-256-gcm"
get '/dump_flash' => "test#dump_flash"
get "/read_session" => "test#read_session"
get "/test_action" => "test#test_action"
app_file "public/foo.txt", "foo"
def remote_ip(env = {})
env = Rack::MockRequest.env_for("/").merge(env).merge!(
endpoint = Proc.new do |e|
assert_equal "1.1.1.1", remote_ip("REMOTE_ADDR" => "1.1.1.1")
assert_equal "1.1.1.2", remote_ip("HTTP_CLIENT_IP" => "1.1.1.2")
assert_equal "1.1.1.1",
assert_equal "10.0.0.0",
assert_match(/oops/, log, log)
get "/foo", to: "foo#index"
match "/406", to: "foo#not_acceptable", via: :all
<% raise 'boooom' %>
File.expand_path("#{app_path}/../new_app")
expected = "Wed, 30 May 1984 19:43:31 GMT"
get "/expires/expires_etag", { private: true }, { "HTTP_IF_NONE_MATCH" => etag }
get "/rails/mailers", {}, { "REMOTE_ADDR" => "4.2.42.42" }
mailer "notifier", <<-RUBY
text_template "#{keyword}/foo", <<-RUBY
<p>Hello, World!</p>
get "/rails/mailers", {}, { "SCRIPT_NAME" => "/my_app" }
<p>Hello, <%= @name %>!</p>
Hello, <%= @name %>!
message = ::Mail.new do
body '<p>Goodbye, World!</p>'
mail to: "to@example.org", cc: "cc@example.com", bcc: "bcc@example.com"
assert_match "<dd id=\"to\">to@example.org</dd>", last_response.body
assert_match "<dd id=\"cc\">cc@example.com</dd>", last_response.body
assert_match "<dd id=\"bcc\">bcc@example.com</dd>", last_response.body
<%= @template %>
app_file "app/models/post.rb", <<-MODEL
p = Post.create(title: "omg")
app_file "app/models/post.rb", <<-RUBY
e = assert_raise(NameError) { User }
e = assert_raise(NameError) { Post }
get "/load"
get "/unload"
get "/c"
$counter ||= 0
$counter += 1
$counter ||= 1
get "/title"
add_column :posts, :body, :text, default: "BODY"
get "/body"
puts "Error loading metal: \#{e.class} \#{e.message}"
get "/:controller(/:action)"
get "/omg/show"
2.times do |i|
callback = ->(*_) { events << _ }
assert_not_includes $:, "#{app_path}/app/models"
app_file "lib/foo.rb", <<-RUBY
assert_includes $:, "#{app_path}/lib"
app_file "app/anything/foo.rb", <<-RUBY
app_file "lib/zoo.rb", <<-ZOO
app_file "lib/zoo/reptile_house.rb", <<-ZOO
config.eager_load_paths << "#{app_path}/lib"
app_file "config/another_locale.yml", "en:\nfoo: ~"
app_file "app/models/foo.rb", <<-RUBY
@foo = I18n.t(:foo)
get "/i18n"
fr:
test "config.i18n.fallbacks.map = { :ca => :'es-ES' } initializes fallbacks with a mapping ca => es-ES" do
I18n::Railtie.config.i18n.fallbacks.map = { ca: :'es-ES' }
I18n::Railtie.config.i18n.fallbacks = { ca: :en }
config.to_prepare { $order << :to_prepare }
app_file "app/mailers/foo.rb", <<-RUBY
render inline: "<%= from_app_helper -%> <%= from_foo_helper %>"
render inline: "<%= respond_to?(:from_bar_helper) -%>"
render json: { omg: 'omg' }
assert_equal '{"omg":"omg"}', last_response.body
add_to_config "config.encoding = '#{charset}'"
Dir.chdir("#{app_path}/app") do
app_file "app/models/a.rb", "A = 1"
app_file "app/models/m.rb", "module M; end"
app_file "app/models/post.rb", <<~RUBY
def self.is_a?(_)
def self.<(_)
output = rails("help")
output = rails("-h")
output = rails("")
output = gem_rails("")
expected = { rails: { orm: :data_mapper, test_framework: :rspec, helper: false } }
c.generators.aliases = { rails: { test_framework: "-w" } }
expected = { rails: { test_framework: "-w" } }
g.plugin aliases: { generator: "-g" },
rails: { orm: :data_mapper },
plugin: { generator: true },
assert_equal({ plugin: { generator: "-g" } }, c.generators.aliases)
rails "generate", "mailer", "notifier", "foo"
output = rails("generate", "--help")
output = rails("destroy", "--help")
rails("generate", "model", "post", "title:string")
output = rails("generate", "model", "post", "title:string", "body:string")
output = rails("generate", "model", "post", "title:string", "body:string", "--skip-collision-check")
output = rails("generate", "model", "post", "title:string", "body:string", "--force")
expected = %w(
File.open(model_file, "a") { |f| f.write("# Add comment to model") }
rails("generate", "scaffold", "post", "title:string")
Process.spawn("#{app_path}/bin/rails dbconsole #{options}", in: fd, out: fd, err: fd)
resets { Time.zone = "UTC" }
<%= Current.customer&.name || 'noone' %>,<%= Time.zone.name %>
a = b = c = nil
ActiveSupport::Reloader.to_complete { a = b = c = 1 }
ActiveSupport::Reloader.to_complete { b = c = 2 }
assert_equal "Once upon a time in a world...",
app_file "app/models/post.rb", <<-CODE
assert_output "> ", @primary
in: @replica, out: @replica, err: @replica
assert_output "> ", @primary, 30
options = "--sandbox -- --singleline --nocolorize"
write_prompt "Post.count", "=> 0"
write_prompt "Post.count", "=> 1"
output = `#{app_path}/bin/rails console --sandbox`
options = "-e test -- --verbose --singleline --nocolorize"
write_prompt "a = 1", "a = 1"
super(@io)
with_rails_env("") do
with_rack_env("") do
app_file "lib/my_logger.rb", <<-RUBY
assert_changes -> { File.exist?(File.join(app_path, "db", "schema.rb")) }, from: false, to: true do
Rails.env = "test"
config.root = '#{new_app}'
File.delete("#{app_path}/config.ru")
Dir.chdir("#{app_path}") do
render inline: "<%= csrf_meta_tags %>"
render inline: "<%= begin; form_for(Post.new) {|f| f.text_field(:name)}; rescue => e; e.to_s; end %>"
get "/posts"
render inline: "<%= begin; form_with(model: Post.new) {|f| f.text_field(:name)}; rescue => e; e.to_s; end %>"
assert_no_match(/id=('|")post_name('|")/, last_response.body)
assert_match(/id=('|")post_name('|")/, last_response.body)
render inline: "<%= begin; form_for(Post.new) {}; rescue => e; e.to_s; end %>"
get "/posts/1"
put "/posts/1", params
script_name: "/bar",
%w(title)
post "/posts.json", '{ "title": "foo", "name": "bar" }', "CONTENT_TYPE" => "application/json"
post "/posts", post: { "title" => "zomg" }
post "/posts", post: { "title" => "zomg" }, format: "json"
app "test"
format.html { render plain: "HTML" }
format.xml { render plain: "XML" }
get "/", {}, { "HTTP_ACCEPT" => "application/xml" }
get "/", { format: :xml }, { "HTTP_ACCEPT" => "application/xml" }
session_options = { key: "_myapp_session", cookie_only: true }
/#\s*(#{tag}):?\s*(.*)$/
<%= Rails.env %>:
foo: "bar"
baz: 1
foo: 0
assert_equal({ foo: 0, bar: { baz: 1 } }, actual)
assert_equal({ foo: 0, bar: { baz: 1 } }, actual.to_h)
- foo
- bar
- baz
qux: 2
key: <%= 'custom key' %>
key: foo:
set_custom_config <<~RUBY, "'custom', env: 'production'"
key: 'walrus'
YAML.stub :load, { "development" => { "key" => "value" } } do
render inline: "<%= stylesheet_link_tag '/application.css' %>"
smtp_settings = { domain: "example.com", open_timeout: 5, read_timeout: 5 }
smtp_settings = { domain: "example.com" }
email: {
root: "#{Dir.tmpdir}/email",
output = rails("routes", "-g", "active_storage")
ActiveRecord::Base.configurations = { production: { db1: { adapter: "mysql2" } } }
def new(app); self; end
ActiveRecord::Base.configurations = { production: { db1: { adapter: "postgresql" } } }
I18n.exception_handler = ->(exception, *) {
I18n.backend.store_translations :en, pears: { pear: "pear", pears: "pears" }
assert_equal "one or none", I18n.t(:apples, count: 0)
assert_equal "pears", I18n.t(:pears, count: 0)
rails "generate", "model", "article"
File.write("log/test.log", "zomg!")
output = `bin/setup 2>&1`
output.sub!(/^Resolving dependencies\.\.\.\n/, "")
output.gsub!(/^The dependency .* will be unused .*\.\n/, "")
output.sub!(/^yarn install v.*?$/, "yarn install")
output.sub!(/^Done in \d+\.\d+s\.\n/, "Done in 0.00s.\n")
output.gsub!(/^warning:\s.*\n/, "")
env.each_key { |k| ENV.delete k.to_s }
app_file "app/assets/javascripts/demo.js.erb", "a = <%= image_path('rails.png').inspect %>;"
assert_equal "alert();\n", File.read(file)
app_file "app/models/user.rb", <<-eoruby
//= link_tree ../images
app_file "app/assets/stylesheets/application.css.erb", "body { background: '<%= asset_path('rails.png') %>'; }"
add_to_config "config.assets.prefix = '/x'"
get "/assets/#{asset_path}"
app_file "app/assets/stylesheets/application.css.erb", "p { background-image: url(<%= asset_path('rails.png') %>) }"
app_file "app/assets/images/rails.png", "p { url: change }"
app_file "app/assets/config/manifest.js", "//= link_tree ../images"
app_file "public/assets/application.css", "a { color: green; }"
assert_equal 0, files.length, "Expected no assets, but found #{files.join(', ')}"
app_file "app/assets/javascripts/demo.js.erb", "<%= :alert %>();"
get '/omg', :to => "omg#index"
get "/omg"
app_file "#{dir}/assets/#{dir}_test.erb", "testing"
app_file "app/assets/javascripts/xmlhr.js.erb", "<%= Post.name %>"
get "/posts", {}, { "HTTPS" => "off" }
get "/posts", {}, { "HTTPS" => "on" }
app_file "app/assets/javascripts/image_loader.js.erb", "var src='<%= image_path('rails.png') %>';"
app_file "app/assets/javascripts/app.js.erb", "var src='<%= image_path('rails.png') %>';"
app_file "app/assets/javascripts/xmlhr.js", "function f1() { alert(); }"
get '/posts', :to => "posts#index"
get '/posts', to: "posts#index"
cases = {
app_file "app/views/posts/#{view_method}.html.erb", "<%= #{view_method} '#{contents}', skip_pipeline: true %>"
assert_match(tag_match, body, "Expected `#{view_method}` to produce a match to #{tag_match}, but did not: #{body}")
app_file "app/views/posts/#{view_method}.html.erb", "<%= #{view_method} '#{contents}', skip_pipeline: true %> "
/\/assets\/application-.*.\.js/ => {},
app_file "app/views/posts/version_#{index}.html.erb", "<%= asset_path('application.js', #{options_hash}) %>"
assert_match(tag_match, body, "Expected `asset_path` with `#{options_hash}` to produce a match to #{tag_match}, but did not: #{body}")
app_file "app/views/posts/#{view_method}.html.erb", "<%= #{ view_method } 'application.js' %>"
assert_match(tag_match, body, "Expected `#{view_method}` to produce a match to #{ tag_match }, but did not: #{ body }")
@loader ||= Class.new do
@cwd = Dir.pwd
exe = "#{script_dir}/rails"
write "foo/bar/#{exe}"
write "foo/#{exe}", keyword
Dir.chdir("foo/bar")
config.root = __dir__
def jruby_skip(message = "")
@begins_to_ends = {}
def on_def(begin_line, *)
def first_arg(arg, *)
parts << part
opts.on("--warnings", "-w", "Run with Ruby warnings enabled") { }
opts.on("-e", "--environment ENV", "Run tests in the ENV environment") { }
env_index = argv.index("--environment") || argv.index("-e")
w_index = argv.index("--warnings") || argv.index("-w")
if filters.any? { |_, lines| lines.any? }
path = path.tr("\\", "/")
when /(:\d+)+$/.match?(path)
file, *lines = path.split(":")
arg.start_with?("/") && arg.end_with?("/")
if filter.is_a?(String) && !filter.start_with?("test_")
filter = filter.gsub(/\s+/, "_")
def ===(method)
@filters.any? { |filter| filter === method }
elsif filter =~ %r%/(.*)/% # Regexp filtering copied from minitest.
lines.map { |line| Filter.new(@runnable, file, line) }
@line = line.to_i if line
test_file == @file && test_range.include?(@line)
file.sub(/^#{app_root}\/?/, "")
@app_root ||= self.class.app_root ||
codes = { red: 31, green: 32, yellow: 33 }
def run(reporter, options = {})
).tap { |arr|
}.each do |task|
@comments << Annotation.new(lineno, $1, $2) if value =~ pattern
lineno = 0
lineno += 1
list << Annotation.new(lineno, $1, $2)
@@directories ||= %w(app config db lib test)
@@extensions ||= {}
register_extensions("builder", "rb", "rake", "ruby") do |tag|
ParserExtractor.new(/#\s*(#{tag}):?\s*(.*)$/)
register_extensions("yml", "yaml") do |tag|
PatternExtractor.new(/#\s*(#{tag}):?\s*(.*)$/)
register_extensions("css", "js") do |tag|
PatternExtractor.new(/\/\/\s*(#{tag}):?\s*(.*)$/)
PatternExtractor.new(/<%\s*#\s*(#{tag}):?\s*(.*?)\s*%>/)
def to_s(options = {})
s << text
def self.enumerate(tag = nil, options = {})
tag ||= Annotation.tags.join("|")
@tag = tag
dirs.inject({}) { |h, dir| h.update(find_in(dir)) }
results = {}
Dir.glob("#{dir}/*") do |item|
puts "#{file}:"
@cipher = "aes-128-gcm"
secrets ||= {}
FileUtils.mv("#{path}.tmp", path)
@root.join("config", "secrets.yml.key")
@root.join("config", "secrets.yml.enc").to_s
if path.end_with?(".enc")
tmp_file = "#{File.basename(path)}.#{Process.pid}"
@@options ||= {}
@@watchable_dirs ||= {}
super || @@options.key?(name.to_sym)
if name.end_with?("=")
@instance ||= new
def <=>(other) # :nodoc:
@@load_counter ||= 0
@load_index = (@@load_counter += 1)
var_name = "@#{type}"
blocks << blk if blk
def call_app(request, env) # :doc:
sprintf('Started %s "%s" for %s at %s',
@root = {}
def add(path, options = {})
values.tap(&:uniq!)
filter_by(&:load_path?)
}.uniq
keys = @root.keys.find_all { |k|
k.start_with?(@current) && k != @current
def <<(path)
@paths << path
map do |p|
if @glob && File.directory?(path)
if !does_exist && File.symlink?(f)
expanded.select { |d| File.directory?(d) }
files = Dir.glob(@glob, base: path)
files.map! { |file| File.join(path, file) }
send_data @email.to_s, filename: "#{@email_action}.eml"
def show_previews? # :doc:
if formats.any? { |f| @email.mime_type == f }
def find_part(format) # :doc:
select { |i| i.before == initializer.name || i.name == initializer.after }.each(&block)
def initializer(name, opts = {}, &blk)
layout -> { request.xhr? ? false : "application" }
@page_title = "Routes"
normalized_path = ("/" + query).squeeze("/")
query_without_url_or_path_suffix = query.gsub(/(\w)(_path$)/, '\1').gsub(/(\w)(_url$)/, '\1')
match ||= (query === route_wrapper.verb)
map(&:first)
class << self # :nodoc:
value ||= yield
value = value.join(", ") if value.is_a?(Array)
info * "\n"
(+"<table>").tap do |table|
table << %(<tr><td class="name">#{CGI.escapeHTML(name.to_s)}</td>)
table << %(<td class="value">#{formatted_value}</td></tr>)
table << "</table>"
%(<html><body style="background-color: #{color}"></body></html>).html_safe
def setup # :nodoc:
def generator(args = default_arguments, options = {}, config = {})
assert content =~ /(\s+)def #{method}(\(.+\))?(.*?)\n\1end/m, "Expected to have method #{method}"
@_file_name ||= super.sub(/_test\z/i, "")
@fixture_name ||=
attributes_hash.map { |k, v| "#{k}: #{v}" }.join(", ")
attribute = attributes.find { |attr| attr.name == name }
directory ".", "test"
template "unit_test.rb", File.join("test/models", class_path, "#{file_name}_test.rb")
@_file_name ||= super.sub(/_mailer\z/i, "")
template "unit_test.rb", File.join("test/jobs", class_path, "#{file_name}_job_test.rb")
@_file_name ||= super.sub(/_job\z/i, "")
@controller_class_path = name.include?("/") ? name.split("/") : name.split("::")
@controller_i18n_scope ||= controller_file_path.tr("/", ".")
@orm_class ||= begin
template "task.rb", File.join("lib/tasks", "#{file_name}.rake")
params = others.map { |name| ":#{name}" }
params.join(", ")
if engine? && !api?
insert_into_file "#{dummy_path}/config/application.rb", indent(<<~RUBY, 4), after: /^\s*config\.load_defaults.*\n/
bin_file = engine? ? "bin/rails.tt" : "bin/test.tt"
entry = "\ngem '#{name}', path: '#{relative_path}'"
if !engine? || !with_dummy_app?
build(:assets_manifest) if !api? && engine?
@name ||= begin
@namespaced_name ||= name.tr("-", "/")
@modules ||= namespaced_name.camelize.split("::")
unwrapped_code = "#{unwrapped_code}".strip.gsub(/\s$\n/, "")
str = +"module #{mod}\n"
str << (content.present? ? "\nend" : "end")
@camelized ||= name.gsub(/\W/, "_").squeeze("_").camelize
if /-\d/.match?(original_name)
elsif /^\d/.match?(camelized)
log ""
@_file_name ||= super.sub(/_helper\z/i, "")
log "Adding #{key_path} to store the encryption key: #{key}"
/(\b#{all_database_gem_names.join('\b|\b')}\b)/
/^gem.*\b#{gem_name}\b.*/
gem_name_and_version.map! { |segment| "\"#{segment}\"" }
say ""
routing_code = actions.map { |action| "get '#{file_name}/#{action}'" }.join("\n")
name.sub(/_?controller$/i, "")
def #{method}(*args, &block)
@generator.send(:#{method}, *args, &block)
build(:db)
def file(*args, &block)
def after_bundle(&block) # :doc:
@argv = argv
File.expand_path("~/.railsrc")
if argument == "new"
if argv.find { |arg| arg == "--no-rc" }
argv.reject { |arg| arg == "--no-rc" }
railsrc(argv) { |rc_argv, rc| insert_railsrc_into_argv!(rc_argv, rc) }
if (customrc = argv.index { |x| x.include?("--rc=") })
puts "Using #{extra_args.join(" ")} from #{railsrc}"
argv.take(1) + extra_args + argv.drop(1)
template(source + ".js", destination + ".js")
def file_path # :doc:
def class_path # :doc:
def class_name # :doc:
def human_name # :doc:
def plural_name # :doc:
def i18n_scope # :doc:
@i18n_scope ||= file_path.tr("/", ".")
def table_name # :doc:
@table_name ||= begin
def index_helper(type: nil) # :doc:
def show_helper(arg = "@#{singular_table_name}", type: :url) # :doc:
def edit_helper(...) # :doc:
def new_helper(type: :url) # :doc:
def route_url # :doc:
@route_url ||= controller_class_path.collect { |dname| "/" + dname }.join + "/" + plural_file_name
resource_name = "#{prefix}#{base_name}"
@class_path = name.include?("/") ? name.split("/") : name.split("::")
names << "#{a.name}_type" if a.polymorphic?
def self.check_class_collision(options = {}) # :doc:
name != name.underscore &&
migration_lookup_at(dirname).grep(/\d+_#{file_name}.rb$/).first
if type && !valid_type?(type)
raise Error, "Could not generate field '#{name}' with unknown type '#{type}'."
when /(string|text|binary|integer)\{(\d+)\}/
return $1, limit: $2.to_i
return :decimal, precision: $1.to_i, scale: $2.to_i
when /(references|belongs_to)\{(.+)\}/
type = $1
return type, {}
def initialize(name, type = nil, index_type = false, attr_options = {})
@field_type ||= case type
@default ||= case type
%w(id type).map { |t| "#{name}_#{t}" }
@column_name ||= reference? ? "#{name}_id" : name
name.end_with?("_id")
name == "password" && type == :digest
type == :token
type == :rich_text
(+"").tap { |s| options_for_migration.each { |k, v| s << ", #{k}: #{v.inspect}" } }
has_uniq_index? ? ", unique: true" : ""
module Erb # :nodoc:
view_base_path = File.join("app/views", class_path, file_name + "_mailer")
class Error < Thor::Error # :nodoc:
@desc ||= if usage_path
@namespace ||= super.delete_suffix("_generator").sub(/:generators:/, ":")
in_base = options.delete(:in) || base_name
{ banner: "" }
{ desc: "#{name.to_s.humanize} to be invoked", banner: "NAME" }
def self.class_option(name, options = {}) # :nodoc:
__dir__
if base.name && !base.name.end_with?("Base")
if base.name.include?("::")
nesting = class_name.split("::")
def indent(content, multiplier = 2) # :doc:
spaces = " " * multiplier
content.each_line.map { |line| line.blank? ? line : "#{spaces}#{line}" }.join
def namespaced? # :doc:
@namespace_dirs ||= namespace.name.split("::").map(&:underscore)
@namespaced_path ||= namespace_dirs.join("/")
def self.banner # :doc:
def self.base_name # :doc:
@base_name ||= if base = name.to_s.split("::").first
@generator_name ||= if generator = name.to_s.split("::").last
@hooks ||= from_superclass(:hooks, {})
no_tasks {
@shebang ||= begin
source_root && File.expand_path("../USAGE", source_root),
@app_const_base ||= app_name.gsub(/\W/, "_").squeeze("_").camelize
@app_const ||= "#{app_const_base}::Application"
if /^\d/.match?(app_const)
class AppBase < Base # :nodoc:
desc: "Name of the app"
@gem_filter = lambda { |gem| true }
def builder # :doc:
@builder ||= begin
def build(meth, *args) # :doc:
->(&block) { option_reasons.each_key(&block) },
option_reasons = {}
due_to = reasons.map { |reason| "--#{reason.dasherize}" }.join(", ")
def create_root # :doc:
when /^https?:\/\//
@required_railties ||= {
%(require "rails/all")
%(#{"# " if !required}require "#{railtie}")
def comment_if(value) # :doc:
question = "#{value}?"
comment ? "# " : ""
def keeps? # :doc:
def sqlite3? # :doc:
def skip_action_text? # :doc:
(comment.gsub(/^/, "# ").chomp + "\n" if comment),
("# " if commented_out),
options.dev? || options.edge? || options.main?
%(Bundle edge Rails instead: gem "rails", github: "rails/rails", branch: "main"))
rubies = shebangs.scan(%r{#!/usr/bin/env (ruby.*)}).flatten.uniq
binfixups = (rubies - %w(ruby)).map do |ruby|
if has_cr || (Gem.win_platform? && !binfixups.empty?)
binfixups.unshift 'sed -i "s/\r$//g" bin/*'
when /^2\.7/
bullseye = Gem.ruby_version >= Gem::Version.new("2.7.4")
when /^3\.0/
bullseye = Gem.ruby_version >= Gem::Version.new("3.0.2")
packages << "python"
GemfileEntry.new("redis", ">= 4.0.1", comment, {}, true)
say_status :run, "bundle #{command}"
Gem.rubygems_version >= Gem::Version.new("3.3.22") ? "windows" : "mswin mswin64 mingw x64_mingw"
git_source(:github) { |repo| "https://github.com/\#{repo}.git" }
if Gem::Version.new(git_version) >= Gem::Version.new("2.28.0")
def initialize(*) # :nodoc:
message << " (#{_versions.join(", ")})"
str << "# #{comment_line}"
str << "\n"
str << "gem #{parts.join(", ")}"
str = names.map(&:inspect)
str = str.join(", ")
log :gemfile, "group #{str}"
def github(repo, options = {}, &block)
log :github, "github #{str}"
def add_source(source, options = {}, &block)
def environment(data = nil, options = {})
data ||= yield if block_given?
def git(commands = {})
run "git #{commands}"
run "git #{cmd} #{options}"
rails_command "generate #{what} #{args.join(" ")}", options
def rake(command, options = {})
empty_block_pattern = /(#{namespace_pattern})((?:\s*end\n){1,#{namespace.size}})/
def log(*args) # :doc:
args << (behavior == :invoke ? :green : :red)
def execute_command(executor, command, options = {}) # :doc:
config = {
in_root { run("#{sudo}#{Shellwords.escape Gem.ruby} bin/#{executor} #{command}", config) }
def quote(value) # :doc:
return value.map do |k, v|
return "#{value}\n" unless value.is_a?(String)
gsub_file path, /\n?\z/, options do |match|
match.end_with?("\n") ? "" : "\n#{str}\n"
rails: {
actions: "-a",
orm: "-o",
stylesheets: "-y",
template_engine: "-e",
test_framework: "-t"
test_unit: {
@fallbacks ||= {}
hide_namespaces "assets", "helper", "css", "js"
api: true,
sorted_groups.each { |b, n| print_list(b, n) }
base = namespace.split(":").first
rails.map! { |n| n.delete_prefix("rails:") }
def find_by_namespace(name, base = nil, context = nil) # :nodoc:
lookups << "#{name}:#{context}" if context
unless name.to_s.include?(?:)
lookups << "#{name}:#{name}"
lookups << "rails:#{name}"
lookups << "#{name}"
def invoke(namespace, args = ARGV, config = {})
names = namespace.to_s.split(":")
if klass = find_by_namespace(names.pop, names.any? && names.join(":"))
args << "--help" if args.empty? && klass.arguments.any?(&:required?)
@command_type ||= "generator"
{ engine: true }, { destination_root: ENGINE_ROOT }
@_all ||= ::Rails::Railtie.subclasses.map(&:instance) +
def each(*args, &block)
_all.each(*args, &block)
def -(others)
_all - others
@paths ||= begin
glob: "{*,*/concerns}",
paths.add "config/initializers", glob: "**/*.rb"
call_stack = caller_locations.map { |l| l.absolute_path || l.path }
@endpoint ||= nil
define_method(:table_name_prefix) { "#{name}_" }
class_eval "def use_relative_model_naming?; true; end", __FILE__, __LINE__
@helpers ||= begin
@env_config ||= {}
if !isolated? || (app == self)
def routes? # :nodoc:
def run_tasks_blocks(*) # :nodoc:
while root_path && File.directory?(root_path) && !File.exist?("#{root_path}/#{flag}")
root_path = parent != root_path && parent
root = File.exist?("#{root_path}/#{flag}") ? root_path : default
@_all_autoload_paths ||= begin
@_all_load_paths ||= begin
elsif caching == false && File.exist?(FILE)
def insert_before(...)
@operations << -> middleware { middleware.insert_before(...) }
def insert_after(...)
@operations << -> middleware { middleware.insert_after(...) }
def swap(...)
@operations << -> middleware { middleware.swap(...) }
def use(...)
@operations << -> middleware { middleware.use(...) }
def delete(...)
@delete_operations << -> middleware { middleware.delete(...) }
def move_before(...)
@delete_operations << -> middleware { middleware.move_before(...) }
def move_after(...)
@delete_operations << -> middleware { middleware.move_after(...) }
def unshift(...)
@operations << -> middleware { middleware.unshift(...) }
def +(other) # :nodoc:
@fallbacks = {}
method = method.to_s.delete_suffix("=").to_sym
if method == :rails
if method == :rails || args.first.is_a?(Hash)
@routes ||= begin
def help(command_name = nil, *)
if command_name == "test"
Minitest.run(%w(--help))
$LOAD_PATH << Rails::Command.root.join("test").to_s
desc name, "Run tests in test/#{name}"
perform("test/#{name}", *args)
perform("test/**/*_test.rb", *args)
perform("test/models", "test/helpers", "test/unit", *args)
@default_options = options || {}
trap(:INT) { exit }
server.to_s == "Rack::Handler::Puma"
class_option :port, aliases: "-p", type: :numeric,
class_option :binding, aliases: "-b", type: :string,
class_option :config, aliases: "-c", type: :string, default: "config.ru",
class_option :using, aliases: "-u", type: :string,
class_option :pid, aliases: "-P", type: :string,
@original_options = local_options - %w( --restart )
user_flag = {}
if command.start_with?("--")
elsif command =~ /\A(-.)/
name = :Port
name = :Host
default_host = environment == "development" ? "localhost" : "0.0.0.0"
gem "#{server}"
if code_or_file == "-"
error "Run '#{self.class.executable} -h' for help."
error ""
code_or_file.ends_with?(".rb")
self.bin = "rails"
run_plugin_generator %w( --help )
def self.banner(*) # :nodoc:
class_option :rc, type: :string, default: File.join("~", ".railsrc"),
plugin_args << "--help" unless type == "new"
extra_args = File.read(railsrc).split(/\n+/).flat_map(&:split)
say "Using #{extra_args.join(" ")} from #{railsrc}"
tag = (annotations.length > 1)
say "Type 'rails' for help."
def help(*)
class_option :key, aliases: "-k", type: :string,
def edit(*)
def show(*)
say "WARNING: #{error.message}", :red
missing_db = database ? "'#{database}' database is not" : "No databases are"
def find_cmd_and_exec(commands, *args) # :doc:
class_option :mode, enum: %w( html list line column ), type: :string,
class_option :database, aliases: "--db", type: :string,
say "Editing #{content_path}..."
available_environments.find { |env| path.end_with?("#{env}.yml.enc") }
def initialize(app, options = {})
aliases = {
desc: "The environment to run `#{self.command_name}` in (e.g. test / development / production)."
def initialize(...)
puts "#{base.camelize}:"
path = "#{base}/#{raw_path}_#{command_type}"
path = path.delete_prefix("#{base}/")
pieces = namespace.split(":")
path = pieces.join("/")
paths << "#{path}/#{pieces.last}"
def exit_on_failure? # :nodoc:
def desc(usage = nil, description = nil, options = {})
@namespace ||= super.chomp("_command").sub(/:command:/, ":")
def banner(command = nil, *)
command.formatted_usage(self).gsub(/^#{namespace}:(\w+)/) { executable($1) }
def help(shell, *) # :nodoc:
@command_name ||= if command = name.to_s.split("::").last
@class_usage ||= ERB.new(File.read(usage_path), trim_mode: "-").result(binding)
if meth == "perform"
@usage ||= meth
path = File.join("../commands", *namespace.delete_prefix("rails:").split(":"), path)
path = File.expand_path(path, __dir__)
def invoke_command(command, *) # :nodoc:
Dir.chdir(File.expand_path("../..", APP_PATH)) unless File.exist?(File.expand_path("config.ru"))
Pathname.new(File.expand_path("../..", APP_PATH))
when /^(.+):(\w+)$/
@command_type ||= "command"
rb: {
line_comment: /^\s*#/,
end_block_comment: /^=end/,
erb: {
line_comment: %r{((^\s*<%#.*%>)|(<!--.*-->))},
css: {
line_comment: %r{^\s*/\*.*\*/},
scss: {
line_comment: %r{((^\s*/\*.*\*/)|(^\s*//))},
js: {
line_comment: %r{^\s*//},
begin_block_comment: %r{^\s*/\*},
end_block_comment: %r{\*/},
coffee: {
begin_block_comment: /^\s*###/,
end_block_comment: /^\s*###/,
def initialize(lines = 0, code_lines = 0, classes = 0, methods = 0)
@lines += 1
@code_lines += 1
if file_path.end_with? "_test.rb"
def calculate_directory_statistics(directory, pattern = /^(?!\.).*?\.(rb|js|ts|css|scss|coffee|rake|erb)$/)
path = "#{directory}/#{file_name}"
if File.directory?(path) && !file_name.start_with?(".")
code_loc = 0
@statistics.each { |k, v| code_loc += v.code_lines unless TEST_TYPES.include? k }
test_loc = 0
@statistics.each { |k, v| test_loc += v.code_lines if TEST_TYPES.include? k }
print " | #{v.rjust(width_for(k))}"
print "+----------------------"
print "+#{'-' * (width_for(k) + 2)}"
puts "+-----+-------+"
print "| #{name.ljust(20)} "
print "| #{statistics.send(k).to_s.rjust(width_for(k))} "
puts "| #{m_over_c.to_s.rjust(3)} | #{loc_over_m.to_s.rjust(5)} |"
Signal.trap("INT") { puts; exit(1) }
@root = "#{Rails.root}/"
line.start_with?(@root) ? line.from(@root.size) : line
@overrides = {}
@main.tag = "rails.main"
@once.tag = "rails.once"
each { |loader| loader.logger = logger }
each(&:log!)
@updater ||= begin
dirs = @external_routes.each_with_object({}) do |dir, hash|
paths.each { |path| load(path) }
@run_after_load_paths ||= -> { }
app_name = app.class.name ? app.railtie_name.chomp("_application") : ""
get "/" => "rails/welcome#index", internal: true
metastore: "rails:/",
entitystore: "rails:/",
when "5.0"
self.ssl_options = { hsts: { subdomains: true } }
when "5.1"
when "5.2"
when "6.0"
when "6.1"
when "7.0"
when "7.1"
self.log_file_size = 100 * 1024 * 1024
if config.is_a?(Hash) && config.values.all?(Hash)
if shared.is_a?(Hash) && shared.values.all?(Hash)
@session_options = options || {}
f = File.open path, "a"
if method.end_with?("=")
def run_load_hooks! # :nodoc:
config = {} if config.nil? && shared.is_a?(Hash)
if config.is_a?(Hash) && shared.is_a?(Hash)
@app_env_config ||= super.merge(
def initializer(name, opts = {}, &block)
def self.add_lib_to_load_path!(root) # :nodoc:
path = File.join root, "lib"
if File.exist?(path) && !$LOAD_PATH.include?(path)
def initialize!(group = :default) # :nodoc:
def config # :nodoc:
@secrets ||= begin
def to_app # :nodoc:
railties.each { |r| r.run_tasks_blocks(app) }
railties.each { |r| r.run_runner_blocks(app) }
railties.each { |r| r.run_server_blocks(app) }
if railtie == :main_app
all = (railties - order)
if r == self
Dir.chdir("..")
include: %w(
lib/active_support/**/*.rb
lib/active_record/**/*.rb
lib/active_model/**/*.rb
lib/action_view/**/*.rb
lib/action_mailer/**/*.rb
lib/active_job/**/*.rb
lib/action_cable/**/*.rb
app/**/active_storage/**/*.rb
lib/active_storage/**/*.rb
app/**/action_mailbox/**/*.rb
lib/action_mailbox/**/*.rb
app/**/action_text/**/*.rb
lib/action_text/**/*.rb
lib/**/*.rb
exclude: %w(
rdoc_files.include("#{cdr}/#{pattern}")
rdoc_files.exclude("#{cdr}/#{pattern}")
options << "-g" # link to GitHub, SDoc flag
klass.name != "ActiveSupport" && klass.in_files.any? { |file| file.absolute_name.include?("core_ext") }
).each do |railtie|
groups.concat hash.map { |k, v| k if v.map(&:to_s).include?(env) }
opts.on("-b", "--backtrace", "Show the complete backtrace") do
opts.on("-f", "--fail-fast", "Abort test run on first failure or error") do
errors_on_guides = {}
puts "\nCould not validate #{f} because of #{e}"
print "E"
ENV.key?("ONLY") ? select_only(guides) : guides
prefixes.any? { |p| guide.start_with?("./output/#{p}") }
if error_list.size == 0
error_summary = error_detail = ""
if %r{https?://api\.rubyonrails\.org}.match?(url)
%(<a href="#{api_link(url)}">#{content}</a>)
%(<a href="#{url}" title="#{title}">#{content}</a>)
%(<a href="#{url}">#{content}</a>)
header_with_id = text.scan(/(.*){#(.*)}/)
%(<h#{header_level}>#{text}</h#{header_level}>)
if text =~ %r{^NOTE:\s+Defined\s+in\s+<code>(.*?)</code>\.?$}
%(<div class="note"><p>Defined in <code><a href="#{github_file_url($1)}">#{$1}</a></code>.</p></div>)
linkback = %(<a href="#footnote-#{$1}-ref"><sup>#{$1}</sup></a>)
%(<p class="footnote" id="footnote-#{$1}">#{linkback} #{$2}</p>)
%(<sup class="footnote" id="footnote-#{$1}-ref">) +
%(<a href="#footnote-#{$1}">#{$1}</a></sup>)
::Rouge::Lexer.find(code_type) ? code_type : "plaintext"
/^\$ /
when "irb"
/^irb.*?> /
css_class = \
%(<div class="#{css_class}"><p>#{$2.strip}</p></div>)
tree = version || edge
path = \
when /\A(action|active)_/
if %r{https?://api\.rubyonrails\.org/v\d+\.}.match?(url)
url.sub("api", "edgeapi")
url.sub(/(?<=\.org)/, "/#{version}")
@raw_body = body
text.downcase.gsub(/\?/, "-questionmark")
.gsub(/!/, "-bang")
.gsub(/\s+/, "-")
if /^-{40,}$/.match?(@raw_body)
@raw_header, _, @raw_body = @raw_body.partition(/^-{40,}$/).map(&:strip)
when "h3"
when "h4"
when "h5"
when "h6"
node.inner_html = "#{node_index(hierarchy)} #{node.inner_html}"
doc.css("h3, h4, h5, h6").each do |node|
raw_index = ""
if level == 1
elsif level == 2
@index = <<-INDEX.html_safe
<div id="subCol">
<h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
@view.content_for(:page_title) { @title }
def guide(name, url, options = {}, &block)
link = content_tag(:a, href: url) { name }
result << content_tag(:dd, "Work in progress", class: "work-in-progress")
result << content_tag(:dd, capture(&block))
@documents_by_section ||= YAML.load_file(File.expand_path("../source/#{@language ? @language + '/' : ''}documents.yaml", __dir__))
base_path = File.expand_path("../assets", __dir__)
images_path = File.join(base_path, "images/**/*")
@all_images = Dir.glob(images_path).reject { |f| File.directory?(f) }.map { |item|
elsif position == "L"
c = capture(&block)
@direction = direction || "ltr"
epub_filename << ".#{@language}" if @language
epub_filename << ".epub"
@guides_dir = File.expand_path("..", __dir__)
@source_dir += "/#{@language}" if @language
@output_dir += "/#{@language}" if @language
Dir.entries("#{@source_dir}/epub").grep(GUIDES_RE).map do |entry|
guides << "epub/#{entry}"
prefixes = @only.split(",").map(&:strip)
FileUtils.cp_r(Dir.glob("#{@guides_dir}/assets/*"), @output_dir)
if guide.end_with?(".md")
guide.sub(/md\z/, "html")
@all || !File.exist?(fout) || File.mtime(fout) < File.mtime(fin)
layout = @epub ? "epub/layout" : "layout"
if guide =~ /\.(\w+)\.erb$/
body = File.read("#{@source_dir}/#{guide}")
File.open(output_path, "w") do |f|
puts "*** BROKEN LINK: ##{fragment_identifier}, perhaps you meant ##{guess}."
|epub|
entries.reject! { |item| File.extname(item) == ".epub" }
zipfile_path = path == "" ? e : File.join(path, e)
Nokogiri::XML(toc).xpath("//ncx:content", "ncx" => "http://www.daisy.org/z3986/2005/ncx/")
output_dir = File.absolute_path(File.join(output_dir, ".."))
puts "=> Using output dir: #{output_dir}"
name.match?(/\A\d/)
puts "=> Using book dir: #{book_dir}"
toc = File.read("toc.ncx")
toc_html = File.read("toc.html")
doc = open_toc_doc(toc)
doc.each do |c|
FileUtils.mv(name, "rails_#{name}")
toc.gsub!(name, "rails_#{name}")
toc_html.gsub!(name, "rails_#{name}")
opf.gsub!(name, "rails_#{name}")
File.write("toc.ncx", toc)
head = Nokogiri::XML::Node.new "head", doc
css = Nokogiri::XML::Node.new "link", doc
$:.unshift __dir__
as_lib = File.expand_path("../activesupport/lib", __dir__)
ap_lib = File.expand_path("../actionpack/lib", __dir__)
av_lib = File.expand_path("../actionview/lib", __dir__)
git_source(:github) { |repo| "https://github.com/#{repo}.git" }
gem "rails", github: "rails/rails", branch: "main"
gem "activesupport", "~> 7.0.0"
puts " #{name} ".center(80, "=")
x.report("fast_blank?") { value.fast_blank? }
gem "rack", "~> 2.0"
local: {
user = User.create!(
profile: {
io: ::StringIO.new("dummy"),
gem "rails", "~> 7.0.0"
gem "activerecord", "~> 7.0.0"
gem "activejob", "~> 7.0.0"
routing (/^replies@/i) => :replies
get "/" => "test#index"
assert_xml "<br/>"
assert_xml "<b>tag</b>"
@xml.to_tag(:tag, obj, @options)
assert_xml "<yo>tag</yo>"
@xml.to_tag(:b, "Howdy", @options)
assert_xml "<b>Howdy</b>"
@xml.to_tag(:b, "blue", @options.merge(type: "color"))
assert_xml("<b type=\"color\">blue</b>")
@xml.to_tag(:b, :name, @options)
assert_xml("<b type=\"symbol\">name</b>")
@xml.to_tag(:b, true, @options)
assert_xml("<b type=\"boolean\">true</b>")
@xml.to_tag(:b, 3.14, @options)
assert_xml("<b type=\"float\">3.14</b>")
@xml.to_tag(:b, BigDecimal("1.2"), @options)
assert_xml("<b type=\"decimal\">1.2</b>")
@xml.to_tag(:b, Date.new(2001, 2, 3), @options)
assert_xml("<b type=\"date\">2001-02-03</b>")
@xml.to_tag(:b, DateTime.new(2001, 2, 3, 4, 5, 6, "+7"), @options)
assert_xml("<b type=\"dateTime\">2001-02-03T04:05:06+07:00</b>")
@xml.to_tag(:b, Time.new(1993, 02, 24, 12, 0, 0, "+09:00"), @options)
assert_xml("<b type=\"dateTime\">1993-02-24T12:00:00+09:00</b>")
@xml.to_tag(:b, time, @options)
assert_xml("<b type=\"dateTime\">1993-02-24T13:00:00+01:00</b>")
assert_xml("<b type=\"array\"><b>first_name</b><b>last_name</b></b>")
@xml.to_tag(:b, { first_name: "Bob", last_name: "Marley" }, @options)
assert_xml("<b><first-name>Bob</first-name><last-name>Marley</last-name></b>")
@xml.to_tag(:b, "Bob", @options.merge(skip_types: 1))
assert_xml("<b>Bob</b>")
assert_xml "<New---York type=\"integer\">33</New---York>"
sleep 0.1 while t.status != "sleep"
assert_equal Time.new(2013, 11, 12, 02, 11, 00, 0), parser.call("2013-11-12T02:11:00Z")
assert_equal 0.0, parser.call("")
assert_equal "{}", parser.call({})
{ "sku" => "BL394D", "quantity" => 4, "description" => "Basketball" }
assert_equal({ 1 => "test" }, parser.call(1 => "test"))
assert_equal({ "1 => 'test'" => nil }, parser.call("{1 => 'test'}"))
assert_equal expected_base64.gsub(/\n/, " ").strip, parser.call(base64, "encoding" => "base64")
hash = Hash.from_xml(<<-eoxml)
<blog>
</logo>
</blog>
Hash.from_xml(<<~eoxml)
<!ENTITY a "&b;&b;&b;&b;&b;&b;&b;&b;&b;&b;">
<!ENTITY b "&c;&c;&c;&c;&c;&c;&c;&c;&c;&c;">
<!ENTITY c "&d;&d;&d;&d;&d;&d;&d;&d;&d;&d;">
<!ENTITY d "&e;&e;&e;&e;&e;&e;&e;&e;&e;&e;">
<!ENTITY e "&f;&f;&f;&f;&f;&f;&f;&f;&f;&f;">
<!ENTITY f "&g;&g;&g;&g;&g;&g;&g;&g;&g;&g;">
&a;
</member>
xml_string = "<root/>"
assert_equal({ "root" => {} }, ActiveSupport::XmlMini.parse(xml_string))
<posts type="array">
<post>a post</post>
</posts>
<products foo="bar"/>
<book name="awesome" id="12345" />
<book name="america" id="67890" />
<root>
</root>
xml_string = "<root></root>"
FILES_DIR = File.expand_path("../fixtures/xml", __dir__)
attack_xml = <<-EOT
<member>x&a;</member>
%b;
(0..127).each do |byte|
def with_env_tz(new_tz = "US/Eastern")
assert_equal Time.utc(2000, 6, 30, 20), zone.utc_to_local(Time.utc(2000, 7)) # dst offset -0400
assert_equal Time.new(1999, 12, 31, 19, 0, 0, -18000), zone.utc_to_local(Time.utc(2000, 1)) # standard offset -0500
assert_equal Time.new(2000, 6, 30, 20, 0, 0, -14400), zone.utc_to_local(Time.utc(2000, 7)) # dst offset -0400
assert_equal Time.utc(1999, 12, 31, 19, 0, 0, 1), zone.utc_to_local(Time.utc(2000, 1, 1, 0, 0, 0, 1)) # standard offset -0500
assert_equal Time.utc(2000, 6, 30, 20, 0, 0, 1), zone.utc_to_local(Time.utc(2000, 7, 1, 0, 0, 0, 1)) # dst offset -0400
assert_equal Time.new(1999, 12, 31, 19, 0, usec, -18000), zone.utc_to_local(Time.utc(2000, 1, 1, 0, 0, 0, 1)) # standard offset -0500
assert_equal Time.new(2000, 6, 30, 20, 0, usec, -14400), zone.utc_to_local(Time.utc(2000, 7, 1, 0, 0, 0, 1)) # dst offset -0400
assert_equal Time.utc(2000, 7, 1, 4), zone.local_to_utc(Time.utc(2000, 7)) # dst offset -0400
assert_equal Time.utc(2000, 1, 1, 5), zone.now.utc
assert_equal Time.new(2010, 1, 31, 22, 0, 0, -7200), zone.utc_to_local(Time.utc(2010, 2)) # daylight saving offset -0200
assert_equal Time.new(2010, 3, 31, 21, 0, 0, -10800), zone.utc_to_local(Time.utc(2010, 4)) # standard offset -0300
travel_to(Time.utc(2000, 1, 1, 4, 59, 59)) # 1 sec before midnight Jan 1 EST
travel_to(Time.utc(2000, 1, 1, 5)) # midnight Jan 1 EST
travel_to(Time.utc(2000, 1, 2, 4, 59, 59)) # 1 sec before midnight Jan 2 EST
travel_to(Time.utc(2000, 1, 2, 5)) # midnight Jan 2 EST
date = Date.new(2014, 2, 18)
assert_equal Time.utc(2007, 2, 5, 15, 30, 45), time.time
twz = zone.local(2006, 4, 2, 1, 59, 59) # 1 second before DST start
assert_equal Time.utc(2006, 4, 2, 1, 59, 59), twz.time
assert_equal Time.utc(2006, 4, 2, 6, 59, 59), twz.utc
assert_equal Time.utc(2006, 4, 2, 7), twz2.utc
assert_equal Time.utc(2006, 4, 2, 3, 30), twz3.time # twz is created for 3:30AM
assert_equal Time.utc(2006, 4, 2, 7, 30), twz3.utc
twz = zone.local(2006, 10, 29, 1)
assert_equal Time.utc(2014, 10, 25, 22, 0, 0), zone.local(2014, 10, 26, 1, 0, 0)
twz = zone.at(secs)
assert_equal Time.utc(1999, 12, 31, 19, 0, 0 + Rational(3, 4)), twz.time
assert_equal Time.utc(2000, 1, 1, 0, 0, 0 + Rational(3, 4)), twz.utc
twz = zone.iso8601("1999-12-31")
assert_equal Time.utc(1999, 12, 31, 0, 0, 0), twz.time
assert_equal Time.utc(1999, 12, 31, 5, 0, 0), twz.utc
twz = zone.iso8601("2050-12-31T19:00:00-10:00") # i.e., 2050-01-01 05:00:00 UTC
with_env_tz("EET") do
assert_equal Time.utc(2013, 3, 10, 2, 0, 0), twz.time
assert_equal Time.utc(2013, 3, 10, 3, 0, 0), twz.time
assert_equal Time.utc(2014, 10, 25, 22, 0, 0), zone.parse("2014-10-26T01:00:00")
assert_equal Time.utc(2021, 3, 28, 0, 0, 0), twz.time
twz = zone.parse("1999-12-31 19:00:00")
(-12..13).each do |timezone_offset|
twz = zone.parse("1883-12-31 19:00:00")
twz = zone.parse("2050-12-31 19:00:00 -10:00") # i.e., 2050-01-01 05:00:00 UTC
zone.stub(:now, zone.local(1999, 12, 31)) do
twz = zone.parse("19:00:00")
assert_equal Time.local(2000, 2, 1), zone.parse("Feb", Time.local(2000, 1, 1))
assert_equal Time.local(2005, 2, 1), zone.parse("Feb 2005", Time.local(2000, 1, 1))
assert_equal Time.local(2005, 2, 2), zone.parse("2 Feb 2005", Time.local(2000, 1, 1))
twz = zone.parse("2012-03-25 03:29:00")
twz = zone.parse("2012-03-11 02:29:00")
zone.stub(:now, zone.local(1999, 12, 31, 12, 59, 59)) do
twz = zone.parse("2012-12-01")
twz = zone.parse("Mon May 28 2012 00:00:00 GMT-0700 (PDT)")
assert_equal Time.utc(2012, 5, 28, 7, 0, 0), twz.utc
twz = zone.parse("2013-03-10 02:00:00")
assert_equal Time.utc(2014, 10, 25, 22, 0, 0), zone.parse("2014-10-26 01:00:00")
twz = zone.rfc3339("2050-12-31T19:00:00-10:00") # i.e., 2050-01-01 05:00:00 UTC
twz = zone.strptime("1999-12-31 12:00:00", "%Y-%m-%d %H:%M:%S")
twz = zone.strptime("1999-12-31 12:00:00 PST", "%Y-%m-%d %H:%M:%S %Z")
twz = zone.strptime("1999-12-31 12:00:00 -08", "%Y-%m-%d %H:%M:%S %:::z")
twz = zone.strptime("1999-12-31 12:00:00 -08:00", "%Y-%m-%d %H:%M:%S %:z")
twz = zone.strptime("1999-12-31 12:00:00 -08:00:00", "%Y-%m-%d %H:%M:%S %::z")
twz = zone.strptime("1999-12-31 12:00:00 %Z", "%Y-%m-%d %H:%M:%S %%Z")
assert_equal Time.local(2000, 2, 1), zone.strptime("Feb", "%b", Time.local(2000, 1, 1))
assert_equal Time.local(2005, 2, 1), zone.strptime("Feb 2005", "%b %Y", Time.local(2000, 1, 1))
assert_equal Time.local(2005, 2, 2), zone.strptime("2 Feb 2005", "%e %b %Y", Time.local(2000, 1, 1))
assert_raise(ArgumentError) { zone.strptime("1999-12-31", "%Y/%m/%d") }
time = zone.strptime(time_str, "%s")
time = zone.strptime(time_str, "%Q")
assert_equal Time.utc(2014, 10, 25, 22, 0, 0), zone.strptime("2014-10-26 01:00:00", "%Y-%m-%d %H:%M:%S")
travel_to(Time.utc(2014, 10, 25, 21)) do # 1 hour before TZ change
travel_to(Time.utc(2014, 10, 25, 22)) do # after TZ change
assert_equal "+09:00:00", twz.strftime("%::z")
assert zone =~ /New_York/
1.upto(all.length - 1) do |i|
mappings = {
expected_time = Time.new(2004, 11, 24, 1, 4, 44)
outer_expected_time = Time.new(2004, 11, 24, 1, 4, 44)
inner_expected_time = Time.new(2004, 10, 24, 1, 4, 44)
initial_expected_time = Time.new(2004, 11, 24, 1, 4, 44)
subsequent_expected_time = Time.new(2004, 10, 24, 1, 4, 44)
traveled_time = Time.new(2004, 11, 24, 1, 4, 44) + duration_usec
expected_time = Time.new(2004, 11, 24, 1, 4, 44) + duration_usec
assert_equal((expected_time + 0.5).to_f, Time.now.to_f)
Time.now.usec != 0
travel_to Time.utc(2014, 10, 10, 10, 10, 50, 999999) do
assert_operator expected_time.to_fs(:db), :<, Time.now.to_fs(:db)
def <<(arg); end
assert_called(@object, :<<) do
@object << 2
assert_equal(10, @object << 2)
assert_nil(@object << 2)
assert_changes(-> { counter }) do
self.file_fixture_path = File.expand_path("../file_fixtures", __dir__)
Class === constant && constant < Foo
assert_changes -> { failures.count }, from: 0, to: 1 do
self.num += 1
self.num -= 1
@object.num = 0
assert_difference "@object.num + 1", +2 do
local_scope = "foo"
assert_difference "@object.num" => 1, "@object.num + 1" => 1 do
assert_difference({ "@object.num" => 0 }, "Object Changed") do
assert_difference -> { @object.num } => 1, -> { @object.num + 1 } => 1 do
assert_difference "@object.num" => 1, "1 + 1" => 1 do
assert_changes -> { @object.num } do
assert_changes "@object.num", from: 0, to: 1 do
assert_changes "@object.num", from: 0, to: 2 do
@new_object = 42
@object = nil
assert_changes -> { token }, to: /\w{32}/ do
assert_changes -> { token }, from: /\w{32}/, to: /\w{32}/ do
assert_changes "@object.num", "@object.num should be 1", to: 1 do
assert_no_changes -> { token }, from: /\w{32}/ do
lines = "HEY\n" * 12
--- expected
+++ actual
@@ -10,4 +10,5 @@
expected = <<~MSG
assert_no_changes -> { 1 } do # this assertion passes
@called_back << :foo
@called_back << :bar
assert_match "#{self.class}: #{name}\n", @out.string
def flush(*)
@logger.tagged("BCX") { @logger.info "Funky time" }
@logger.tagged("BCX") { @logger.tagged("Jason") { @logger.info "Funky time" } }
@logger.tagged("BCX", "Jason", "New") { @logger.info "Funky time" }
@logger.tagged(%w(BCX Jason New)) { @logger.info "Funky time" }
@logger.tagged("BCX", %w(Jason New)) { @logger.info "Funky time" }
@logger.info "a"
@logger.info "b"
assert_equal %w(B), @logger.pop_tags(1)
@logger.info "c"
@logger.info "d"
@logger.tagged("BCX") { |logger| logger.info "Funky time" }
@logger.tagged(nil, "", "New") { @logger.info "Funky time" }
@logger.tagged("OMG") { @logger.info "Cool story" }
@logger.tagged("Jason") { @logger.info "Funky time" }
@logger.tagged("BCX", "Jason", "New").info "Funky time"
@logger.tagged("BCX", %w(Jason New)).info "Funky time"
@logger.tagged(nil, "", "New").info "Funky time"
logger = @logger.tagged("BCX")
original_event = ActiveSupport::Notifications::Event.new("open_party.doodle", Time.at(0), Time.at(10), "id", { foo: "bar" })
(name == :bar) || super
@logger.info("Foo")
@lock.exclusive { @lock.exclusive { } }
exclusive_thread = Thread.new { @lock.exclusive { } }
sharing_thread = Thread.new { @lock.sharing { } }
exclusive_threads = (1..2).map do
@lock.exclusive { }
@lock.sharing { }
@lock.exclusive(purpose: :x) { }
@lock.exclusive(purpose: :z) { }
@lock.exclusive(purpose: :y) { }
assert(Array(threads).all? { |t| t.join(0.001).nil? })
@thread = Thread.new { @latch.wait }
assert_equal(true, wrapper.secure_compare!("and_another_one", on_rotation: -> { @witness = true }))
@buffer << "<script>"
@buffer << "<script>".html_safe
@buffer << "hello &amp; goodbye".html_safe
@buffer << "Hello"
@buffer << ERB::Util.html_escape("<script>")
assert_match(/^--- #{str}/, yaml)
data = { "str" => ActiveSupport::SafeBuffer.new(str) }
assert_equal({ "str" => str }, YAML.load(yaml))
chop: nil,
delete: "foo",
next: nil,
succ: nil,
@buffer.public_send("#{unsafe_method}!", *dummy_args)
@buffer.gsub!("", "<>")
assert_equal "hello&lt;&gt;", clean + @buffer
multiplied_safe_buffer = "<br />".html_safe * 2
multiplied_unsafe_buffer = @buffer.gsub("", "<>") * 2
assert_equal "<>hello", @buffer + clean
clean = "<script>".html_safe
assert_not_predicate @buffer.gsub!("", "").clone_empty, :html_safe?
safe_string = "foo".html_safe.gsub!("f", '<script>alert("lolpwnd");</script>')
safe_string = "<div>foo</div>".html_safe
safe_string = "<div>foo</div>"
unsafe_string = +'<script>alert("XSS");</script>'
x = "foo %{x} bar".html_safe % { x: "qux" }
x = "foo %{x} bar".html_safe % { x: "<br/>" }
assert_equal "foo &lt;br/&gt; bar", x
x = "foo %{x} bar".html_safe % { x: "<br/>".html_safe }
assert_equal "foo <br/> bar", x
x = "Hello".html_safe
a = "foo123".html_safe
a = "aaa".html_safe.gsub!(/a/).with_index { |m, i| i }
{ digest: salt == "salt" ? "SHA1" : "MD5" }
make_coordinator.rotate(digest: "MD5") { {} }
{ digest: "MD5" } if salt == "salt"
{ digest: "SHA1" } if salt == "salt"
def self.===(other)
Exception === other && other.respond_to?(:weird?)
@result = "alldead"
@result = "weird"
@result = "killed"
@result = "sos_first"
@result = "sos_cool_error"
i = 10
reloader.to_prepare { i += 1 }
reloader.to_prepare(prepend: true) { i = 0 }
r = new_reloader { true }
r.to_run { invoked = true }
r.wrap { }
r = new_reloader { false }
reloader.to_run { called << :reloader_run }
reloader.wrap { called << :body }
@reloader ||= new_reloader { true }
filter_words << "blah"
filter_words << lambda { |key, value|
a.each_with_index do |(key, value), index|
a.foo = nil
a.foo!
assert_equal "#<ActiveSupport::OrderedOptions {:foo=>:bar, :baz=>:quz}>", a.inspect
@hash = Hash.new
key, value = "purple", "5422a8"
key, value = "white", "ffffff"
bad_key = "black"
assert_equal @ordered_hash, @ordered_hash.each_key { |k| keys << k }
assert_equal @ordered_hash, @ordered_hash.each_value { |v| values << v }
keys << key
assert_equal copy, @ordered_hash.delete_if { |k, _| k == "pink" }
(copy = @ordered_hash.dup).delete("pink")
@ordered_hash.reject! { |k, _| k == "pink" }
new_ordered_hash = @ordered_hash.reject { |k, _| k == "pink" }
merged = hash.merge(b: 2, c: 7) do |key, old_value, new_value|
new_value + 1
hash.merge!(a: 1, c: 7) do |key, old_value, new_value|
new_value + 3
@ordered_hash.each { |*v| ordered_hash_values << v }
@ordered_hash.each_pair { |*v| ordered_hash_values << v }
values = @deserialized_ordered_hash.map { |_, value| value }
@options = { hello: "world" }
local_options = { "cool" => true }
local_options = { cool: true }
local_options = { hello: "moon" }
expected = { conditions: { method: :get, domain: "www" } }
with_options conditions: { method: :get, domain: "www" } do |outer|
expected = { conditions: { method: :post, domain: "www" } }
with_options html: { class: "foo", style: { margin: 0, display: "block" } } do |outer|
outer.with_options html: { title: "bar", style: { margin: "1em", color: "#fff" } } do |inner|
expected = { html: { class: "foo", title: "bar", style: { margin: "1em", display: "block", color: "#fff" } } }
local_lambda = lambda { { lambda: true } }
local_proc = proc { }
merge! fizz: "buzz"
expected = { hello: "world", foo: "bar", fizz: "buzz" }
delegate :to_hash, :deep_merge, to: :@hash
@hash = hash
assert_equal("(755) 6123-4567", number_helper.number_to_phone(75561234567, pattern: /(\d{3,4})(\d{4})(\d{4})/, area_code: true))
assert_equal("133-1234-5678", number_helper.number_to_phone(13312345678, pattern: /(\d{3})(\d{4})(\d{4})/))
assert_equal("-$ 1,234,567,890.50", number_helper.number_to_currency(-1234567890.50, format: "%u %n"))
assert_equal("1,234,567,890.50 K&#269;", number_helper.number_to_currency("1234567890.50", unit: "K&#269;", format: "%n %u"))
assert_equal("1,234,567,890.50 - K&#269;", number_helper.number_to_currency("-1234567890.50", unit: "K&#269;", format: "%n %u", negative_format: "%n - %u"))
assert_equal("0.00", number_helper.number_to_currency(+0.0, unit: "", negative_format: "(%n)"))
assert_equal("-$1,11", number_helper.number_to_currency("-1,11"))
assert_equal("-$0,11", number_helper.number_to_currency("-0,11"))
assert_equal("-$,11", number_helper.number_to_currency("-,11"))
assert_equal("$0.00", number_helper.number_to_currency("-0.0"))
assert_equal("1.000,000%", number_helper.number_to_percentage(1000, delimiter: ".", separator: ","))
assert_equal("-0.13 %", number_helper.number_to_percentage("-0.13", precision: nil, format: "%n %"))
assert_equal("1,23,456.78", number_helper.number_to_delimited("123456.78", delimiter_pattern: /(\d+?)(?=(\d\d)+(\d)(?!\d))/))
assert_equal("111.2346" + "0" * 96, number_helper.number_to_rounded("111.2346", precision: 100))
volume = { unit: "ml", thousand: "lt", million: "m3" }
distance = { mili: "mm", centi: "cm", deci: "dm", unit: "m", ten: "dam", hundred: "hm", thousand: "km" }
assert_equal "4", number_helper.number_to_human(4, units: { unit: "", ten: "tens " })
assert_equal "123", number_helper.number_to_human(123, units: { thousand: "k" })
options = { "raise" => true }
assert_equal({ "raise" => true }, options)
assert_equal("$x.", number_helper.number_to_currency("x."))
number: {
currency: { format: { unit: "&$", format: "%u - %n", negative_format: "(%u - %n)", precision: 2 } },
human: {
format: {
format: "%n %u",
units: {
byte: "b",
kb: "k"
deci: { one: "Tenth", other: "Tenths" },
unit: "u",
ten: { one: "Ten", other: "Tens" },
thousand: "t",
million: "m",
billion: "b",
trillion: "t",
percentage: { format: { delimiter: "", precision: 2, strip_insignificant_zeros: true } },
precision: { format: { delimiter: "", significant: true } }
custom_units_for_number_to_human: { mili: "mm", centi: "cm", deci: "dm", unit: "m", ten: "dam", hundred: "hm", thousand: "km" }
assert_equal("&$ - 10.00", number_to_currency(10, locale: "ts"))
assert_equal("(&$ - 10.00)", number_to_currency(-10, locale: "ts"))
assert_equal("-10.00 - &$", number_to_currency(-10, locale: "ts", format: "%n - %u"))
assert_equal("$10.00", number_to_currency(10, locale: "empty"))
assert_equal("-$10.00", number_to_currency(-10, locale: "empty"))
number: { format: { separator: ";" } }
assert_equal("&$ - 10;00", number_to_currency(10, locale: "ts"))
currency: { format: { unit: "@", format: "%n %u" } }
assert_equal("-10.00 @", number_to_currency(-10, locale: "no_negative_format"))
assert_equal("1.00", number_to_rounded(1.0, locale: "ts"))
assert_equal("1%", number_to_percentage(1, locale: "ts"))
assert_equal("1.24%", number_to_percentage(1.2434, locale: "ts"))
assert_equal("2 k", number_to_human_size(2048, locale: "ts"))
assert_equal("42 b", number_to_human_size(42, locale: "ts"))
assert_equal "2 t", number_to_human(2000, locale: "ts")
assert_equal "1 Tenth", number_to_human(0.1, locale: "ts")
assert_equal "1.3 Tenth", number_to_human(0.134, locale: "ts")
assert_equal "2 Tenths", number_to_human(0.2, locale: "ts")
assert_equal "1 Ten", number_to_human(10, locale: "ts")
assert_equal "1.2 Ten", number_to_human(12, locale: "ts")
assert_equal "2 Tens", number_to_human(20, locale: "ts")
@subscription = @notifier.subscribe { |*args| @events << event(*args) }
event = e
listener = ->(event) do
event_name = "foo"
times = (1..4).map { |s| Time.new(2020, 1, 1) + s }
callback1 = lambda { |event| events1 << event }
callback2 = lambda { |event| events2 << event }
callback = lambda { |*_| events << _.first }
@notifier.subscribe(/subscription/) { |*args| @matched_events << event(*args) }
def finish(*args); @finishes << args; end
def publish(*args); @publishes << args; end
@notifier.subscribe("1") { |*args| events << args }
@notifier.subscribe(/\d/) { |*args| events << args }
@notifier.subscribe { |*args| @another << args }
assert_equal 2, instrument(:awesome) { 1 + 1 }
1 + 1
time = Time.now.to_f
event = event(:foo, time, time + 0.01, random_id, {})
notifier.subscribe(:symbol) { |*_| }
notifier.subscribe(Object.new) { |*_| }
@payload = { foo: Object.new }
notifier.finish "hi", 2, {}
notifier.finish "hi", 1, {}
notifier.start "hi", 1, {}
notifier.start("hi.world", 1, {})
notifier.finish("hi.world", 2, {})
notifier.start("hello.world", 1, {})
notifier.finish("hello.world", 2, {})
str.to_s.unpack("U*").map { |cp| cp.to_s(16) }.join(" ")
str = +""
mb_a = (+"a").mb_chars
mb_b = (+"b").mb_chars
assert_equal "ab", mb_a + "b"
assert_equal "ab", "a" + mb_b
assert_equal "ab", mb_a + mb_b
assert_equal "ab", mb_a << "b"
assert_equal "ab", (+"a") << mb_b
assert_equal "abb", mb_a << mb_b
assert(("a".mb_chars + "b").kind_of?(@proxy_class))
assert(("a".mb_chars + "b".mb_chars).kind_of?(@proxy_class))
assert(((+"a").mb_chars << "b").kind_of?(@proxy_class))
assert(((+"a").mb_chars << "b".mb_chars).kind_of?(@proxy_class))
@whitespace = "\n\t "
@chars.split(//).each do |character|
proxy.public_send("#{method}!")
assert_nil(@chars =~ /wrong/u)
assert_equal "", (+"").mb_chars.insert(0, "")
before = @chars.to_s
assert_raise(ArgumentError) { @chars.rjust(10, "") }
assert_raise(ArgumentError) { @chars.ljust(10, "") }
assert_raise(ArgumentError) { @chars.center(10, "") }
assert_equal "", "".mb_chars.reverse
assert_nil "".mb_chars.slice(-1..1)
assert_nil "".mb_chars.slice(-1, 1)
assert_equal "", "".mb_chars.slice(0..10)
assert_equal "", @chars.slice(4..10)
chars.slice!(0, 2)
assert_raise(TypeError) { @chars.slice(2..3, 1) }
assert_raise(TypeError) { @chars.slice(1, 2..3) }
assert_raise(ArgumentError) { @chars.slice(1, 1, 1) }
assert_equal "", "".mb_chars.upcase
assert_equal "ll", "hello".mb_chars.method(:slice).call(2..3) # Defined on Chars
chars = +"hello".mb_chars
assert_equal "jello", "hello".mb_chars.method(:gsub).call(/h/, "j") # Defined on String
example = chars("")
assert_equal "#{good}#{good}", chars("#{bad}#{bad}").tidy_bytes
assert_equal "#{good}#{good}#{good}", chars("#{bad}#{bad}#{bad}").tidy_bytes
assert_equal "#{good}a", chars("#{bad}a").tidy_bytes
assert_equal "a#{good}a", chars("a#{bad}a").tidy_bytes
assert_equal "a#{good}", chars("a#{bad}").tidy_bytes
byte_string = "\270\236\010\210\245"
l: 0x1100, v: 0x1160, t: 0x11A8, lv: 0xAC00, lvt: 0xAC01, cr: 0x000D, lf: 0x000A,
end.pack("U*")
@config.rotate :signed, "older secret", salt: "salt", digest: "SHA1"
@config.rotate :signed, "old secret", salt: "salt", digest: "SHA256"
def self.dump(*); ""; end
codec = make_codec(secret("new"), on_rotation: proc { called = true })
called = ""
codec = make_codec(secret("new"), on_rotation: proc { called += "via constructor" })
assert_roundtrip data, codec, { purpose: "x" }, { purpose: "x" }
assert_no_roundtrip data, codec, { purpose: "x" }, { purpose: "y" }
assert_no_roundtrip data, codec, { purpose: "x" }, {}
assert_no_roundtrip data, codec, {}, { purpose: "x" }
assert_roundtrip data, codec, { purpose: :x }, { purpose: :x }
assert_roundtrip data, codec, { purpose: :x }, { purpose: "x" }
assert_roundtrip data, codec, { purpose: "x" }, { purpose: :x }
message = encode(data, codec, purpose: "x")
assert_roundtrip "a string", codec, { purpose: "x", expires_in: 1.year }, { purpose: "x" }
JSON.dump(value) << "!"
JSON.load(value.chomp!("!"))
{ "a_number" => 123, "a_time" => Time.local(2004), "an_object" => { "key" => "value" } },
def roundtrip(data, codec, encode_options = {}, decode_options = {})
@secrets ||= {}
secret_generator = ->(salt) { salt + "!" }
secret_generator = ->(salt, foo:, bar: nil) { foo + bar }
coordinator.rotate(foo: "foo", bar: "bar")
coordinator.rotate { { foo: "foo", bar: "bar" } }
@data = { "some" => "data", "now" => Time.utc(2010) }
data, hash = @verifier.generate(@data).split("--")
assert_not @verifier.valid_message?("#{data.reverse}--#{hash}")
assert_not @verifier.valid_message?("#{data}--#{hash.reverse}")
data = "??"
message = verifier.generate({ :foo => 123, "bar" => Time.utc(2010) })
exp = { "foo" => 123, "bar" => "2010-01-01T00:00:00.000Z" }
@data = { some: "data", now: Time.utc(2010) }
coordinator.rotate { { foo: "foo", bar: 0 } }
SECRET_GENERATOR = proc { |salt, secret_length:| "".ljust(secret_length, salt) }
@data = { some: "data", now: Time.local(2010) }
text, iv = @verifier.verify(@encryptor.encrypt_and_sign(@data)).split("--")
text, iv = @encryptor.encrypt_and_sign(@data).split("--")
message = encryptor.encrypt_and_sign({ :foo => 123, "bar" => Time.utc(2010) })
bad_encoding_characters = "\n!@#"
assert_not_verified("#{::Base64.encode64 message.to_s}--#{::Base64.encode64 iv.to_s}")
data = "x" * 10001
data = 1
text, iv, auth_tag = encryptor.encrypt_and_sign(@data).split("--")
data = "this_is_data"
t.write "hi mom!"
f = File.open(t.path, "w")
str = +"\x80"
fname = File.join Dir.tmpdir, "lol", "rofl.log"
f = File.open(fname, "w")
@logger.add(Logger::INFO) { @message }
@logger.info { @message }
threads = (1..2).collect do |thread_number|
info { "info" }
info "#{color("cool", :red)}, #{color("isn't it?", :blue, bold: true)}"
info "#{color("rad", :green, bold: true, underline: true)}, #{color("isn't it?", :yellow, italic: true)}"
info "#{color("bogus", :red, true)}"
i = 0
ActiveSupport.on_load(:basic_hook) { i += 1 }
block = proc { i += incr }
i += incr
i += obj.incr + incr_amt
@incr = incr
@a, @b = a, b
{ foo: "hello", bar: "world" }
if json.start_with?("{") && json.end_with?("}")
assert_equal %({"exitstatus":#{$?.exitstatus},"pid":#{$?.pid}}), ActiveSupport::JSON.encode($?)
assert_equal %({\"a\":\"b\"}), ActiveSupport::JSON.encode(a: :b)
assert_equal %({\"a\":1}), ActiveSupport::JSON.encode("a" => 1)
assert_equal %({"1":2}), ActiveSupport::JSON.encode(1 => 2)
assert_equal %({\"a\":\"b\",\"c\":\"d\"}), sorted_json(ActiveSupport::JSON.encode(a: :b, c: :d))
assert_equal "{\"\\u003c\\u003e\":\"\\u003c\\u003e\"}", ActiveSupport::JSON.encode("<>" => "<>")
assert_equal %w( "$" "A" "A0" "A0B" "_" "a" "0" "1" ).sort, object_keys(ActiveSupport::JSON.encode(values))
assert_equal %({"a":1}), ActiveSupport::JSON.encode({ "a" => 1, :b => 2, :c => 3 }, { only: "a" })
assert_equal %("2005-02-01T15:15:10.000-05:00"), ActiveSupport::JSON.encode(Time.local(2005, 2, 1, 15, 15, 10))
assert_equal '{"time":"2009/01/01 00:00:00 +0000"}', { time: Time.utc(2009) }.to_json
assert_equal({ "foo" => "hello" }, JSON.parse(json))
struct = Struct.new(:foo, :bar).new
struct.foo = "hello"
struct.bar = "world"
klass = Struct.new(:foo, :bar)
struct = klass.new "hello", "world"
assert_equal({ "foo" => { "foo" => "hello" } }, JSON.parse(json))
person = {
name: "John",
address: {
city: "London",
country: "UK"
assert_equal({ "address" => { "city" => "London" } }, json)
assert_equal(%({"address":{"city":"London"}}), json)
{ name: "John", address: { city: "London", country: "UK" } },
{ name: "Jean", address: { city: "Paris", country: "France" } }
{ "address" => { "city" => "London" } },
{ "address" => { "city" => "Paris" } }
def each(*, &blk)
@people.each do |p|
def as_json(options = {})
f.foo = "hello"
f.bar = "world"
hash = { "foo" => f, "other_hash" => { "foo" => "other_foo", "test" => "other_test" } }
assert_equal({ "foo" => { "foo" => "hello", "bar" => "world" },
json = { foo: OptionsTest.new }.as_json
assert_equal({ "foo" => :default }, json)
Struct.new("Custom", :name, :sub)
json_strings = ""
json_string_and_date = ""
json_custom = ""
assert_equal({ "name" => "David",
assert_equal({ "name" => "David", "email" => "sample@example.com" },
assert_equal({ "name" => "David", "date" => "2010-01-01" },
data = Data.define(:name, :email).new("test", "test@example.com")
assert_equal({ "name" => "test", "email" => "test@example.com" },
assert_equal %({"foo":"hello","bar":"world"}), JSON.dump(h)
assert_equal %({"foo":"hello","bar":"world"}), JSON.generate(h)
{ "number" => Float::NAN }
%q({"return\\"To\\":":{"\/categories":"\/"}}) => { "return\"To\":" => { "/categories" => "/" } },
%q({"returnTo":{"\/categories":1}}) => { "returnTo" => { "/categories" => 1 } },
%({"a": "2007-01-01 01:12:34 Z\\nwas my birthday"}) => { "a" => "2007-01-01 01:12:34 Z\nwas my birthday" },
%({"a":1}) => { "a" => 1 },
%({"a": ""}) => { "a" => "" },
%({"a":"\\""}) => { "a" => "\"" },
%({"a": false}) => { "a" => false },
%q({"a": "http:\/\/test.host\/posts\/1"}) => { "a" => "http://test.host/posts/1" },
%q({"a": "\u003cunicode\u0020escape\u003e"}) => { "a" => "<unicode escape>" },
%q({"a": "\u003cbr /\u003e"}) => { "a" => "<br />" },
%q({"a":"\n"}) => { "a" => "\n" },
%q({"a":"\u000a"}) => { "a" => "\n" },
%q({"a":"Line1\u000aLine2"}) => { "a" => "Line1\nLine2" },
expected = { "a" => "2007-01-01 01:12:34 Z" }
assert_equal expected, ActiveSupport::JSON.decode(%({"a": "2007-01-01 01:12:34 Z"}))
I18n.stub(:default_locale, :"en-GB") do
inflect.human(/_cnt$/i, '\1_count')
inflect.human(/^prefx_/i, '\1')
inflect.plural(/$/, "s")
inflect.plural(/z$/i, "ces")
inflect.singular(/s$/, "")
inflect.singular(/es$/, "")
inflect.irregular("el", "los")
assert_equal("luces", "luz".pluralize(:es))
assert_equal("los", "el".pluralize(:es))
assert_equal("agua", "agua".pluralize(:es))
inflect.plural(/(quiz)$/i, '\1zes')
inflect.singular(/(database)s$/i, '\1')
@date = Date.parse("2008-7-2")
@time = Time.utc(2008, 7, 2, 16, 47, 1)
assert_equal now.strftime("%a, %d %b %Y %H:%M:%S %z"), I18n.localize(now)
assert_equal @date.strftime("%Y-%m-%d"), I18n.localize(@date)
assert_equal @date.strftime("%Y-%m-%d"), I18n.localize(@date, format: :default)
assert_equal @date.strftime("%B %d, %Y"), I18n.localize(@date, format: :long)
assert_equal @time.strftime("%a, %d %b %Y %H:%M:%S %z"), I18n.localize(@time)
assert_equal @time.strftime("%a, %d %b %Y %H:%M:%S %z"), I18n.localize(@time, format: :default)
assert_equal @time.strftime("%d %b %H:%M"), I18n.localize(@time, format: :short)
assert_equal @time.strftime("%B %d, %Y %H:%M"), I18n.localize(@time, format: :long)
I18n.backend.store_translations "en", support: { array: { two_words_connector: " & " } }
I18n.backend.store_translations "en", support: { array: { last_word_connector: " and " } }
@strings = { "a" => 1, "b" => 2 }
@nested_strings = { "a" => { "b" => { "c" => 3 } } }
@symbols = { a: 1, b: 2 }
@nested_symbols = { a: { b: { c: 3 } } }
@mixed = { :a => 1, "b" => 2 }
@nested_mixed = { "a" => { b: { "c" => 3 } } }
@integers = { 0 => 1, 1 => 2 }
@nested_integers = { 0 => { 1 => { 2 => 3 } } }
assert_equal "a", @strings.__send__(:convert_key, :a)
hashes = { :@strings => @strings, :@symbols => @symbols, :@mixed => @mixed }
has_key?: true, include?: true, key?: true,
member?: true }
assert_equal(expected, hash.__send__(meth, "a"),
assert_equal(expected, hash.__send__(meth, :a),
assert_raise(KeyError) { @mixed.fetch_values(:a, :c) }
hash.update({ "a" => 1 }, { "b" => 2 })
other = { "a" => 1, :b => 2 }
merged = hash.merge({ "a" => 1 }, { "b" => 2 })
assert hash.key?("b")
other = { "a" => 4, :b => 2, "c" => 10 }
merged = hash.merge(other) { |key, old, new| old > new ? old : new }
merged = hash.merge(other_indifferent) { |key, old, new| old + new }
hash = HashWithIndifferentAccess.new("some" => "value", "other" => "value")
get_hash = proc { { a: "foo" }.with_indifferent_access }
assert_equal "foo", hash.delete("a")
assert_equal({ "a" => 1 }, hash)
indifferent_strings.select! { |k, v| v == 1 }
assert_equal({ "a" => 1 }, indifferent_strings)
indifferent_strings.reject! { |k, v| v != 1 }
assert_equal({ "aa" => 1, "bb" => 2 }, hash)
hash = ActiveSupport::HashWithIndifferentAccess.new(@strings).transform_keys({ "a" => "x", "y" => "z" })
hash = ActiveSupport::HashWithIndifferentAccess.new(@strings).transform_keys({ "a" => "A", "q" => "Q" }) { |k| k * 3 }
assert_equal({ "aa" => { "bb" => { "cc" => 3 } } }, hash)
indifferent_strings.transform_keys! { |k| k * 2 }
assert_equal({ "aa" => 1, "bb" => 2 }, indifferent_strings)
hash.transform_keys!({ "a" => "x", "y" => "z" })
hash.transform_keys!({ "a" => "A", "q" => "Q" }) { |k| k * 3 }
hash.deep_transform_keys! { |k| k * 2 }
hash.deep_transform_keys! { |k| k.to_sym }
assert_equal({ "a" => 2, "b" => 4 }, hash)
assert_equal({ "a" => 2, "b" => 4 }, indifferent_strings)
assert_equal("a", key)
hash_contain_nil_value = @strings.merge("z" => nil)
array << { "address" => "1" }
hash = { "urls" => { "url" => array } }.with_indifferent_access
hash = { "urls" => { "url" => array.freeze } }.with_indifferent_access
h = HashWithIndifferentAccess.new(a: { b: "b" })
dup = h.dup
h = { "user" => { "id" => 5 } }.with_indifferent_access
h = { user: { id: 5 } }.with_indifferent_access
h.default = "1234"
data = { "this" => { "views" => 1234 } }.with_indifferent_access
h = Hash.new { 5 }.merge(1 => 2).with_indifferent_access
assert_equal "foo", h.default("foo")
assert_not(indiff.keys.any? { |k| k.kind_of? String }, "A key was converted to a string!")
hash_1 = HashWithIndifferentAccess.new(a: "a", b: "b", c: { c1: "c1", c2: "c2", c3: { d1: "d1" } })
hash_2 = HashWithIndifferentAccess.new(a: 1, c: { c1: 2, c3: { d2: "d2" } })
hash_3 = { a: 1, c: { c1: 2, c3: { d2: "d2" } } }
hash.store("test1", 11)
expected = { "test1" => 11, "test2" => 22 }
original = { a: "x", b: "y", c: 10 }.with_indifferent_access
expected = { a: "x", b: "y" }.with_indifferent_access
original = { "login" => "bender", "password" => "shiny", "stuff" => "foo" }
original = { :a => 1, "b" => 2, :c => 3, "d" => 4 }.with_indifferent_access
expected = { a: 1, b: 2 }.with_indifferent_access
remaining = { c: 3, d: 4 }.with_indifferent_access
assert hash.key?("a")
hash.default_proc = proc { |h, v| raise "walrus" }
hash.default_proc = proc { |h, k| k + 1 }
hash.default_proc = proc { |h, k| raise "walrus" }
normal_hash = Hash.new { 1 + 2 }
@foo = "bar"
hash = Hash.new(3)
2 + 1
h = { foo: :bar }
h.default = :baz
if pid = fork
assert_no_difference -> { count } do
assert_difference -> { count }, +1 do
@tmpfiles ||= %w(foo.rb bar.rb baz.rb).map { |f| tmpfile(f) }
Dir.mktmpdir(nil, __dir__) { |dir| @tmpdir = dir; super }
checker = new_checker { i += 1 }
checker = new_checker(tmpfiles) { i += 1 }
executor.to_run { called << :run }
called << :body
executor.to_run { @foo = true }
executor.to_run { called << :run_1 }
executor.to_run { called << :run_2 }
executor.wrap { called << :body }
called << :early
called << :late
invoked << :"run_#{letter}"
:"state_#{letter}"
invoked << :"complete_#{letter}"
other_executor.to_run { called << :other_run }
touch(File.join(actual_dir, "a.rb"))
dir1 = File.join(tmpdir, "app")
dir2 = File.join(tmpdir, "test")
touch(File.join(dir1, "a.rb"))
touch(File.join(dir2, "a.rb"))
2 + 2
result = @reporter.handle(fallback: -> { 2 + 2 }) do
@key_path = File.join(@tmpdir, "content.txt.key")
encrypted_file(@content_path, key_path: "", env_key: "").read
@tmpdir = Dir.mktmpdir("config-")
@credentials.write({ something: { good: true, bad: false } }.to_yaml)
@credentials.write({ something: { good: true, bad: false, nested: { foo: "bar" } } }.to_yaml)
assert_equal ({ good: true, bad: false, nested: { foo: "bar" } }), @credentials.something
@credentials.write({ something: { good: true } }.to_yaml)
def zero() 0 end
def one(a) a end
BAR = "foo bar"
hash = { k: 1 }
instance.foo_bar = "foo bar!"
legacy = Module.new { def self.name; "Legacy"; end }
assert_deprecated(@deprecator) { 1 + 1 }
@deprecator.allow("fubar", if: -> { true }) do
@deprecator.allow("fubar", if: -> { false }) do
@deprecator.behavior = ->(_, callstack, *) { @callstack = callstack }
klass = Class.new { extend mod }
callback = proc { }
File.write("#{@root_dir}/x.rb", "X = :X")
def x.to_path; "x"; end
File.write("#{dir}/y.rb", "Y = :Y")
$loaded_service_one ||= 0
Person = Struct.new(:id, :name, :time_zone)
self.person = Person.new(1, "#{account}'s person")
Current.person = Person.new(42, "David", "Central Time (US & Canada)")
@utc = Time.utc(2000, 1, 1, 0)
assert_equal Time.utc(1999, 12, 31, 19), @twz.time
assert_equal Time.utc(2014, 10, 25, 22, 0, 0), Time.local(2014, 10, 26, 1, 0, 0).in_time_zone("Moscow")
assert_equal "1999-12-31 19:00:00 EST -0500", @twz.strftime("%Y-%m-%d %H:%M:%S %Z %z")
assert_equal "%Z %z", @twz.strftime("%%Z %%z")
assert_equal "%EST %-0500", @twz.strftime("%%%Z %%%z")
one_third_sec = Time.utc(1986, 12, 12, 6, 23, 00, Rational(1000000, 3))
assert_equal "1999-12-31 19:00:00 -0500", @twz.to_s
assert_equal "1999-12-31 19:00:00 -0500", @twz.to_fs
assert_equal "2000-01-01 00:00:00", @twz.to_fs(:db)
assert_equal "2000-01-01 00:00:00", @twz.to_formatted_s(:db)
@twz += Rational(1, 8)
assert_equal(yaml, { "twz" => @twz }.to_yaml)
assert_equal({ "twz" => @twz }, loaded)
assert_equal 1, @twz <=> Time.utc(1999, 12, 31, 23, 59, 59)
assert_equal 0, @twz <=> Time.utc(2000, 1, 1, 0, 0, 0)
assert_equal(-1, @twz <=> Time.utc(2000, 1, 1, 0, 0, 1))
assert_equal 1, @twz <=> DateTime.civil(1999, 12, 31, 23, 59, 59)
assert_equal 0, @twz <=> DateTime.civil(2000, 1, 1, 0, 0, 0)
assert_equal(-1, @twz <=> DateTime.civil(2000, 1, 1, 0, 0, 1))
assert @twz.between?(Time.utc(1999, 12, 31, 23, 59, 59), Time.utc(2000, 1, 1, 0, 0, 1))
assert_equal false, @twz.between?(Time.utc(2000, 1, 1, 0, 0, 1), Time.utc(2000, 1, 1, 0, 0, 2))
Date.stub(:current, Date.new(2000, 1, 1)) do
Time.stub(:current, Time.local(2005, 2, 10, 15, 30, 45)) do
twz = ActiveSupport::TimeWithZone.new(Time.utc(2017, 3, 6, 12, 0, 0), @time_zone)
assert_equal false, @twz.eql?(Time.utc(2000, 1, 1, 0, 0, 1))
assert_equal false, @twz.eql?(DateTime.civil(1999, 12, 31, 23, 59, 59))
assert_equal Time.utc(1999, 12, 31, 19, 0, 5), (@twz + 5).time
datetime = DateTime.civil(2000, 1, 1, 0)
assert_equal DateTime.civil(1999, 12, 31, 19, 0, 5), (twz + 5).time
assert_equal Time.utc(2000, 1, 5, 19, 0, 0), (@twz + 5.days).time
assert_equal Time.utc(1999, 12, 31, 18, 59, 55), (@twz - 5).time
assert_equal DateTime.civil(1999, 12, 31, 18, 59, 55), (twz - 5).time
assert_equal Time.utc(1999, 12, 26, 19, 0, 0), (@twz - 5.days).time
utc = Time.utc(2006, 4, 2, 6, 59, 59) # == Apr 2 2006 01:59:59 EST; i.e., 1 second before daylight savings start
twz = twz + 1
utc = Time.utc(2006, 10, 29, 5, 59, 59) # == Oct 29 2006 01:59:59 EST; i.e., 1 second before daylight savings end
assert_equal Time.utc(2006, 10, 29, 1, 59, 59), twz.time
twz = twz - 1
time = @twz.to_time
assert_equal Time.utc(2000, 1, 31, 19, 0, 0), @twz.months_since(1).time
time = @twz.time
def time.foo; "bar"; end
utc = Time.utc(2000, 1, 1, 0, 30)
utc = Time.utc(2000, 1, 1, 0, 30, 10)
twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006, 4, 2, 1, 59, 59))
assert_equal "Sun, 02 Apr 2006 03:00:00.000000000 EDT -04:00", (twz + 1).inspect
assert_equal "Sun, 02 Apr 2006 10:30:01.000000000 EDT -04:00", (twz + 1.days + 1.second).inspect
assert_equal "Sun, 29 Oct 2006 10:30:01.000000000 EST -05:00", (twz + 1.days + 1.second).inspect
@t, @dt, @zone = Time.utc(2000), DateTime.civil(2000), Time.zone
time = Time.local(1999, 12, 31, 19) # == Time.utc(2000)
Time.zone = "Alaska"
time = "2019-01-01 00:00:00Z".to_time.end_of_month
Time.zone = -9.hours
t1 = Thread.new { Time.zone = "Alaska"; Time.zone }
t2 = Thread.new { Time.zone = "Hawaii"; Time.zone }
time = Time.local(2000, 7, 1)
assert_equal Time.utc(2000, 6, 30, 23, 0, 0), time_with_zone
@d = Date.civil(2000)
@s = "Sat, 01 Jan 2000 00:00:00"
@u = "Sat, 01 Jan 2000 00:00:00 UTC +00:00"
@z = "Fri, 31 Dec 1999 19:00:00 EST -05:00"
assert_equal Time.utc(2014, 10, 25, 22, 0, 0), "2014-10-26 01:00:00".in_time_zone
assert_equal 2 * 3600 - 1, Time.local(2005, 4, 3, 1, 59, 59).seconds_since_midnight, "just before DST start"
assert_equal 2 * 3600 + 1, Time.local(2005, 4, 3, 3, 0, 1).seconds_since_midnight, "just after DST start"
with_env_tz "NZ" do
assert_equal 2 * 3600 - 1, Time.local(2006, 10, 1, 1, 59, 59).seconds_since_midnight, "just before DST start"
assert_equal 2 * 3600 + 1, Time.local(2006, 10, 1, 3, 0, 1).seconds_since_midnight, "just after DST start"
assert_equal 1 * 3600 - 1, Time.local(2005, 10, 30, 0, 59, 59).seconds_since_midnight, "just before DST end"
assert_equal 3 * 3600 + 1, Time.local(2005, 10, 30, 2, 0, 1).seconds_since_midnight, "just after DST end"
assert_equal 2 * 3600 - 1, Time.local(2006, 3, 19, 1, 59, 59).seconds_since_midnight, "just before DST end"
assert_equal 4 * 3600 + 1, Time.local(2006, 3, 19, 3, 0, 1).seconds_since_midnight, "just after DST end"
assert_equal 21 * 3600 - 2, Time.local(2005, 4, 3, 3, 0, 1).seconds_until_end_of_day, "just after DST start"
assert_equal 21 * 3600 - 2, Time.local(2006, 10, 1, 3, 0, 1).seconds_until_end_of_day, "just after DST start"
assert_equal 22 * 3600 - 2, Time.local(2005, 10, 30, 2, 0, 1).seconds_until_end_of_day, "just after DST end"
assert_equal 23 * 3600, Time.local(2006, 3, 19, 1, 59, 59).seconds_until_end_of_day, "just before DST end"
assert_equal 21 * 3600 - 2, Time.local(2006, 3, 19, 3, 0, 1).seconds_until_end_of_day, "just after DST end"
time = Time.utc(2016, 4, 23, 0, 0, Rational(1, 1_000_000_000))
time = Time.utc(2016, 4, 23, 0, 0, 0.000_000_001)
time = Time.utc(2016, 4, 23, 0, 0, 0, Rational(1, 1_000))
time = Time.utc(2016, 4, 23, 0, 0, 0, 0.001)
time = Time.utc(2016, 4, 23, 0, 0, "0.123456789".to_r)
time = Time.utc(2016, 4, 30, 23, 59, "59.123456789".to_r)
assert_equal Time.utc(2016, 5, 1, 0, 0), time.ceil
assert_equal Time.local(2005, 2, 4, 0, 0, 0), Time.local(2005, 2, 4, 10, 10, 10).beginning_of_day
assert_equal Time.local(2006, 4, 2, 0, 0, 0), Time.local(2006, 4, 2, 10, 10, 10).beginning_of_day, "start DST"
assert_equal Time.local(2006, 10, 29, 0, 0, 0), Time.local(2006, 10, 29, 10, 10, 10).beginning_of_day, "ends DST"
assert_equal Time.local(2006, 3, 19, 0, 0, 0), Time.local(2006, 3, 19, 10, 10, 10).beginning_of_day, "ends DST"
assert_equal Time.local(2006, 10, 1, 0, 0, 0), Time.local(2006, 10, 1, 10, 10, 10).beginning_of_day, "start DST"
assert_equal Time.local(2005, 2, 4, 12, 0, 0), Time.local(2005, 2, 4, 10, 10, 10).middle_of_day
assert_equal Time.local(2006, 4, 2, 12, 0, 0), Time.local(2006, 4, 2, 10, 10, 10).middle_of_day, "start DST"
assert_equal Time.local(2006, 10, 29, 12, 0, 0), Time.local(2006, 10, 29, 10, 10, 10).middle_of_day, "ends DST"
assert_equal Time.local(2006, 3, 19, 12, 0, 0), Time.local(2006, 3, 19, 10, 10, 10).middle_of_day, "ends DST"
assert_equal Time.local(2006, 10, 1, 12, 0, 0), Time.local(2006, 10, 1, 10, 10, 10).middle_of_day, "start DST"
assert_equal Time.local(2005, 2, 4, 19, 0, 0), Time.local(2005, 2, 4, 19, 30, 10).beginning_of_hour
assert_equal Time.local(2005, 2, 4, 19, 30, 0), Time.local(2005, 2, 4, 19, 30, 10).beginning_of_minute
assert_equal Time.local(2007, 8, 12, 23, 59, 59, Rational(999999999, 1000)), Time.local(2007, 8, 12, 10, 10, 10).end_of_day
assert_equal Time.local(2007, 4, 2, 23, 59, 59, Rational(999999999, 1000)), Time.local(2007, 4, 2, 10, 10, 10).end_of_day, "start DST"
assert_equal Time.local(2007, 10, 29, 23, 59, 59, Rational(999999999, 1000)), Time.local(2007, 10, 29, 10, 10, 10).end_of_day, "ends DST"
assert_equal Time.local(2006, 3, 19, 23, 59, 59, Rational(999999999, 1000)), Time.local(2006, 3, 19, 10, 10, 10).end_of_day, "ends DST"
assert_equal Time.local(2006, 10, 1, 23, 59, 59, Rational(999999999, 1000)), Time.local(2006, 10, 1, 10, 10, 10).end_of_day, "start DST"
assert_equal Time.local(2015, 2, 8, 23, 59, 59, Rational(999999999, 1000)), Time.new(2015, 2, 8, 8, 0, 0, "+05:00").end_of_day
assert_equal Time.local(2005, 2, 4, 19, 59, 59, Rational(999999999, 1000)), Time.local(2005, 2, 4, 19, 30, 10).end_of_hour
assert_equal Time.local(2005, 2, 4, 19, 30, 59, Rational(999999999, 1000)), Time.local(2005, 2, 4, 19, 30, 10).end_of_minute
assert_equal Time.local(2005, 2, 20, 10, 10, 10), Time.local(2005, 2, 22, 10, 10, 10).ago(86400 * 2)
assert_equal Time.local(2005, 4, 2, 3, 18, 0), Time.local(2005, 4, 3, 4, 18, 0).ago(24.hours), "dt-24.hours=>st"
assert_equal Time.local(2005, 4, 2, 3, 18, 0), Time.local(2005, 4, 3, 4, 18, 0).ago(86400), "dt-86400=>st"
assert_equal Time.local(2005, 4, 2, 3, 18, 0), Time.local(2005, 4, 3, 4, 18, 0).ago(86400.seconds), "dt-86400.seconds=>st"
assert_equal Time.local(2005, 4, 1, 4, 18, 0), Time.local(2005, 4, 2, 4, 18, 0).ago(24.hours), "st-24.hours=>st"
assert_equal Time.local(2005, 4, 1, 4, 18, 0), Time.local(2005, 4, 2, 4, 18, 0).ago(86400), "st-86400=>st"
assert_equal Time.local(2005, 4, 1, 4, 18, 0), Time.local(2005, 4, 2, 4, 18, 0).ago(86400.seconds), "st-86400.seconds=>st"
assert_equal Time.local(2006, 9, 30, 3, 18, 0), Time.local(2006, 10, 1, 4, 18, 0).ago(24.hours), "dt-24.hours=>st"
assert_equal Time.local(2006, 9, 30, 3, 18, 0), Time.local(2006, 10, 1, 4, 18, 0).ago(86400), "dt-86400=>st"
assert_equal Time.local(2006, 9, 30, 3, 18, 0), Time.local(2006, 10, 1, 4, 18, 0).ago(86400.seconds), "dt-86400.seconds=>st"
assert_equal Time.local(2006, 9, 29, 4, 18, 0), Time.local(2006, 9, 30, 4, 18, 0).ago(24.hours), "st-24.hours=>st"
assert_equal Time.local(2006, 9, 29, 4, 18, 0), Time.local(2006, 9, 30, 4, 18, 0).ago(86400), "st-86400=>st"
assert_equal Time.local(2006, 9, 29, 4, 18, 0), Time.local(2006, 9, 30, 4, 18, 0).ago(86400.seconds), "st-86400.seconds=>st"
assert_equal Time.local(2005, 10, 29, 5, 3), Time.local(2005, 10, 30, 4, 3, 0).ago(24.hours), "st-24.hours=>dt"
assert_equal Time.local(2005, 10, 29, 5, 3), Time.local(2005, 10, 30, 4, 3, 0).ago(86400), "st-86400=>dt"
assert_equal Time.local(2005, 10, 29, 5, 3), Time.local(2005, 10, 30, 4, 3, 0).ago(86400.seconds), "st-86400.seconds=>dt"
assert_equal Time.local(2005, 10, 28, 4, 3), Time.local(2005, 10, 29, 4, 3, 0).ago(24.hours), "dt-24.hours=>dt"
assert_equal Time.local(2005, 10, 28, 4, 3), Time.local(2005, 10, 29, 4, 3, 0).ago(86400), "dt-86400=>dt"
assert_equal Time.local(2005, 10, 28, 4, 3), Time.local(2005, 10, 29, 4, 3, 0).ago(86400.seconds), "dt-86400.seconds=>dt"
assert_equal Time.local(2006, 3, 18, 5, 3), Time.local(2006, 3, 19, 4, 3, 0).ago(24.hours), "st-24.hours=>dt"
assert_equal Time.local(2006, 3, 18, 5, 3), Time.local(2006, 3, 19, 4, 3, 0).ago(86400), "st-86400=>dt"
assert_equal Time.local(2006, 3, 18, 5, 3), Time.local(2006, 3, 19, 4, 3, 0).ago(86400.seconds), "st-86400.seconds=>dt"
assert_equal Time.local(2006, 3, 17, 4, 3), Time.local(2006, 3, 18, 4, 3, 0).ago(24.hours), "dt-24.hours=>dt"
assert_equal Time.local(2006, 3, 17, 4, 3), Time.local(2006, 3, 18, 4, 3, 0).ago(86400), "dt-86400=>dt"
assert_equal Time.local(2006, 3, 17, 4, 3), Time.local(2006, 3, 18, 4, 3, 0).ago(86400.seconds), "dt-86400.seconds=>dt"
assert_equal Time.local(2005, 4, 2, 4, 18, 0), Time.local(2005, 4, 3, 4, 18, 0).ago(1.day), "dt-1.day=>st"
assert_equal Time.local(2005, 4, 1, 4, 18, 0), Time.local(2005, 4, 2, 4, 18, 0).ago(1.day), "st-1.day=>st"
assert_equal Time.local(2006, 9, 30, 4, 18, 0), Time.local(2006, 10, 1, 4, 18, 0).ago(1.day), "dt-1.day=>st"
assert_equal Time.local(2006, 9, 29, 4, 18, 0), Time.local(2006, 9, 30, 4, 18, 0).ago(1.day), "st-1.day=>st"
assert_equal Time.local(2005, 10, 29, 4, 3), Time.local(2005, 10, 30, 4, 3, 0).ago(1.day), "st-1.day=>dt"
assert_equal Time.local(2005, 10, 28, 4, 3), Time.local(2005, 10, 29, 4, 3, 0).ago(1.day), "dt-1.day=>dt"
assert_equal Time.local(2006, 3, 18, 4, 3), Time.local(2006, 3, 19, 4, 3, 0).ago(1.day), "st-1.day=>dt"
assert_equal Time.local(2006, 3, 17, 4, 3), Time.local(2006, 3, 18, 4, 3, 0).ago(1.day), "dt-1.day=>dt"
assert_equal Time.local(2005, 2, 22, 10, 10, 11), Time.local(2005, 2, 22, 10, 10, 10).since(1)
assert_equal Time.local(2005, 2, 22, 11, 10, 10), Time.local(2005, 2, 22, 10, 10, 10).since(3600)
assert_equal Time.local(2005, 2, 24, 10, 10, 10), Time.local(2005, 2, 22, 10, 10, 10).since(86400 * 2)
assert_equal Time.local(2005, 2, 24, 11, 10, 35), Time.local(2005, 2, 22, 10, 10, 10).since(86400 * 2 + 3600 + 25)
assert_equal DateTime.civil(2038, 1, 20, 11, 59, 59), Time.utc(2038, 1, 18, 11, 59, 59).since(86400 * 2)
assert_equal Time.local(2005, 4, 3, 20, 27, 0), Time.local(2005, 4, 2, 19, 27, 0).since(24.hours), "st+24.hours=>dt"
assert_equal Time.local(2005, 4, 3, 20, 27, 0), Time.local(2005, 4, 2, 19, 27, 0).since(86400), "st+86400=>dt"
assert_equal Time.local(2005, 4, 3, 20, 27, 0), Time.local(2005, 4, 2, 19, 27, 0).since(86400.seconds), "st+86400.seconds=>dt"
assert_equal Time.local(2005, 4, 4, 19, 27, 0), Time.local(2005, 4, 3, 19, 27, 0).since(24.hours), "dt+24.hours=>dt"
assert_equal Time.local(2005, 4, 4, 19, 27, 0), Time.local(2005, 4, 3, 19, 27, 0).since(86400), "dt+86400=>dt"
assert_equal Time.local(2005, 4, 4, 19, 27, 0), Time.local(2005, 4, 3, 19, 27, 0).since(86400.seconds), "dt+86400.seconds=>dt"
assert_equal Time.local(2006, 10, 1, 20, 27, 0), Time.local(2006, 9, 30, 19, 27, 0).since(24.hours), "st+24.hours=>dt"
assert_equal Time.local(2006, 10, 1, 20, 27, 0), Time.local(2006, 9, 30, 19, 27, 0).since(86400), "st+86400=>dt"
assert_equal Time.local(2006, 10, 1, 20, 27, 0), Time.local(2006, 9, 30, 19, 27, 0).since(86400.seconds), "st+86400.seconds=>dt"
assert_equal Time.local(2006, 10, 2, 19, 27, 0), Time.local(2006, 10, 1, 19, 27, 0).since(24.hours), "dt+24.hours=>dt"
assert_equal Time.local(2006, 10, 2, 19, 27, 0), Time.local(2006, 10, 1, 19, 27, 0).since(86400), "dt+86400=>dt"
assert_equal Time.local(2006, 10, 2, 19, 27, 0), Time.local(2006, 10, 1, 19, 27, 0).since(86400.seconds), "dt+86400.seconds=>dt"
assert_equal Time.local(2005, 4, 3, 19, 27, 0), Time.local(2005, 4, 2, 19, 27, 0).since(1.day), "st+1.day=>dt"
assert_equal Time.local(2005, 4, 4, 19, 27, 0), Time.local(2005, 4, 3, 19, 27, 0).since(1.day), "dt+1.day=>dt"
assert_equal Time.local(2006, 10, 1, 19, 27, 0), Time.local(2006, 9, 30, 19, 27, 0).since(1.day), "st+1.day=>dt"
assert_equal Time.local(2006, 10, 2, 19, 27, 0), Time.local(2006, 10, 1, 19, 27, 0).since(1.day), "dt+1.day=>dt"
assert_equal Time.local(2005, 4, 3, 19, 27, 0), Time.local(2005, 4, 2, 19, 27, 0).tomorrow, "st+1.day=>dt"
assert_equal Time.local(2005, 4, 4, 19, 27, 0), Time.local(2005, 4, 3, 19, 27, 0).tomorrow, "dt+1.day=>dt"
assert_equal Time.local(2006, 10, 1, 19, 27, 0), Time.local(2006, 9, 30, 19, 27, 0).tomorrow, "st+1.day=>dt"
assert_equal Time.local(2006, 10, 2, 19, 27, 0), Time.local(2006, 10, 1, 19, 27, 0).tomorrow, "dt+1.day=>dt"
assert_equal Time.local(2005, 4, 2, 19, 27, 0), Time.local(2005, 4, 3, 19, 27, 0).yesterday, "dt-1.day=>st"
assert_equal Time.local(2005, 4, 3, 19, 27, 0), Time.local(2005, 4, 4, 19, 27, 0).yesterday, "dt-1.day=>dt"
assert_equal Time.local(2006, 9, 30, 19, 27, 0), Time.local(2006, 10, 1, 19, 27, 0).yesterday, "dt-1.day=>st"
assert_equal Time.local(2006, 10, 1, 19, 27, 0), Time.local(2006, 10, 2, 19, 27, 0).yesterday, "dt-1.day=>dt"
assert_equal Time.local(2005, 10, 30, 23, 45, 0), Time.local(2005, 10, 30, 0, 45, 0).since(24.hours), "dt+24.hours=>st"
assert_equal Time.local(2005, 10, 30, 23, 45, 0), Time.local(2005, 10, 30, 0, 45, 0).since(86400), "dt+86400=>st"
assert_equal Time.local(2005, 10, 30, 23, 45, 0), Time.local(2005, 10, 30, 0, 45, 0).since(86400.seconds), "dt+86400.seconds=>st"
assert_equal Time.local(2005, 11, 1, 0, 45, 0), Time.local(2005, 10, 31, 0, 45, 0).since(24.hours), "st+24.hours=>st"
assert_equal Time.local(2005, 11, 1, 0, 45, 0), Time.local(2005, 10, 31, 0, 45, 0).since(86400), "st+86400=>st"
assert_equal Time.local(2005, 11, 1, 0, 45, 0), Time.local(2005, 10, 31, 0, 45, 0).since(86400.seconds), "st+86400.seconds=>st"
assert_equal Time.local(2006, 3, 20, 0, 45, 0), Time.local(2006, 3, 19, 1, 45, 0).since(24.hours), "dt+24.hours=>st"
assert_equal Time.local(2006, 3, 20, 0, 45, 0), Time.local(2006, 3, 19, 1, 45, 0).since(86400), "dt+86400=>st"
assert_equal Time.local(2006, 3, 20, 0, 45, 0), Time.local(2006, 3, 19, 1, 45, 0).since(86400.seconds), "dt+86400.seconds=>st"
assert_equal Time.local(2006, 3, 21, 1, 45, 0), Time.local(2006, 3, 20, 1, 45, 0).since(24.hours), "st+24.hours=>st"
assert_equal Time.local(2006, 3, 21, 1, 45, 0), Time.local(2006, 3, 20, 1, 45, 0).since(86400), "st+86400=>st"
assert_equal Time.local(2006, 3, 21, 1, 45, 0), Time.local(2006, 3, 20, 1, 45, 0).since(86400.seconds), "st+86400.seconds=>st"
assert_equal Time.local(2005, 10, 31, 0, 45, 0), Time.local(2005, 10, 30, 0, 45, 0).since(1.day), "dt+1.day=>st"
assert_equal Time.local(2005, 11, 1, 0, 45, 0), Time.local(2005, 10, 31, 0, 45, 0).since(1.day), "st+1.day=>st"
assert_equal Time.local(2006, 3, 20, 1, 45, 0), Time.local(2006, 3, 19, 1, 45, 0).since(1.day), "dt+1.day=>st"
assert_equal Time.local(2006, 3, 21, 1, 45, 0), Time.local(2006, 3, 20, 1, 45, 0).since(1.day), "st+1.day=>st"
assert_equal Time.local(2005, 10, 31, 0, 45, 0), Time.local(2005, 10, 30, 0, 45, 0).tomorrow, "dt+1.day=>st"
assert_equal Time.local(2005, 11, 1, 0, 45, 0), Time.local(2005, 10, 31, 0, 45, 0).tomorrow, "st+1.day=>st"
assert_equal Time.local(2006, 3, 20, 1, 45, 0), Time.local(2006, 3, 19, 1, 45, 0).tomorrow, "dt+1.day=>st"
assert_equal Time.local(2006, 3, 21, 1, 45, 0), Time.local(2006, 3, 20, 1, 45, 0).tomorrow, "st+1.day=>st"
assert_equal Time.local(2005, 10, 30, 0, 45, 0), Time.local(2005, 10, 31, 0, 45, 0).yesterday, "st-1.day=>dt"
assert_equal Time.local(2005, 10, 31, 0, 45, 0), Time.local(2005, 11, 1, 0, 45, 0).yesterday, "st-1.day=>st"
assert_equal Time.local(2006, 3, 19, 1, 45, 0), Time.local(2006, 3, 20, 1, 45, 0).yesterday, "st-1.day=>dt"
assert_equal Time.local(2006, 3, 20, 1, 45, 0), Time.local(2006, 3, 21, 1, 45, 0).yesterday, "st-1.day=>st"
assert_equal Time.local(2006, 2, 22, 15, 15, 10), Time.local(2005, 2, 22, 15, 15, 10).change(year: 2006)
assert_equal Time.local(2005, 6, 22, 15, 15, 10), Time.local(2005, 2, 22, 15, 15, 10).change(month: 6)
assert_equal Time.local(2012, 9, 22, 15, 15, 10), Time.local(2005, 2, 22, 15, 15, 10).change(year: 2012, month: 9)
assert_equal Time.local(2005, 1, 2, 5, 0, 0, 0), Time.local(2005, 1, 2, 11, 22, 33, 44).change(hour: 5)
assert_equal Time.local(2005, 1, 2, 11, 6, 0, 0), Time.local(2005, 1, 2, 11, 22, 33, 44).change(min: 6)
assert_equal Time.local(2005, 1, 2, 11, 22, 7, 0), Time.local(2005, 1, 2, 11, 22, 33, 44).change(sec: 7)
assert_equal Time.local(2005, 1, 2, 11, 22, 33, 8), Time.local(2005, 1, 2, 11, 22, 33, 44).change(usec: 8)
assert_equal Time.local(2005, 1, 2, 11, 22, 33, 8), Time.local(2005, 1, 2, 11, 22, 33, 2).change(nsec: 8000)
assert_raise(ArgumentError) { Time.local(2005, 1, 2, 11, 22, 33, 8).change(usec: 1, nsec: 1) }
assert_nothing_raised { Time.new(2015, 5, 9, 10, 00, 00, "+03:00").change(nsec: 999999999) }
assert_equal Time.utc(2006, 2, 22, 15, 15, 10), Time.utc(2005, 2, 22, 15, 15, 10).change(year: 2006)
assert_equal Time.utc(2005, 6, 22, 15, 15, 10), Time.utc(2005, 2, 22, 15, 15, 10).change(month: 6)
assert_equal Time.utc(2012, 9, 22, 15, 15, 10), Time.utc(2005, 2, 22, 15, 15, 10).change(year: 2012, month: 9)
assert_equal Time.utc(2005, 1, 2, 11, 22, 33, 8), Time.utc(2005, 1, 2, 11, 22, 33, 2).change(nsec: 8000)
assert_equal Time.new(2006, 2, 22, 15, 15, 10, "-08:00"), Time.new(2005, 2, 22, 15, 15, 10, "-08:00").change(year: 2006)
assert_equal Time.new(2005, 6, 22, 15, 15, 10, "-08:00"), Time.new(2005, 2, 22, 15, 15, 10, "-08:00").change(month: 6)
assert_equal Time.new(2012, 9, 22, 15, 15, 10, "-08:00"), Time.new(2005, 2, 22, 15, 15, 10, "-08:00").change(year: 2012, month: 9)
assert_equal 10, Time.new(2005, 2, 22, 15, 15, 0, "-08:00").change(usec: 10).usec
assert_equal 10, Time.new(2005, 2, 22, 15, 15, 0, "-08:00").change(nsec: 10).nsec
assert_raise(ArgumentError) { Time.new(2005, 2, 22, 15, 15, 45, "-08:00").change(usec: 1000000) }
assert_raise(ArgumentError) { Time.new(2005, 2, 22, 15, 15, 45, "-08:00").change(nsec: 1000000000) }
assert_equal Time.new(2006, 2, 22, 15, 15, 10, "-08:00"), Time.new(2006, 2, 22, 15, 15, 10, "+01:00").change(offset: "-08:00")
assert_equal Time.new(2006, 2, 22, 15, 15, 10, -28800), Time.new(2006, 2, 22, 15, 15, 10, 3600).change(offset: -28800)
assert_raise(ArgumentError) { Time.new(2005, 2, 22, 15, 15, 45, "+01:00").change(usec: 1000000, offset: "-08:00") }
assert_raise(ArgumentError) { Time.new(2005, 2, 22, 15, 15, 45, "+01:00").change(nsec: 1000000000, offset: -28800) }
one_am_1 = Time.local(2005, 10, 30, 00, 59, 59) + 1 # 2005-10-30 01:00:00 -0400
assert_operator one_am_1, :<, one_am_2
assert_equal one_am_1 + 1, one_am_1.change(sec: 1)
assert_equal one_am_2 + 1, one_am_2.change(sec: 1)
one_am_2 = Time.new(2005, 10, 30, 02, 00, 00, Time.zone) - 3600 # 2005-10-30 01:00:00 -0500
one30_am_1 = Time.local(2005, 03, 27, 01, 29, 59) + 1 # 2005-03-27 01:30:00 +1100
assert_equal one30_am_1 + 1, one30_am_1.change(min: 30, sec: 1)
assert_equal one30_am_2 + 1, one30_am_2.change(min: 30, sec: 1)
one30_am_2 = Time.new(2005, 03, 27, 02, 00, 00, Time.zone) - 1800 # 2005-03-27 01:30:00 +1030
assert_equal Time.local(2006, 2, 28, 15, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(years: 1)
assert_equal Time.local(2005, 6, 28, 15, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(months: 4)
assert_equal Time.local(2005, 3, 21, 15, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(weeks: 3)
assert_equal Time.local(2005, 3, 25, 3, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(weeks: 3.5)
assert_in_delta Time.local(2005, 3, 26, 12, 51, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(weeks: 3.7), 1
assert_equal Time.local(2005, 3, 5, 15, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(days: 5)
assert_equal Time.local(2005, 3, 6, 3, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(days: 5.5)
assert_in_delta Time.local(2005, 3, 6, 8, 3, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(days: 5.7), 1
assert_equal Time.local(2012, 9, 28, 15, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 7)
assert_equal Time.local(2013, 10, 3, 15, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 19, days: 5)
assert_equal Time.local(2013, 10, 17, 15, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 19, weeks: 2, days: 5)
assert_equal Time.local(2001, 12, 27, 15, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(years: -3, months: -2, days: -1)
assert_equal Time.local(2005, 2, 28, 15, 15, 10), Time.local(2004, 2, 29, 15, 15, 10).advance(years: 1) # leap day plus one year
assert_equal Time.local(2005, 2, 28, 20, 15, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(hours: 5)
assert_equal Time.local(2005, 2, 28, 15, 22, 10), Time.local(2005, 2, 28, 15, 15, 10).advance(minutes: 7)
assert_equal Time.local(2005, 2, 28, 15, 15, 19), Time.local(2005, 2, 28, 15, 15, 10).advance(seconds: 9)
assert_equal Time.local(2005, 2, 28, 20, 22, 19), Time.local(2005, 2, 28, 15, 15, 10).advance(hours: 5, minutes: 7, seconds: 9)
assert_equal Time.local(2005, 2, 28, 10, 8, 1), Time.local(2005, 2, 28, 15, 15, 10).advance(hours: -5, minutes: -7, seconds: -9)
assert_equal Time.local(2013, 10, 17, 20, 22, 19), Time.local(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 19, weeks: 2, days: 5, hours: 5, minutes: 7, seconds: 9)
assert_equal Time.utc(2006, 2, 22, 15, 15, 10), Time.utc(2005, 2, 22, 15, 15, 10).advance(years: 1)
assert_equal Time.utc(2005, 6, 22, 15, 15, 10), Time.utc(2005, 2, 22, 15, 15, 10).advance(months: 4)
assert_equal Time.utc(2005, 3, 21, 15, 15, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(weeks: 3)
assert_equal Time.utc(2005, 3, 25, 3, 15, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(weeks: 3.5)
assert_in_delta Time.utc(2005, 3, 26, 12, 51, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(weeks: 3.7), 1
assert_equal Time.utc(2005, 3, 5, 15, 15, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(days: 5)
assert_equal Time.utc(2005, 3, 6, 3, 15, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(days: 5.5)
assert_in_delta Time.utc(2005, 3, 6, 8, 3, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(days: 5.7), 1
assert_equal Time.utc(2012, 9, 22, 15, 15, 10), Time.utc(2005, 2, 22, 15, 15, 10).advance(years: 7, months: 7)
assert_equal Time.utc(2013, 10, 3, 15, 15, 10), Time.utc(2005, 2, 22, 15, 15, 10).advance(years: 7, months: 19, days: 11)
assert_equal Time.utc(2013, 10, 17, 15, 15, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 19, weeks: 2, days: 5)
assert_equal Time.utc(2001, 12, 27, 15, 15, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(years: -3, months: -2, days: -1)
assert_equal Time.utc(2005, 2, 28, 15, 15, 10), Time.utc(2004, 2, 29, 15, 15, 10).advance(years: 1) # leap day plus one year
assert_equal Time.utc(2005, 2, 28, 20, 15, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(hours: 5)
assert_equal Time.utc(2005, 2, 28, 15, 22, 10), Time.utc(2005, 2, 28, 15, 15, 10).advance(minutes: 7)
assert_equal Time.utc(2005, 2, 28, 15, 15, 19), Time.utc(2005, 2, 28, 15, 15, 10).advance(seconds: 9)
assert_equal Time.utc(2005, 2, 28, 20, 22, 19), Time.utc(2005, 2, 28, 15, 15, 10).advance(hours: 5, minutes: 7, seconds: 9)
assert_equal Time.utc(2005, 2, 28, 10, 8, 1), Time.utc(2005, 2, 28, 15, 15, 10).advance(hours: -5, minutes: -7, seconds: -9)
assert_equal Time.utc(2013, 10, 17, 20, 22, 19), Time.utc(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 19, weeks: 2, days: 5, hours: 5, minutes: 7, seconds: 9)
assert_equal Time.new(2006, 2, 22, 15, 15, 10, "-08:00"), Time.new(2005, 2, 22, 15, 15, 10, "-08:00").advance(years: 1)
assert_equal Time.new(2005, 6, 22, 15, 15, 10, "-08:00"), Time.new(2005, 2, 22, 15, 15, 10, "-08:00").advance(months: 4)
assert_equal Time.new(2005, 3, 21, 15, 15, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(weeks: 3)
assert_equal Time.new(2005, 3, 25, 3, 15, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(weeks: 3.5)
assert_in_delta Time.new(2005, 3, 26, 12, 51, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(weeks: 3.7), 1
assert_equal Time.new(2005, 3, 5, 15, 15, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(days: 5)
assert_equal Time.new(2005, 3, 6, 3, 15, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(days: 5.5)
assert_in_delta Time.new(2005, 3, 6, 8, 3, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(days: 5.7), 1
assert_equal Time.new(2012, 9, 22, 15, 15, 10, "-08:00"), Time.new(2005, 2, 22, 15, 15, 10, "-08:00").advance(years: 7, months: 7)
assert_equal Time.new(2013, 10, 3, 15, 15, 10, "-08:00"), Time.new(2005, 2, 22, 15, 15, 10, "-08:00").advance(years: 7, months: 19, days: 11)
assert_equal Time.new(2013, 10, 17, 15, 15, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(years: 7, months: 19, weeks: 2, days: 5)
assert_equal Time.new(2001, 12, 27, 15, 15, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(years: -3, months: -2, days: -1)
assert_equal Time.new(2005, 2, 28, 15, 15, 10, "-08:00"), Time.new(2004, 2, 29, 15, 15, 10, "-08:00").advance(years: 1) # leap day plus one year
assert_equal Time.new(2005, 2, 28, 20, 15, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(hours: 5)
assert_equal Time.new(2005, 2, 28, 15, 22, 10, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(minutes: 7)
assert_equal Time.new(2005, 2, 28, 15, 15, 19, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(seconds: 9)
assert_equal Time.new(2005, 2, 28, 20, 22, 19, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(hours: 5, minutes: 7, seconds: 9)
assert_equal Time.new(2005, 2, 28, 10, 8, 1, "-08:00"), Time.new(2005, 2, 28, 15, 15, 10, "-08:00").advance(hours: -5, minutes: -7, seconds: -9)
assert_equal Time.local(1582, 10, 14, 15, 15, 10), Time.local(1582, 10, 15, 15, 15, 10).advance(days: -1)
assert_equal Time.local(1582, 10, 15, 15, 15, 10), Time.local(1582, 10, 14, 15, 15, 10).advance(days: 1)
assert_equal Time.local(1582, 10, 5, 15, 15, 10), Time.local(1582, 10, 4, 15, 15, 10).advance(days: 1)
assert_equal Time.local(1582, 10, 4, 15, 15, 10), Time.local(1582, 10, 5, 15, 15, 10).advance(days: -1)
assert_equal Time.local(999, 10, 4, 15, 15, 10), Time.local(1000, 10, 4, 15, 15, 10).advance(years: -1)
assert_equal Time.local(1000, 10, 4, 15, 15, 10), Time.local(999, 10, 4, 15, 15, 10).advance(years: 1)
assert_equal Time.local(2005, 2, 21), Time.local(2005, 3, 1, 15, 15, 10).last_week
assert_equal Time.local(2005, 2, 22), Time.local(2005, 3, 1, 15, 15, 10).last_week(:tuesday)
assert_equal Time.local(2005, 2, 25), Time.local(2005, 3, 1, 15, 15, 10).last_week(:friday)
assert_equal Time.local(2006, 10, 30), Time.local(2006, 11, 6, 0, 0, 0).last_week
assert_equal Time.local(2006, 11, 15), Time.local(2006, 11, 23, 0, 0, 0).last_week(:wednesday)
assert_equal Time.local(2006, 4, 3), Time.local(2006, 4, 2, 23, 1, 0).next_week, "just crossed standard => daylight"
assert_equal Time.local(2006, 10, 2), Time.local(2006, 10, 1, 23, 1, 0).next_week, "just crossed standard => daylight"
assert_equal Time.local(2006, 10, 30), Time.local(2006, 10, 29, 23, 1, 0).next_week, "just crossed daylight => standard"
assert_equal Time.local(2006, 3, 20), Time.local(2006, 3, 19, 23, 1, 0).next_week, "just crossed daylight => standard"
time = Time.utc(2005, 2, 21, 17, 44, 30.12345678901)
with_env_tz "UTC" do
assert_equal "Thu, 05 Feb 2009 14:30:05 -0600", Time.local(2009, 2, 5, 14, 30, 5).to_fs(:rfc822)
assert_equal "Mon, 09 Jun 2008 04:05:01 -0500", Time.local(2008, 6, 9, 4, 5, 1).to_fs(:rfc822)
assert_equal "2009-02-05T14:30:05-06:00", Time.local(2009, 2, 5, 14, 30, 5).to_fs(:iso8601)
assert_equal "2008-06-09T04:05:01-05:00", Time.local(2008, 6, 9, 4, 5, 1).to_fs(:iso8601)
assert_equal "2009-02-05T14:30:05Z", Time.utc(2009, 2, 5, 14, 30, 5).to_fs(:iso8601)
assert_equal "2009-02-05 14:30:05.000000000 -0600", Time.local(2009, 2, 5, 14, 30, 5).to_fs(:inspect)
assert_equal "2008-06-09 04:05:01.000000000 -0500", Time.local(2008, 6, 9, 4, 5, 1).to_fs(:inspect)
assert_equal "20050221143000", Time.local(2005, 2, 21, 14, 30, 0).to_fs(:custom)
time = Time.new(1999, 12, 31, 19, 0, Rational(1, 8), -18000)
assert_equal Date.new(2005, 2, 21), Time.local(2005, 2, 21, 17, 44, 30).to_date
assert_equal Time.utc(2005, 2, 21, 17, 44, 30).to_datetime, DateTime.civil(2005, 2, 21, 17, 44, 30, 0)
assert_equal Time.local(2005, 2, 21, 17, 44, 30).to_datetime, DateTime.civil(2005, 2, 21, 17, 44, 30, Rational(Time.local(2005, 2, 21, 17, 44, 30).utc_offset, 86400))
assert_equal Time.local(2005, 2, 21, 17, 44, 30), Time.local(2005, 2, 21, 17, 44, 30).to_time
assert_equal Time.local(2005, 2, 21, 17, 44, 30).utc_offset, Time.local(2005, 2, 21, 17, 44, 30).to_time.utc_offset
midnight = Time.local(2005, 2, 21, 0, 0, 0)
assert_equal false, Time.local(1999, 12, 31, 23, 59, 59).today?
assert_equal false, Time.utc(1999, 12, 31, 23, 59, 59).today?
assert_equal false, Time.utc(2000, 1, 2, 0).today?
assert_equal false, Time.utc(2000, 1, 1, 0).prev_day?
assert_equal false, Time.utc(2000, 1, 2, 0).prev_day?
assert_equal false, Time.local(1999, 12, 31, 23, 59, 59).next_day?
assert_equal false, Time.utc(1999, 12, 31, 23, 59, 59).next_day?
assert_equal false, Time.utc(2000, 1, 1, 0).next_day?
twz = Time.utc(2005, 2, 10, 15, 30, 45).in_time_zone("Central Time (US & Canada)")
assert_equal 1, Time.utc(2000) <=> Time.utc(1999, 12, 31, 23, 59, 59, 999)
assert_equal 0, Time.utc(2000) <=> Time.utc(2000, 1, 1, 0, 0, 0)
assert_equal(-1, Time.utc(2000) <=> Time.utc(2000, 1, 1, 0, 0, 0, 001))
assert_equal 1, Time.utc(2000) <=> DateTime.civil(1999, 12, 31, 23, 59, 59)
assert_equal 0, Time.utc(2000) <=> DateTime.civil(2000, 1, 1, 0, 0, 0)
assert_equal(-1, Time.utc(2000) <=> DateTime.civil(2000, 1, 1, 0, 0, 1))
assert_equal 1, Time.utc(2000) <=> Time.utc(1999, 12, 31, 23, 59, 59, 999).to_s
assert_equal 0, Time.utc(2000) <=> Time.utc(2000, 1, 1, 0, 0, 0).to_s
assert_equal(-1, Time.utc(2000) <=> Time.utc(2000, 1, 1, 0, 0, 1, 0).to_s)
assert_equal Time.utc(2000, 1, 1, 0, 0, 0), Time.at(DateTime.civil(2000, 1, 1, 0, 0, 0))
assert_raise(TypeError) { assert_equal(Time.utc(2000, 1, 1, 0, 0, 0), Time.at(DateTime.civil(2000, 1, 1, 0, 0, 0), 0)) }
dt = DateTime.civil(2000, 1, 1, 0, 0, 0, "+0")
assert_equal Time.local(1999, 12, 31, 19, 0, 0), Time.at(dt)
dt = DateTime.civil(2000, 7, 1, 1, 0, 0, "+1")
assert_equal Time.local(2000, 6, 30, 20, 0, 0), Time.at(dt)
assert_equal Time.new(1970, 1, 1, 0, 42, 17, "-08:00"), Time.at(31337, in: -28800)
assert_equal Time.local(1999, 12, 31, 19, 0, 0), Time.at(twz)
assert_equal Time.local(2000, 6, 30, 20, 0, 0), Time.at(twz)
assert_equal Time.at(Time.utc(2000, 1, 1, 0, 0, 0, 111)).to_f, Time.utc(2000, 1, 1, 0, 0, 0, 111).to_f
assert_equal Time.local(2000, 7, 1), Time.at(Time.local(2000, 7, 1))
assert_equal "EDT", Time.at(Time.local(2000, 7, 1)).zone
assert_equal 86_400.0, Time.utc(2000, 1, 2) - DateTime.civil(2000, 1, 1)
assert_equal Time.local(2006, 4, 2, 3), Time.local(2006, 4, 2, 2)
assert_predicate Time.local(2006, 4, 2, 2), :dst?
assert Time === Time.utc(2000)
assert_equal Time.local(2011, 6, 7, 0, 0, 0)..Time.local(2011, 6, 7, 23, 59, 59, Rational(999999999, 1000)), Time.local(2011, 6, 7, 10, 10, 10).all_day
assert_equal Time.local(2011, 6, 6, 0, 0, 0)..Time.local(2011, 6, 12, 23, 59, 59, Rational(999999999, 1000)), Time.local(2011, 6, 7, 10, 10, 10).all_week
assert_equal Time.local(2011, 6, 5, 0, 0, 0)..Time.local(2011, 6, 11, 23, 59, 59, Rational(999999999, 1000)), Time.local(2011, 6, 7, 10, 10, 10).all_week(:sunday)
assert_equal Time.local(2011, 6, 1, 0, 0, 0)..Time.local(2011, 6, 30, 23, 59, 59, Rational(999999999, 1000)), Time.local(2011, 6, 7, 10, 10, 10).all_month
assert_equal Time.local(2011, 4, 1, 0, 0, 0)..Time.local(2011, 6, 30, 23, 59, 59, Rational(999999999, 1000)), Time.local(2011, 6, 7, 10, 10, 10).all_quarter
assert_equal Time.local(2011, 1, 1, 0, 0, 0)..Time.local(2011, 12, 31, 23, 59, 59, Rational(999999999, 1000)), Time.local(2011, 6, 7, 10, 10, 10).all_year
assert_equal date_time_init(2005, 2, 24, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_day(-2)
assert_equal date_time_init(2005, 2, 23, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_day(-1)
assert_equal date_time_init(2005, 2, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_day(0)
assert_equal date_time_init(2005, 2, 21, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_day(1)
assert_equal date_time_init(2005, 2, 20, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_day(2)
assert_equal date_time_init(2005, 2, 21, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_day
assert_equal date_time_init(2005, 2, 28, 10, 10, 10), date_time_init(2005, 3, 2, 10, 10, 10).prev_day.prev_day
assert_equal date_time_init(2005, 2, 20, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_day(-2)
assert_equal date_time_init(2005, 2, 21, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_day(-1)
assert_equal date_time_init(2005, 2, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_day(0)
assert_equal date_time_init(2005, 2, 23, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_day(1)
assert_equal date_time_init(2005, 2, 24, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_day(2)
assert_equal date_time_init(2005, 2, 23, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_day
assert_equal date_time_init(2005, 4, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_month(-2)
assert_equal date_time_init(2005, 3, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_month(-1)
assert_equal date_time_init(2005, 2, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_month(0)
assert_equal date_time_init(2005, 1, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_month(1)
assert_equal date_time_init(2004, 12, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_month(2)
assert_equal date_time_init(2005, 1, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_month
assert_equal date_time_init(2004, 12, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).prev_month.prev_month
assert_equal date_time_init(2004, 12, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_month(-2)
assert_equal date_time_init(2005, 1, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_month(-1)
assert_equal date_time_init(2005, 2, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_month(0)
assert_equal date_time_init(2005, 3, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_month(1)
assert_equal date_time_init(2005, 4, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_month(2)
assert_equal date_time_init(2005, 3, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_month
assert_equal date_time_init(2005, 4, 22, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).next_month.next_month
assert_equal date_time_init(2003, 6, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).next_year(-2)
assert_equal date_time_init(2004, 6, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).next_year(-1)
assert_equal date_time_init(2005, 6, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).next_year(0)
assert_equal date_time_init(2006, 6, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).next_year(1)
assert_equal date_time_init(2007, 6, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).next_year(2)
assert_equal date_time_init(2006, 6, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).next_year
assert_equal date_time_init(2007, 6, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).next_year.next_year
t = Time.utc(2000)
t = Time.local(2000)
t = Time.parse("00:00:00.500")
s = :hello
assert s.starts_with?("h")
assert s.starts_with?("he", "lo")
assert_not s.starts_with?("el", "lo")
assert s.ends_with?("o")
assert s.ends_with?("lo")
assert_not s.ends_with?("el")
assert s.ends_with?("he", "lo")
assert_not s.ends_with?("he", "ll")
assert_equal "", "".strip_heredoc
name = "Kuldeep"
assert_equal "", "".upcase_first
s = "hello"
assert_equal "Hello Wor...", "Hello World!!".truncate(12)
assert_equal "Hello<br>Big<br>World!...", "Hello<br>Big<br>World!<br>".truncate_words(3, separator: "<br>")
assert_equal "Hello<br>Big<br>World!", "Hello<br>Big<br>World!".truncate_words(3, separator: "<br>")
assert_equal "Hello\n<br>Big...", "Hello\n<br>Big<br>Wide<br>World!".truncate_words(2, separator: "<br>")
assert_equal (+"\354\225\204\353\246\254\353\236\221 \354\225\204\353\246\254 ...").force_encoding(Encoding::UTF_8),
assert_equal "This is a good day", original.remove(" to ", /die/)
assert_equal "This is a good day", original.remove!(" to ", /die/)
assert_equal "h", "hello".at(0)
assert_equal "lo", "hello".at(-2..-1)
assert_equal "lo", "hello".at(/lo/)
assert_equal "llo", "hello".from(2)
assert_equal "lo", "hello".from(-2)
assert_equal "hel", "hello".to(2)
assert_equal "hell", "hello".to(-2)
assert_equal "h", "hello".to(-5)
assert_equal "", "hello".to(-7)
assert_equal "hello", "hello".from(0).to(-1)
assert_equal "ell", "hello".from(1).to(-2)
assert_equal "x", "x".first
assert_equal "he", "hello".first(2)
assert_equal "", "hello".first(0)
assert_equal "x", "x".first(4)
string = "hello"
string = "he"
(0..string.length + 1).each do |limit|
assert_equal "o", "hello".last
assert_equal "x", "x".last
assert_equal "llo", "hello".last(3)
assert_equal "", "hello".last(0)
assert_equal "x", "x".last(4)
assert_equal Time.utc(2005, 2, 27, 23, 50), "2005-02-27 23:50".to_time(:utc)
assert_equal Time.local(2005, 2, 27, 23, 50), "2005-02-27 23:50".to_time
assert_equal Time.utc(2005, 2, 27, 23, 50, 19, 275038), "2005-02-27T23:50:19.275038".to_time(:utc)
assert_equal Time.utc(2039, 2, 27, 23, 50), "2039-02-27 23:50".to_time(:utc)
assert_equal Time.local(2039, 2, 27, 23, 50), "2039-02-27 23:50".to_time
assert_equal Time.local(2011, 2, 27, 17, 50), "2011-02-27 13:50 -0100".to_time
assert_equal Time.utc(2011, 2, 27, 23, 50), "2011-02-27 22:50 -0100".to_time(:utc)
assert_equal Time.local(2005, 2, 27, 22, 50), "2005-02-27 14:50 -0500".to_time
assert_equal Time.utc(now.year, now.month, now.day, 23, 50), "23:50".to_time(:utc)
assert_equal Time.utc(now.year, now.month, now.day, 23, 50), "22:50 -0100".to_time(:utc)
Time.stub(:now, Time.local(2012, 1, 1)) do
assert_equal Time.local(2012, 1, 1, 10, 0), "2012-01-01 10:00".to_time
assert_equal Time.utc(2012, 1, 1, 10, 0), "2012-01-01 10:00".to_time(:utc)
assert_equal Time.local(2012, 1, 1, 13, 0), "2012-01-01 10:00 -0800".to_time
assert_equal Time.utc(2012, 1, 1, 18, 0), "2012-01-01 10:00 -0800".to_time(:utc)
assert_equal Time.local(2012, 1, 1, 10, 0), "2012-01-01 10:00 -0500".to_time
assert_equal Time.utc(2012, 1, 1, 15, 0), "2012-01-01 10:00 -0500".to_time(:utc)
assert_equal Time.local(2012, 1, 1, 5, 0), "2012-01-01 10:00 UTC".to_time
assert_equal Time.utc(2012, 1, 1, 10, 0), "2012-01-01 10:00 UTC".to_time(:utc)
assert_equal Time.local(2012, 1, 1, 13, 0), "2012-01-01 10:00 PST".to_time
assert_equal Time.utc(2012, 1, 1, 18, 0), "2012-01-01 10:00 PST".to_time(:utc)
assert_equal Time.local(2012, 1, 1, 10, 0), "2012-01-01 10:00 EST".to_time
assert_equal Time.utc(2012, 1, 1, 15, 0), "2012-01-01 10:00 EST".to_time(:utc)
Time.stub(:now, Time.local(2012, 7, 1)) do
assert_equal Time.local(2012, 7, 1, 10, 0), "2012-07-01 10:00".to_time
assert_equal Time.utc(2012, 7, 1, 10, 0), "2012-07-01 10:00".to_time(:utc)
assert_equal Time.local(2012, 7, 1, 13, 0), "2012-07-01 10:00 -0700".to_time
assert_equal Time.utc(2012, 7, 1, 17, 0), "2012-07-01 10:00 -0700".to_time(:utc)
assert_equal Time.local(2012, 7, 1, 10, 0), "2012-07-01 10:00 -0400".to_time
assert_equal Time.utc(2012, 7, 1, 14, 0), "2012-07-01 10:00 -0400".to_time(:utc)
assert_equal Time.local(2012, 7, 1, 6, 0), "2012-07-01 10:00 UTC".to_time
assert_equal Time.utc(2012, 7, 1, 10, 0), "2012-07-01 10:00 UTC".to_time(:utc)
assert_equal Time.local(2012, 7, 1, 13, 0), "2012-07-01 10:00 PDT".to_time
assert_equal Time.utc(2012, 7, 1, 17, 0), "2012-07-01 10:00 PDT".to_time(:utc)
assert_equal Time.local(2012, 7, 1, 10, 0), "2012-07-01 10:00 EDT".to_time
assert_equal Time.utc(2012, 7, 1, 14, 0), "2012-07-01 10:00 EDT".to_time(:utc)
assert_equal Time.local(2012, 1, 1, 10, 0), "10:00".to_time
assert_equal Time.local(2012, 1, 1, 6, 0), "10:00 -0100".to_time
assert_equal Time.utc(2012, 1, 1, 11, 0), "10:00 -0100".to_time(:utc)
assert_equal Time.local(2012, 1, 1, 10, 0), "10:00 -0500".to_time
assert_equal Time.utc(2012, 1, 1, 15, 0), "10:00 -0500".to_time(:utc)
assert_equal Time.local(2012, 1, 1, 5, 0), "10:00 UTC".to_time
assert_equal Time.utc(2012, 1, 1, 10, 0), "10:00 UTC".to_time(:utc)
assert_equal Time.local(2012, 1, 1, 13, 0), "10:00 PST".to_time
assert_equal Time.utc(2012, 1, 1, 18, 0), "10:00 PST".to_time(:utc)
assert_equal Time.local(2012, 1, 1, 12, 0), "10:00 PDT".to_time
assert_equal Time.utc(2012, 1, 1, 17, 0), "10:00 PDT".to_time(:utc)
assert_equal Time.local(2012, 1, 1, 10, 0), "10:00 EST".to_time
assert_equal Time.utc(2012, 1, 1, 15, 0), "10:00 EST".to_time(:utc)
assert_equal Time.local(2012, 1, 1, 9, 0), "10:00 EDT".to_time
assert_equal Time.utc(2012, 1, 1, 14, 0), "10:00 EDT".to_time(:utc)
assert_equal Time.local(2012, 7, 1, 10, 0), "10:00".to_time
assert_equal Time.utc(2012, 7, 1, 10, 0), "10:00".to_time(:utc)
assert_equal Time.local(2012, 7, 1, 7, 0), "10:00 -0100".to_time
assert_equal Time.utc(2012, 7, 1, 11, 0), "10:00 -0100".to_time(:utc)
assert_equal Time.local(2012, 7, 1, 11, 0), "10:00 -0500".to_time
assert_equal Time.utc(2012, 7, 1, 15, 0), "10:00 -0500".to_time(:utc)
assert_equal Time.local(2012, 7, 1, 6, 0), "10:00 UTC".to_time
assert_equal Time.utc(2012, 7, 1, 10, 0), "10:00 UTC".to_time(:utc)
assert_equal Time.local(2012, 7, 1, 14, 0), "10:00 PST".to_time
assert_equal Time.utc(2012, 7, 1, 18, 0), "10:00 PST".to_time(:utc)
assert_equal Time.local(2012, 7, 1, 13, 0), "10:00 PDT".to_time
assert_equal Time.utc(2012, 7, 1, 17, 0), "10:00 PDT".to_time(:utc)
assert_equal Time.local(2012, 7, 1, 11, 0), "10:00 EST".to_time
assert_equal Time.utc(2012, 7, 1, 15, 0), "10:00 EST".to_time(:utc)
assert_equal Time.local(2012, 7, 1, 10, 0), "10:00 EDT".to_time
assert_equal Time.utc(2012, 7, 1, 14, 0), "10:00 EDT".to_time(:utc)
assert_equal DateTime.civil(now.year, now.month, now.day, 23, 50, 0, "-04:00"), "23:50 -0400".to_datetime
assert_equal Date.new(2005, 2, 27), "2005-02-27".to_date
@string = +"hello"
string << @to_s_object
@combination = @other_string + "<foo>"
@other_combination = @string + "<foo>"
@other_string = +"other"
string = @other_string.concat("<foo>")
string = @other_string << "<foo>"
@other_string = "other%s"
string = @other_string % "<foo>"
_ = "%s %s %s".html_safe % @other_string
string.insert(0, "<b>".html_safe)
string.insert(0, "<b>")
assert_equal "<b>", string
string.replace("<b>")
assert_equal "&lt;b&gt;", string
if "".respond_to?(:bytesplice)
string.bytesplice(0, 0, "<b>".html_safe)
string.bytesplice(0..1, "<b>".html_safe)
string.bytesplice(1, 0, "<b>")
string.bytesplice(1..2, "<b>")
assert_equal "foo".to_yaml, "foo".html_safe.to_yaml(foo: 1)
string = '<>&"\''
expected = "&lt;&gt;&amp;&quot;&#39;"
string = "\251 <"
string = "<b>hello</b>".html_safe
string = "1 < 2 &amp; 3"
escaped_string = "1 &lt; 2 &amp; 3"
unsafe_char = ">"
assert_equal "__", ERB::Util.xml_name_escape(unsafe_char * 2)
assert_equal "__#{safe_char}_",
ERB::Util.xml_name_escape("#{unsafe_char * 2}#{safe_char}#{unsafe_char}")
assert_equal "_#{safe_char}",
common_dangerous_chars = "&<>\"' %*+,/;=^|"
assert_equal false, "foo".exclude?("o")
assert_equal true, "foo".exclude?("p")
assert_equal str, str.indent(1, "\t")
assert_equal "\tfoo\n\t\t\bar", "foo\n\t\bar".indent(1)
&nbsp;&nbsp;&nbsp;&nbsp;def some_method(x, y)
&nbsp;&nbsp;def some_method(x, y)
assert_equal " foo\n\n bar", "foo\n\nbar".indent(1)
assert_equal " foo\n \n bar", "foo\n\nbar".indent(1, nil, true)
assert_equal false, /(?m:)/.multiline?
date_range = Date.new(2005, 12, 10)..Date.new(2005, 12, 12)
assert_equal "BETWEEN '2005-12-10' AND '2005-12-12'", date_range.to_fs(:db)
date_range = Time.utc(2005, 12, 10, 15, 30)..Time.utc(2005, 12, 10, 17, 30)
assert_equal "BETWEEN '2005-12-10 15:30:00' AND '2005-12-10 17:30:00'", date_range.to_fs(:db)
alphabet_range = ("a".."z")
assert_equal "BETWEEN 'a' AND 'z'", alphabet_range.to_fs(:db)
number_range = (1..100)
assert_equal "BETWEEN '1' AND '100'", number_range.to_fs(:db)
assert((1..5).overlaps?(5..10))
assert_not (1...5).overlaps?(5..10)
assert((5..10).overlaps?(1..5))
assert_not (5..10).overlaps?(1...5)
assert((1..5).overlaps?(..10))
assert((..5).overlaps?(..10))
assert((1..10).include?(1..10))
assert((1...10).include?(1...10))
assert((1..10).include?(1...11))
assert_not((1..10).include?(5..3))
assert_not((1..5).include?(3...3))
assert((1..).include?(2))
assert((1..).include?(2..4))
assert_not((1..).include?(0..4))
assert((..2).include?(1))
assert((..2).include?(-1..1))
assert_not((..2).include?(-1..3))
assert((1..10) === (1..10))
assert((1...10) === (1...10))
assert((1..10) === (1...11))
assert_not((1..10) === (5..3))
assert_not((1..5) === (3...3))
assert((1..) === (2..4))
assert_not((1..) === (0..4))
assert((..2) === (-1..1))
assert_not((..2) === (-1..3))
assert_not_includes (1...10), 1..10
assert_not_includes (2..8), 1..3
assert_not_includes (2..8), 5..9
assert((1.0...10.0).include?(1.0...10.0))
range = (1..3)
time_range_1 = Time.utc(2005, 12, 10, 15, 30)..Time.utc(2005, 12, 10, 17, 30)
time_range_2 = Time.utc(2005, 12, 10, 17, 00)..Time.utc(2005, 12, 10, 18, 00)
time_range_2 = Time.utc(2005, 12, 10, 17, 31)..Time.utc(2005, 12, 10, 18, 00)
((twz - 1.hour)..twz).each { }
((twz - 1.hour)..twz).step(1) { }
assert ((twz - 1.hour)..twz).cover?(twz)
assert ((twz - 1.hour)..twz) === twz
assert(((datetime - 1.hour)..datetime).each { })
assert(((datetime - 1.hour)..datetime).step(1) { })
existing = Pathname.new(__FILE__)
@mixed_attr = :mixed
@object.with(private_attr: :changed) { }
@object.with(mixed_attr: :changed) { }
@string = "Hello"
assert_nil @string.try(method, "llo", "y")
assert_raise(NoMethodError) { @string.try!(method, "llo", "y") }
assert_equal "Hey", @string.try(:sub, "llo", "y")
assert_equal "Hey", @string.try(:sub, "llo") { |match| "y" }
nil.try { ran = true }
assert_query_equal "a=10", a: 10
assert_query_equal "a%3Ab=c+d", "a:b" => "c d"
assert_query_equal "a%3Ab=c+d", "a:b".html_safe => "c d"
assert_query_equal "a=", "a" => empty
assert_equal "",
{}.to_query
assert_query_equal "a=1&b%5Bc%5D=3",
a: 1, b: { c: 3, d: {} }
a: { b: { c: {} } }
assert_query_equal "b%5Bc%5D=false&b%5Be%5D=&b%5Bf%5D=&p=12",
p: 12, b: { c: false, e: nil, f: "" }
assert_query_equal "b%5Bc%5D=3&b%5Bf%5D=",
b: { c: 3, k: {}, f: "" }
hash = { name: "Nakshay", nationality: "Indian" }
hash = { type: "human", name: "Nakshay" }
{ "name" => "gorby", "id" => "123" },
{ "name" => "puff", "d" => "true" }
assert_equal expected.split("&"), actual.to_query.split("&")
def foo.to_s; "foo" end
def to_json(*)
require(file) || skip("'#{file}' was already loaded")
expected = Time.new(2004, 7, 25)
expected = Date.new(2004, 7, 25)
assert_equal({ "bar" => "bar", "baz" => "baz" }, @source.instance_values)
assert_equal %w(goodbye olleh bar), (+"hello").instance_exec("goodbye") { |arg|
h = { "a" => 100, "b" => 200 }
assert "a".in?(h)
assert_not "z".in?(h)
assert "lo".in?("hello")
assert_not "ol".in?("hello")
assert ?h.in?("hello")
assert 25.in?(1..50)
assert_not 75.in?(1..50)
assert 1.in?(s)
assert_not 3.in?(s)
class C < B
assert A.in?(B)
assert A.in?(C)
assert_not A.in?(A)
assert_not A.in?(D)
assert_raise(ArgumentError) { 1.in?(1) }
assert_equal "stuff", "stuff".presence_in(%w( lots of stuff ))
assert_nil "stuff".presence_in(%w( lots of crap ))
hash = { a: { b: "b" } }
hash = { a: zero_hash }
hash = { Integer => 1 }
hash = { key => :value }
BLANK.each { |v| assert_equal false, v.present?, "#{v.inspect} should not be present" }
@now = Time.local(2005, 2, 10, 15, 30, 45)
@dtnow = DateTime.civil(2005, 2, 10, 15, 30, 45)
@seconds = {
10.minutes => 600,
1.hour + 15.minutes => 4500,
2.days + 4.hours + 30.minutes => 189000,
assert_equal @now.advance(days: 1).advance(months: 1), (1.day + 1.month).since(@now)
assert_equal @now.advance(days: 7), (1.week + 5.seconds - 5.seconds).since(@now)
assert_equal @now.advance(years: 2), (4.years - 2.years).since(@now)
assert_equal @now + 8, @now + 8.seconds
assert_equal @now + 22.9, @now + 22.9.seconds
assert_equal @now.advance(days: 2).advance(months: -3), @now + 2.days - 3.months
assert_equal @now.advance(days: 1).advance(months: 2), @now + 1.day + 2.months
assert_equal Time.utc(2005, 2, 28, 15, 15, 10), Time.utc(2004, 2, 29, 15, 15, 10) + 1.year
assert_equal DateTime.civil(2005, 2, 28, 15, 15, 10), DateTime.civil(2004, 2, 29, 15, 15, 10) + 1.year
assert_equal @today + 1, @today + 1.day
assert_equal @today >> 1, @today + 1.month
assert_equal @today.to_time.since(60 * 60), @today + 1.hour
assert_equal Date.new(2005, 2, 28), Date.new(2004, 2, 29) + 1.year
assert_equal("800 555 1212", 8005551212.to_fs(:phone, delimiter: " "))
assert_equal("555.1212", 5551212.to_fs(:phone, delimiter: "."))
assert_equal("-$ 1,234,567,890.50", -1234567890.50.to_fs(:currency, format: "%u %n"))
assert_equal("($1,234,567,890.50)", -1234567890.50.to_fs(:currency, negative_format: "(%u%n)"))
assert_equal("&pound;1234567890,50", 1234567890.50.to_fs(:currency, unit: "&pound;", separator: ",", delimiter: ""))
assert_equal("-111.235", -111.2346.to_fs(:rounded))
assert_equal("31.83", 31.825.to_fs(:rounded, precision: 2))
assert_equal("31.82", 31.825.to_fs(:rounded, precision: 2, round_mode: :down))
assert_equal("3268", (32.6751 * 100.00).to_fs(:rounded, precision: 0))
assert_equal("0", 0.to_fs(:rounded, precision: 0))
assert_equal("0.00100", 0.001.to_fs(:rounded, precision: 5))
assert_equal("0.001", 0.00111.to_fs(:rounded, precision: 3))
assert_equal("10.00", 9.995.to_fs(:rounded, precision: 2))
assert_equal("11.00", 10.995.to_fs(:rounded, precision: 2))
assert_equal("0.00", -0.001.to_fs(:rounded, precision: 2))
assert_equal("1.000,000%", 1000.to_fs(:percentage, delimiter: ".", separator: ","))
assert_equal("0", 0.to_fs(:delimited))
assert_equal "12.345.678,05", 12345678.05.to_fs(:delimited, separator: ",", delimiter: ".")
assert_equal "12.345.678,05", 12345678.05.to_fs(:delimited, delimiter: ".", separator: ",")
assert_equal "-123", -123.to_fs(:human)
assert_equal "-0.5", -0.5.to_fs(:human)
assert_equal "0.5", 0.5.to_fs(:human)
assert_equal "12 ml", 12.to_fs(:human, units: volume)
assert_equal "1.23 dm", 0.123.to_fs(:human, units: distance)
assert_equal "1.23 dam", 12.3.to_fs(:human, units: distance)
assert_equal "4", 4.to_fs(:human, units: { unit: "", ten: "tens " })
assert_equal "123.lt", 123456.to_fs(:human, units: volume, format: "%n.%u")
assert_equal "2.5", 2.5.to_fs(:invalid)
assert_equal "2.5", 2.5.to_s
assert_equal "2.5", 2.5.to_fs
assert_equal "10000 10.0", BigDecimal("1000010").to_s("5F")
assert_equal "10000 10.0", BigDecimal("1000010").to_fs("5F")
1.to_s({})
1.to_fs({})
delegate :street, :city, :to_f, to: :place
def foo; 1; end
@type ||= nil.type_name
sym == :extra_missing || super
@case = kase
@maze = maze
@params = { foo: "bar" }
@full_name = "#{first} #{last}"
delegate :to_i, to: :shift, allow_nil: true
delegate :to_s, to: :shift
def two(a, b) end
def opt(a, b, c, d = nil) end
def kwargs(a:, b:) end
def kwargs_with_block(a:, b:, c:, &block) end
def opt_kwargs(a:, b: 3) end
def opt_kwargs_with_block(a:, b:, c:, d: "", &block) end
@david = Someone.new("David", Somewhere.new("Paulina", "Chicago"))
@david.place_name = "Fred"
david = Name.new("David", "Hansson")
Name.send :delegate, :go, to: :you, prefix: true
Name.send :delegate, :go, to: :_you, prefix: true
Name.send :delegate, :go, to: :You, prefix: true
Name.send :delegate, :go, to: :@you, prefix: true
rails = Project.new("Rails", Someone.new("David"))
rails = Project.new("Rails", "David")
someone = Someone.new("foo", "bar")
assert e.backtrace.any? { |a| a.include?(file_and_line) },
assert_equal "2", se.to_s
private(*delegate(:street, :city, to: :@place))
private(*delegate(:street, :city, to: :@place, prefix: :the))
delegate(:street, :city, to: :@place, private: true)
delegate(:street, to: :@place)
delegate(:city, to: :@place, private: true)
delegate(:street, :city, to: :@place, prefix: :the, private: true)
c = Class.new do
delegate :zero, :zero_with_block, :one, :one_with_block, :two, :opt,
d.new.one(1)
d.new.two(1, 2)
d.new.opt(1, 2, 3)
d.new.kwargs(a: 1, b: 2)
d.new.kwargs_with_block(a: 1, b: 2, c: 3)
d.new.opt_kwargs(a: 1)
d.new.opt_kwargs_with_block(a: 1, b: 2, c: 3)
e = Class.new do
klass = Class.new { concerning(:Foo) { } }
klass = Class.new { concerning(:Foo, prepend: true) { } }
def hi; "self"; end
def hi; "hello, #{super}"; end
included { @foo = 1 }
prepended { @foo = 2 }
@title, @Data = nil, nil
e.subject = "We got a long way to go"
e.body = "No, really, this is not a joke."
m = @module = Module.new do
cattr_accessor(:quux) { :quux }
@object = @class.new
@module.foo = :test
@object.foo = :test2
@module.cattr_accessor(:defcount) { count += 1 }
@module.cattr_accessor(:defn1, :defn2) { count += 1 }
@class.foo = 42
@class.foo = :test
@class.foo = :test2
@class.foo = "things"
@class.foo = "fries"
@class.foo = "super"
@subclass.foo = "sub"
@subclass.baz = "sub"
@class.baz = "super"
class << o; @x = 1; end
assert_equal 1, o.class_eval { @x }
@upcase_strings = { "A" => 1, "B" => 2 }
@nested_upcase_strings = { "A" => { "B" => { "C" => 3 } } }
assert_equal({ "a" => { b: { "c" => 3 } } }, @nested_mixed)
assert_equal({ "a" => "1", "b" => "2" }, @strings.deep_transform_values { |value| value.to_s })
assert_equal({ "a" => { "b" => { "c" => "3" } } }, @nested_strings.deep_transform_values { |value| value.to_s })
assert_equal({ "a" => "1", "b" => "2" }, @strings.deep_transform_values! { |value| value.to_s })
assert_equal({ "a" => { "b" => { "c" => "3" } } }, @nested_strings.deep_transform_values! { |value| value.to_s })
assert_equal({ "a" => { b: { "c" => "3" } } }, transformed_hash)
assert_equal({ :a => 1, "b" => 2 }, @mixed)
{ failure: "stuff", funny: "business" }.assert_valid_keys(:failure, :funny)
{ failure: "stuff", funny: "business" }.assert_valid_keys(:failure, :funny, :sunny)
{ failore: "stuff", funny: "business" }.assert_valid_keys(:failure, :funny)
hash_1 = { a: "a", b: "b", c: { c1: "c1", c2: "c2", c3: { d1: "d1" } } }
hash_2 = { a: 1, c: { c1: 2, c3: { d2: "d2" } } }
expected = { a: 1, b: "b", c: { c1: 2, c2: "c2", c3: { d1: "d1", d2: "d2" } } }
hash_1 = { e: false }
hash_2 = { e: "e" }
defaults = { d: 0, a: "x", b: "y", c: 10 }.freeze
expected = { d: 0, a: 1, b: 2, c: 10 }
defaults = { a: "x", b: "y", c: 10 }.freeze
expected = { a: 1, b: 2, c: 10 }
original = { a: "x", b: "y", c: 10 }
expected_return = { c: 10 }
expected_original = { a: "x", b: "y" }
expected = { a: "x", b: "y" }
hash = Hash.new(0)
hash.update(a: 1, b: 2)
hash.slice!(:a)
original = { a: 1, b: 2, c: 3, d: 4 }
expected = { a: 1, b: 2 }
remaining = { c: 3, d: 4 }
original = { a: nil, b: nil }
expected = { a: nil }
remaining = { b: nil }
expected = { a: "x" }
original = { a: "x", b: "y" }
def to_xml(options = {})
assert_equal "", {}.to_param
assert_equal "hello=world", { hello: "world" }.to_param
assert_equal "hello=10", { "hello" => 10 }.to_param
assert_equal "hello=world&say_bye=true", { :hello => "world", "say_bye" => true }.to_param
assert_equal "10=20&30=40&50=60", { 10 => 20, 30 => 40, 50 => 60 }.to_param
assert_equal "custom-1=param-1&custom2-1=param2-1", { ToParam.new("custom") => ToParam.new("param"), ToParam.new("custom2") => ToParam.new("param2") }.to_param
@xml_options = { root: :person, skip_instruct: true, indent: 0 }
xml = { name: "David", street: "Paulina" }.to_xml(@xml_options)
xml = { name: "David", street_name: "Paulina" }.to_xml(@xml_options.merge(dasherize: false))
xml = { name: "David", street_name: "Paulina" }.to_xml(@xml_options.merge(dasherize: true))
xml = { name: "David", street_name: "Paulina" }.to_xml(@xml_options.merge(camelize: true))
xml = { name: "David", street_name: "Paulina" }.to_xml(@xml_options.merge(camelize: :lower))
xml = { name: "David", street: "Paulina", age: 26, age_in_millis: 820497600000, moved_on: Date.new(2005, 11, 15), resident: :yes }.to_xml(@xml_options)
assert_includes xml, %(<age type="integer">26</age>)
xml = { name: "David", street: "Paulina", age: nil }.to_xml(@xml_options)
assert_includes xml, %(<age nil="true"/>)
xml = { name: "David", street: "Paulina", age: nil }.to_xml(@xml_options.merge(skip_types: true))
xml = { name: "David", street: "Paulina" }.to_xml(@xml_options) do |x|
xml = { name: "David", address: { street: "Paulina" } }.to_xml(@xml_options)
xml = { name: "David", address: { street: "Paulina" }, child: IWriteMyOwnXML.new }.to_xml(@xml_options)
topics_xml = <<-EOT
<topics type="array" page="1" page-count="1000" per-page="2">
<id type="integer">1</id>
<parent-id nil="true"></parent-id>
</topic>
<parent-id></parent-id>
</topics>
id: 1,
written_on: Date.new(2003, 7, 16),
viewed_at: Time.utc(2003, 7, 16, 9, 28),
topic_xml = <<-EOT
<title></title>
<id type="integer"></id>
id: nil,
<rsp stat="ok">
<photos page="1" pages="1" perpage="100" total="16">
</photos>
</rsp>
server: "76",
ispublic: "1",
isfriend: "0",
isfamily: "0",
test_xml = <<-EOT
blog_xml = <<-XML
<posts type="array"></posts>
<logo type="file">
bacon_xml = <<-EOT
<chunky type="boolean"> 1 </chunky>
<notes type="string"></notes>
</bacon>
weight: 0.5,
expires_at: Time.utc(2007, 12, 25, 12, 34, 56),
notes: "",
caption: "That'll do, pig."
product_xml = <<-EOT
</product>
image: { "type" => "ProductImage", "filename" => "image.gif" },
Hash.from_xml '<product><name type="foo">value</name></product>', %w(foo)
expected = { "numbers" => { "type" => "Array", "value" => "1" } }
expected = { "product" => { "name" => :value } }
expected = "<person><throw><ball>red</ball></throw></person>"
bare_string: "First & Last Name",
alert_xml = <<-XML
</alert>
assert_equal Time.utc(2008, 2, 10, 15, 30, 45), alert_at
options = { skip_instruct: true }
{}.to_xml(options)
original = { a: "a", b: "b" }.with_indifferent_access
mapped = original.transform_values { |v| v + "!" }
File.open(file_name, "w", 0755) do |file|
source = "Posts: <%= @post.length %>"
source = "Posts: <%= @post.length %> <% puts 'hi' %>"
source = "Posts: <%= @post.length %> <% puts 'hi' %>\nfoo <%"
source = "\nPosts: <%= @post.length %> <% puts 'hi' %>\nfoo <%"
source = "Posts: <%= \n @post.length %> <% puts 'hi' %>\nfoo <%"
source = "<%= @post.length %> <% puts 'hi' %>"
source = "@post.length %> <% puts 'hi' %>"
source = "%> <% puts 'hi' %>"
source = "%> <% puts 'hi'"
source = "<% puts 'hi'"
def +(p) self.class.new(price + p.price) end
def assert_typed_equal(e, v, cls, msg = nil)
assert_equal(e, v, msg)
assert_equal 60, enum.sum { |i| i * 2 }
assert_equal "abc", enum.sum("")
assert_equal "aabbcc", enum.sum("") { |i| i * 2 }
enum.sum { |i| i * 2 }
assert_equal 60, payments.sum { |p| p.price * 2 }
payments.sum { |p| p }
assert_equal 60, payments.sum { |p| p.price.to_i * 2 }
assert_equal 20, (1..4).sum { |i| i * 2 }
assert_equal 10, (1..4).sum
assert_equal 10, (1..4.5).sum
assert_equal 6, (1...4).sum
("a".."c").sum
assert_equal "abc", ("a".."c").sum("")
assert_equal 0, (10..0).sum
assert_equal 5, (10..0).sum(5)
assert_equal 10, (10..10).sum
assert_equal 42, (10...10).sum(42)
assert_typed_equal 20.0, (1..4).sum(0.0) { |i| i * 2 }, Float
assert_typed_equal 10.0, (1..4).sum(0.0), Float
assert_typed_equal 20.0, (1..4).sum(10.0), Float
assert_typed_equal 5.0, (10..0).sum(5.0), Float
enum = %w(a b c)
assert_equal({ 5 => Payment.new(5), 15 => Payment.new(15), 10 => Payment.new(10) },
assert_equal({ Payment.new(5) => 5, Payment.new(15) => 15, Payment.new(10) => 10 }, payments.index_with(&:price))
assert_equal({ title: nil, body: nil }, %i( title body ).index_with(nil))
assert_equal({ title: {}, body: {} }, %i( title body ).index_with({}))
assert_equal({ Payment.new(5) => 5, Payment.new(15) => 15, Payment.new(10) => 10 }, payments.index_with.each(&:price))
infinity = 1.0 / 0.0
assert_equal true, very_long_enum.many? { |x| x > 100 }
assert_equal({ foo: 1, baz: 3 }, { foo: 1, bar: 2, baz: 3 }.excluding(:bar))
assert_equal({ b: 1, f: true }, values.compact_blank)
assert_equal({ b: 1, f: true }, values)
d = 1.day
k = Class.new
class << k; undef_method :== end
assert_not d.is_a?(k)
assert 1.day == 1.day
assert 1.day == 1.day.to_i
assert 1.day.to_i == 1.day
assert_not (1.day == "foo")
I18n.backend.store_translations(:de, support: { array: { last_word_connector: " und " } })
assert_equal "10 years, 1 month, and 1 day", (10.years + 1.month + 1.day).inspect
assert_equal 7.days, 1.day * 7
assert_equal 1.day, 7.days / 7
assert_equal 1, 1.day / 1.day
assert_equal Date.civil(2017, 1, 1), Date.civil(2017, 1, 1) + 0.days
assert_equal Date.civil(2017, 1, 3), Date.civil(2017, 1, 1) + 1.day * 2
assert_instance_of Date, Date.civil(2017, 1, 1) + 1.day * 2
assert_equal Date.civil(2017, 2, 15), Date.civil(2017, 1, 1) + 1.day * 45
assert_instance_of Date, Date.civil(2017, 1, 1) + 1.day * 45
assert_equal Date.civil(2017, 1, 3), Date.civil(2017, 1, 1) + 4.days / 2
assert_instance_of Date, Date.civil(2017, 1, 1) + 4.days / 2
assert_equal Date.civil(2017, 2, 15), Date.civil(2017, 1, 1) + 90.days / 2
assert_instance_of Date, Date.civil(2017, 1, 1) + 90.days / 2
assert_equal((now + 1.public_send(unit)).class, Time, "Time + 1.#{unit} must be Time")
1.second.ago("")
assert_equal((86400 * 7) * 1.5, 1.5.weeks)
assert_equal((86400 * 7) * 1.7, 1.7.weeks)
assert_equal t + 1, (1.minute / 60).since(t)
assert_equal t - 1, 1.second.ago(t)
assert_equal t - 1, (1.minute / 60).ago(t)
assert 1.second.since >= now + 1
assert 1.second.ago >= now - 1
assert_in_delta((24 * 1.7).hours.since(t), 1.7.days.since(t), 1)
assert_in_delta((24 * 1.7).hours.ago(t), 1.7.days.ago(t), 1)
assert_equal((7 * 36).hours.since(t), 1.5.weeks.since(t))
assert_in_delta((7 * 24 * 1.7).hours.since(t), 1.7.weeks.since(t), 1)
assert_equal((7 * 36).hours.ago(t), 1.5.weeks.ago(t))
assert_in_delta((7 * 24 * 1.7).hours.ago(t), 1.7.weeks.ago(t), 1)
assert_equal Time.local(2000, 1, 1, 0, 0, 5), 5.seconds.since
assert_equal Time.utc(2000, 1, 1, 0, 0, 5), 5.seconds.since.time
with_env_tz "CET" do
assert_equal Time.local(2009, 3, 29, 0, 0, 0) + 24.hours, Time.local(2009, 3, 30, 1, 0, 0)
assert_equal Time.local(2009, 3, 29, 0, 0, 0) + 1.day, Time.local(2009, 3, 30, 0, 0, 0)
1.minute.times { counter += 1 }
cased = \
assert_equal(-1, (0.seconds <=> 1.second))
assert_equal(-1, (1.second <=> 1.minute))
assert_equal(-1, (1 <=> 1.minute))
assert_equal(0, (0.seconds <=> 0.seconds))
assert_equal(0, (0.seconds <=> 0.minutes))
assert_equal(0, (1.second <=> 1.second))
assert_equal(1, (1.second <=> 0.second))
assert_equal(1, (1.minute <=> 1.second))
assert_equal(1, (61 <=> 1.minute))
assert_equal 2.days, 2 * 1.day
assert_equal Time.utc(2017, 1, 3), Time.utc(2017, 1, 1) + 2 * 1.day
assert_equal Date.civil(2017, 1, 3), Date.civil(2017, 1, 1) + 2 * 1.day
assert_equal(1, scalar <=> 5)
assert_equal(0, scalar <=> 10)
assert_equal(-1, scalar <=> 15)
assert_nil(scalar <=> "foo")
scalar + "foo"
assert_equal({ days: 1, seconds: 10 }, (scalar + 1.day).parts)
assert_equal({ days: -1, seconds: 10 }, (scalar + -1.day).parts)
assert_equal({ days: -1, seconds: 10 }, (scalar - 1.day).parts)
assert_equal({ days: 1, seconds: 10 }, (scalar - -1.day).parts)
scalar - "foo"
scalar * "foo"
assert_equal({ days: 2 }, (scalar * 2.days).parts)
assert_equal({ days: -2 }, (scalar * -2.days).parts)
scalar / "foo"
scalar % "foo"
assert_equal({ hours: 1 }, (scalar % 2.hours).parts)
(1..11).each do |month|
assert_equal Date.civil(2015, 2, 28), Date.civil(2015, 1, 31) + 1.month
assert_equal Date.civil(2016, 2, 29), Date.civil(2016, 1, 31) + 1.month
time = Time.parse("Nov 29, 2016")
d1 = 3.months - 3.months
d2 = 2.months - 2.months
assert_equal time + d1, time + d2
assert_equal 660, (d1 + 60).to_i
time = Time.parse("Dec 7, 2021")
datetime = DateTime.new(2005, 2, 21, 14, 30, 0, 0)
assert_match(/^2005-02-21T14:30:00(Z|\+00:00)$/, datetime.to_default_s)
assert_equal "2009-02-05T14:30:05-06:00", DateTime.civil(2009, 2, 5, 14, 30, 5, Rational(-21600, 86400)).to_fs(:iso8601)
assert_equal "2008-06-09T04:05:01-05:00", DateTime.civil(2008, 6, 9, 4, 5, 1, Rational(-18000, 86400)).to_fs(:iso8601)
assert_equal "2009-02-05T14:30:05+00:00", DateTime.civil(2009, 2, 5, 14, 30, 5).to_fs(:iso8601)
datetime = DateTime.new(2005, 2, 21, 14, 30, 0)
assert_equal Time.local(2016, 3, 11, 10, 11, 12), DateTime.new(2016, 3, 11, 15, 11, 12, 0).localtime
assert_equal Time.local(2016, 3, 21, 11, 11, 12), DateTime.new(2016, 3, 21, 15, 11, 12, 0).localtime
assert_equal Time.local(2016, 4, 1, 11, 11, 12), DateTime.new(2016, 4, 1, 16, 11, 12, Rational(1, 24)).localtime
assert_equal Time.local(2016, 3, 11, 10, 11, 12), DateTime.new(2016, 3, 11, 15, 11, 12, 0).getlocal
assert_equal Time.local(2016, 3, 21, 11, 11, 12), DateTime.new(2016, 3, 21, 15, 11, 12, 0).getlocal
assert_equal Time.local(2016, 4, 1, 11, 11, 12), DateTime.new(2016, 4, 1, 16, 11, 12, Rational(1, 24)).getlocal
assert_equal Date.new(2005, 2, 21), DateTime.new(2005, 2, 21, 14, 30, 0).to_date
assert_equal DateTime.new(2005, 2, 21, 14, 30, 0), DateTime.new(2005, 2, 21, 14, 30, 0).to_datetime
assert_instance_of Time, DateTime.new(2005, 2, 21, 10, 11, 12, 0).to_time
assert_equal Time.local(2005, 2, 21, 5, 11, 12).getlocal(0), DateTime.new(2005, 2, 21, 10, 11, 12, 0).to_time
assert_equal Time.local(2005, 2, 21, 5, 11, 12).getlocal(0).utc_offset, DateTime.new(2005, 2, 21, 10, 11, 12, 0).to_time.utc_offset
assert_equal Time.local(2005, 2, 21, 5, 11, 12), DateTime.new(2005, 2, 21, 10, 11, 12, 0).to_time
assert_equal Time.local(2005, 2, 21, 5, 11, 12).utc_offset, DateTime.new(2005, 2, 21, 10, 11, 12, 0).to_time.utc_offset
assert_equal Time.utc(2005, 2, 21, 10, 11, 12, 256), DateTime.new(2005, 2, 21, 10, 11, 12 + Rational(256, 1000000), 0).to_time
assert_equal Time.local(2010, 5, 4, 0, 0, 0), DateTime.civil_from_format(:local, 2010, 5, 4)
assert_equal Time.utc(2010, 5, 4, 0, 0, 0), DateTime.civil_from_format(:utc, 2010, 5, 4)
assert_equal DateTime.civil(2005, 2, 4, 0, 0, 0), DateTime.civil(2005, 2, 4, 10, 10, 10).beginning_of_day
assert_equal DateTime.civil(2005, 2, 4, 12, 0, 0), DateTime.civil(2005, 2, 4, 10, 10, 10).middle_of_day
assert_equal DateTime.civil(2005, 2, 4, 19, 0, 0), DateTime.civil(2005, 2, 4, 19, 30, 10).beginning_of_hour
assert_equal DateTime.civil(2005, 2, 4, 19, 30, 0), DateTime.civil(2005, 2, 4, 19, 30, 10).beginning_of_minute
assert_equal DateTime.civil(2005, 2, 20, 10, 10, 10), DateTime.civil(2005, 2, 22, 10, 10, 10).ago(86400 * 2)
assert_equal DateTime.civil(2005, 2, 22, 10, 10, 11), DateTime.civil(2005, 2, 22, 10, 10, 10).since(1)
assert_equal DateTime.civil(2005, 2, 22, 11, 10, 10), DateTime.civil(2005, 2, 22, 10, 10, 10).since(3600)
assert_equal DateTime.civil(2005, 2, 24, 10, 10, 10), DateTime.civil(2005, 2, 22, 10, 10, 10).since(86400 * 2)
assert_equal DateTime.civil(2005, 2, 24, 11, 10, 35), DateTime.civil(2005, 2, 22, 10, 10, 10).since(86400 * 2 + 3600 + 25)
assert_not_equal DateTime.civil(2005, 2, 22, 10, 10, 11), DateTime.civil(2005, 2, 22, 10, 10, 10).since(1.333)
assert_not_equal DateTime.civil(2005, 2, 22, 10, 10, 12), DateTime.civil(2005, 2, 22, 10, 10, 10).since(1.667)
assert_equal DateTime.civil(2006, 2, 22, 15, 15, 10), DateTime.civil(2005, 2, 22, 15, 15, 10).change(year: 2006)
assert_equal DateTime.civil(2005, 6, 22, 15, 15, 10), DateTime.civil(2005, 2, 22, 15, 15, 10).change(month: 6)
assert_equal DateTime.civil(2012, 9, 22, 15, 15, 10), DateTime.civil(2005, 2, 22, 15, 15, 10).change(year: 2012, month: 9)
assert_equal DateTime.civil(2005, 2, 22, 15, 15, 10, Rational(-5, 24)), DateTime.civil(2005, 2, 22, 15, 15, 10, 0).change(offset: Rational(-5, 24))
assert_equal DateTime.civil(2005, 2, 1, 15, 15, 10.7), DateTime.civil(2005, 2, 22, 15, 15, 10.7).change(day: 1)
assert_raise(ArgumentError) { DateTime.civil(2005, 1, 2, 11, 22, 0).change(usec: 1, nsec: 1) }
assert_equal DateTime.civil(2013, 10, 17, 15, 15, 10), DateTime.civil(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 19, weeks: 2, days: 5)
assert_equal DateTime.civil(2001, 12, 27, 15, 15, 10), DateTime.civil(2005, 2, 28, 15, 15, 10).advance(years: -3, months: -2, days: -1)
assert_equal DateTime.civil(2013, 10, 17, 20, 22, 19), DateTime.civil(2005, 2, 28, 15, 15, 10).advance(years: 7, months: 19, weeks: 2, days: 5, hours: 5, minutes: 7, seconds: 9)
assert_equal DateTime.civil(2012, 10, 29, 13, 15, 10), DateTime.civil(2012, 9, 28, 1, 15, 10).advance(days: 1.5, months: 1)
assert_equal DateTime.civil(2010, 3, 29), DateTime.civil(2010, 2, 28, 22, 58, 59).advance(months: 1, hours: 1, minutes: 1, seconds: 1)
assert_match(/^1880-02-28T15:15:10\+00:?00$/, DateTime.civil(1880, 2, 28, 15, 15, 10).xmlschema)
assert_match(/^1980-02-28T15:15:10\+00:?00$/, DateTime.civil(1980, 2, 28, 15, 15, 10).xmlschema)
assert_match(/^2080-02-28T15:15:10\+00:?00$/, DateTime.civil(2080, 2, 28, 15, 15, 10).xmlschema)
assert_match(/^1880-02-28T15:15:10-06:?00$/, DateTime.civil(1880, 2, 28, 15, 15, 10, -0.25).xmlschema)
assert_match(/^1980-02-28T15:15:10-06:?00$/, DateTime.civil(1980, 2, 28, 15, 15, 10, -0.25).xmlschema)
assert_match(/^2080-02-28T15:15:10-06:?00$/, DateTime.civil(2080, 2, 28, 15, 15, 10, -0.25).xmlschema)
Time.stub(:now, Time.local(1999, 12, 31, 23, 59, 59)) do
assert_equal true, DateTime.civil(2005, 2, 21, 10, 11, 12).utc?
assert_equal true, DateTime.civil(2005, 2, 21, 10, 11, 12, 0).utc?
assert_equal false, DateTime.civil(2005, 2, 21, 10, 11, 12, 0.25).utc?
assert_equal false, DateTime.civil(2005, 2, 21, 10, 11, 12, -0.25).utc?
assert_equal 0, DateTime.civil(2005, 2, 21, 10, 11, 12, 0).utc_offset
assert_equal(-21600, DateTime.civil(2005, 2, 21, 10, 11, 12, -0.25).utc_offset)
assert_equal(-18000, DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-5, 24)).utc_offset)
assert_instance_of Time, DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24)).utc
assert_equal DateTime.civil(2005, 2, 21, 16, 11, 12, 0), DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24)).utc
assert_equal DateTime.civil(2005, 2, 21, 15, 11, 12, 0), DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-5, 24)).utc
assert_equal DateTime.civil(2005, 2, 21, 10, 11, 12, 0), DateTime.civil(2005, 2, 21, 10, 11, 12, 0).utc
assert_equal DateTime.civil(2005, 2, 21, 9, 11, 12, 0), DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(1, 24)).utc
assert_equal DateTime.civil(2005, 2, 21, 9, 11, 12, 0), DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(1, 24)).getutc
dt = DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-5, 24))
assert_equal 1, DateTime.civil(2000) <=> Time.utc(1999, 12, 31, 23, 59, 59)
assert_equal 0, DateTime.civil(2000) <=> Time.utc(2000, 1, 1, 0, 0, 0)
assert_equal(-1, DateTime.civil(2000) <=> Time.utc(2000, 1, 1, 0, 0, 1))
assert_equal 1, DateTime.civil(2000) <=> DateTime.civil(1999, 12, 31, 23, 59, 59)
assert_equal 0, DateTime.civil(2000) <=> DateTime.civil(2000, 1, 1, 0, 0, 0)
assert_equal(-1, DateTime.civil(2000) <=> DateTime.civil(2000, 1, 1, 0, 0, 1))
assert_equal 1, DateTime.civil(2000) <=> Time.utc(1999, 12, 31, 23, 59, 59).to_s
assert_equal 0, DateTime.civil(2000) <=> Time.utc(2000, 1, 1, 0, 0, 0).to_s
assert_equal(-1, DateTime.civil(2000) <=> Time.utc(2000, 1, 1, 0, 0, 1).to_s)
assert_equal 1, DateTime.civil(1970, 1, 1, 12, 0, 0) <=> 2440587
assert_equal 0, DateTime.civil(1970, 1, 1, 12, 0, 0) <=> 2440588
assert_equal(-1, DateTime.civil(1970, 1, 1, 12, 0, 0) <=> 2440589)
assert_equal 946684800.0, DateTime.civil(1999, 12, 31, 19, 0, 0, Rational(-5, 24)).to_f
assert_equal 946684800.5, DateTime.civil(1999, 12, 31, 19, 0, 0.5, Rational(-5, 24)).to_f
assert_equal 946684800, DateTime.civil(1999, 12, 31, 19, 0, 0, Rational(-5, 24)).to_i
assert_equal Rational(1, 2), DateTime.civil(2000, 1, 1, 0, 0, Rational(1, 2)).subsec
date = Date.new(2005, 2, 21)
date = Date.new(2005, 2, 1)
0.upto(138) do |year|
Date.new(2005, 2, 21).to_time(:tokyo)
assert_equal Date.new(2005, 2, 21), Date.new(2005, 2, 21).to_date
assert_equal Date.new(2005, 2, 21), Date.new(2005, 2, 11).change(day: 21)
assert_equal Date.new(2007, 5, 11), Date.new(2005, 2, 11).change(year: 2007, month: 5)
assert_equal Date.new(2006, 2, 22), Date.new(2005, 2, 22).change(year: 2006)
assert_equal Date.new(2005, 6, 22), Date.new(2005, 2, 22).change(month: 6)
assert_equal Date.new(2008, 3, 2), Date.new(2008, 3, 02).sunday
assert_equal Date.new(2008, 3, 2), Date.new(2008, 2, 29).sunday
assert_equal Date.new(2008, 12, 31).to_s, Date.new(2008, 2, 22).end_of_year.to_s
assert_equal Date.new(2005, 3, 31), Date.new(2005, 3, 20).end_of_month
assert_equal Date.new(2005, 2, 28), Date.new(2005, 2, 20).end_of_month
assert_equal Date.new(2005, 4, 30), Date.new(2005, 4, 20).end_of_month
assert_equal Date.new(2006, 2, 28), Date.new(2005, 2, 28).advance(years: 1)
assert_equal Date.new(2005, 6, 28), Date.new(2005, 2, 28).advance(months: 4)
assert_equal Date.new(2005, 3, 21), Date.new(2005, 2, 28).advance(weeks: 3)
assert_equal Date.new(2005, 3, 5), Date.new(2005, 2, 28).advance(days: 5)
assert_equal Date.new(2012, 9, 28), Date.new(2005, 2, 28).advance(years: 7, months: 7)
assert_equal Date.new(2013, 10, 3), Date.new(2005, 2, 28).advance(years: 7, months: 19, days: 5)
assert_equal Date.new(2013, 10, 17), Date.new(2005, 2, 28).advance(years: 7, months: 19, weeks: 2, days: 5)
assert_equal Date.new(2005, 2, 28), Date.new(2004, 2, 29).advance(years: 1) # leap day plus one year
assert_equal Date.new(2012, 2, 29), Date.new(2011, 2, 28).advance(years: 1, days: 1)
assert_equal Date.new(2010, 3, 29), Date.new(2010, 2, 28).advance(months: 1, days: 1)
assert_equal Date.new(1582, 10, 15), Date.new(1582, 10, 4).advance(days: 1)
assert_equal Date.new(1582, 10, 4), Date.new(1582, 10, 15).advance(days: -1)
5.upto(14) do |day|
assert_equal Date.new(1582, 10, 4), Date.new(1582, 11, day).advance(months: -1)
assert_equal Date.new(1582, 10, 4), Date.new(1583, 10, day).advance(years: -1)
assert_equal Date.new(2005, 5, 9), Date.new(2005, 5, 17).last_week
assert_equal Date.new(2010, 2, 12), Date.new(2010, 2, 19).last_week(:friday)
Time.stub(:now, Time.local(2000, 1, 1)) do
Time.stub(:now, Time.local(1999, 12, 31, 23)) do
assert_equal Time.local(2005, 2, 21, 0, 0, 45), Date.new(2005, 2, 21).since(45)
assert_equal zone.local(2005, 2, 21, 0, 0, 45), Date.new(2005, 2, 21).since(45)
assert_equal Time.local(2005, 2, 20, 23, 59, 15), Date.new(2005, 2, 21).ago(45)
assert_equal zone.local(2005, 2, 20, 23, 59, 15), Date.new(2005, 2, 21).ago(45)
assert_equal Time.local(2005, 2, 21, 0, 0, 0), Date.new(2005, 2, 21).beginning_of_day
assert_equal Time.local(2005, 2, 21, 12, 0, 0), Date.new(2005, 2, 21).middle_of_day
assert_equal zone.local(2005, 2, 21, 0, 0, 0), Date.new(2005, 2, 21).beginning_of_day
assert_equal Time.local(2005, 2, 21, 23, 59, 59, Rational(999999999, 1000)), Date.new(2005, 2, 21).end_of_day
assert_equal zone.local(2005, 2, 21, 23, 59, 59, Rational(999999999, 1000)), Date.new(2005, 2, 21).end_of_day
beginning_of_day = Time.local(2011, 6, 7, 0, 0, 0)
end_of_day = Time.local(2011, 6, 7, 23, 59, 59, Rational(999999999, 1000))
beginning_of_day = zone.local(2011, 6, 7, 0, 0, 0)
end_of_day = zone.local(2011, 6, 7, 23, 59, 59, Rational(999999999, 1000))
assert_equal Date.new(2011, 6, 6)..Date.new(2011, 6, 12), Date.new(2011, 6, 7).all_week
assert_equal Date.new(2011, 6, 5)..Date.new(2011, 6, 11), Date.new(2011, 6, 7).all_week(:sunday)
assert_equal Date.new(2011, 6, 1)..Date.new(2011, 6, 30), Date.new(2011, 6, 7).all_month
assert_equal Date.new(2011, 4, 1)..Date.new(2011, 6, 30), Date.new(2011, 6, 7).all_quarter
assert_equal Date.new(2011, 1, 1)..Date.new(2011, 12, 31), Date.new(2011, 6, 7).all_year
assert_match(/^1980-02-28T00:00:00-05:?00$/, Date.new(1980, 2, 28).xmlschema)
assert_match(/^1980-06-28T00:00:00-04:?00$/, Date.new(1980, 6, 28).xmlschema)
if ::DateTime === Date.new(1880, 6, 28).to_time
assert_match(/^1880-02-28T00:00:00-05:?00$/, Date.new(1880, 2, 28).xmlschema)
options = { years: 3, months: 11, days: 2 }
assert_equal({ years: 3, months: 11, days: 2 }, options)
@utc_time = Time.utc(2016, 4, 23, 14, 11, 12)
@date_time = DateTime.new(2016, 4, 23, 14, 11, 12, 0)
source = Time.new(2016, 4, 23, 15, 11, 12, 3600)
source = Time.new(2016, 4, 23, 15, 11, 12, 3600).freeze
source = DateTime.new(2016, 4, 23, 15, 11, 12, Rational(1, 24))
source = DateTime.new(2016, 4, 23, 15, 11, 12, Rational(1, 24)).freeze
source = "2016-04-23T15:11:12+01:00"
assert_equal date_time_init(2005, 2, 21, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).yesterday
assert_equal date_time_init(2005, 2, 28, 10, 10, 10), date_time_init(2005, 3, 2, 10, 10, 10).yesterday.yesterday
assert_equal date_time_init(2005, 2, 23, 10, 10, 10), date_time_init(2005, 2, 22, 10, 10, 10).tomorrow
assert_equal date_time_init(2005, 1, 1, 10, 10, 10), date_time_init(2004, 12, 31, 10, 10, 10).days_since(1)
assert_equal date_time_init(2004, 12, 25, 10, 10, 10), date_time_init(2005, 1, 1, 10, 10, 10).weeks_ago(1)
assert_equal date_time_init(2005, 7, 14, 10, 10, 10), date_time_init(2005, 7, 7, 10, 10, 10).weeks_since(1)
assert_equal date_time_init(2004, 11, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).months_ago(7)
assert_equal date_time_init(2004, 12, 5, 10, 10, 10), date_time_init(2005, 6, 5, 10, 10, 10).months_ago(6)
assert_equal date_time_init(2003, 2, 28, 10, 10, 10), date_time_init(2004, 2, 29, 10, 10, 10).years_ago(1) # 1 year ago from leap day
assert_equal date_time_init(2005, 2, 28, 10, 10, 10), date_time_init(2004, 2, 29, 10, 10, 10).years_since(1) # 1 year since leap day
assert_equal date_time_init(2005, 2, 1, 0, 0, 0), date_time_init(2005, 2, 22, 10, 10, 10).beginning_of_month
assert_equal date_time_init(2005, 10, 1, 0, 0, 0), date_time_init(2005, 12, 31, 10, 10, 10).beginning_of_quarter
assert_equal date_time_init(2007, 3, 31, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 2, 15, 10, 10, 10).end_of_quarter
assert_equal date_time_init(2007, 3, 31, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 3, 31, 0, 0, 0).end_of_quarter
assert_equal date_time_init(2007, 6, 30, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 4, 1, 0, 0, 0).end_of_quarter
assert_equal date_time_init(2008, 6, 30, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2008, 5, 31, 0, 0, 0).end_of_quarter
assert_equal 1, date_time_init(2005, 1, 1, 0, 0, 0).quarter
assert_equal 1, date_time_init(2005, 2, 15, 12, 0, 0).quarter
assert_equal 1, date_time_init(2005, 3, 31, 23, 59, 59).quarter
assert_equal 2, date_time_init(2005, 4, 1, 0, 0, 0).quarter
assert_equal 2, date_time_init(2005, 5, 15, 12, 0, 0).quarter
assert_equal 2, date_time_init(2005, 6, 30, 23, 59, 59).quarter
assert_equal 3, date_time_init(2005, 7, 1, 0, 0, 0).quarter
assert_equal 3, date_time_init(2005, 8, 15, 12, 0, 0).quarter
assert_equal 3, date_time_init(2005, 9, 30, 23, 59, 59).quarter
assert_equal 4, date_time_init(2005, 10, 1, 0, 0, 0).quarter
assert_equal 4, date_time_init(2005, 11, 15, 12, 0, 0).quarter
assert_equal date_time_init(2005, 1, 1, 0, 0, 0), date_time_init(2005, 2, 22, 10, 10, 10).beginning_of_year
assert_equal date_time_init(2006, 10, 30, 0, 0, 0), date_time_init(2006, 10, 23, 0, 0, 0).next_week
assert_equal date_time_init(2005, 2, 28, 15, 15, 10), date_time_init(2005, 2, 22, 15, 15, 10).next_week(:monday, same_time: true)
assert_equal date_time_init(2005, 2, 28, 15, 15, 10, 999999), date_time_init(2005, 2, 22, 15, 15, 10, 999999).next_week(:monday, same_time: true)
assert_equal date_time_init(2006, 10, 30, 0, 0, 0), date_time_init(2006, 10, 23, 0, 0, 0).next_week(:monday, same_time: true)
assert_equal date_time_init(2015, 1, 8, 0, 0, 0), date_time_init(2015, 1, 7, 0, 0, 0).next_weekday
assert_equal date_time_init(2015, 1, 8, 15, 15, 10), date_time_init(2015, 1, 7, 15, 15, 10).next_weekday
assert_equal date_time_init(2015, 1, 5, 0, 0, 0), date_time_init(2015, 1, 2, 0, 0, 0).next_weekday
assert_equal date_time_init(2015, 1, 5, 15, 15, 10), date_time_init(2015, 1, 2, 15, 15, 10).next_weekday
assert_equal date_time_init(2015, 1, 5, 0, 0, 0), date_time_init(2015, 1, 3, 0, 0, 0).next_weekday
assert_equal date_time_init(2015, 1, 5, 15, 15, 10), date_time_init(2015, 1, 3, 15, 15, 10).next_weekday
assert_equal date_time_init(2005, 9, 30, 15, 15, 10), date_time_init(2005, 8, 31, 15, 15, 10).next_month
assert_equal date_time_init(2005, 11, 30, 15, 15, 10), date_time_init(2005, 8, 31, 15, 15, 10).next_quarter
assert_equal date_time_init(2006, 10, 30, 0, 0, 0), date_time_init(2006, 11, 6, 0, 0, 0).prev_week
assert_equal date_time_init(2006, 11, 15, 0, 0, 0), date_time_init(2006, 11, 23, 0, 0, 0).prev_week(:wednesday)
assert_equal date_time_init(2006, 10, 30, 0, 0, 0), date_time_init(2006, 11, 6, 0, 0, 0).prev_week(:monday, same_time: true)
assert_equal date_time_init(2006, 11, 15, 0, 0, 0), date_time_init(2006, 11, 23, 0, 0, 0).prev_week(:wednesday, same_time: true)
assert_equal date_time_init(2015, 1, 6, 0, 0, 0), date_time_init(2015, 1, 7, 0, 0, 0).prev_weekday
assert_equal date_time_init(2015, 1, 6, 15, 15, 10), date_time_init(2015, 1, 7, 15, 15, 10).prev_weekday
assert_equal date_time_init(2015, 1, 2, 0, 0, 0), date_time_init(2015, 1, 5, 0, 0, 0).prev_weekday
assert_equal date_time_init(2015, 1, 2, 15, 15, 10), date_time_init(2015, 1, 5, 15, 15, 10).prev_weekday
assert_equal date_time_init(2015, 1, 2, 0, 0, 0), date_time_init(2015, 1, 4, 0, 0, 0).prev_weekday
assert_equal date_time_init(2015, 1, 2, 15, 15, 10), date_time_init(2015, 1, 4, 15, 15, 10).prev_weekday
assert_equal date_time_init(2004, 2, 29, 10, 10, 10), date_time_init(2004, 3, 31, 10, 10, 10).prev_month
assert_equal date_time_init(2004, 2, 29, 10, 10, 10), date_time_init(2004, 5, 31, 10, 10, 10).prev_quarter
assert_equal date_time_init(2004, 2, 29, 0, 0, 0), date_time_init(2004, 3, 31, 0, 0, 0).last_month
assert_equal date_time_init(2004, 6, 5, 10, 0, 0), date_time_init(2005, 6, 5, 10, 0, 0).last_year
assert_equal 0, date_time_init(2011, 11, 01, 0, 0, 0).days_to_week_start(:tuesday)
assert_equal 1, date_time_init(2011, 11, 02, 0, 0, 0).days_to_week_start(:tuesday)
assert_equal 2, date_time_init(2011, 11, 03, 0, 0, 0).days_to_week_start(:tuesday)
assert_equal 3, date_time_init(2011, 11, 04, 0, 0, 0).days_to_week_start(:tuesday)
assert_equal 4, date_time_init(2011, 11, 05, 0, 0, 0).days_to_week_start(:tuesday)
assert_equal 5, date_time_init(2011, 11, 06, 0, 0, 0).days_to_week_start(:tuesday)
assert_equal 6, date_time_init(2011, 11, 07, 0, 0, 0).days_to_week_start(:tuesday)
assert_equal 3, date_time_init(2011, 11, 03, 0, 0, 0).days_to_week_start(:monday)
assert_equal 3, date_time_init(2011, 11, 06, 0, 0, 0).days_to_week_start(:thursday)
assert_equal 3, date_time_init(2011, 11, 07, 0, 0, 0).days_to_week_start(:friday)
assert_equal 3, date_time_init(2011, 11, 8, 0, 0, 0).days_to_week_start(:saturday)
assert_equal 3, date_time_init(2011, 11, 9, 0, 0, 0).days_to_week_start(:sunday)
assert_equal 6, Time.local(2012, 03, 8, 0, 0, 0).days_to_week_start
assert_equal 5, Time.local(2012, 03, 7, 0, 0, 0).days_to_week_start
assert_equal 4, Time.local(2012, 03, 6, 0, 0, 0).days_to_week_start
assert_equal 3, Time.local(2012, 03, 5, 0, 0, 0).days_to_week_start
assert_equal 2, Time.local(2012, 03, 4, 0, 0, 0).days_to_week_start
assert_equal 1, Time.local(2012, 03, 3, 0, 0, 0).days_to_week_start
assert_equal 0, Time.local(2012, 03, 2, 0, 0, 0).days_to_week_start
assert_equal date_time_init(2005, 11, 28, 0, 0, 0), date_time_init(2005, 11, 28, 0, 0, 0).beginning_of_week # monday
assert_equal date_time_init(2005, 11, 28, 0, 0, 0), date_time_init(2005, 11, 29, 0, 0, 0).beginning_of_week # tuesday
assert_equal date_time_init(2005, 11, 28, 0, 0, 0), date_time_init(2005, 11, 30, 0, 0, 0).beginning_of_week # wednesday
assert_equal date_time_init(2005, 11, 28, 0, 0, 0), date_time_init(2005, 12, 01, 0, 0, 0).beginning_of_week # thursday
assert_equal date_time_init(2005, 11, 28, 0, 0, 0), date_time_init(2005, 12, 02, 0, 0, 0).beginning_of_week # friday
assert_equal date_time_init(2005, 11, 28, 0, 0, 0), date_time_init(2005, 12, 03, 0, 0, 0).beginning_of_week # saturday
assert_equal date_time_init(2005, 11, 28, 0, 0, 0), date_time_init(2005, 12, 04, 0, 0, 0).beginning_of_week # sunday
assert_equal date_time_init(2008, 1, 6, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 12, 31, 10, 10, 10).end_of_week
assert_equal date_time_init(2007, 9, 2, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 8, 27, 0, 0, 0).end_of_week # monday
assert_equal date_time_init(2007, 9, 2, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 8, 28, 0, 0, 0).end_of_week # tuesday
assert_equal date_time_init(2007, 9, 2, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 8, 29, 0, 0, 0).end_of_week # wednesday
assert_equal date_time_init(2007, 9, 2, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 8, 30, 0, 0, 0).end_of_week # thursday
assert_equal date_time_init(2007, 9, 2, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 8, 31, 0, 0, 0).end_of_week # friday
assert_equal date_time_init(2007, 9, 2, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 9, 01, 0, 0, 0).end_of_week # saturday
assert_equal date_time_init(2007, 9, 2, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 9, 02, 0, 0, 0).end_of_week # sunday
assert_equal date_time_init(2005, 3, 31, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2005, 3, 20, 10, 10, 10).end_of_month
assert_equal date_time_init(2005, 2, 28, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2005, 2, 20, 10, 10, 10).end_of_month
assert_equal date_time_init(2005, 4, 30, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2005, 4, 20, 10, 10, 10).end_of_month
assert_equal date_time_init(2007, 12, 31, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 2, 22, 10, 10, 10).end_of_year
assert_equal date_time_init(2007, 12, 31, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2007, 12, 31, 10, 10, 10).end_of_year
assert_equal date_time_init(2017, 12, 18, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).next_occurring(:monday)
assert_equal date_time_init(2017, 12, 19, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).next_occurring(:tuesday)
assert_equal date_time_init(2017, 12, 20, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).next_occurring(:wednesday)
assert_equal date_time_init(2017, 12, 21, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).next_occurring(:thursday)
assert_equal date_time_init(2017, 12, 15, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).next_occurring(:friday)
assert_equal date_time_init(2017, 12, 16, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).next_occurring(:saturday)
assert_equal date_time_init(2017, 12, 17, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).next_occurring(:sunday)
assert_equal date_time_init(2017, 12, 11, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).prev_occurring(:monday)
assert_equal date_time_init(2017, 12, 12, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).prev_occurring(:tuesday)
assert_equal date_time_init(2017, 12, 13, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).prev_occurring(:wednesday)
assert_equal date_time_init(2017, 12, 10, 3, 14, 15), date_time_init(2017, 12, 14, 3, 14, 15).prev_occurring(:sunday)
assert_equal date_time_init(2012, 9, 17, 0, 0, 0), date_time_init(2012, 9, 18, 0, 0, 0).monday
assert_equal date_time_init(2012, 9, 23, 23, 59, 59, Rational(999999999, 1000)), date_time_init(2012, 9, 19, 0, 0, 0).sunday
assert_predicate date_time_init(2015, 1, 3, 0, 0, 0), :on_weekend?
assert_predicate date_time_init(2015, 1, 3, 15, 15, 10), :on_weekend?
assert_predicate date_time_init(2015, 1, 4, 0, 0, 0), :on_weekend?
assert_predicate date_time_init(2015, 1, 4, 15, 15, 10), :on_weekend?
assert_not_predicate date_time_init(2015, 1, 5, 0, 0, 0), :on_weekend?
assert_not_predicate date_time_init(2015, 1, 5, 15, 15, 10), :on_weekend?
assert_not_predicate date_time_init(2015, 1, 4, 0, 0, 0), :on_weekday?
assert_not_predicate date_time_init(2015, 1, 4, 15, 15, 10), :on_weekday?
assert_predicate date_time_init(2015, 1, 5, 0, 0, 0), :on_weekday?
assert_predicate date_time_init(2015, 1, 5, 15, 15, 10), :on_weekday?
assert_equal false, date_time_init(2017, 3, 6, 12, 0, 0).before?(date_time_init(2017, 3, 5, 12, 0, 0))
assert_equal false, date_time_init(2017, 3, 6, 12, 0, 0).before?(date_time_init(2017, 3, 6, 12, 0, 0))
assert_equal true, date_time_init(2017, 3, 6, 12, 0, 0).before?(date_time_init(2017, 3, 7, 12, 0, 0))
assert_equal true, date_time_init(2017, 3, 6, 12, 0, 0).after?(date_time_init(2017, 3, 5, 12, 0, 0))
assert_equal false, date_time_init(2017, 3, 6, 12, 0, 0).after?(date_time_init(2017, 3, 6, 12, 0, 0))
assert_equal false, date_time_init(2017, 3, 6, 12, 0, 0).after?(date_time_init(2017, 3, 7, 12, 0, 0))
class Bar < Foo; end
class Baz < Bar; end
class B < A; end
class C < B; end
@sub = Class.new(@klass)
@sub.setting = 1
val = @klass.public_send(:setting=, 1)
bd = BigDecimal "0.01"
assert_equal "0.01", bd.to_s
assert_equal "+0.01", bd.to_s("+F")
assert_equal "+0.0 1", bd.to_s("+1F")
ary = %w(foo bar)
o = Struct.new(:foo).new(123)
("a".."i").to_a.in_groups_of(3) do |group|
("a".."g").to_a.in_groups_of(3) do |group|
("a".."g").to_a.in_groups_of(3, "foo") do |group|
("a".."g").to_a.in_groups_of(3, false) do |group|
array = (1..7).to_a
1.upto(array.size + 1) do |number|
array = (1..9).to_a
(1..9).to_a.in_groups(3)
array.in_groups(3, "foo")
(1..7).to_a.in_groups(3, false)
a = (1..10).to_a
assert_equal({ foo: 1 }, options)
hash.foo = 1
options = { words_connector: " " }
assert_equal({ words_connector: " " }, options)
@@counter = 0
@@counter += 1
assert_equal "1,2,3", collection.to_fs(:db)
{ name: "David", age: 26, age_in_millis: 820497600000 },
{ name: "Jason", age: 31, age_in_millis: BigDecimal("1.0") }
assert_includes xml, %(<age type="integer">26</age>), xml
assert_includes xml, %(<age type="integer">31</age>), xml
assert_includes xml, %(<object type="float">2.0</object>), xml
{ name: "David", age: 26, age_in_millis: 820497600000 }, { name: "Jason", age: 31 }
{ name: "David", street_address: "Paulina" }, { name: "Jason", street_address: "Evergreen" }
assert_equal 0, xml.rindex(/<\?xml /)
assert_includes xml, %(<count>2</count>), xml
assert_match(/type="array"\/>/, xml)
assert_equal %w( a b c d ), %w( a b c d ).from(0)
assert_equal %w( c d ), %w( a b c d ).from(2)
assert_equal %w(), %w( a b c d ).from(10)
assert_equal %w( d e ), %w( a b c d e ).from(-2)
assert_equal %w(), %w( a b c d e ).from(-10)
assert_equal %w( a ), %w( a b c d ).to(0)
assert_equal %w( a b c ), %w( a b c d ).to(2)
assert_equal %w( a b c d ), %w( a b c d ).to(10)
assert_equal %w( a b c ), %w( a b c d ).to(-2)
assert_equal %w(), %w( a b c ).to(-10)
array = (1..42).to_a
assert_equal Ace::Base::Case, yield("::Ace::Base::Case")
assert_equal Ace::Base::Case::Dice, yield("Ace::Base::Case::Dice")
assert_equal Ace::Base::Case::Dice, yield("Ace::Base::Fase::Dice")
assert_equal Ace::Base::Fase::Dice, yield("Ace::Base::Fase::Dice")
assert_equal Ace::Gas::Case, yield("Ace::Gas::Case")
assert_equal Ace::Gas::Case::Dice, yield("Ace::Gas::Case::Dice")
assert_equal Ace::Base::Case::Dice, yield("Ace::Gas::Case::Dice")
assert_raises(NameError) { yield("Ace::Gas::Base") }
assert_raises(NameError) { yield("") }
assert_raises(NameError) { yield("::") }
assert_raises(NameError) { yield("Ace::gas") }
assert_nil yield("")
assert_nil yield("::")
assert_nil yield("A::Object::B")
file.write("wrong: <%= foo %>")
assert_equal({ foo: :bar }, Parent.config)
assert_equal({ foo: :bar }, mixin.config)
assert_equal "bar's baz + baz", @klass.baz
included.module_eval { def foo; @foo << :included; end }
@klass.class_eval { def foo; super; @foo << :class; end }
prepended.module_eval { def foo; super; @foo << :prepended; end }
included.class_methods { def foo; @foo << :included; end }
@klass.class_eval { def self.foo; super; @foo << :class; end }
@logger.formatter.datetime_format = "%Y-%m-%d"
@bc.add_filter { |line| line.gsub("/my/prefix", "") }
@bc.add_silencer { |line| line.include?("mongrel") }
@bc.add_silencer { |line| line.include?("yolo") }
target_dir = Gem.path.detect { |p| p != Gem.default_dir }
set_callback(:save, :after, *filters, &blk)
set_callback :dispatch, :before, :log, unless: proc { |c| c.action_name == :index || c.action_name == :show }
@logger << "Done"
skip_callback :dispatch, :before, :log, if: proc { |c| c.action_name == :update }
@@starts_true, @@starts_false = true, false
before_save Proc.new { |r| r.history << "b00m" }, if: Proc.new { |r| false }
before_save Proc.new { |r| r.history << "b00m" }, unless: Proc.new { |r| true }
before_save Proc.new { |r| r.history << "b00m" }, if: :no
before_save Proc.new { |r| r.history << "b00m" }, unless: :yes
before_save Proc.new { |r| r.history << "b00m" }, if: :yes, unless: :yes
@history << "running"
when /^log_(.*)/
@history << $1
when /^wrap_(.*)/
@history << "wrap_#$1"
@history << "unwrap_#$1"
when /^double_(.*)/
@history << "first_#$1"
@history << "second_#$1"
@history << "third_#$1"
sym.match?(/^(log|wrap)_/) || super
set_callback :save, :before, proc { |m| m.history << "yup" }
@history << "boom"
@history << "yup"
@history << "w0tyes after"
@history << "tweedle dum pre"
@history << "tweedle dum post"
@history << "tweedle"
set_callback :save, :before, :action, if: :yes
@recorder << 3
@recorder << 2
@recorder << 1
@history << "around1"
@history << "around2"
@history << "first"
@history << "second"
@history << "third"
@saved = true
define_callbacks :save, terminator: ->(_, result_lambda) { result_lambda.call == :halt }
define_callbacks :save, terminator: ->(_, result_lambda) { result_lambda.call == :halt },
@record << "yielded"
@record << "one"
@record << "two"
@record << "three"
set_callback :save, :before, :first, :second, :first, :third
skip_callback :save, :before, :before_save_method, if: -> { age > 21 }
klass = build_class(->() { calls << :foo })
klass = build_class(->(o) { calls << o })
klass = build_class(->(x, y) { })
klass = build_class(->(*args) { calls << args })
define_singleton_method(:foo) { |o| z << o }
klass = Class.new {
define_singleton_method(:before) { |o| z << o }
object = build_class(->(*args) { z << args }).new
object = build_class(->() { z << 0 }).new
object = build_class(->(x) { z << x }).new
object = build_class(->(a, b) { }).new
define_method(:hello) { memo << :hi }
subclass = Class.new(klass) { set_callback :foo, :before, :world }
subclass.class_eval { define_method(:world) { events << :world } }
define_singleton_method(:before) { |o| calls << o }
build_class(->(o) { calls << o }).new.run
klass.class_eval { define_method(:bar) { calls << klass } }
9.downto(0) { |i|
@history << __method__.to_s
set_callback :dispatch, :before, :before1, :before2, if: proc { |c| c.action_name == "index" || c.action_name == "update" }
set_callback :dispatch, :after, :after1, :after2, if: proc { |c| c.action_name == "update" || c.action_name == "delete" }
@log << "before1"
@log << "before2"
@log << "after1"
@log << "after2"
@log << action_name
skip_callback :dispatch, :before, :before2, unless: proc { |c| c.action_name == "update" }
skip_callback :dispatch, :after, :after2, unless: proc { |c| c.action_name == "delete" }
skip_callback :dispatch, :before, :before2, unless: proc { |c| c.action_name == "update" }, if: :state_open?
@state == :open
@performed ||= false
@count = 0
@count += 1
parent = Parent.new("foo")
default_args = {
block = -> { :custom_redis_client }
@cache = nil
def lookup_store(options = {})
@cache.fetch_multi("a", "b", "c") do |key|
key * 2
@cache.fetch_multi("a", "b", "c", namespace: "custom-namespace") do |key|
@cache.fetch_multi() { }
assert @cache.redis.ttl("#{@namespace}:foo") > 0
@cache.redis.setex "#{@namespace}:bar", 120, 1
assert @cache.redis.ttl("#{@namespace}:bar") > 60
@cache.redis.set "#{@namespace}:dar", 10
assert @cache.redis.ttl("#{@namespace}:dar") > 0
@cache.write("foo", nil)
assert_nil @cache.fetch("foo") { "baz" }
assert_nil @cache.fetch("foo") { nil }
error_handler: -> (method:, returning:, exception:) { raise exception })
key = "#{prefix}#{SecureRandom.uuid}"
@cache.write(key, "bar")
@cache.delete_matched("#{prefix}*")
cache.write("foo", "bar")
cache.write("fu", "baz")
@cache.write("foo", "bar", raw: true)
@cache.read("foo", raw: true)
@cache.write("name", "value")
@cache.write("name", 1, raw: true)
@cache.read("foo")
@cache.read_multi("foo", "bar")
assert_equal({ "foo" => nil, "bar" => nil }, @cache.read_multi("foo", "bar"))
Time.stub(:now, Time.now + 1.minute) do
@cache.write(1, "aaaaaaaaaa") && sleep(0.001)
@cache.write(2, "bbbbbbbbbb") && sleep(0.001)
@cache.write(3, "cccccccccc") && sleep(0.001)
@cache.write(4, "dddddddddd") && sleep(0.001)
@cache.write(5, "eeeeeeeeee") && sleep(0.001)
@cache.read(2) && sleep(0.001)
@cache.prune(@record_size * 3)
assert_not @cache.exist?(3), "no entry"
assert_not @cache.exist?(1), "no entry"
@cache.write(6, "ffffffffff") && sleep(0.001)
@cache.write(7, "gggggggggg") && sleep(0.001)
@cache.write(8, "hhhhhhhhhh") && sleep(0.001)
@cache.write(9, "iiiiiiiiii") && sleep(0.001)
@cache.write(10, "kkkkkkkkkk") && sleep(0.001)
@cache.read(4) && sleep(0.001)
assert_not @cache.exist?(6), "no entry"
assert_not @cache.exist?(5), "no entry"
long_key = "*" * 2 * @record_size
assert_not @cache.exist?(4), "no entry"
assert_not @cache.exist?(2), "no entry"
@cache.prune(30, 0.001)
item = { "foo" => "bar" }
key = "test_key"
item = "my_string"
@cache.write(1, nil)
def get(key, options = {})
@namespace = "test-#{Random.rand(16**32).to_s(16)}"
client(cache).stub(:flush_all, -> { stub_called = true; client.delete("#{@namespace}:#{key}") }) do
short_key = "a" * 250
long_key = "b" * 251
normalized_key = @cache.send(:normalize_key, short_key, { namespace: "ns" })
key_one = "d" * 1000 + "a"
key_two = "d" * 1000 + "b"
cache.write("foo", 2)
assert_equal "2", cache.read("foo")
assert_equal "1", @cache.read("foo", raw: true)
assert_equal "0", @cache.read("foo", raw: true)
cache.fetch("nil_foo") { nil }
assert_equal "bar", cache.fetch("nil_foo") { "bar" }
cache1.fetch("not_nil_foo") { nil }
assert_nil cache.fetch("not_nil_foo") { "bar" }
@cache.write("foo", "bar")
value = @cache.read("foo")
value << "bingo"
times: 0,
) do
cache.write("foo", val)
times: 1,
cache.write("foo", "bar", expires_in: 1, unless_exist: true)
host = "custom_host"
@cache.instance_variable_get(:@data).with { |c| c.set(@cache.send(:normalize_key, key, nil), "value", 0, compress: false) }
assert_equal "value", @cache.fetch(key) { "value" }
@cache.instance_variable_get(:@data).with { |c| c.set(@cache.send(:normalize_key, key, nil), false, 0, compress: false) }
@cache.instance_variable_get(:@data).with { |c| c.set(@cache.send(:normalize_key, key, nil), nil, 0, compress: false) }
(0...length).map { (65 + rand(26)).chr }.join
@old_store.write("foo", "bar")
assert_equal "bar", @cache.read("foo")
assert_equal "bar", @old_store.read("foo")
cache_dir = options.delete(:cache_dir) { @cache_dir }
@cache_dir = Dir.mktmpdir("file-store-")
keep = File.join(cache_dir, ".keep")
@cache.write("%" * 870, 1)
assert_equal 1, @cache.read("%" * 870)
key = @cache.send(:normalize_key, "views/index?id=1", {})
key = @cache_with_pathname.send(:normalize_key, "views/index?id=1", {})
path = @cache.send(:normalize_key, key, {})
assert File.basename(tmpname + ".lock").length <= 255, "Temp filename too long: #{File.basename(tmpname + '.lock').length}"
File.stub(:exist?, -> { raise StandardError.new("failed") }) do
@cache.send(:read_entry, "winston", **{})
@cache.write("foo", "bar", expires_in: 10)
@cache.write("baz", "qux")
@cache.write("quux", "corge", expires_in: 20)
Time.stub(:now, time + 15) do
assert_equal 2, Dir.glob(File.join(cache_dir, "**")).size
File.atomic_write(cache_file_path, cache_dir) { |f| Marshal.dump({ "foo": "bar" }, f) }
assert_equal 1, Dir.glob(File.join(cache_dir, "**")).size
middleware = Middleware.new("<3", key).new(->(env) {
_, _, body = middleware.call({})
body.each { }
assert_throws(:warden) { middleware.call({}) }
test_val = "tester"
proc = lambda { test_val }
@cache.fetch("foo") { "bar" }
@cache.fetch("foo", namespace: "string_namespace") { "bar" }
@cache.fetch("foo", namespace: proc) { "bar" }
@cache.mute { @cache.fetch("foo") { "bar" } }
key = +"foo"
old_values = {}
Time.stub(:now, Time.at(entry.expires_at + 1)) do
assert_equal({ type: value }, @cache.read(key))
@cache.delete_matched("*")
other_key = "#{prefix}#{SecureRandom.uuid}"
@cache.write(key, 1, raw: true)
@peek.write(key, 2, raw: true)
@peek.write(key, 3, raw: true)
@cache.fetch_multi(key, other_key) { |_key| true }
initial = +"bar"
initial << "baz"
@cache.fetch(key) { initial }
app = lambda { |env|
app.call({})
Time.stub(:now, time + 61) do
val = cache.fetch(key) { "1" }
fetched = cache.fetch_multi(key, other_key) { |k| "unavailable" }
cache.fetch_multi(key, other_key) { |k| "unavailable" }
assert @cache.write(key, "1", raw: true)
assert_equal "1", @cache.read(key, raw: true)
assert_equal "1", @cache.fetch(key, raw: true)
assert_equal "2", @cache.fetch(key, raw: true) { "2" }
key = (+"\xC3\xBCmlaut").force_encoding(Encoding::UTF_8)
cache = ActiveSupport::Cache.lookup_store(*store, { pool: { size: 2, timeout: 1 } }.merge(store_options))
def store_options; {}; end
@cache.fetch(key, version: 1) { value }
@cache.fetch(m1v1) { value }
second_fetch_values = @cache.fetch_multi(m1v1, m2v2) { |m| m.cache_key + " 2nd" }
assert_equal({ m1v1 => "#{model_name}/1", m2v1 => "#{model_name}/2" }, first_fetch_values)
assert_equal({ m1v1 => "#{model_name}/1", m2v2 => "#{model_name}/2 2nd" }, second_fetch_values)
@store.write("foo", "bar")
@store.read("foo")
@store.write_multi({ "foo" => "bar", "egg" => "spam" })
@store.read_multi("foo", "egg")
@cache.write(key, "baz")
assert_equal "bar", @cache.fetch(key) { "baz" }
assert_equal "baz", @cache.fetch(key) { "baz" }
assert_equal 10, @cache.fetch(key) { |key| cache_miss = true; key.length }
version: "v42",
@cache.fetch(key, force: true) { "bar" }
assert_nil @cache.fetch(key) { "baz" }
assert_nil @cache.fetch(key, skip_nil: true) { nil }
assert_equal "foo_bar", @cache.fetch(key, force: true) { "foo_bar" }
assert @cache.write(key, a: "b")
assert_equal({ a: "b" }, @cache.read(key))
@cache.write(other_key, "baz")
assert_equal({ key => "bar", other_key => "baz" }, @cache.read_multi(key, other_key))
@cache.write(key, "bar", expires_in: 10)
Time.stub(:now, time + 11) do
@cache.write(other_key, "biz")
values = @cache.fetch_multi(key, other_key, third_key) { |value| value * 2 }
assert_equal({ key => "bar", other_key => "biz", third_key => (third_key * 2) }, values)
assert_equal((third_key * 2), @cache.read(third_key))
values = @cache.fetch_multi(key, third_key, other_key, expires_in: nil) { |value| value * 2 }
assert_equal({ key => "bar", third_key => (third_key * 2), other_key => "biz" }, values)
foo = cache_struct.new(key, "FOO!")
@cache.write(other_key, "BAM!")
values = @cache.fetch_multi(foo, bar) { |object| object.title }
assert_equal({ foo => "FOO!", bar => "BAM!" }, values)
@cache.write(key, "BAM")
values = @cache.fetch_multi(other_key, third_key, key) { |key| key.upcase }
values = @cache.fetch_multi(key, other_key, force: true) { |value| value * 2 }
assert_equal({ key => (key * 2), other_key => (other_key * 2) }, values)
assert_equal(key * 2, @cache.read(key))
values = @cache.fetch_multi(key, other_key, skip_nil: true) { |k| k == key ? k : nil }
assert_equal({ key => key, other_key => nil }, values)
@cache.write(klass.new(key), "bar")
assert_equal "bar", @cache.read("#{key}/foo")
@cache.write({ key => 1, other_key => 2 }, "bar")
assert_equal "bar", @cache.read({ key => 1, other_key => 2 })
bar = +"bar"
assert_nothing_raised { bar.gsub!(/.*/, "baz") }
time = Time.local(2008, 4, 24)
@cache.write(key, "bar", expires_in: 1.minute)
Time.stub(:now, time + 30) do
Time.stub(:now, time + 1.minute + 1.second) do
Time.stub(:now, time + 2.minute + 1.second) do
@cache.write(key, "bar", expires_at: time + 15.seconds)
Time.stub(:now, time + 10) do
@cache.write(key, "bar", expire_in: 20)
Time.stub(:now, time + 21) do
@cache.write(key, "bar", expired_in: 20)
@cache.write(key, "bar", expire_in: 60, expires_at: 1.minute.from_now)
@cache.write(key, "bar", expires_in: -60)
time = @cache.send(:read_entry, @cache.send(:normalize_key, key, {}), **{}).expires_at
Time.stub(:now, Time.at(time)) do
@cache.write(key, "bar", expires_in: 60)
Time.stub(:now, time + 71) do
Time.stub(:now, time + 91) do
@cache.write(key, "foo", expires_in: 60)
assert_equal({ key => "baz", other_key => "bar" }, result)
absurd_key = "#/:*(<+=> )&$%@?;'\"\'`~-"
assert_equal "2", @cache.fetch(absurd_key, raw: true) { "2" }
assert_nil @cache.read("#{key}x")
assert_equal({ key => "bar" }, @cache.read_multi(key))
assert @cache.fetch(key, raw: true) { }
actual_entry = @cache.send(:read_entry, @cache.send(:normalize_key, actual, {}), **{})
uncompressed_entry = @cache.send(:read_entry, @cache.send(:normalize_key, uncompressed, {}), **{})
@cache.fetch_multi "a", "b", "c" do |key|
writes = { key_1 => value_1, key_2 => value_2 }
@cache.fetch_multi(key_2, key_1) { |key| key * 2 }
@cache.fetch_multi() { |key| key * 2 }
@cache.write(key, 3, raw: true)
@cache.write("fu", "baz")
@cache.write("foo/bar", "baz")
@cache.write("fu/baz", "bar")
assert @cache.exist?("fu")
assert @cache.exist?("fu/baz")
@logger = @log1
logger << "foo"
@local_level = ::Logger::DEBUG
add(::Logger::INFO, message, &block)
add(::Logger::WARN, message, &block)
def <<(x)
@chevrons << x
def each(&block); @lines.each(&block); end
def write(x); @lines << x; end
def empty?; @lines.empty?; end
benchmark { i_was_run = true }
benchmark("test_run") { i_was_run = true }
benchmark("included_debug_run", level: :debug) { }
benchmark("skipped_debug_run", level: :debug) { }
assert_match(/^#{message} \(.*\)$/, buffer.last)
assert @array_inquirer.any? { |v| v == :mobile }
assert_not @array_inquirer.any? { |v| v == :desktop }
(name == :foo) || super
data = StringIO.new(data || "")
texts = +""
element.texts.each { |t| texts << t.value }
attributes = {}
@hash = {}
def to_hash(hash = {})
node_hash = {}
elsif c.text? || c.cdata?
@hash = @hash_stack.pop
def on_start_element(name, attrs = {})
raise "Document too deep!" if depth == 0
(0...child_nodes.length).each do |i|
attribute_hash = {}
(0...attributes.length).each do |i|
text = +""
if String === number
if value.is_a?(::Method) || value.is_a?(::Proc)
if value.arity == 1
type_name ||= value.class.name if value && !value.respond_to?(:to_str)
def rename_key(key, options = {})
sign = (seconds < 0 ? "-" : "+")
minutes = (seconds.abs % 3600) / 60
arg *= 3600 if arg.abs <= 13
all.find { |z| z.utc_offset == arg.to_i }
def clear # :nodoc:
@zones = nil
@zones_map = nil
@zones_map ||= MAPPING.each_with_object({}) do |(name, _), zones|
def <=>(zone)
result = (utc_offset <=> zone.utc_offset)
result = (name <=> zone.name) if result == 0
def =~(re)
time = Time.utc(*args)
def at(*args)
if parts.key?(:yday)
time = Time.new(
parts.fetch(:hour, 0),
parts.fetch(:min, 0),
parts.fetch(:sec, 0) + parts.fetch(:sec_fraction, 0),
def parse(str, now = now())
parts.fetch(:sec) + parts.fetch(:sec_fraction, 0),
def strptime(str, format, now = now())
today + 1
today - 1
t : Time.utc(t.year, t.month, t.day, t.hour, t.min, t.sec, t.sec_fraction * 1_000_000)
def init_with(coder) # :nodoc:
coder.tag = "!ruby/object:#{self.class}"
coder.map = { "name" => tzinfo.name }
@period ||= time_zone.period_for_utc(@utc)
def in_time_zone(new_zone = ::Time.zone)
zone == "UTC" || zone == "UCT"
alias_method :gmt?, :utc?
%(#{time.strftime("%Y/%m/%d %H:%M:%S")} #{formatted_offset(false)})
coder.map = { "utc" => utc, "zone" => time_zone, "time" => time }
if format == :db
utc <=> other
alias_method :before?, :<
alias_method :after?, :>
alias_method :since, :+
alias_method :in, :+
def -(other)
result = utc.acts_like?(:date) ? utc.ago(other) : utc - other rescue utc.ago(other)
new_zone ||= time_zone
klass == ::Time || super
alias_method :kind_of?, :is_a?
def method_missing(...)
wrap_with_time_zone time.__send__(...)
@time += 1.hour
return time if time.instance_of?(::Time) && time.utc?
new_name = "__simple_stub__#{method_name}"
if date_or_time.is_a?(Date) && !date_or_time.is_a?(DateTime)
stubs.stub_object(Time, :now) { at(now) }
stubs.stub_object(Time, :new) do |*args, **options|
stubs.stub_object(Date, :today) { jd(now.to_date.jd) }
heading = "#{self.class}: #{name}"
divider = "-" * heading.size
@tagged_logger ||= (defined?(Rails.logger) && Rails.logger)
def warn(message, *)
stream_io = eval("$#{stream}", binding, __FILE__, __LINE__)
@size = size
def <<(work)
set_process_title("#{klass}##{method}")
def <<(o)
@queue << o
if test = @queue.pop
@@after_fork_hooks << blk
@@run_cleanup_hooks << blk
object.stub(method_name, proc { times_called += 1; returns }, &block)
error = "Expected #{method_name} to be called #{times} times, " \
error = "#{message}.\n#{error}" if message
klass.define_method("stubbed_#{method_name}") do |*|
failures.map! { |e|
test_opts = "-n#{self.class.name}##{name}"
$-I.each do |p|
load_path_args << "-I"
msg = "the directory '%s' does not contain a file named '%s'"
recorders.delete_if { |r| reports.equal?(r) }
elsif (report = reports.find { |r| error_class === r.error })
assert warnings.any? { |w| match.match?(w) }, "No deprecation warning matched #{match}: #{warnings.join(', ')}"
test_name = "test_#{name.gsub(/\s+/, '_')}".to_sym
names = test_name.split "::"
names.last.sub!(/Test$/, "")
message ||= "Expected #{mu_pp(object)} to be nil or false"
error = super(*exp, &block)
yield.tap { assert(true) }
exps = expressions.keys.map { |e|
e.respond_to?(:call) ? e : lambda { eval(e, block.binding) }
before = exps.map(&:call)
exp = expression.respond_to?(:call) ? expression : -> { eval(expression.to_s, block.binding) }
error = "#{error}. It was already #{to}" if before == to
error = "Expected change to #{to}, got #{after}\n"
assert to === after, error
warning = <<~MSG
def pop_tags(count = 1)
tags.reject!(&:blank?)
elsif @tags.size == 1
def spot(_)
@ex = ex
super(@ex.__getobj__)
file, line = trace.match(/^(.+?):(\d+).*$/, &:captures) || trace
__getobj__.to_s.split("\n")
method_name.end_with?("?") || super
if method_name.end_with?("?")
l = a.unpack "C#{a.bytesize}"
res = 0
b.each_byte { |byte| res |= byte ^ l.shift }
res == 0
key = if klass.is_a?(Module) && klass.respond_to?(:===)
if method.arity == 0
-> e { method.call }
-> e { object.instance_exec(&rescuer) }
-> e { object.instance_exec(e, &rescuer) }
to_run(:after) { self.class.prepare! }
def self.run!(reset: false) # :nodoc:
def self.check! # :nodoc:
def run! # :nodoc:
def class_unload!(&block) # :nodoc:
def complete! # :nodoc:
if k == "disable_to_s_conversion"
k = "#{k}="
undef_method :==
::Object.send(:raise, *args)
pattern.is_a?(Regexp) ? pattern : "(?i:#{Regexp.escape pattern.to_s})"
deep_patterns = patterns.extract! { |pattern| pattern.to_s.include?("\\.") }
@mask = mask
@blocks = nil
if item.to_s.include?("\\.")
@regexps << item
if s.include?("\\.")
strings << s
full_key = full_parent_key ? "#{full_parent_key}.#{key}" : key.to_s
if @regexps.any? { |r| r.match?(key.to_s) }
value = @mask
elsif @deep_regexps&.any? { |r| r.match?(full_key) }
value = value.map { |v| value_for_key(key, v, full_parent_key, original_params) }
@blocks.each { |b| b.arity == 2 ? b.call(key, value) : b.call(key, value, original_params) }
if name_string.chomp!("=")
bangs = name_string.chomp!("!")
super() { |h, k| parent._get(k) }
class OrderedHash < ::Hash # :nodoc:
coder.represent_seq "!omap", map { |k, v| { k => v } }
dup.tap { |hash| hash.select!(*args, &block) }
dup.tap { |hash| hash.reject!(*args, &block) }
undef_method(method) unless method.start_with?("__", "instance_eval", "class", "object_id")
if arguments.size == 1 && arguments.first.is_a?(Proc)
arguments << lambda { |*args| @options.deep_merge(proc.call(*args)) }
@context.__send__(method, *arguments, **options, &block)
@context.__send__(method, *arguments, &block)
s = rounded_number.to_s("F")
a, b = s.split(".", 2)
b << "0" * precision
a << "."
default_pattern = /(\d{1,3})(\d{3})(\d{4}$)/
default_pattern = /(\d{0,3})(\d{3})(\d{4})$/
code.blank? ? "" : "+#{code}#{delimiter}"
ext.blank? ? "" : " x #{ext}"
conversion_format.gsub("%n", number_to_format).gsub("%u", unit)
exp = (Math.log(number) / Math.log(base)).to_i
-1 => :deci, -2 => :centi, -3 => :mili, -6 => :micro, -9 => :nano, -12 => :pico, -15 => :femto }
@number = number / (10**exponent)
format.gsub("%n", rounded_number).gsub("%u", unit).strip
exponent = number != 0 ? Math.log10(number.abs).floor : 0
unit_exponents(units).find { |e| exponent >= e } || 0
left, right = number.to_s.split(".")
@options ||= begin
separator: ".",
delimiter: ",",
format: "%u%n",
negative_format: "-%u%n",
unit: "$",
delimiter: "",
format: "%n%"
delimiter: ""
byte: "Bytes",
unit: "",
@id = id
def new_event(name, payload = {}) # :nodoc:
Event.new(name, nil, nil, @id, payload)
@cpu_time_start = 0.0
@cpu_time_finish = 0.0
@time = now
@end = now
diff > 0.0 ? diff : 0.0
def parent_of?(event) # :nodoc:
start = (time - event.time) * 1000
start <= 0 && (start + duration >= event.duration)
def clear_cache(key = nil) # :nodoc:
each do |s|
def groups_for(name) # :nodoc:
group.start(@name, @id, @payload)
all_listeners_for(name).reject { |s| s.silenced?(name) }
all_listeners_for(name).any? { |s| !s.silenced?(name) }
exclusions << -name if pattern === name
def ===(name)
pattern === name && !exclusions.include?(name)
pattern === name
delegate :<=>, :=~, :match?, :acts_like_string?, to: :wrapped_string
result = @wrapped_string.__send__(method, *args, &block)
if method.end_with?("!")
@wrapped_string.split(*args).map { |i| self.class.new(i) }
chars(downcase.to_s.gsub(/\b('?\S)/u) { $1.upcase })
def as_json(options = nil) # :nodoc:
define_method("#{method}!") do |*args|
super(*args, **options)
@args = args
self.class.new(*args, *@args.drop(args.length), **@options, **options)
@codecs = {}
@rotate_options << (block || options)
filter_map { |type, name| name if type == :key || type == :keyreq }
rotate_options.map { |options| build(salt.to_s, **options) }.reduce(&:fall_back_to)
@signed << args
has_metadata = metadata.any? { |k, v| v }
data = wrap_in_metadata_envelope({ "data" => data }, **metadata) if has_metadata
elsif expected_metadata.none? { |k, v| v }
{ "_rails" => hash }
object.is_a?(Hash) && object.key?("_rails")
string.start_with?('{"_rails":{"message":')
@url_safe = url_safe
error = as.new(error.to_s) if as
@digest = digest&.to_s || "SHA1"
@verifier = if !@aead_mode
cipher.auth_data = "" if aead_mode?
cipher.auth_data = ""
parts.map! { |part| encode(part) }.join(SEPARATOR)
parts.reverse!.map! { |part| decode(part) }
@local_level_key ||= :"logger_thread_safe_level_#{object_id}"
silencer ? log_at(severity) { yield self } : yield(self)
sources.any? { |source| source == logger_source }
define_method(:add) do |*args, &block|
define_method(:<<) do |x|
logger << x
@flush_count = 0
@flush_count += 1
@logger ||= if defined?(Rails) && Rails.respond_to?(:logger)
def attach_to(...) # :nodoc:
subscriber.event_levels = log_levels.transform_keys { |k| "#{k}.#{namespace}" }
@event_levels = {}
def #{level}(progname = nil, &block)
def color(text, color, mode_options = {}) # :doc:
in Rails 7.2. Use an option hash instead (eg. `color("my text", :red, bold: true)`).
options = { bold: options }
logger.error "Could not log #{name.inspect} event. #{e.class}: #{e.message} #{e.backtrace}"
en: {
nth: {
when 1; "st"
when 2; "nd"
when 3; "rd"
when 4, 5, 6, 7, 8, 9, 10, 11, 12, 13; "th"
num_modulo %= 10 if num_modulo > 13
def on_load(name, options = {}, &block)
@options = options || {}
s = super
value.each do |k, v|
value.map { |v| jsonify(v) }
data.map! { |d| convert_dates_from(d) }
@scope =
if separator == "-"
re_leading_trailing_separator = /^-|-$/i
re_leading_trailing_separator = /^#{re_sep}|#{re_sep}$/i
word = $2
$1 ? "::#{substituted}" : substituted
word = camel_cased_word.to_s.gsub("::", "/")
word.gsub!(inflections.acronyms_underscore_regex) { "#{$1 && '_' }#{$2.downcase}" }
word.tr!("-", "_")
result.tr!("_", " ")
result.sub!(/\A\w/) do |match|
camelize(singularize(table_name.to_s.sub(/.*\./, "")))
underscored_word.tr("_", "-")
path = path.to_s
if i = path.rindex("::")
raise if e.name && !(camel_cased_word.to_s.split("::").include?(e.name.to_s) ||
e.name.to_s == camel_cased_word.to_s)
parts = camel_cased_word.split("::")
part.empty? ? acc : "#{part}(::#{acc})?"
@__instance__ = Concurrent::Map.new
def <<(*word)
@regex_array += words.map { |word| to_regex(word) }
@regex_array.any? { |regex| regex.match? str }
/\b#{::Regexp.escape(string)}\Z/i
plural(/(#{s0})#{srest}$/i, '\1' + prest)
plural(/(#{p0})#{prest}$/i, '\1' + prest)
singular(/(#{s0})#{srest}$/i, '\1' + srest)
singular(/(#{p0})#{prest}$/i, '\1' + srest)
plural(/#{s0.downcase}(?i)#{srest}$/, p0.downcase + prest)
plural(/#{p0.downcase}(?i)#{prest}$/, p0.downcase + prest)
singular(/#{s0.downcase}(?i)#{srest}$/, s0.downcase + srest)
singular(/#{p0.downcase}(?i)#{prest}$/, s0.downcase + srest)
def clear(scope = :all)
@acronyms = {}
inflect.plural(/s$/i, "s")
inflect.plural(/^(ax|test)is$/i, '\1es')
inflect.plural(/(octop|vir)us$/i, '\1i')
inflect.plural(/(octop|vir)i$/i, '\1i')
inflect.plural(/(alias|status)$/i, '\1es')
inflect.plural(/(bu)s$/i, '\1ses')
inflect.plural(/(buffal|tomat)o$/i, '\1oes')
inflect.plural(/sis$/i, "ses")
inflect.plural(/(hive)$/i, '\1s')
inflect.plural(/(x|ch|ss|sh)$/i, '\1es')
inflect.plural(/(matr|vert|ind)(?:ix|ex)$/i, '\1ices')
inflect.plural(/^(m|l)ouse$/i, '\1ice')
inflect.plural(/^(m|l)ice$/i, '\1ice')
inflect.plural(/^(ox)$/i, '\1en')
inflect.plural(/^(oxen)$/i, '\1')
inflect.singular(/s$/i, "")
inflect.singular(/(ss)$/i, '\1')
inflect.singular(/(n)ews$/i, '\1ews')
inflect.singular(/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)(sis|ses)$/i, '\1sis')
inflect.singular(/(^analy)(sis|ses)$/i, '\1sis')
inflect.singular(/(hive)s$/i, '\1')
inflect.singular(/(tive)s$/i, '\1')
inflect.singular(/(s)eries$/i, '\1eries')
inflect.singular(/(m)ovies$/i, '\1ovie')
inflect.singular(/(x|ch|ss|sh)es$/i, '\1')
inflect.singular(/^(m|l)ice$/i, '\1ouse')
inflect.singular(/(bus)(es)?$/i, '\1')
inflect.singular(/(o)es$/i, '\1')
inflect.singular(/(shoe)s$/i, '\1')
inflect.singular(/(cris|test)(is|es)$/i, '\1is')
inflect.singular(/(octop|vir)(us|i)$/i, '\1us')
inflect.singular(/(alias|status)(es)?$/i, '\1')
inflect.singular(/^(ox)en/i, '\1')
inflect.singular(/(vert|ind)ices$/i, '\1ex')
inflect.singular(/(matr)ices$/i, '\1ix')
inflect.singular(/(quiz)zes$/i, '\1')
I18n.public_send("#{setting}=", value)
I18n.load_path.keep_if { |p| File.exist?(p) }
args = \
I18n.load_path << File.expand_path("locale/en.yml", __dir__)
I18n.load_path << File.expand_path("locale/en.rb", __dir__)
/(?:_|\b)html\z/.match?(key)
unless i18n_option?(name) || (name == :count && value.is_a?(Numeric))
def default(key = (no_key = true))
keys.map! { |key| convert_key(key) }
indices.map! { |key| convert_key(key) }
dup.tap { |hash| hash.transform_values!(&block) }
dup.tap { |h| h.transform_keys!(hash, &block) }
dup.tap(&:compact!)
_new_hash = Hash.new
each do |key, value|
key.kind_of?(Symbol) ? key.name : key
key.kind_of?(Symbol) ? key.to_s : key
if block && key?(key)
if pid == 0
def fork(...)
if @pid != new_pid
@pid = new_pid
if Process.respond_to?(:_fork) # Ruby 3.1+
def initialize(files, dirs = {}, &block)
all = @files.select { |f| File.exist?(f) }
@updated_at || max_mtime(paths) || Time.at(0)
globs = hash.map do |key, value|
key.gsub(",", '\,')
def run(...)
Null = Object.new # :nodoc:
def self.to_run(*args, &block)
set_callback(:run, *args, &block)
RunHook = Struct.new(:hook) do # :nodoc:
@active_key ||= :"active_execution_wrapper_#{object_id}"
def self.active? # :nodoc:
def run # :nodoc:
@_hook_state ||= {}
@core = Core.new(files, dirs)
@files = files.map { |file| Pathname(file).expand_path }.to_set
@dirs = dirs.each_with_object({}) do |(dir, exts), hash|
@listener = @dtw.any? ? Listen.to(*@dtw, &method(:changed)) : nil
@missing.any?(&:exist?)
@updated.make_true if (modified + added + removed).any? { |f| watching?(f) }
elsif dir == @common_path || dir.root?
dtw = @dirs.keys | @files.map(&:dirname)
accounted_for = dtw.to_set + Gem.path.map { |path| Pathname(path) }
dtw.reject { |dir| dir.ascend.drop(1).any? { |parent| accounted_for.include?(parent) } }
paths.map { |path| path.ascend.to_a }.reduce(&:&)&.first
@subscribers.delete_if { |s| subscriber === s }
def set_context(...)
unless disabled_subscribers&.any? { |s| s === subscriber }
instance_variable_set :"@#{default}", env == default
def #{env}?
@#{env}
if !key.nil? && content_path.exist?
tmp_file = "#{Process.pid}.#{content_path.basename.to_s.chomp('.enc')}"
super "Invalid YAML in '#{content_path}'."
@config = nil
def validate! # :nodoc:
hash.each do |k, v|
config.presence || {}
output = +"P"
time = +""
output << "T#{time}" unless time.empty?
parts = @duration.parts.each_with_object(Hash.new(0)) do |(k, v), p|
sprintf("%0.0#{@precision}f", seconds)
DATE_TO_PART = { "Y" => :years, "M" => :months, "W" => :weeks, "D" => :days }
TIME_TO_PART = { "H" => :hours, "M" => :minutes, "S" => :seconds }
@parts = {}
@mode = :start
@sign = 1
self.sign = (scanner.matched == "-") ? -1 : 1
fractions = parts.values.reject(&:zero?).select { |a| (a % 1) != 0 }
unless fractions.empty? || (fractions.size == 1 && fractions.last == @parts.values.reject(&:zero?).last)
delegate :to_i, :to_f, :to_s, to: :value
def -@
if Scalar === other || Duration === other
value <=> other
calculate(:+, other)
calculate(:-, other)
calculate(:*, other)
def /(other)
calculate(:/, other)
def %(other)
calculate(:%, other)
def variable? # :nodoc:
if Scalar === other
def ===(other) # :nodoc:
new(value, { seconds: value }, false)
def hours(value) # :nodoc:
def days(value) # :nodoc:
def weeks(value) # :nodoc:
def years(value) # :nodoc:
parts = {}
remainder_sign = value <=> 0
parts.inject(0) do |total, (part, value)|
@value, @parts = value, parts
@parts.reject! { |k, v| v.zero? } unless value == 0
@variable = @parts.any? { |part, _| VARIABLE_PARTS.include?(part) }
seconds = @parts.fetch(:seconds, 0) + other
self + (-other)
if Duration === other || Scalar === other
def -@ # :nodoc:
def +@ # :nodoc:
def is_a?(klass) # :nodoc:
Duration == klass || value.is_a?(klass)
alias :kind_of? :is_a?
def instance_of?(klass) # :nodoc:
Duration === other && other.value.eql?(value)
sum(1, time)
def ago(time = ::Time.current)
sum(-1, time)
coder.map = { "value" => @value, "parts" => @parts }
def _parts # :nodoc:
def sum(sign, time = ::Time.current)
unless time.acts_like?(:time) || time.acts_like?(:date)
@parts.inject(time) do |t, (type, number)|
if type == :seconds
t.since(sign * number * 60)
elsif type == :hours
t.since(sign * number * 3600)
t.advance(type => sign * number)
def <<(object)
def reject!(classes) # :nodoc:
def <<(klass)
@refs.reject! do |ref|
yield ref.__getobj__
@refs.delete_if { |ref| !ref.weakref_alive? }
when String then "#{warning} (#{message})"
} || callstack.first
if md = offending_line.match(/^(.+?):(\d+)(?::in `(.*?)')?/)
instance_methods.each { |m| undef_method m unless /^__|^object_id$/.match?(m) }
target.__send__(called, *args, &block)
@var = var
@instance.__send__(@method)
@deprecator.warn("#{@var} is deprecated! Call #{@method}.#{called} instead of #{@var}.#{called}. Args: #{args.inspect}", callstack)
def self.new(*args, **options, &block)
mod = nil
mod ||= Module.new
@options = {}
@deprecators = {}
each { |deprecator| deprecator.public_send("#{name}=", value) }
silence: ->(message, callstack, deprecator) { },
when -2..3
def raw_state(&block) # :nodoc:
@_under_path = nil
@_at_path = nil
@_under_path, old_path = path, @_under_path
@_under_path = old_path
@_at_path, old_path = path, @_at_path
@_at_path = old_path
relpath += ".rb" unless relpath.end_with?(".rb")
batch <<
def reset_all # :nodoc:
def clear_all # :nodoc:
send(name, *args, &block)
@attributes = {}
self.attributes = {}
new_attributes.each { |key, value| public_send("#{key}=", value) }
keys.index_with { |key| public_send(key) }
old_zone, ::Time.zone = ::Time.zone, new_zone
::Time.zone = old_zone
db: "%Y-%m-%d %H:%M:%S",
inspect: "%Y-%m-%d %H:%M:%S.%9N %z",
number: "%Y%m%d%H%M%S",
time: "%H:%M",
short: "%d %b %H:%M",
long: "%B %d, %Y %H:%M",
time.strftime("%B #{day_format}, %Y %H:%M")
rfc822: lambda { |time|
time.strftime("%a, %d %b %Y %H:%M:%S #{offset_format}")
def ===(other)
super || (self == Time && other.is_a?(ActiveSupport::TimeWithZone))
if month == 2 && ::Date.gregorian_leap?(year)
days_in_month(2, year) + 337
::Time.zone ? ::Time.zone.now : ::Time.now
return at_without_coercion(*args, **kwargs) if args.size != 1 || !kwargs.empty?
to_i - change(hour: 0).to_i + (usec / 1.0e+6)
end_of_day.to_i - to_i
::Time.new(new_year, new_month, new_day, new_hour, new_min, new_sec, new_offset)
::Time.utc(new_year, new_month, new_day, new_hour, new_min, new_sec)
new_time = ::Time.new(new_year, new_month, new_day, new_hour, new_min, new_sec, zone)
::Time.local(new_sec, new_min, new_hour, new_day, new_month, new_year, nil, nil, isdst, nil)
::Time.new(new_year, new_month, new_day, new_hour, new_min, new_sec, utc_offset)
options.fetch(:minutes, 0) * 60 +
hour: 23,
min: 59,
sec: 59,
def prev_day(days = 1)
def next_day(days = 1)
def in_time_zone(zone = ::Time.zone)
def *(_)
def %(args)
(!html_safe? || arg.html_safe?) ? arg : CGI.escapeHTML(arg.to_s)
if !html_safe? || arg.html_safe?
block.binding.eval("proc { |m| $~ = m }").call(match_data)
def pluralize(count = nil, locale = :en)
if count == 1
re = indent_empty_lines ? /^/ : /^(?!$)/
dup.tap { |_| _.indent!(amount, indent_string, indent_empty_lines) }
gsub! pattern, ""
stop = \
omission ||= ""
if self =~ /\A((?>.+?#{sep}){#{words_count - 1}}.+?)#{sep}.*/m
def to_time(form = :local)
parts.fetch(:offset, form == :utc ? 0 : nil)
form == :utc ? time.utc : time.to_time
def first(limit = 1)
def last(limit = 1)
def self.base58(n = 16)
idx = byte % 64
def self.base36(n = 16)
other.begin == self.begin || cover?(other.begin) || other.cover?(self.begin)
def step(n = 1, &block)
db: -> (start, stop) do
def ===(value)
if value.is_a?(::Range)
is_backwards_op = value.exclude_end? ? :>= : :>
operator = exclude_end? && !value.exclude_end? ? :< : :<=
value_max = !exclude_end? && value.exclude_end? ? value.max : value.last
public_send("#{key}=", value)
public_send("#{key}=", old_value)
def try(*args, &block)
if args.empty? && block_given?
if block.arity == 0
def try!(*args, &block)
def try(*)
def try!(*)
collect(&:to_param).join "/"
collect { |value| value.to_query(prefix) }.join "&"
unless (value.is_a?(Hash) || value.is_a?(Array)) && value.empty?
query.join("&")
if options.is_a?(::JSON::State)
class Data # :nodoc:
finite? ? self : nil
finite? ? to_s : nil
map { |v| options ? v.as_json(options.dup) : v.as_json }
subset.each do |k, v|
%(#{strftime("%Y/%m/%d %H:%M:%S")} #{formatted_offset(false)})
strftime("%Y-%m-%d")
strftime("%Y/%m/%d")
strftime("%Y/%m/%d %H:%M:%S %z")
variables.map! { |s| s.to_s.freeze }
in?(another_object) ? self : nil
map(&:deep_dup)
hash = dup
if ::String === key || ::Symbol === key
respond_to?(:empty?) ? !!empty? : !self
empty? ||
class Time # :nodoc:
respond_to? :"acts_like_#{duck}?"
def to_fs(format = nil, options = nil)
parts = module_parent_name.split("::")
method_name = prefix ? "#{method_prefix}#{method}" : method
if to.is_a?(Module)
defn = parameters.filter_map { |type, arg| arg if type == :req }
defn << "&block" if parameters.last&.first == :block
defn.join(", ")
method_def <<
module_eval(method_def.join(";"), file, line)
return false if name == :marshal_dump || name == :_dump
if #{target}.nil?
if #{allow_nil == true}
__send__(method, concern(topic, &block))
def self.#{sym}
@__thread_mattr_#{sym} ||= "attr_#{sym}_\#{object_id}"
def #{sym}
def self.#{sym}=(obj)
def #{sym}=(obj)
self.class.#{sym} = obj
definition << "def self.#{sym}; @@#{sym}; end"
definition << "def #{sym}; @@#{sym}; end"
sym_default_value = (block_given? && default.nil?) ? yield : default
class_variable_set("@@#{sym}", sym_default_value) unless sym_default_value.nil? && class_variable_defined?("@@#{sym}")
definition << "def self.#{sym}=(val); @@#{sym} = val; end"
definition << "def #{sym}=(val); @@#{sym} = val; end"
attr_name, internal_name = "#{attr_name}=", "#{internal_name}=" if type == :writer
location.delete_suffix(".rb") == path.to_s.delete_suffix(".rb")
number == 0 ? self == 0 : self % number == 0
omit = slice(*self.keys - keys)
hash = slice(*keys)
transform_keys!(&:to_s)
each_key do |k|
raise ArgumentError.new("Unknown key: #{k.inspect}. Valid keys are: #{valid_keys.map(&:inspect).join(', ')}")
object.map { |e| _deep_transform_keys_in_object(e, &block) }
object.map! { |e| _deep_transform_keys_in_object!(e, &block) }
keys.each { |key| delete(key) }
object.map { |e| _deep_transform_values_in_object(e, &block) }
object.map! { |e| _deep_transform_values_in_object!(e, &block) }
if this_val.is_a?(Hash) && other_val.is_a?(Hash)
deep_to_h(@xml)
params.map { |v| normalize_keys(v) }
_, entries = Array.wrap(value.detect { |k, v| not v.is_a?(String) })
entries.collect { |v| deep_to_h(v) }
xml_value = value.transform_values { |v| deep_to_h(v) }
!nothing?(value) && !garbage?(value)
value.map! { |i| deep_to_h(i) }
Tempfile.open(".#{basename(file_name)}", temp_dir) do |temp_file|
def html_escape(s) # :nodoc:
s = s.to_s
name = name.to_s
start_re = /<%(?:={1,2}|-|\#|%)?/m
source.scan_until(/(?:#{start_re}|#{finish_re})/)
if source.scan(/(.*?)(?=#{finish_re}|\z)/m)
map(&key).min
map(&key).max
to_enum(:index_by) { size if respond_to?(:size) }
to_enum(:index_with) { size if respond_to?(:size) }
cnt = 0
any? do |element, *args|
cnt += 1 if yield element, *args
cnt > 1
any? { (cnt += 1) > 1 }
reject(&:blank?)
reject { |_k, v| v.blank? }
delete_if { |_k, v| v.blank? }
if block_given? || !(first.is_a?(Integer) && last.is_a?(Integer))
actual_last = exclude_end? ? (last - 1) : last
sum = initial_value || 0
sum + (actual_last - first + 1) * (actual_last + first) / 2
delete_if(&:blank?)
if hash_class == Digest::MD5 || hash_class == OpenSSL::Digest::MD5
match_data = namespace.match(/\A(\h{8})-(\h{4})-(\h{4})-(\h{4})-(\h{4})(\h{8})\z/)
match_data.captures.map { |s| s.to_i(16) }.pack("NnnnnN")
def self.civil_from_format(utc_or_local, year, month = 1, day = 1, hour = 0, min = 0, sec = 0)
if utc_or_local.to_sym == :local
offset = ::Time.local(year, month, day).utc_offset.to_r / 86400
(sec_fraction * 1_000_000).to_i
(sec_fraction * 1_000_000_000).to_i
(offset * 86400).to_i
::Time.zone ? ::Time.zone.now.to_datetime : ::Time.now.to_datetime
sec + (min * 60) + (hour * 3600)
utc = new_offset(0)
offset == 0
time = acts_like?(:time) ? self : nil
time || to_time
sunday: 0,
monday: 1,
friday: 5,
to_date == ::Date.current
first_quarter_month = month - (2 + month) % 3
last_quarter_month = month + (12 - month) % 3
(month / 3.0).ceil
(wday - start_day_number) % 7
from_now += 7 unless from_now > 0
ago += 7 unless ago > 0
other.change(hour: hour, min: min, sec: sec, nsec: try(:nsec))
short: "%d %b",
long: "%B %d, %Y",
db: "%Y-%m-%d",
inspect: "%Y-%m-%d",
number: "%Y%m%d",
date.strftime("%B #{day_format}, %Y") # => "April 25th, 2007"
rfc822: "%d %b %Y",
strftime("%a, %d %b %Y")
::Time.zone ? ::Time.zone.today : ::Date.today
d = self
::Date.new(
if other.is_a?(Time)
class Date # :nodoc:
k.singleton_class? || k == self
unless name.is_a?(Symbol) || name.is_a?(String)
defined?(@#{name}) ? @#{name} : self.class.#{name}
class_methods << <<~RUBY
attr_writer :#{name}
class_methods << "silence_redefinition_of_method def #{name}?; !!self.#{name}; end"
methods << "silence_redefinition_of_method def #{name}?; !!self.#{name}; end"
attrs.each { |name| public_send("#{name}=", default) }
def to_s(format = "F")
if number.to_i <= 0
padding = (number - size % number) % number
start = 0
length = division + (modulo > 0 && modulo > index ? 1 : 0)
last_group << fill_with if fill_with != false &&
modulo > 0 && length == division
def split(value = nil, &block)
arr = dup
while (idx = arr.index(&block))
while (idx = arr.index(value))
result << arr
def to_sentence(options = {})
words_connector: ", ",
two_words_connector: " and ",
last_word_connector: ", and "
+""
collect(&:id).join(",")
if first.class != Hash && all?(first.class)
if position >= 0
Dir.glob(File.expand_path("core_ext/*.rb", __dir__)).sort.each do |path|
YAML.unsafe_load(source, **options) || {}
YAML.load(source, **options) || {}
erb = ERB.new(@content).tap { |e| e.filename = @content_path }
keys.reject { |m| method_defined?(m) }.each do |key|
def #{key}; _get(#{key.inspect}); end
@_config ||= if respond_to?(:superclass) && superclass.respond_to?(:config)
reader, reader_line = "def #{name}; config.#{name}; end", __LINE__
writer, writer_line = "def #{name}=(value); config.#{name} = value; end", __LINE__
send("#{name}=", block_given? ? yield : default)
@_config = nil
def raw_state # :nodoc:
@cv = new_cond
@sharing = Hash.new(0)
@waiting = {}
@sleeping = {}
@waiting.any? { |t, (_, c)| t != Thread.current && !c.include?(purpose) }
@waiting.any? { |t, (p, _)| compatible.include?(p) && @waiting.all? { |t2, (_, c2)| t == t2 || c2.include?(p) } }
mon_try_enter ||
@owner = nil
@count -= 1
@methods = {}
as = as.to_sym
@cache.module_eval("# frozen_string_literal: true\n" + @sources.join(";"), path, line)
@line = line
method_set.apply(@owner, @path, @line - 1)
env.value = !env.halted && (!block_given? || yield)
if !halted && user_conditions.all? { |c| c.call(target, value) }
if user_conditions.all? { |c| c.call(target, value) }
if: @if.dup,
@kind == _kind && filter == _filter
@if.map { |c| CallTemplate.build(c, self).make_lambda } +
arg.halted || !@user_conditions.all? { |c| c.call(arg.target, arg.value) }
@before.each { |b| b.call(arg) }
@after.each { |a| a.call(arg) }
}.merge!(config)
@single_callbacks = {}
def each(&block); @chain.each(&block); end
callbacks.each { |c| append_one(c) }
callbacks.each { |c| prepend_one(c) }
@chain.delete_if { |c| callback.duplicates?(c) }
callback = chain.find { |c| c.matches?(type, filter) }
if callback && (options.key?(:if) || options.key?(:unless))
callbacks.each { |c| chain.delete(c) }
@app = nil
@data = {}
!!@data.delete(key)
def fetch_entry(key) # :nodoc:
def clear(options = nil) # :nodoc:
def cleanup(options = nil) # :nodoc:
def increment(name, amount = 1, options = nil) # :nodoc:
def decrement(name, amount = 1, options = nil) # :nodoc:
hit = true
def delete_entry(key, **)
gem "redis", ">= 4.0.1"
warn "The Redis cache store requires the redis gem, version 4.0.1 or later. Please add it to your Gemfile: `gem \"redis\", \">= 4.0.1\"`"
def build_redis(redis: nil, url: nil, **redis_options) # :nodoc:
if redis.is_a?(Proc)
urls.each { |u| dist.add_node url: u }
@redis ||= begin
cursor = "0"
end until cursor == "0"
redis.then { |c| c.flushdb }
redis.then { |c| c.info }
redis.then { |c| c.pipelined(&block) }
redis.then { |c| c.get(key) }
raw = options&.fetch(:raw, false)
keys = names.map { |name| normalize_key(name, options) }
redis.then { |c| c.mget(*keys) }
names.zip(values).each_with_object({}) do |(name, value), results|
if race_condition_ttl && expires_in && expires_in > 0 && !raw
modifiers = {}
redis.then { |c| c.set key, payload, **modifiers }
redis.then { |c| c.del key }
redis.then { |c| c.del(entries) }
if raw && !payload.nil?
super(entry, raw: raw, **options)
c = c.node_for(key) if c.is_a?(Redis::Distributed)
redis_version = redis.then { |c| c.info("server").fetch("redis_version") }
@supports_expire_nx = Gem::Version.new(redis_version) >= Gem::Version.new("7.0.0")
def read_entry(key, **s)
def write_entry(key, entry, **)
@cache_size = 0
keys = synchronize { @data.keys }
prune(@max_size * 0.75, @max_prune_time) if @cache_size > @max_size
rescue_error_with(nil) { @data.with { |c| c.flush_all } }
@data.with { |c| c.stats }
@data.with { |c| c.get(key, options) }
@data.with { |c| c.send(method, key, payload, expires_in, **options) }
raw_values = @data.with { |c| c.get_multi(keys_to_names.keys) }
rescue_error_with(false) { @data.with { |c| c.delete(key) } }
key = key.gsub(ESCAPE_KEY_CHARS) { |match| "%#{match.getbyte(0).to_s(16).upcase}" }
key_separator = ":hash:"
FileUtils.rm_r(root_dirs.collect { |f| File.join(cache_path, f) })
File.atomic_write(key, cache_path) { |f| f.write(payload) }
File.open(file_name, "r+") do |f|
Dir.each_child(dir) do |d|
name = File.join(dir, d)
num = num.to_i + amount
expanded_cache_key = namespace ? +"#{namespace}/" : +""
expanded_cache_key << "#{prefix}/"
raise "Could not find cache store adapter for #{store} (#{e})"
unless options.key?(:pool) || options.key?(:pool_size) || options.key?(:pool_timeout)
{}.tap do |pool_options|
@coder = @options.delete(:coder) { default_coder } || NullCoder
entries = hash.each_with_object({}) do |(name, value), memo|
reads = {}
names.map! { |key| normalize_key(key, options) }
def new_entry(value, options = nil) # :nodoc:
if source.start_with?("^")
entries.count { |key| delete_entry(key, **options) }
alias_key = aliases.detect { |key| options.key?(key) }
if key && key.encoding != Encoding::UTF_8
if key.size > 1
key.collect { |k, v| "#{k}=#{v}" }.sort!
if logger && logger.debug? && !silence?
logger.debug "Cache #{operation}: #{normalize_key(key, options)}#{options.blank? ? "" : " (#{options.inspect})"}"
payload = { key: key, store: self.class.name }
if (race_ttl > 0) && (Time.now.to_f - entry.expires_at <= race_ttl)
@created_at = 0.0
@expires_in = expires_at&.to_f || expires_in && (expires_in.to_f + Time.now.to_f)
@version && version && @version != version
@expires_in && @created_at + @expires_in <= Time.now.to_f
@expires_in ? @created_at + @expires_in : nil
@expires_in = value.to_f - @created_at
@s ||= Marshal.dump(@value).bytesize
if @value && !compressed? && !(@value.is_a?(Numeric) || @value == true || @value == false)
if @value.is_a?(String)
@value = @value.dup
gems_result = '\3 (\4) \5'
@filters.each do |f|
backtrace = backtrace.map { |line| f.call(line.to_s) }
@silencers.any? do |s|
name.end_with?("?") || super
if name.end_with?("?")
when ActionableError, -> it { Class === it && it < ActionableError }
ActiveStorage::Current.url_options = { protocol: "https://", host: "example.com", port: nil }
assert_dom_equal %(<video src="#{polymorphic_url @blob}" />), video_tag(@blob)
@user = User.create!(name: "DHH")
assert_dom_equal %(<img src="#{polymorphic_url @blob}" />), image_tag(@blob)
assert_dom_equal %(<img src="#{polymorphic_url variant}" />), image_tag(variant)
assert_dom_equal %(<img src="#{polymorphic_url preview}" />), image_tag(preview)
assert_dom_equal %(<audio src="#{polymorphic_url @blob}" />), audio_tag(@blob)
@service.delete_prefixed("#{key}/a/a/")
assert_not @service.exist?("#{key}/a/a/a")
assert_not @service.exist?("#{key}/a/a/b")
assert @service.exist?("#{key}/a/b/a")
@service.delete("#{key}/a/a/a")
@service.delete("#{key}/a/a/b")
@service.delete("#{key}/a/b/a")
data = %w(To get her)
Net::HTTP.start(uri.host, uri.port, use_ssl: true) do |http|
user = User.create! name: "DHH", avatar: blob
custom_metadata: { "foo" => "baz" },
assert_match(/#{@service.bucket.name}\/#{@key}/, url)
mirror_config = (1..3).to_h do |i|
service: "Disk",
headers.each do |k, v|
assert_match(/storage\.googleapis\.com\/.*\/#{@key}/, url)
tmp_config = { tmp: { service: "Disk", root: File.join(Dir.tmpdir, "active_storage") } }
assert_match(/^https:\/\/example.com\/rails\/active_storage\/disk\/.*$/,
assert_match(/^https:\/\/example.com\/rails\/active_storage\/disk\/.*\/avatar\.png$/,
assert_match(/^http:\/\/example.com:3001\/rails\/active_storage\/disk\/.*\/avatar\.png$/,
@service.root = tmp_config.dig(:tmp, :root)
tmp_config = {
assert_match(/^https:\/\/example.com\/rails\/active_storage\/disk\/.*\/avatar\.png/, url)
data = "Foobar"
assert_match(/.*\.blob\.core\.windows\.net\/.*\/#{@key}/, url)
user = User.create!(name: "Josh")
mock_upload = lambda do |_, _, options = {}|
blob.variant(saver: { "-write": "/tmp/file.erb" }).processed
blob.variant(saver: { "something": { "-write": "/tmp/file.erb" } }).processed
a = Admin.new(name: "DHH")
data = "First file"
data = "Hello world!"
name: "Nate",
avatar: {
blobs = 3.times.map { create_blob(data: "123", filename: "numbers.txt", content_type: "text/plain", identify: false) }
blobs = 3.times.map { create_blob(data: "123", filename: "numbers.txt", content_type: "text/plain", identify: false).dup }
test "image?" do
test "video?" do
test "text?" do
create_blob(data: "Hello, world!").tap do |blob|
assert_match(/\.jpg\z/, file.path)
kwargs = {
custom_metadata: { "test" => true }
blob.update!(metadata: { custom: { "test" => true } })
@user = User.create!(name: "Josh")
track_transaction_depth = ->(*) do
hash = { io: StringIO.new("STUFF"), filename: "town.jpg", content_type: "image/jpeg" }
@io ||= StringIO.new("")
@user.name = "Tina"
user = User.new(name: "John")
new_user = User.find_by(name: "John")
User.new(name: "Jason").tap do |user|
assert_changes -> { @user.updated_at } do
{ io: StringIO.new("STUFF"), filename: "funky.jpg", content_type: "image/jpeg" },
{ io: StringIO.new("THINGS"), filename: "town.jpg", content_type: "image/jpeg" })
user = User.create!(name: "John") do |user|
@connection.columns(table).find { |c| c.name == "id" }
setup { @blob = create_blob }
user = users(:first)
:passw, :secret, :token, :_key, :crypt, :salt, :certificate, :otp, :ssn
$LOAD_PATH.unshift File.expand_path("../../../lib", __dir__)
get blob.url, headers: { "Range" => "bytes=5-9" }
get blob.url, headers: { "Range" => "bytes=1000-1000" }
params: "Something else entirely!", headers: { "Content-Type" => "text/plain" }
get rails_storage_proxy_url(create_file_blob(filename: "racecar.jpg")), headers: { "Range" => "bytes=5-9" }
get rails_storage_proxy_url(create_file_blob(filename: "racecar.jpg")), headers: { "Range" => "bytes=*/1234" }
get rails_storage_proxy_url(create_file_blob(filename: "racecar.jpg")), headers: { "Range" => "bytes=5-9,13-17" }
blob = create_blob(data: "bad", filename: "bad_file.bad", content_type: "image/bad_type")
def process(file, format:) # :doc:
Please add `gem 'image_processing', '~> 1.2'` to your Gemfile.
loader(page: 0).
if name.to_s == "combine_options"
method_name = name.to_s.tr("-", "_")
if arg.is_a?(Integer) || arg.is_a?(Float)
elsif arg.is_a?(String) || arg.is_a?(Symbol)
if value.is_a?(Integer) || value.is_a?(Float)
elsif value.is_a?(String) || value.is_a?(Symbol)
gem "aws-sdk-s3", "~> 1.48"
@client = Aws::S3::Resource.new(**options)
) do |out|
metadata.transform_keys { |key| "x-amz-meta-#{key}" }
@services = {}
gem "google-cloud-storage", "~> 1.11"
def url_for_direct_upload(key, expires_in:, checksum:, custom_metadata: {}, **)
version = :v2
version = :v4
args = {
query: {
def public_url(key, **)
@client ||= Google::Cloud::Storage.new(**config.except(:bucket, :cache_control, :iam, :gsa_email))
http = Net::HTTP.new(uri.host, uri.port)
metadata.transform_keys { |key| "x-goog-meta-#{key}" }
def upload(key, io, checksum: nil, **)
File.open(path_for(key), "rb") do |file|
Dir.glob(path_for("#{prefix}*")).each do |path|
key: key,
{ "Content-Type" => content_type }
def path_for(key) # :nodoc:
gem "azure-storage-blob", ">= 2.0"
_, io = client.get_blob(container, key)
uri_for(key), false,
service: "b",
).tap do |blob|
client.generate_uri("#{container}/#{key}")
blob = blob_for(key)
metadata.transform_keys { |key| "x-ms-meta-#{key}" }
def open(*args, **options, &block)
def url(key, **options)
disposition = (type.to_s.presence_in(%w( attachment inline )) || "inline")
@variants ||= {}
@ffmpeg_exists = system(ffmpeg_path, "-version", out: File::NULL, err: File::NULL)
@pdftoppm_exists = system(pdftoppm_path, "-v", out: File::NULL, err: File::NULL)
draw self.class.pdftoppm_path, "-singlefile", "-cropbox", "-r", "72", "-png", file.path, &block
@mutool_exists = $?.exitstatus == 1
draw self.class.mutool_path, "draw", "-F", "png", "-o", "-", file.path, "1", &block
@blob = blob
def draw(*argv) # :doc:
def capture(*argv, to:)
IO.popen(argv, err: err) { |out| IO.copy_stream(out, to) }
raise PreviewError, "#{argv.first} failed (status #{$?.exitstatus}): #{err.read.to_s.chomp}"
def logger # :doc:
def tmpdir # :doc:
message = "Uploaded file to key: #{key_in(event)}"
info event, color("Deleted file from key: #{key_in(event)}", RED)
message = "Mirrored file at key: #{key_in(event)}"
record.public_send("#{name}")
generated_association_methods.class_eval <<-CODE, __FILE__, __LINE__ + 1
def #{name}
@active_storage_attached ||= {}
scope :"with_attached_#{name}", -> { includes("#{name}_attachment": :blob) }
scope :"with_attached_#{name}", -> {
includes("#{name}_attachments": { blob: { variant_records: { image_attachment: :blob } } })
@attachment_changes ||= {}
def initialize_dup(*) # :nodoc:
def reload(*) # :nodoc:
@name, @record = name, record
@blob ||= find_or_build_blob
record.public_send("#{name}_blob=", blob)
if record.public_send("#{name}_blob") == blob
if terms = descriptor.split(":", 2)
angle == 90 || angle == 270 || angle == -90 || angle == -270
@probe ||= download_blob_to_tempfile { |file| probe_from(file) }
return {}
rescue ::Vips::Error => error
delegate :key, :url, :download, to: :image, allow_nil: true
@record =
def as_json(*)
format || :png
def unfurl(io, identify: true) # :nodoc:
scope :with_all_variant_records, -> { includes(blob: { variant_records: { image_attachment: :blob } }) }
data = +""
data << "\r\n--#{boundary}\r\n"
data << "Content-Type: #{blob.content_type_for_serving}\r\n"
data << "Content-Range: bytes #{range.begin}-#{range.end}/#{blob.byte_size}\r\n\r\n"
data << chunk
data << "\r\n--#{boundary}--\r\n"
delegate :keys, :key?, :has_key?, :empty?, to: :@parameters
@config ||= read_config
types.any? do |type|
!conn.mariadb? && conn.database_version >= "8.0.13"
conn.mariadb? && conn.database_version >= "10.2.1"
t.integer :random_number, default: -> { "random()" }
t.column :char1, "char(1)", default: "Y"
t.text :char3, limit: 50, default: "a text field"
create_table :"1_need_quoting", force: true do |t|
t.string :json_data_empty, null: true, default: "", limit: 1024
create_table :books, id: :integer, force: true do |t|
default_zero = { default: 0 }
t.column :name, :string, default: "<untitled>"
create_table :bulbs, primary_key: "ID", force: true do |t|
create_table :old_cars, id: :integer, force: true do |t|
create_table :edges, force: true, id: false do |t|
(1..8).each do |i|
t.integer :"c_int_#{i}", limit: i
create_table :pets, primary_key: :pet_id, force: true do |t|
create_table :toys, primary_key: :toy_id, force: true do |t|
create_table(t, force: true) { }
t.string "a$b"
create_table :fk_test_has_pk, primary_key: "pk_id", force: :cascade do |t|
t.foreign_key :fk_test_has_pk, column: "fk_id", name: "fk_name", primary_key: "pk_id"
uuid_default = connection.supports_pgcrypto_uuid? ? {} : { default: "uuid_generate_v4()" }
create_table :uuid_parents, id: :uuid, force: true, **uuid_default do |t|
t.date :modified_date_function, default: -> { "now()" }
t.datetime :modified_time_function, default: -> { "now()" }
t.bigint :bigint_default, default: -> { "0::bigint" }
t.oid :obj_id
execute "SELECT setval('#{seq_name}', 100)"
$$
fixed_date date default to_date('2004-01-01', 'YYYY-MM-DD'),
t.binary :uuid, limit: 36, default: -> { "(uuid())" }
t.text :tiny_text_2, size: :tiny
t.text :long_text_2, size: :long
default_scope -> { where(published: true) }
class_name: "Vertex", join_table: "edges",
class_name: "Job",
has_one :family_tree, -> { where(token: nil) }, foreign_key: "member_id"
scope :with_pet, -> { joins(:pet) }
scope :base, -> { all }
where "written_on < ?", time
scope :approved, -> { where(approved: true) }
scope :rejected, -> { where(approved: false) }
scope :true, -> { where(approved: true) }
scope :false, -> { where(approved: false) }
scope :children, -> { where.not(parent_id: nil) }
scope :has_children, -> { where(id: Topic.children.select(:parent_id)) }
scope :by_lifo, -> { where(author_name: "lifo") }
scope :replied, -> { where "replies_count > 0" }
scope "approved_as_string", -> { where(approved: true) }
scope :anonymous_extension, -> { } do
}.new(self)
has_many :open_replies, -> { open }, class_name: "Reply", foreign_key: "parent_id"
default_scope -> { where(approved: false) }
belongs_to :tag, -> { includes(:tagging) }
belongs_to :blue_tag, -> { where tags: { name: "Blue" } }, class_name: "Tag", foreign_key: :tag_id
has_many :ordered_taggings, -> { order("taggings.id DESC") }, foreign_key: "tag_id", class_name: "Tagging"
validates :name, presence: true, if: -> { true }
scope :ordered, -> { Reply.order(:id) }
if attribute_present?("title") && attribute_present?("content") && content == "Mismatch"
errors.add(:title, "is Wrong Create") if attribute_present?("title") && title == "Wrong Create"
errors.add(:title, "is Wrong Update") if attribute_present?("title") && title == "Wrong Update"
default_scope -> { where(skimmer: true) }
scope :skimmers_or_not, -> { unscope(where: :skimmer) }
has_many :taggings_with_no_tag, -> { joins("LEFT OUTER JOIN tags ON tags.id = taggings.tag_id").where("tags.id": nil) }, as: :taggable, class_name: "Tagging"
has_and_belongs_to_many :developers_named_david, -> { where("name = 'David'").distinct }, class_name: "Developer"
has_and_belongs_to_many :salaried_developers, -> { where "salary > 0" }, class_name: "Developer"
has_and_belongs_to_many :developers_with_callbacks, class_name: "Developer", before_add: Proc.new { |o, r| o.developers_log << "before_adding#{r.id || '<new>'}" },
after_add: Proc.new { |o, r| o.developers_log << "after_adding#{r.id || '<new>'}" },
before_remove: Proc.new { |o, r| o.developers_log << "before_removing#{r.id}" },
after_remove: Proc.new { |o, r| o.developers_log << "after_removing#{r.id}" }
scope :all_as_scope, -> { all }
super + " :)"
scope :containing_the_letter_a, -> { where("body LIKE '%a%'") }
scope :titled_with_an_apostrophe, -> { where("title LIKE '%''%'") }
scope :ordered_by_post_id, -> { order("posts.post_id ASC") }
scope :limit_by, lambda { |l| limit(l) }
scope :locked, -> { lock }
.group("posts.id")
.having("count(comments.id) >= #{comments_count}")
belongs_to :author_with_posts, -> { includes(:posts) }, class_name: "Author", foreign_key: :author_id
belongs_to :author_with_select, -> { select(:id) }, class_name: "Author", foreign_key: :author_id
belongs_to :author_with_the_letter_a, -> { where("name LIKE '%a%'") }, class_name: "Author", foreign_key: :author_id
has_one :first_comment, -> { order("id ASC") }, class_name: "Comment"
has_one :last_comment, -> { order("id desc") }, class_name: "Comment"
scope :no_comments, -> { left_joins(:comments).where(comments: { id: nil }) }
scope :with_post, ->(post_id) { joins(:comments).where(comments: { post_id: post_id }) }
scope :with_comments, -> { preload(:comments) }
scope :with_tags, -> { preload(:taggings) }
scope :with_tags_cte, -> { with(posts_with_tags: where("tags_count > 0")).from("posts_with_tags AS posts") }
scope :tagged_with, ->(id) { joins(:taggings).where(taggings: { tag_id: id }) }
has_many :nonexistent_comments, -> { where "comments.id < 0" }, class_name: "Comment"
.to_a
has_many :misc_tags, -> { where tags: { name: "Misc" } }, through: :taggings, source: :tag
has_many :first_taggings, -> { where taggings: { comment: "first" } }, as: :taggable, class_name: "Tagging"
has_many :first_blue_tags, -> { where tags: { name: "Blue" } }, through: :first_taggings, source: :tag
has_many :first_blue_tags_2, -> { where taggings: { comment: "first" } }, through: :taggings, source: :blue_tag
has_many :invalid_taggings, -> { where "taggings.id < 0" }, as: :taggable, class_name: "Tagging"
has_many :readers_with_person, -> { includes(:person) }, class_name: "Reader"
has_many :skimmers, -> { where skimmer: true }, class_name: "Reader"
def self.log(message = nil, side = nil, new_record = nil)
default_scope { where(id: 1) }
has_many :taggings, -> { rewhere(taggable_type: "TaggedPost") }, as: :taggable
scope :unscoped_all, -> { unscoped { all } }
scope :authorless, -> { unscoped { where(author_id: 0) } }
{ "name" => nil }
has_and_belongs_to_many :parrots, -> { order("parrots.id ASC") }, validate: true
before_add: proc { |p, pa| p.ship_log << "before_adding_proc_parrot_#{pa.id || '<new>'}" },
after_add: proc { |p, pa| p.ship_log << "after_adding_proc_parrot_#{pa.id || '<new>'}" },
before_remove: proc { |p, pa| p.ship_log << "before_removing_proc_parrot_#{pa.id}" },
after_remove: proc { |p, pa| p.ship_log << "after_removing_proc_parrot_#{pa.id}" }
def build(attributes = {})
has_many :birds, -> { order("birds.id ASC") }
before_add: proc { |p, b| p.ship_log << "before_adding_proc_bird_#{b.id || '<new>'}" },
after_add: proc { |p, b| p.ship_log << "after_adding_proc_bird_#{b.id || '<new>'}" },
before_remove: proc { |p, b| p.ship_log << "before_removing_proc_bird_#{b.id}" },
after_remove: proc { |p, b| p.ship_log << "after_removing_proc_bird_#{b.id}" }
has_one :foo_bulb, -> { where name: "foo" }, foreign_key: :car_id, class_name: "Bulb"
ship_log << "#{callback}_#{record.class.name.downcase}_#{record.id || '<new>'}"
has_one :ship_with_annotation, -> { annotate("that is a rocket") }, class_name: :Ship, foreign_key: :pirate_id
(1 << INSURES.index(insure)) & mask.to_i > 0
numbers.inject(0) { |sum, n| sum + (1 << n) }
enum breed: { african: 0, australian: 1 }
has_many :pets, -> { order "pets.name desc" }
scope :including_last_pet, -> {
owners.*, (
) as last_pet_id
scope :clubs, -> { from("clubs") }
belongs_to :member, -> { order("members.id DESC") }
select("'1' as foo")
default_scope -> {
has_one :favorite_club, -> { where "memberships.favorite = ?", true }, through: :membership, source: :club
has_one :hairy_club, -> { where clubs: { name: "Moustache and Eyebrow Fancier Club" } }, through: :membership, source: :club
scope :with_member_type_id, -> (id) { where(member_type_id: id) }
has_many :molecules, -> { distinct }
has_many :shipping_lines, -> { from("shipping_lines") }, autosave: true
class_name: "Human",
has_many :family_trees, -> { where(token: nil) }
has_many :comments, ->(developer) { where(body: "I'm #{developer.name}") }
scope :jamises, -> { where(name: "Jamis") }
default_scope { select("name") }
default_scope -> { where(mentor_id: 1) }
default_scope -> { where(mentor_id: 1) }, all_queries: true
default_scope -> { where(firm_id: firm_id) if firm_id }, all_queries: true
included { default_scope { where(mentor_id: 1) } }
scope :by_name, -> { order("name DESC") }
default_scope { where("name = 'David'") }
default_scope { where(name: "David") }
where(name: "David")
scope :david, -> { where(name: "David") }
default_scope { where(name: "Jamis") }
scope :poor, -> { where("salary < 150000") }
scope :david, -> { where name: "David" }
scope :david2, -> { unscoped.where name: "David" }
default_scope -> { where(name: "Jamis", salary: 50000) }
default_scope -> { where(salary: 50000) }
default_scope -> { where(name: "Jamis") }
other.is_a?(self.class) && other.street == street && other.city == city && other.country == country
if str.is_a?(Hash)
new(*str.to_s.split)
@first, @last = first, last
@hi_count ||= 0
@hi_count += 1
@bye_count ||= 0
@bye_count += 1
self.metadata = { code: company_id && "%08x" % company_id, company_id: company_id, developer_id: developer_id }
@destroy_count += 1
if @destroy_count == 1
table_name => "id"
def column(name, sql_type = nil, options = {})
has_many :clients, -> { order("id") }, dependent: :destroy
has_many :clients_sorted_desc, -> { order("id DESC") }, class_name: "Client"
has_many :clients_of_firm, -> { order "id" }, foreign_key: "client_of", class_name: "Client"
has_many :clients_like_ms, -> { where("name = 'Microsoft'").order("id") }, class_name: "Client"
has_many :clients_sorted_desc, -> { order "id DESC" }, class_name: "Client"
has_many :clients_of_firm, -> { order "id" }, foreign_key: "client_of", class_name: "Client", inverse_of: :firm
has_many :clients_ordered_by_name, -> { order "name" }, class_name: "Client"
has_many :dependent_clients_of_firm, -> { order "id" }, foreign_key: "client_of", class_name: "Client", dependent: :destroy
has_many :limited_clients, -> { limit 1 }, class_name: "Client"
has_many :clients_like_ms_with_hash_conditions, -> { where(name: "Microsoft").order("id") }, class_name: "Client"
has_many :clients_grouped_by_firm_id, -> { group("firm_id").select("firm_id") }, class_name: "Client"
has_many :clients_grouped_by_name, -> { group("name").select("name") }, class_name: "Client"
has_one :account_with_select, -> { select("id, firm_id") }, foreign_key: "firm_id", class_name: "Account"
has_one :readonly_account, -> { readonly }, foreign_key: "firm_id", class_name: "Account"
has_one :account_using_primary_key, -> { order("id") }, primary_key: "firm_id", class_name: "Account"
has_many :developers_with_select, -> { select("id, name, first_name") }, class_name: "Developer"
log << "before_remove#{record.id}"
log << "after_remove#{record.id}"
has_one :account, -> { order(:id) }, foreign_key: "firm_id", dependent: :nullify
has_one :account, -> { order("id") }, foreign_key: "firm_id", dependent: :restrict_with_exception
has_many :companies, -> { order("id") }, foreign_key: "client_of", dependent: :restrict_with_exception
has_one :account, -> { order("id") }, foreign_key: "firm_id", dependent: :restrict_with_error
has_many :companies, -> { order("id") }, foreign_key: "client_of", dependent: :restrict_with_error
belongs_to :firm_with_select, -> { select("id") }, class_name: "Firm", foreign_key: "firm_id"
belongs_to :firm_with_condition, -> { where "1 = ?", 1 }, class_name: "Firm", foreign_key: "client_of"
belongs_to :readonly_firm, -> { readonly }, class_name: "Firm", foreign_key: "firm_id"
belongs_to :bob_firm, -> { where name: "Bob" }, class_name: "Firm", foreign_key: "client_of"
has_many :dependent_conditional_clients_of_firm, -> { order("id").where("name = ?", "BigShot Inc.") }, foreign_key: "client_of", class_name: "Client", dependent: :delete_all
scope :containing_the_letter_e, -> { where("comments.body LIKE '%e%'") }
scope :not_again, -> { where("comments.body NOT LIKE '%again%'") }
scope :for_first_post, -> { where(post_id: 1) }
scope :for_first_author, -> { joins(:post).where("posts.author_id" => 1) }
scope :created, -> { all }
scope :ordered_by_post_id, -> { order("comments.post_id DESC") }
update(body: "bar")
assoc.has_many :students, -> { where(active: true) }
has_many :favorites, -> { where(memberships: { favorite: true }) }, through: :memberships, source: :member
scope :general, -> { left_joins(:category).where(categories: { name: "General" }).unscope(:limit) }
-> { select "posts.*, 1 as correctness_marker" },
class_name: "Post",
-> { where title: "Yet Another Testing Title" },
has_and_belongs_to_many :posts_grouped_by_title, -> { group("title").select("title") }, class_name: "Post"
has_many :ordered_post_comments, -> { order(id: :desc) }, through: :posts, source: :comments
has_many :human_writers_of_typed_essays, -> { where(essays: { type: TypedEssay.name }) }, through: :essays, source: :writer, source_type: "Human", primary_key: :name
scope :general, -> { where(name: "General") }
has_many :all_bulbs, -> { unscope(where: :name) }, class_name: "Bulb"
has_many :all_bulbs2, -> { unscope(:where) }, class_name: "Bulb"
has_many :other_bulbs, -> { unscope(where: :name).where(name: "other") }, class_name: "Bulb"
has_many :old_bulbs, -> { rewhere(name: "old") }, class_name: "Bulb"
has_many :foo_bulbs, -> { where(name: "foo") }, class_name: "Bulb"
has_many :awesome_bulbs, -> { awesome }, class_name: "Bulb"
scope :incl_tyres, -> { includes(:tyres) }
scope :incl_engines, -> { includes(:engines) }
attribute :wheels_owned_at, :datetime, default: -> { Time.now }
default_scope { order("name desc") }
scope :awesome, -> { where(frickinawesome: true) }
def self.new(attributes = {}, &block)
bulb_type = (attributes || {}).delete(:bulb_type)
has_many :tags, -> { where name: "Der be rum" }, through: :taggings, dependent: :destroy_async
enum last_read: { unread: 0, reading: 2, read: 3, forgotten: nil }
enum cover: { hard: "hard", soft: "soft" }
enum :cover, { hard: "0", soft: "1" }, default: :hard
has_many :posts_with_comments, -> { includes(:comments) }, class_name: "Post"
has_many :popular_grouped_posts, -> { includes(:comments).group("type").having("SUM(legacy_comments_count) > 1").select("type") }, class_name: "Post"
has_many :posts_sorted_by_id, -> { order(:id) }, class_name: "Post"
has_many :posts_sorted_by_id_limited, -> { order("posts.id").limit(1) }, class_name: "Post"
-> { order(id: :desc) },
-> { where("ratings.value > 5").order(:id) },
has_many :comments_with_include, -> { includes(:post).where(posts: { type: "Post" }) }, through: :posts, source: :comments
has_one :comment_on_first_post, -> { order("posts.id desc, comments.id asc") }, through: :first_post, source: :comments
has_many :thinking_posts, -> { where(title: "So I was thinking") }, dependent: :delete_all, class_name: "Post"
has_many :welcome_posts, -> { where(title: "Welcome to the weblog") }, class_name: "Post"
-> { where(title: "Welcome to the weblog").where(comments_count: 1) },
-> { where(title: "Welcome to the weblog").where("legacy_comments_count > 0") },
has_many :comments_desc, -> { order("comments.id DESC") }, through: :posts_sorted_by_id, source: :comments
has_many :hello_posts, -> { where "posts.body = 'hello'" }, class_name: "Post"
has_many :posts_with_no_comments, -> { where("comments.id" => nil).includes(:comments) }, class_name: "Post"
has_many :posts_with_no_comments_2, -> { left_joins(:comments).where("comments.id": nil) }, class_name: "Post"
has_many :hello_posts_with_hash_conditions, -> { where(body: "hello") }, class_name: "Post"
before_add: Proc.new { |o, r| o.post_log << "before_adding#{r.id || '<new>'}" },
after_add: Proc.new { |o, r| o.post_log << "after_adding#{r.id || '<new>'}" },
before_remove: Proc.new { |o, r| o.post_log << "before_removing#{r.id}" },
after_remove: Proc.new { |o, r| o.post_log << "after_removing#{r.id}" }
has_many :categorizations, -> { }
has_many :favorite_authors, -> { order("name") }, through: :author_favorites
has_many :similar_posts, -> { distinct }, through: :tags, source: :tagged_posts
has_many :distinct_tags, -> { select("DISTINCT tags.*").order("tags.name") }, through: :posts, source: :tags
has_one :recent_post, -> { order(id: :desc) }, class_name: "Post"
has_many :posts_with_extension, -> { order(:title) }, class_name: "Post" do
has_many :posts_with_extension_and_instance, ->(record) { order(:title) }, class_name: "Post" do
has_many :top_posts, -> { order(id: :asc) }, class_name: "Post"
has_many :other_top_posts, -> { order(id: :asc) }, class_name: "Post"
has_many :topics_without_type, -> { select(:id, :title, :author_name) },
@post_log << "before_adding#{object.id || '<new>'}"
@post_log << "after_adding#{object.id}"
@post_log << "before_removing#{object.id}"
@post_log << "after_removing#{object.id}"
default_scope { order(id: :asc) }
read_store_attribute(:settings, :phone_number).gsub(/(\d{3})(\d{3})(\d{4})/, '(\1) \2-\3')
super || "red"
scope :open, -> { where("firm_name = ?", "37signals") }
scope :available, -> { open }
create_table("things") do |t|
topic = Topic.new(content: { "omg" => "lol" })
assert_equal({ "omg" => "lol" }, yaml_load(YAML.dump(topic)).content)
topic = Topic.new(parent_id: "123")
.group("authors.id")
coder = {}
author.name = "Sean"
self.primary_key = "id"
create_view "ebooks'", <<~SQL
assert_equal({ "id" => 2, "name" => "Ruby for Rails", "cover" => "hard", "status" => 0 },
assert_equal({ "name" => "Agile Web Development with Rails", "status" => 2 },
r.title = "Bad"
r.content = "Good"
r = WrongReply.new(title: "Valid title", author_name: "secret", content: "Good")
WrongReply.create!("title" => "OK") do |r|
d = Developer.new("name" => "David", "salary" => "100,000")
topic = klass.create("approved" => true)
topic.wibble.gsub!("-", "")
update!(author_name: "#{title} #{id}")
topic = Topic.new(new_title: "abc")
t = Topic.new("title" => nil)
t2 = Topic.new("title" => nil)
Topic.create!("title" => "abc")
t2 = Topic.new("title" => "abc")
t = Topic.new("title" => "new\nline")
t = Topic.create("title" => "I'm unique!")
r1 = t.replies.create "title" => "r1", "content" => "hello world"
r2 = t.replies.create "title" => "r2", "content" => "hello world"
t2 = Topic.create("title" => "I'm unique too!")
r3 = t2.replies.create "title" => "r3", "content" => "hello world"
t = Topic.create(title: "I'm unique!")
r1 = t.replies.create(title: "r1", content: "hello world")
r2 = t.replies.create(title: "r2", content: "hello world")
r3 = t2.replies.create(title: "r3", content: "hello world")
a = Author.create(name: "Sergey")
e1 = a.essays.create(name: "Essay")
e2 = p.essays.create(name: "Essay")
r1 = ReplyWithTitleObject.create "title" => "r1", "content" => "hello world"
r2 = ReplyWithTitleObject.create "title" => "r1", "content" => "hello world"
t = Topic.create("title" => "What, me worry?")
r1 = t.unique_replies.create "title" => "r1", "content" => "a barrel of fun"
r2 = t.silly_unique_replies.create "title" => "r2", "content" => "a barrel of fun"
r3 = t.replies.create "title" => "r2", "content" => "a barrel of fun"
t = Topic.create("title" => "The earth is actually flat!")
r1 = t.replies.create "author_name" => "jeremy", "author_email_address" => "jeremy@rubyonrails.com", "title" => "You're joking!", "content" => "Silly reply"
r2 = t.replies.create "author_name" => "jeremy", "author_email_address" => "jeremy@rubyonrails.com", "title" => "You're joking!", "content" => "Silly reply again..."
r3 = t.replies.create "author_name" => "jeremy", "author_email_address" => "jeremy_alt_email@rubyonrails.com", "title" => "You're wrong", "content" => "It's cubic"
r3.author_name = "jj"
t = Topic.new("title" => "I'm unique!", :parent_id => 2)
t2 = Topic.new("title" => "I'm UNIQUE!", :parent_id => 1)
t2.parent_id = 4
t = Topic.new("title" => "I'm unique!")
t2 = Topic.new("title" => "I'm %")
t3 = Topic.new("title" => "I'm uniqu_!")
t3 = Topic.new("title" => "I'M uNiQUe!")
Topic.create!("title" => 101)
t2 = Topic.new("title" => 101)
t1 = Topic.new("title" => "I'm unique!", "author_name" => "Mary")
t2 = Topic.new("title" => "I'm unique!", "author_name" => "David")
g = Guid.new
g.key = "foo"
w3 = Conjurer.new(name: "Rincewind", city: "Quirm")
Topic.create("title" => "I'm a topic", "approved" => true)
Topic.create("title" => "I'm an unapproved topic", "approved" => false)
t3 = Topic.new("title" => "I'm a topic", "approved" => true)
t4 = Topic.new("title" => "I'm an unapproved topic", "approved" => false)
abc = klass.create!(dashboard_id: "abc")
t = Topic.new("title" => "This is a unique title")
t.id += 1
t = Topic.new(title: "abc")
t = Topic.create!(title: "abc")
t.author_name = "John"
t.title = "abc v2"
t = Topic.create!(title: "abc", author_name: "John")
t.author_name = "Amy"
e1 = Event.create!(title: "abc")
e2 = Event.create!(title: "cde")
t.event = e2
b = Boy.new
b.name = "Alex"
f = Face.new
b.face = f
if 123.455.to_d(5) == BigDecimal("123.46")
o = @owner.new("name" => "nopets")
o.pets.build("name" => "apet")
2.times { o.pets.build("name" => "apet") }
pet = Pet.create!(name: "Fancy Pants", nickname: "Fancy")
pet.nickname = ""
I18n.backend.store_translations("en", errors: { messages: { custom: nil } })
@unique ||= Topic.create title: "unique!"
I18n.backend.store_translations "en", activerecord: { errors: { models: { topic: { attributes: { replies: { invalid: "custom message" } } } } } }
I18n.backend.store_translations "en", errors: { attributes: { title: { taken: "Custom taken message" } } }
I18n.backend.store_translations "en", activerecord: { errors: { models: { topic: { taken: "Custom taken message" } } } }
I18n.backend.store_translations "en", activerecord: { errors: { models: { topic: { attributes: { title: { taken: "Custom taken message" } } } } } }
I18n.backend.store_translations "en", activerecord: { errors: { models: { topic: { attributes: { title: { taken: "custom en message" } } } } } }
t = Topic.create("title" => "uhohuhoh", "content" => "whatever")
r.content = r3.content = "non-empty"
r = Reply.new("title" => "A reply", "content" => "with content!")
r.topic = Topic.create("title" => "uhohuhoh")
t = Topic.new
r = Reply.create("title" => "A reply", "content" => "with content!")
human = Human.new(name: "John")
human = Human.create!(name: "John")
ids = Post.order("title").pluck(:id)
ids = Post.order(:title).pluck(:id)
ids_expected = Post.order(Arel.sql("title") => Arel.sql("asc")).pluck(:id)
ids = Post.order(title: :asc).pluck(:id)
ids_expected = Post.order(Arel.sql("title") => Arel.sql("ASC")).pluck(:id)
ids = Post.order(title: :ASC).pluck(:id)
ids = Post.order(title: "asc").pluck(:id)
ids_expected = Post.order(Arel.sql("author_id"), Arel.sql("title")).pluck(:id)
ids = Post.order(:author_id, :title).pluck(:id)
ids_expected = Post.order(Arel.sql("author_id"), Arel.sql("title") => Arel.sql("asc")).pluck(:id)
ids = Post.order(:author_id, title: :asc).pluck(:id)
ids = Post.order("posts.title").pluck(:id)
ids = Post.order("title desc").pluck(:id)
ids = Post.order("type::text #{direction} nulls #{position}").pluck(:id)
Post.order("REPLACE(title, 'misc', 'zzzz') asc").pluck(:id)
Post.order("REPLACE(title, 'misc', 'zzzz')" => :asc).pluck(:id)
ids_expected = Post.order(Arel.sql("REPLACE(title, 'misc', 'zzzz'), id")).pluck(:id)
ids = Post.order("author_id, length(trim(title))").pluck(:id)
Post.order("REPLACE(title, 'misc', 'zzzz')")
values_expected = Post.pluck(Arel.sql("title"), Arel.sql("id"))
values = Post.pluck(:title, :id)
Post.pluck("REPLACE(title, 'misc', 'zzzz')")
Post.pluck(:title, "REPLACE(title, 'misc', 'zzzz')")
Post.includes(:comments).pluck(:title, "REPLACE(title, 'misc', 'zzzz')")
model.foo = "foo"
model.foo = "bar"
assert_equal "string", mapping.fetch(1) { "int" }
assert_equal "int", mapping.fetch(2) { "int" }
string = +""
if type.include?("(")
mapping.register_type("foo") { |*args| args.join("-") }
assert_equal "foo-1-2-3", mapping.fetch("foo", 1, 2, 3) { |*args| args.join("-") }
assert_equal "foo-2-3-4", mapping.fetch("foo", 2, 3, 4) { |*args| args.join("-") }
assert_equal "bar-1-2-3", mapping.fetch("bar", 1, 2, 3) { |*args| args.join("-") }
expected_time = ::Time.utc(2000, 1, 1, 10, 30, 0)
topic = Topic.new(bonus_time: { 4 => 10, 5 => 30 })
value = type.cast("1999-12-31T12:34:56.789-10:00")
author = klass.create!(name: "Sean")
author.name << " Griffin"
firm = Firm.create(name: "Apple")
model.foo = 1
p = Task.create!(starting: ::Time.now)
value = type.cast("1999-12-31 12:34:56.789 -1000")
def ==(other) self.args == other.args end
@first, @second = Topic.find(1, 2).sort_by(&:id)
author = Author.new(name: "DHH")
num = nil
topic = Class.new(Topic) {
new_topic = topic.new(title: "A new topic",
author_name: "Ben",
last_read: "2004-04-15",
bonus_time: "2005-01-30t15:28:00.00+01:00",
topic_one = Topic.new(title: "A new topic")
@first.content = "One"
@first.content = "Two"
@first.content = "Four"
Topic.connection.stub(:commit_db_transaction, -> { raise("OH NOES") }) do
topic = Topic.new(title: "test")
topic_1 = Topic.new(title: "test_1")
topic_2 = Topic.new(title: "test_2")
movie = Movie.new(name: "foo")
movie = Movie.create!(name: "foo")
assert_no_difference(-> { klass.count }) do
meta = class << topic; self; end
@first = Topic.find(1)
threads = (1..3).map do
tag = Tag.create(name: "jon")
@before_commit ||= {}
@after_commit ||= {}
@after_rollback ||= {}
blocks.each { |b| b.call(self) } if blocks
@first.after_commit_block { |r| r.history << :after_commit }
def @first.valid?(*)
record.after_commit_block(:save) { |r| r.history << :after_save }
new_record.after_commit_block(:create) { |r| r.save! }
r.content = "bar"
def @first.rollbacks(i = 0); @rollbacks ||= 0; @rollbacks += i if i; end
def @first.commits(i = 0); @commits ||= 0; @commits += i if i; end
@first.after_rollback_block { |r| r.rollbacks(1) }
@first.after_commit_block { |r| r.commits(1) }
def second.rollbacks(i = 0); @rollbacks ||= 0; @rollbacks += i if i; end
def second.commits(i = 0); @commits ||= 0; @commits += i if i; end
second.after_commit_block { |r| r.commits(1) }
first = klass.new(title: "foo")
define_method(:object_id) { 42 }
record.after_commit_block { |r| r.history << :after_commit }
after_commit(if: opts, on: :create) { }
record.after_commit_block(:create) { |r| r.history << :commit_on_create }
record.after_commit_block(:update) { |r| r.history << :commit_on_update }
if model != ActiveRecord::Base && !old
time = Time.now.utc - 25.days
time = (Time.now.utc - 25.days).change(nsec: 0)
time = Time.now.utc - 2.days
owner.update pets_attributes: { "0" => { id: "1", name: "Alfred" } }
class User < ::User
{ updated_at: updated_at }
@user = User.create!(password_digest: "$2a$4$#{"x" * 22}#{"y" * 31}")
User.find_by_token_for!(:lookup, "bad")
new_time = Time.utc(2015, 2, 16, 0, 0, 0)
now = Time.now.change(usec: 0)
new_time = Time.utc(2015, 2, 16, 4, 54, 0)
validate { errors.add(:base, :invalid) }
def self.name; "Pet"; end
pet.name = "I'm a parrot"
def self.name; "Toy"; end
pet = toy.pet
toy1 = klass.find(1)
toy2 = klass.find(2)
def self.name; "Car"; end
car = car_class.find(1)
toy = toy_class.find(3)
toy = klass.find(1)
toy.pet = nil
foo = Foo.new(start: time, finish: time)
time = ::Time.now.change(nsec: 123)
time = ::Time.utc(2000, 1, 1, 12, 30, 0, 999999)
assert_match %r{t\.time\s+"start",\s+precision: 4$}, output
assert_match %r{t\.time\s+"finish",\s+precision: 6$}, output
assert_match %r{t\.time\s+"start",\s+precision: 0$}, output
assert_match %r{t\.time\s+"finish",\s+precision: 0$}, output
File.write(File.join(tmp_dir, "zines.yml"), <<~YML)
idx = 42
def assert_queries(num = 1, options = {}, &block)
ignore_none = options.fetch(:ignore_none) { num == :any }
if num == :any
mesg = "#{the_log.size} instead of #{num} queries were executed.#{the_log.size == 0 ? '' : "\nQueries:\n#{the_log.join("\n")}"}"
def assert_no_queries(options = {}, &block)
old_callbacks = {}
if cfg.has_key?(:zone)
$stderr.puts <<-MSG
\n#{self}
Got: #{Time.zone}
3,
times: 6,
env => {
primary: {
define_method("test_#{k}_create") do
assert_called(eval("@#{v}"), :create) do
f.puts "This is a cache."
path = "#{dir}/fake_db_config_schema.rb"
@configurations = { "development" => { "database" => "my-db" } }
define_method("test_#{k}_drop") do
assert_called(eval("@#{v}"), :drop) do
@configurations = { development: { "database" => "my-db" } }
:drop,
backup = SQLite3::Backup.new(dest_db, "main", source_db, "main")
define_method("test_#{k}_purge") do
assert_called(eval("@#{v}"), :purge) do
configurations = { development: { "database" => "my-db" } }
assert_called(eval("@#{v}"), :charset) do
assert_called(eval("@#{v}"), :collation) do
eval("@#{v}"), :structure_dump,
eval("@#{v}"),
{ ruby: "schema.rb", sql: "structure.sql" }.each_pair do |fmt, filename|
user = User.create! token: "asdf"
user.token = "uiop"
firm = Firm.create!(name: "NASA")
proc { dev.ship }
@john = Admin::User.create!(
name: "John Doe", color: "black", remember_login: true,
height: "tall", is_a_good_guy: true,
@john.color = "red"
user.color = "red"
@john.settings = { color: @john.color, some: "thing" }
@john.color = "black"
@john.phone_number = "(123) 456-7890"
@john.color = "yellow"
@john.height = "low"
user = Admin::User.find_by_name("Jamis")
user.update(settings: { "color" => { "jenny" => "blue" }, homepage: "rails" })
user.height = "low"
assert_equal false, @john.json_data.delete_if { |k, v| k == "height" }.any?
@john.height = "short"
@john.weight = "heavy"
assert_equal({}, @john.params)
sql = Book.where(author_id: 96, cover: "hard").to_sql
b1 = Book.create(name: "my book")
b2 = Book.create(name: "my other book")
a = Book.find_or_create_by(name: "my book")
b = Book.find_or_create_by(name: "my other book")
Book.where(name: "my book").where("author_id > 3")
Book.create(name: "my book", author_id: 4)
book = Book.find_by(name: "my book")
@toy = Toy.first
}, ->(*) { :shard_one })
}, ->(*) { :shard_one }, { lock: false })
}, ->(*) { "shard_one" })
myobj = MyObject.new("value1", "value2")
topic = Topic.create("content" => myobj)
serialize(:content, type: Hash, default: { key: "value" })
t = klass.new
assert_equal({ key: "value" }, t.content)
attribute :content, default: { key: "value" }
hash = { "content1" => "value1", "content2" => "value2" }
t = ImportantTopic.new(content: { foo: :bar })
assert_equal({ foo: :bar }, t.content)
orig = Topic.new(content: { foo: :bar })
t = Topic.find(id)
hash = { "important1" => "value1", "important2" => "value2" }
myobj = Time.local(2008, 1, 1, 1, 0)
myobj = "Yes"
settings = { "color" => "blue" }
settings = { "color" => "green" }
topic = Topic.create!(content: { zomg: true })
expected = "can't load `content`: was supposed to be a Array, but was a Hash. -- {:zomg=>true}"
topic = Topic.create(content: { "things" => "stuff" })
topic = Topic.create!(content: {})
topic = Topic.create!(content: { foo: "bar" })
!new.nil?
topic = klass.create!(content: { trial: true })
assert_equal({ "trial" => true }, topic.content)
value + " encoded"
value.gsub(" encoded", "")
value.gsub(" serialized", "")
topic = model.create!(foo: "bar")
attribute :content, default: { "key" => "value" }
assert_equal({ "key" => "value" }, t.content)
topic = Topic.create!(content: { "foo" => "bar" })
serialize(:content, type: Hash, default: { "key" => "value" })
t = ImportantTopic.new(content: { "foo" => "bar" })
assert_equal({ "foo" => "bar" }, t.content)
myobj = { "somevalue" => "thevalue" }
topic = Topic.create!(content: { "zomg" => true })
expected = "can't load `content`: was supposed to be a Array, but was a Hash. -- {\"zomg\"=>true}"
name: "aaron stack",
age: 25,
created_at: Time.utc(2006, 8, 1),
preferences: { "gem" => "<strong>ruby</strong>" },
@user = User.new
assert_sql(%r{/\* scoped \*/}) do
assert_predicate log.select { |query| query.match?(%r{/\* scoped \*/}) }, :empty?
where("name = 'David'").
assert_predicate log.select { |query| query.match?(%r{/\* unscope \*/}) }, :empty?
Developer.where("projects.id" => 2).to_a
assert_match "(salary = 80000)", sql
@welcome = Post.find(1)
assert_equal Topic.all.to_a, Topic.base.map { |i| i }
scope :since, Proc.new { where("written_on >= ?", Time.now - 1.day) }
stats = {}
Class.new(Post).class_eval { scope :containing_the_letter_z, where("body LIKE '%z%'") }
:to_ary,
:to_sql,
Class.new(Post).class_eval { scope name, -> { where(approved: true) } }
scope = Topic.where("content LIKE '%Have%'")
topics.any? { true }
topics.many? { true }
klass.class_eval { scope name, -> { where(approved: true) } }
subklass.class_eval { scope name, -> { where(approved: true) } }
scope :"title containing space", ->(space: " ") { where("title LIKE '%#{space}%'") }
assert_equal klass.where("title LIKE '% %'"), klass.public_send(:"title containing space", space: " ")
assert_sql(/COUNT/i) { topics.size }
relation = Topic.where("1=1")
post = Post.find(1)
group.each { |t| assert t.approved? }
one = assert_queries(1) { post.comments.limit_by(1).to_a }
two = assert_queries(1) { post.comments.limit_by(2).to_a }
assert_sql(%r{/\* from-scope \*/}) do
create_sql = capture_sql { klass.create!(name: "Steve") }.first
update_sql = capture_sql { dev.update!(name: "Not Eileen") }.first
update_sql = capture_sql { dev.update!(name: "Not Nikita") }.first
reload_sql = capture_sql { dev.reload({ unscoped: true }) }.first
received_2 = DeveloperOrderedBySalary.select("id").where("name" => "Jamis").unscope({ where: :name }, :select).collect(&:name)
scope :by_name, -> name { unscope(where: :name).where(name: name) }
Developer.where(name: "Jamis").unscope("where" => :name)
assert_equal Developer.where(name: "David").map(&:id), scope.map(&:id)
}.join
expected = <<~STR
assert_no_match %r{(?<=, ) do \|t\|}, output
matches = lines.map { |line| line.match(pattern) }
output.scan(/^( *)create_table.*?\n(.*?)^\1end/m).map { |m| m.last.split(/\n/) }
assert column_set.all? { |column| !column.match(/\bt\.\w+\s{2,}/) }
assert_no_line_up(column_set, /limit: /)
assert_no_line_up(column_set, /null: /)
assert_match %r{"c_int_without_limit"(?!.*limit)}, output
assert_match %r{c_int_1.*limit: 2}, output
assert_match %r{c_int_2.*limit: 2}, output
assert_match %r{"c_int_3"(?!.*limit)}, output
assert_match %r{"c_int_4"(?!.*limit)}, output
assert_match %r{c_int_1.*limit: 1}, output
assert_match %r{c_int_3.*limit: 3}, output
assert_match %r{c_int_4.*limit: 4}, output
assert_match %r{c_int_5.*limit: 5}, output
assert_match %r{c_int_6.*limit: 6}, output
assert_match %r{c_int_7.*limit: 7}, output
assert_match %r{c_int_8.*limit: 8}, output
assert_match %r{t\.bigint\s+"c_int_5"$}, output
assert_match %r{t\.bigint\s+"c_int_6"$}, output
assert_match %r{t\.bigint\s+"c_int_7"$}, output
assert_match %r{t\.bigint\s+"c_int_8"$}, output
match = output.match(%r{create_table "movies"(.*)do})
assert_match %r{t\.text\s+"params"$}, output
assert_match %r{t\.binary\s+"data"$}, output
assert_match %r{t\.binary\s+"blob_data"$}, output
index_definition.sub!(/, name: "company_expression_index"\z/, "")
assert_match %r{CASE.+lower\(\(name\)::text\).+END\) DESC"\z}i, index_definition
assert_match %r{CASE.+lower\(`name`\).+END\) DESC"\z}i, index_definition
assert_match %r{CASE.+lower\(name\).+END\) DESC"\z}i, index_definition
assert_match %r{t\.binary\s+"var_binary",\s+limit: 255$}, output
assert_match %r{t\.binary\s+"tiny_blob",\s+size: :tiny$}, output
assert_match %r{t\.binary\s+"medium_blob",\s+size: :medium$}, output
assert_match %r{t\.binary\s+"long_blob",\s+size: :long$}, output
assert_match %r{t\.text\s+"tiny_text",\s+size: :tiny$}, output
assert_match %r{t\.text\s+"normal_text"$}, output
assert_match %r{t\.text\s+"medium_text",\s+size: :medium$}, output
assert_match %r{t\.text\s+"long_text",\s+size: :long$}, output
assert_match %r{t\.binary\s+"tiny_blob_2",\s+size: :tiny$}, output
assert_match %r{t\.binary\s+"medium_blob_2",\s+size: :medium$}, output
assert_match %r{t\.binary\s+"long_blob_2",\s+size: :long$}, output
assert_match %r{t\.text\s+"tiny_text_2",\s+size: :tiny$}, output
assert_match %r{t\.text\s+"medium_text_2",\s+size: :medium$}, output
assert_match %r{t\.text\s+"long_text_2",\s+size: :long$}, output
assert_no_match %r{t\.boolean\s+"has_fun",.+limit: 1}, output
assert_match %r{t\.oid\s+"obj_id"$}, output
output = dump_all_table_schema(/./)
match = output.match(%r{create_table "goofy_string_id"(.*)do.*\n(.*)\n})
create_table("dog_owners") do |t|
create_table("dogs") do |t|
assert_no_match %r{create_table "foo_.+_bar"}, output
assert_no_match %r{add_index "foo_.+_bar"}, output
assert_no_match %r{add_foreign_key "foo_.+_bar"}, output
assert_no_match %r{create_table "foo\$.+\$bar"}, output
assert_no_match %r{add_index "foo\$.+\$bar"}, output
assert_no_match %r{add_foreign_key "foo\$.+\$bar"}, output
create_table("cats") do |t|
create_table("omg_cats") do |t|
t.text :uuid, default: -> { "gen_random_uuid()" }
t.text :uuid, default: -> { "uuid()" }
assert_match %r{t\.string\s+"string_with_default",.*?default: "Hello!"}, output
assert_match %r{t\.date\s+"date_with_default",\s+default: "2014-06-05"}, output
assert_match %r{t\.time\s+"time_with_default",\s+default: "2000-01-01 07:17:04"}, output
assert_match %r{t\.text\s+"text_with_default",.*?default: "John' Doe"}, output
assert_match %r{t\.text\s+"uuid",.*?default: -> \{ "gen_random_uuid\(\)" \}}, output
assert_match %r{t\.text\s+"uuid",.*?default: -> \{ "uuid\(\)" \}}, output
sub_query_pattern = /\(\bselect\b.*?\bwhere\b.*?\)/i
assert_equal "100!%", Binary.sanitize_sql_like("100%", "!")
assert_equal "great!!", Binary.sanitize_sql_like("great!", "!")
assert_equal 'C:\\Programs\\MsPaint', Binary.sanitize_sql_like('C:\\Programs\\MsPaint', "!")
assert_equal "1__000_%", Binary.sanitize_sql_like("1_000%", "_")
assert_equal "1%_000%%", Binary.sanitize_sql_like("1_000%", "%")
where("title LIKE ?", sanitize_sql_like(term, "!"))
scope :search_as_scope, -> (term) {
assert_sql(/LIKE '20!% !_reduction!_!!'/) do
assert_equal "'1'", bind(":a", a: 1) # ' ruby-mode
assert_equal "1", bind(":a", a: 1) # ' ruby-mode
assert_nothing_raised { bind("'+00:00'", foo: "bar") }
@ary = ary
def each(&b)
@ary.each(&b)
assert_equal quoted_abc, bind("?", %w(a b c))
assert_equal quoted_abc, bind(":a", a: %w(a b c)) # '
assert_equal quoted_abc, bind(":a", a: SimpleEnumerable.new(%w(a b c))) # '
assert_equal "'0'", bind("?", 0..0)
assert_equal "'1','2','3'", bind("?", 1..3)
assert_equal "0", bind("?", 0..0)
assert_equal "1,2,3", bind("?", 1..3)
assert_equal quoted_abc, bind("?", "a"..."d")
assert_equal quoted_nil, bind("?", 0...0)
assert_equal quoted_nil, bind("?", "a"..."a")
assert_equal quoted_empty, bind("?", "")
assert_equal "name=#{quoted_bambi}", bind("name=?", "Bambi")
assert_equal "name=#{quoted_bambi}", bind("name=?", "Bambi".mb_chars)
l = Proc.new { bind(":a::integer '2009-01-01'::date", a: "10") }
{ "col_1" => "row 1 col 1", "col_2" => "row 1 col 2" },
{ "col_1" => "row 2 col 1", "col_2" => "row 2 col 2" },
{ "col_1" => "row 3 col 1", "col_2" => "row 3 col 2" },
{ "col_1" => "row 1 col 1", "col_2" => "row 1 col 2" }, result.first)
{ "col_1" => "row 3 col 1", "col_2" => "row 3 col 2" }, result.last)
types = { "col1" => Type::Integer.new, "col2" => Type::Float.new }
types = { "col1" => Type::Integer.new }
x = Group.new
x.order = "x"
x.order = "y"
pet = Pet.find_by_name("parrot")
Kernel.load(File.expand_path("../models/owner.rb", __dir__))
x = Post.where("author_id = ?", 1)
posts = Post.where("author_id = ? AND id = ?", 1, 1)
2.times { topics.to_a }
subquery = Comment.from("#{Comment.table_name} /*! USE INDEX (PRIMARY) */").joins(:post).select(:id).order(:id)
subquery = Comment.from("#{Comment.table_name} /*! USE INDEX (PRIMARY) */").joins(:post).order(:id)
subquery = Comment.from("#{Comment.quoted_table_name} /*! USE INDEX (PRIMARY) */").joins(:post).select(:id).order(:id)
subquery = Comment.from("#{Comment.quoted_table_name} /*! USE INDEX (PRIMARY) */").joins(:post).order(:id)
subquery = Comment.from("(#{relation.to_sql}) #{Comment.table_name}_grouped").select("type", "post_count")
topics = Topic.order("id")
topics = Topic.order(Arel.sql("id") => :desc)
topics = Topic.order(Arel.sql("id") => :asc).reverse_order
Topic.order(Arel.sql("REPLACE(title, '', '')") => :asc).reverse_order
topics = Topic.order(id: "desc")
topics = Topic.order(id: "asc")
e = assert_raise(ArgumentError) { Topic.order(:name, "id DESC", id: :asfsdf) }
topics = Topic.order("author_name").order("title").reorder("id").to_a
topics = Topic.reorder("id desc", "id desc")
limit(1).to_a
assert_match(/field\(id, '1','3','2'\)/, query)
assert_match(/field\(id, 1,3,2\)/, query)
assert_match(/field\(id, NULL\)/, query)
assert_match(/field\(id, '1', '3', '2'\)/, query)
assert_match(/field\(id, 1, 3, 2\)/, query)
query = Tag.order(Arel.sql("field(id, ?)", nil)).to_sql
even_ids = Developer.all.select { |d| d.id % 2 == 0 }.map(&:id)
where("project_id=1").to_a
).to_a
.where(comments: { id: 1 })
post = Post.create! title: "Uhuu", body: "body"
post = posts.find { |p| p.id == 1 }
{ name: david.name },
{ name: "Santiago" },
{ name: "tenderlove" },
ids = Author.pluck(:id)
slugs = ids.map { |id| "#{id}-as-a-slug" }
relation = Author.where("id in (?)", Author.where(id: david).select(:id))
relation = Post.where("id in (?)", david.posts.select(:id))
relation = Post.where("id in (:post_ids)", post_ids: david.posts.select(:id))
expected = { 1 => 4, 2 => 1 }
no_posts = posts.where(title: "")
assert posts.any? { |p| p.id > 0 }
assert_not posts.any? { |p| p.id <= 0 }
assert posts.many? { |p| p.id > 0 }
assert_not posts.many? { |p| p.id < 2 }
assert posts.none? { |p| p.id < 0 }
assert_not posts.none? { |p| p.id == 1 }
assert_not posts.one? { |p| p.id < 3 }
assert posts.one? { |p| p.id == 1 }
posts = Post.where(title: "You told a lie")
hen = birds.where(name: "hen").create!
bird.color = "grey"
canary = Bird.create!(color: "yellow", name: "canary")
bird.name = "parrot"
same_parrot = Bird.where(color: "green").first_or_create { |bird| bird.name = "parakeet" }
same_parrot = Bird.where(color: "green").first_or_create! { |bird| bird.name = "parakeet" }
Bird.where(color: "green").first_or_create! { |bird| bird.pirate_id = 1 }
bird = Bird.find_or_create_by(name: "bob")
find_by_mock = -> (*) do
bird = Bird.create_with(color: "green").find_or_create_by(name: "bob")
bird = Bird.find_or_create_by(name: "bob") do |record|
Subscriber.create_or_find_by!(nick: "bob", name: "the cat")
hens = Bird.where(name: "hen")
relation = Post.where(author_id: 1).order("id ASC").limit(1)
assert_equal Post.all.sort_by(&:id), all_posts.sort_by(&:id)
assert_equal all_posts.sort_by(&:id), relation.scoping { Post.except(:where, :order, :limit).sort_by(&:id) }
tag1 = Tag.create(name: "Foo")
tag2 = Tag.create(name: "Foo")
scope = Post.having("")
scope = Post.includes(:comments).order({ "comments.label": :ASC })
scope = Post.includes(:comments).order({ "posts.title": :ASC })
scope = Post.where(comments: { body: "Bla" })
scope = Post.where("comments.body" => "Bla")
scope = Post.where.not(comments: { body: "Bla" })
scope = Post.where.not("comments.body" => "Bla")
scope = Post.having(comments: { body: "Bla" })
scope = Post.having("comments.body" => "Bla")
post = nil
assert sql_log.any? { |sql| /order by/i.match?(sql) }, "ORDER BY was not used in the query: #{sql_log}"
assert sql_log.all? { |sql| !/order by/i.match?(sql) }, "ORDER BY was used in the query: #{sql_log}"
assert_difference("Post.count", -3) { david.posts.delete_by(body: "hello") }
assert_equal posts(:eager_other), Post.order(:id).find_by("author_id = ?", 2)
assert_nil Post.all.find_by("1 = 0")
assert_sql(/^((?!ORDER).)*$/) { Post.all.find_by(author_id: 2) }
assert_equal posts(:eager_other), Post.order(:id).find_by!("author_id = 2")
assert_equal posts(:eager_other), Post.order(:id).find_by!("author_id = ?", 2)
assert_sql(/^((?!ORDER).)*$/) { Post.all.find_by!(author_id: 2) }
Post.all.find_by!("1 = 0")
assert_sql(%r(/\* loading for inspect \*/)) do
assert_equal 10, out.string.scan(/#<\w*Post:/).size
assert_sql(%r(/\* loading for pp \*/)) do
test "#load" do
p1 = Post.where(id: 1)
p2 = Post.where(id: 2)
p0 = Post.where(author_id: 0)
posts = Post.where(author: authors(:mary), text: "hullo").order(:id)
comments = comments.unscope(where: { posts: :id })
5.times do |idx|
Post.create!(title: idx.to_s, body: idx.to_s)
third_post = posts.find_by(title: "3")
assert_equal({}, value)
assert_equal({ "id" => 10 }, relation.where_values_hash)
assert_equal({ "hello" => "world" }, relation.scope_for_create)
assert_equal({ "id" => 10 }, relation.scope_for_create)
assert_equal({ "hello" => "world", "id" => 10 }, relation.scope_for_create)
assert_equal({ "name" => :lol }, relation.where_clause.to_h)
nb_inner_join = queries.sum { |sql| sql.scan(/INNER\s+JOIN/i).size }
post = Post.create!(title: "haha", body: "huhu")
selected = Post.select(:join).from(Post.select("id as #{quoted_join}")).map(&:join)
assert_equal({ 2 => 1, 4 => 3, 5 => 1 }, authors(:david).posts.merge(posts_with_special_comments_with_ratings).count)
assert_match %r{= 1 /\* foo \*/}, post_with_annotation.to_sql
assert_sql(%r{/\* foo \*/}) do
assert_sql(%r{/\* foo \*/ /\* bar \*/}) do
post_with_annotation = Post.where(id: 1).annotate("**//foo//**")
assert_includes post_with_annotation.to_sql, "= 1 /* ** //foo// ** */"
assert_predicate log.select { |query| query.match?(%r{/\*}) }, :empty?
post_with_hint = Post.where(id: 1).optimizer_hints("**//BADHINT//**")
assert_includes post_with_hint.to_sql, "/*+ ** //BADHINT// ** */"
post_with_hint = Post.where(id: 1).optimizer_hints("/*+ BADHINT */")
assert_includes post_with_hint.to_sql, "/*+ BADHINT */"
cte_options = {
.with(posts_with_tags: Post.where("tags_count > 0"))
posts = Post.where(id: "1-foo")
joined.each { |post|
author.id = 1
parent.id = 1
hidden.id = 2
car = cars(:honda)
thing.id = 1
Post.where(id: { "posts.author_id" => 10 }).first
assert_equal post, Post.where(posts: { "id" => post.id }).first
assert_equal a + (b + c), (a + b) + c
assert_not_equal a + b, b + a
wcs = (0..9).map do |i|
actual = wc.except("id1", "id2", "id4", "id7", "id8")
Arel::Nodes::Grouping.new(Arel.sql("foo = bar")),
assert_equal common_or + new_or, a.or(b)
h = Hash.new(0)
relation = Post.where(body: "hello").where(body: "world").rewhere(body: "hullo")
relation = Post.where(body: "hello").where(type: "StiPost").rewhere(body: "hullo", type: "Post")
expected = Post.where(body: "hullo", type: "Post")
relation = Post.where(body: "hello").where(type: "Post").rewhere(body: "hullo")
relation = Post.where(text: "hello").where(text: "world").rewhere(text: "hullo")
posts.each { |post| assert_equal "rofl", post.title }
assert posts.all? { |post| "ig" == post.title }
pets = Pet.joins(:toys).where(toys: { name: "Bone" })
pets = Pet.left_joins(:toys).where(toys: { name: "Bone" })
pets = Pet.includes(:toys).where(toys: { name: "Bone" })
Pet.joins(:toys).where(toys: { name: "Bone" }).update_counters(integer: 1)
topic = Topic.create!(title: "Foo", author_name: nil)
expected.map! { |version| version + 1 }
Author.order(order).update_all("id = id + 1")
left = Post.where(id: 1)
right = Post.where(id: 2)
left = Post.distinct.where("id = 1")
left = Post.order("body asc").where("id = 1")
left = Post.order("body asc").where("id = 1").unscope(:order)
right = Post.order("body asc").where("id = 2")
post = Post.select(:title, posts: { title: :post_title }).take
Post.select(posts: { boo: :post_title }).take
Post.select(posts: { "UPPER(title)" => :post_title }).take
post = Post.joins(:comments).select(:title, posts: { title: :post_title }, comments: { body: :comment_body }).take
expected = Post.select(:title, posts: { title: :post_title }).to_sql
actual = Post.select(:title, :body).reselect(:title, posts: { title: :post_title }).to_sql
posts = Post.select("posts.id * 1.1 AS foo").eager_load(:comments)
assert_match %r{#{Regexp.escape(topic_title)} ~ 'rails'}i, Topic.where(title: /rails/).to_sql
assert_match %r{#{Regexp.escape(topic_title)} ~ 'rails'}i, Reply.joins(:topic).where(topics: { title: /rails/ }).to_sql
expected = Post.where("id = 1 or id = 2").to_a
assert_equal expected, Post.where("id = 1").or(Post.where("id = 2")).to_a
expected = Post.where("id = 1").to_a
assert_equal expected, Post.where("id = 1").or(Post.where("id = 1")).to_a
expected = Post.where("id = 1 or id = 2 or id = 3").order("body asc").to_a
expected = Post.where("id = 1 or id = 2")
partial = Post.where("id = 1 and id != 2")
partial = Post.where(id: 1).where.not(id: 2)
expected = Post.where("id = 1 or id = 2").sort_by(&:id)
assert_equal expected, Post.order("body asc").where("id = 1").unscope(:order).or(Post.where("id = 2")).sort_by(&:id)
assert_equal expected, Post.order(:id).where("id = 1").or(Post.order(:id).where("id = 2").unscope(:order)).sort_by(&:id)
Post.order("body asc").where("id = 1").unscope(:order).or(Post.order("body asc").where("id = 2")).to_a
groups = Post.where("id < 10").group("body")
expected = groups.having("COUNT(*) > 1 OR body like 'Such%'").count
expected = Post.where("id = 1 or body LIKE '\%a\%'").to_a
expected = Post.where("body LIKE '\%a\%' OR title LIKE ?", "%'%").order("id DESC").to_a
p = Post.where("id = 1")
assert_equal expected, p.or(Post.where("id = 2")).to_a
actual = joined.where(authors: { id: 1 })
assert_match %r{#{quoted_posts} /\* foo \*/\z}, Post.annotate("foo").or(Post.all).to_sql
assert_match %r{#{quoted_posts} /\* foo \*/\z}, Post.annotate("foo").or(Post.annotate("foo")).to_sql
assert_match %r{#{quoted_posts} /\* foo \*/\z}, Post.annotate("foo").or(Post.annotate("bar")).to_sql
assert_match %r{#{quoted_posts} /\* foo \*/ /\* bar \*/\z}, Post.annotate("foo", "bar").or(Post.annotate("foo")).to_sql
Post.from("posts").or(Post.from("posts"))
Paragraph.where(id: i, book_id: i * i)
test "##{method}!" do
test "#_select!" do
test "#order!" do
test "#from!" do
test "#lock!" do
test "#reorder!" do
test "merge!" do
test "none!" do
test "#regroup!" do
david, mary, bob = authors = authors(:david, :mary, :bob)
david, mary, bob = authors(:david, :mary, :bob)
assert_sql(/WHERE #{Regexp.escape(author_id)} NOT IN \((\?|\W?\w?\d), \g<1>\)\z/) do
only_david = Author.where("#{author_id} IN (?)", david)
assert_sql(/WHERE \(#{Regexp.escape(author_id)} IN \('1'\)\)\z/) do
assert_sql(/WHERE \(#{Regexp.escape(author_id)} IN \(1\)\)\z/) do
devs = Developer.where("salary >= 80000").merge(Developer.limit(2)).merge(Developer.order("id ASC").where("id < 3"))
assert_match(/.?post_id.? = #{post.id}\z/i, sql)
right = Post.where(title: "wtf").where(title: "bbq")
right = Post.where(id: 1)
relation = Post.all.merge(Post.order(Arel.sql("title LIKE '%?'")))
assert_sql(%r{/\* bar \*/ /\* foo \*/}) do
assert_sql(%r{/\* foo \*/ /\* bar \*/ /\* baz \*/ /\* qux \*/}) do
assert_sql(%r{FROM #{Regexp.escape(Post.quoted_table_name)} /\* foo \*/\z}) do
assert_sql(%r{FROM #{Regexp.escape(Post.quoted_table_name)} /\* foo \*/ /\* bar \*/\z}) do
assert_sql(%r{FROM #{Regexp.escape(Post.quoted_table_name)} /\* bar \*/ /\* foo \*/\z}) do
hello_by_bob = Post.where(body: "hello").joins(:author).
merge(Author.where(name: "Bob")).order("posts.id").pluck("posts.id")
where.not("authors.name": "David").
callback = -> (event) do
dog_status = {}
posts = Post.in_order_of(:id, order)
posts = Post.in_order_of(Arel.sql("id * 2"), order.map { |id| id * 2 })
posts = Post.where(type: "Post").order(:type).in_order_of(:id, order)
posts = Post.where(type: "Post").order(:type).in_order_of("id", order)
bob = Author.create(name: "Bob")
davids = Author.where(name: "David").from("#{Author.quoted_table_name} /*! USE INDEX (PRIMARY) */")
pets = Pet.joins(:toys).where("toys.name = ?", "Bone")
:all?, :collect, :compact, :detect, :each, :each_cons, :each_with_index,
:exclude?, :find_all, :flat_map, :group_by, :include?, :length,
:map, :none?, :one?, :partition, :reject, :reverse, :rotate,
:sample, :second, :sort, :sort_by, :slice, :third, :index, :rindex,
:to_ary, :to_set, :to_xml, :to_yaml, :join,
:in_groups, :in_groups_of, :to_sentence, :to_formatted_s, :to_fs, :as_json
method.end_with?("=", "!", "?", "value", "values", "clause")
:any?, :many?, :none?, :one?,
:create_or_find_by, :create_or_find_by!,
hash = { "id" => 123 }
:has_many,
:balance, nil, { class_name: "Money", mapping: %w(balance amount) }, Customer
:gps_location, nil, {}, Customer
:firm,
class_name: "Firm",
exit!(1)
conn = nil
dev.name = "Forbidden."
Developer.joins(", projects").each { |d| assert_not d.readonly? }
@quoter = Class.new {
}.new
assert_equal "''", @quoter.quote_string("'")
assert_equal "\\\\", @quoter.quote_string("\\")
assert_equal "hi''i", @quoter.quote_string("hi'i")
assert_equal "hi\\\\i", @quoter.quote_string("hi\\i")
t = Time.now.change(usec: 0)
expected = t.change(year: 2000, month: 1, day: 1)
expected = expected.getlocal.to_fs(:db).sub("2000-01-01 ", "")
t = Time.new(2000, 7, 1, 0, 0, 0, "+04:30")
float = 1.2
bignum = 1 << 100
bigdec = BigDecimal((1 << 100).to_s)
assert_equal "'lo\\\\l'", @quoter.quote('lo\l')
assert_equal "'lo\\\\l'", @quoter.quote(string)
assert_sql(%r{/\*application:active_record\*/}) do
dash.name = "New name"
assert_sql("SELECT 1 /*query_counter:1*/") do
assert_sql(%r{/\*application='active_record'\*/}) do
{ custom_proc: -> { "test content" }, another_proc: -> { "more test content" } },
{ tracestate: "congo=t61rcWkgMzE,rojo=00f067aa0ba902b7", custom_proc: -> { "Joe's Shack" } },
{ custom_proc: -> { 1234 } },
assert_sql(%r{custom_proc='1234'\*/}) do
@logger = ::Logger.new File::NULL
@events << event
mw = middleware { |env|
Post.create!(title: "a new post", body: "and a body")
mw.call({})
assert_raises(RuntimeError) { mw.call({}) }
if Process.respond_to?(:fork) && !in_memory_db?
rd, wr = IO.pipe
pid = fork {
status = 0
status = 1
}.call({})
if !$?.success?
assert_queries(2) { Task.find(1); Task.find(1) }
assert_queries(1) { Task.find(1); Task.find(1) }
assert_queries(2) { Task.find(1); Task.find(1); Task.find(2) }
assert_queries(2) { Task.find(1); Task.find(2) }
assert_no_queries { Task.find(1); Task.find(1); Task.find(2) }
assert_queries(1) { Topic.find(1); Topic.find(1) }
assert_queries(2) { task.lock!; task.lock! }
lambda { |env| executor.wrap { app.call(env) } }
JsonObj.create(payload: { a: 1 })
search.merge!(b: 2)
task = Task.find(1)
Task.cache { Task.insert({ starting: Time.now }) }
Task.cache { Task.insert!({ starting: Time.now }) }
Task.cache { Task.upsert({ starting: Time.now }) }
p = Post.find(1)
id = topic.id
k.table_name = "bar"
k.primary_key = "foo"
dashboard.id = "2"
assert_match %r/create_table "barcodes", primary_key: "code", id: { type: :string, limit: 42 }/, schema
column = @connection.columns(:widgets).find { |c| c.name == "id" }
assert_match %r{create_table "widgets", id: :#{@pk_type}, }, schema
assert_match %r/create_table "widgets", id: { type: :bigint, unsigned: true }/, schema
@timed_out = 0
@timed_out += 1
topic_data = { 1 => { "content" => "1 updated" }, 2 => { "content" => "2 updated" } }
{ "content" => "1 duplicated" }, { "content" => "1 updated" }, { "content" => "2 updated" }
topic_data = { 1 => { "content" => "1 updated" }, 2 => { "content" => "2 updated" }, 99999 => {} }
Topic.update!(Topic.first, "content" => "1 updated")
topic = Topic.build("title" => "New Topic") do |t|
t.author_name = "David"
topic.attributes = { "title" => "null", "author_name" => "null" }
topic = Topic.create("title" => "New Topic") do |t|
topic.written_on = "2003-12-12 23:23:00"
@counter ||= 0
@counter += 1
Topic.where("1=0").scoping { topic.delete }
t = klass.create(title: "New Topic", author_name: "Not David")
topic.update_column("content", "--- Have a nice day\n...\n")
topic.update_column(:content, "--- You too\n...\n")
new_name = "sebavan"
t = Topic.order("id").limit(1).first
topic.update("content" => "--- Have a nice day\n...\n", :author_name => "Jose")
topic.update_columns(content: "--- You too\n...\n", "author_name" => "Sebastian")
topic.update_columns(content: "--- Have a nice day\n...\n", author_name: "Jose")
topic.update("approved" => true, "title" => "The First Topic Updated")
topic.update(id: 3, title: "Hm is it possible?")
topic.update({})
reply.update!("title" => "The Second Topic of the day updated", "content" => "Have a nice evening")
should_be_destroyed_reply = Reply.create("title" => "hello", "content" => "world")
should_not_be_destroyed_reply = Reply.create("title" => "hello", "content" => "world")
Topic.where("1=0").scoping { Topic.destroy(1) }
Topic.where("1=0").scoping { Topic.delete(1) }
post = Post.select("posts.*, 1 as wibble").last!
post.id = 1
name: "Bob",
parrot.name = "Barb"
assert_match(/WHERE .*#{column}/, sql)
normalizes :name, with: -> name { name.titlecase }
@time = Time.utc(1999, 12, 31, 12, 34, 56)
normalizes :name, with: -> name { name&.titlecase || "Untitled" }, apply_to_nil: true
normalizes :name, with: -> name { name.reverse }
normalizes :name, with: -> name { name.succ }
aircraft.name = "0"
class_name: "Bird",
before_add: proc { |p, b|
@@add_callback_called << b
before_add: proc { |p, b| @@add_callback_called << b })
@birds.map do |bird|
{ "name" => "New Bird" },
pirate.update(ship_attributes: { "_destroy" => true, :id => ship.id })
pirate.ship_attributes = { name: "Red Pearl", _reject_me_if_new: true }
pirate.update(ship_attributes: { name: "s2", id: ship.id })
pirate.ship_attributes = { name: "Ship 1" }
pirate.ship_attributes = { name: "Ship 1", pirate_id: pirate.id + 1 }
human = Human.create(name: "Jon")
pirate = Pirate.create!(catchphrase: "Stop wastin' me time", ship_attributes: { name: "White Pearl", _destroy: "1" })
pirate.update!(ship_attributes: { id: pirate.ship.id, name: "The Golden Hind", _destroy: "1" })
pirate.update!(ship_attributes: { id: pirate.ship.id, name: "Black Pearl", _destroy: "1" })
pirate.ship_attributes = { id: "" }
).find_or_create_by!(
name: "Monkey D. Luffy"
@pirate.reload.ship_attributes = { name: "Davy Jones Gold Dagger", _destroy: "1" }
@pirate.reload.ship_attributes = { "id" => @ship.id, "name" => "Davy Jones Gold Dagger" }
@ship.stub(:id, "ABC1X") do
@pirate.ship_attributes = { id: @ship.id, name: "Davy Jones Gold Dagger" }
@pirate.update(ship_attributes: { id: @pirate.ship.id, _destroy: "1" })
@pirate.update(catchphrase: "Arr", ship_attributes: { id: @ship.id, name: "Mister Pablo" })
@pirate.attributes = { ship_attributes: { id: @ship.id, _destroy: "1" } }
@ship.reload.pirate_attributes = { catchphrase: "Arr", _destroy: "1" }
@ship.reload.pirate_attributes = { "id" => @pirate.id, "catchphrase" => "Arr" }
@pirate.stub(:id, "ABC1X") do
@ship.pirate_attributes = { id: @pirate.id, catchphrase: "Arr" }
@ship.update(pirate_attributes: { id: @ship.pirate.id, _destroy: "1" })
@ship.attributes = { pirate_attributes: { :id => pirate.id, "_destroy" => true } }
:catchphrase => "Arr",
association_getter => { "foo" => { name: "Grace OMalley" } })
@child_1.stub(:id, "ABC1X") do
@child_2.stub(:id, "ABC2X") do
{ id: @child_1.id, name: "Grace OMalley" },
{ id: @child_2.id, name: "Privateers Greed" }
association_getter => { "foo" => { name: "Grace OMalley" }, "bar" => { name: "Privateers Greed" } }
@pirate.public_send(association_setter, "foo" => { "_destroy" => "0" })
association_getter => { "foo" => { id: @child_1.id, name: "Grace OMalley" } })
human = Human.create!(name: "John",
@pirate.attributes = { parrots_attributes: { foo: { name: "Lovely Day" }, bar: { name: "Blown Away" } } }
@child_1, @child_2 = @pirate.birds
@child_1, @child_2 = @pirate.parrots
@pirate.attributes = { parrots_attributes: { "foo" => { name: "Big Big Love" } } }
@pirate.attributes = { parrots_attributes: { "foo" => { name: "Lovely Day" }, "bar" => { name: "Blown Away" } } }
@pirate.attributes = { parrots_attributes: { "foo" => { name: "Lovely Day" },
@pet1, @pet2 = pets(:chew), pets(:mochi)
@params = {
@pet1 = pets(:chew)
attributes = { pets_attributes: { "1" => { id: @pet1.id,
name: "Foo2",
_destroy: true } } }
@part = @ship.parts.create!(name: "Mast")
assert_difference("@part.trinkets.count", -1) { @ship.save }
ship = Ship.new(name: "The Black Rock")
part = ShipPart.new(name: "Stern", ship_attributes: { name: nil })
c1 = Course.find(1)
c2 = Course.find(2)
e1 = Entrant.find(1)
e2 = Entrant.find(2)
e3 = Entrant.find(3)
c1.name = "Typo"
e1.name = "Typo"
raise "No I messed up."
attributes = { "last_read(1i)" => "2004", "last_read(2i)" => "6", "last_read(3i)" => "24" }
attributes = { "last_read(1i)" => "", "last_read(2i)" => "6", "last_read(3i)" => "24" }
attributes = { "last_read(1i)" => "2004", "last_read(2i)" => "", "last_read(3i)" => "24" }
attributes = { "last_read(1i)" => "2004", "last_read(2i)" => "6", "last_read(3i)" => "" }
attributes = { "last_read(1i)" => "", "last_read(2i)" => "6", "last_read(3i)" => "" }
attributes = { "last_read(1i)" => "2004", "last_read(2i)" => "", "last_read(3i)" => "" }
attributes = { "last_read(1i)" => "", "last_read(2i)" => "", "last_read(3i)" => "24" }
attributes = { "last_read(1i)" => "", "last_read(2i)" => "", "last_read(3i)" => "" }
assert_equal Time.utc(2004, 6, 24, 16, 24, 0), topic.written_on
assert_equal Time.utc(2004, 6, 24, 23, 24, 0), topic.written_on
topic = Topic.new("bonus_time(4i)" => "01", "bonus_time(5i)" => "05")
topic = Topic.new("written_on(1i)" => "1952", "written_on(2i)" => "3", "written_on(3i)" => "11")
topic = Topic.create_with("written_on(1i)" => "1952", "written_on(2i)" => "3", "written_on(3i)" => "11").new
Topic.new("written_on(4i)" => "13", "written_on(5i)" => "55")
address = Address.new("The Street", "The City", "The Country")
attributes = { "address(1)" => address.street, "address(2)" => address.city, "address(3)" => address.country }
attributes = { "address(3)" => address.country, "address(2)" => address.city, "address(1)" => address.street }
attributes = { "address(2)" => address.city, "address(3)" => address.country }
attributes = { "address(1)" => "", "address(2)" => address.city, "address(3)" => address.country }
attributes = { "address(1)" => "The Street", "address(2)" => address.city, "address(3000)" => address.country }
@went_up = false
def up; @went_up = true; end
def down; @went_down = true; end
def puts(*)
_, migrator_a = migrator_class(3)
_, migrator_b = migrator_class(2)
_, migrator_b = migrator_class(3)
define_method(:up) { yield(:up, x); super() }
define_method(:down) { yield(:down, x); super() }
}) if block_given?
m(nil, i + 1) { |c, migration|
define_method(:migrations) { |*|
@undefined_consts = {}
assert pass_two.all? { |x| !x.went_down }
Sensor.new("Two", 2),
assert migrations.all? { |m| !m.went_down }
assert migrations.all? { |m| !m.went_up }
_, migrations = sensors(3)
result = migrator.run(:up, 1)
long_name = "a" * (name_limit + 1)
short_name = "a" * name_limit
def create_table; "hi mom!"; end
@went_up = true
assert Reminder.create("content" => "hello world", "remind_at" => Time.now)
data_column = columns.detect { |c| c.name == "data" }
t.column :foo, :bar
AND state = 'idle'
@connection.create_table(:delete_me, force: true) { |t| }
}.fetch(classname) {
t.string :name, default: -> { "gen_random_uuid()" }
t.string :name, default: -> { "UUID()" }
assert_match(/\A(.+)-(.+)-(.+)-(.+)\Z/, person_data.fetch("name"))
@columns = @indexes = nil
columns.detect { |c| c.name == name.to_s }
indexes.detect { |i| i.name == name.to_s }
def write(text = ""); end
sources = {}
travel_to(Time.utc(2010, 7, 26, 10, 10, 10)) do
travel_to(Time.utc(2010, 2, 20, 10, 10, 10)) do
on_skip = Proc.new { |name, migration| skipped << "#{name} #{migration.name}" }
id_column = td.columns.find { |col| col.name == "id" }
foo_column = td.columns.find { |col| col.name == "foo" }
pk = connection.send(:column_for, :users, :id)
t.references :bar, index: { unique: true }
fk = @connection.foreign_keys("testings").find { |k| k.to_table == "testing_parents" }
filename = "#{number}_#{name.underscore}.rb"
assert_nothing_raised { CheckPending.new(proc { }).call({}) }
CheckPending.new(proc { flunk }).call({})
t.string :first_name, index: { nema: "test" }
add_index "test_models", "first_name", nema: "my_index"
too_long_index_name = good_index_name + "x"
connection.add_index("testings", "last_name", where: "first_name = 'john doe'")
connection.add_index("testings", "last_name", include: :foo, where: "first_name = 'john doe'")
assert foreign_keys.all? { |fk| fk.to_table == "rockets" }
column: "rocket_id", primary_key: "pk", name: "custom_pk")
database: ":memory:",
assert_match %r{\s+add_foreign_key "fk_test_has_fk", "fk_test_has_pk", column: "fk_id", primary_key: "pk_id"$}, output
assert_match %r{\s+add_foreign_key "fk_test_has_fk", "fk_test_has_pk", column: "fk_id", primary_key: "pk_id", name: "fk_name"$}, output
create_table("cities") { |t| }
create_table("houses") do |t|
assert_no_changes -> { column_for(:astronauts, :rocket_id).bigint? }, from: true do
t.column :foo, :string, limit: 5
column = connection.columns(:more_testings).find { |el| el.name == "testings_id" }
long_table_name = "a" * (connection.table_name_length + 1)
{ precision: 0 }
{ precision: nil }
class V5_2 < V6_0
class V5_1 < V6_0
class V5_0 < V6_0
class V4_2 < V6_0
assert_match %r{create_table "legacy_primary_keys", id: :(?:integer|serial), (?!default: nil)}, schema
}.new)
def foo(kw:)
assert_equal "bar", recorder.foo(kw: "bar")
tables = @recorder.commands.map { |_cmd, args, _block| args }
block = Proc.new { |t| t.string :name }
block = Proc.new do |t|
block = Proc.new { }
rename_column "test_models", "id", "id_test"
rename_column "test_models", "id_test", "id"
assert old_columns.find { |c| c.name == "age" && c.type == :integer }
assert_not new_columns.find { |c| c.name == "age" && c.type == :integer }
assert new_columns.find { |c| c.name == "age" && c.type == :string }
c.name == "approved" && c.type == :boolean && default == true
c.name == "approved" && c.type == :boolean && default == false
t.string "col_two", limit: 128, null: false
remove_column("my_table", "col_two")
rename_column("my_table", "col_one", "col_three")
string = "foo\nbar"
add_column "test_models", "bio", :text
add_column "test_models", "wealth", :decimal, precision: "30", scale: "10"
bio: "I was born ....", age: 18, height: 1.78,
moment_of_truth: "1782-10-10 21:40:18", male: true
assert_equal "I was born ....", bob.bio
t.integer :foo, :bar
t.bigint :foo, :bar
t.string :foo, :bar
t.json :foo, :bar
t.xml :foo, :bar
t.remove :bar, :baz
t.remove :bar, :baz, type: :string, null: false
t.rename :bar, :baz
t.column :one, :string, default: "hello"
one = columns.detect { |c| c.name == "one" }
two = columns.detect { |c| c.name == "two" }
three = columns.detect { |c| c.name == "three" }
four = columns.detect { |c| c.name == "four" }
five = columns.detect { |c| c.name == "five" } unless mysql
array_column = columns.detect { |c| c.name == "foo" }
foo = columns.detect { |c| c.name == "foo" }
default = columns.detect { |c| c.name == "default_int" }
created_at_column = created_columns.detect { |c| c.name == "created_at" }
updated_at_column = created_columns.detect { |c| c.name == "updated_at" }
connection.execute("insert into testings (#{quoted_id}, #{quoted_foo}) values (1, 'hello')")
connection.execute("insert into testings (#{quoted_id}, #{quoted_foo}, #{quoted_bar}) values (2, 'hello', NULL)")
column = connection.columns(:testings).find { |c| c.name == "foo" }
assert_equal false, connection.columns(:testings).find { |c| c.name == "foo" }.null
assert connection.columns(:testings).find { |c| c.name == "foo" }.null
logger.sql(Event.new(0.9, sql: "hi mom!"))
logger.sql(Event.new(0.9, sql: "hi mom!", name: "foo"))
logger.sql(Event.new(0.9, sql: "hi mom!", name: "SCHEMA"))
logger.sql(Event.new(0.9, sql: verb.to_s))
logger.sql(Event.new(0.9, sql: verb.to_s, name: "SQL"))
logger.sql(Event.new(0.9, sql: verb.to_s, name: "Model Load"))
logger.sql(Event.new(0.9, sql: verb.to_s, name: "Model Exists"))
logger.sql(Event.new(0.9, sql: "SELECT * from models", name: "Model Load", async: true, lock_wait: 0.01))
logger.sql(Event.new(0.9, sql: sql))
logger.sql(Event.new(0, sql: "hi mom!"))
Binary.create(data: { a: 1 })
p1 = Person.find(1)
p2 = Person.find(1)
p1.first_name = "stu"
p2.first_name = "sue"
p2.first_name = "sue2"
p1 = Person.new(first_name: "anika")
p2 = Person.find(p1.id)
p1 = Person.new(first_name: "mira")
p1.first_name = "mira2"
p1.first_name = "mira3"
person.id = 2
t1.title = "new title1"
t2.title = "new title2"
assert_queries(1) { t1.update(title: "title2") }
assert_queries(1) { t2.save! }
p1 = Person.create!(first_name: "anika")
counter_test model, -1 do |id|
p1 = Person.new(first_name: "fjord")
frog = ::Frog.create(name: "Old Frog")
frog.name = "New Frog"
first, second = duel { Person.find 1 }
def duel(zzz = 5, &block)
t0, t1, t2, t3 = nil, nil, nil, nil
t0 = Time.now
t1 = Time.now
t2 = Time.now
t3 = Time.now
assert t1 > t0 + zzz
assert_match(/t\.#{column_type}\s+"settings"/, output)
x = klass.new(payload: { "string" => "foo", :symbol => :bar })
assert_equal({ "string" => "foo", :symbol => :bar }, x.payload_before_type_cast)
assert_equal({ "string" => "foo", "symbol" => "bar" }, x.payload)
assert_equal({ "string" => "foo", "symbol" => "bar" }, x.reload.payload)
data = '{"a_key":"a_value"}'
assert_equal({ "a_key" => "a_value" }, hash)
assert_equal({ "a_key" => "a_value" }, type.deserialize(data))
assert_equal({}, type.deserialize("{}"))
assert_equal({ "key" => nil }, type.deserialize('{"key": null}'))
x.payload = { '"a\'' => "b" }
assert_equal({ "k" => "v" }, x.payload)
json = klass.create!(payload: "foo")
y = x.dup
json.payload = { "one" => "two" }
assert_equal({ "one" => "two", "three" => "four" }, json.payload)
json.payload = { "three" => "four", "one" => "two" }
new_klass.create!(settings: MySettings.new("one" => "two"))
assert_equal({ "one" => "two" }, record.settings.to_hash)
assert_equal({ "three" => "four" }, record.reload.settings.to_hash)
PP.pp(x, io)
assert_match %r(\A#{native_type}\b), sql_type
age: 16,
preferences: { "shows" => "anime" }
assert_match %r{^\{"namespaced_contact":\{}, json
assert_match %r{^\{"contact":\{}, json
assert_match %r{"age":16}, json
assert_match %r{"preferences":\{"shows":"anime"\}}, json
assert_no_match %r{"preferences":\{"shows":"anime"\}}, json
assert_no_match %r{"age":16}, json
super({ only: %w(name) }.freeze)
super(only: %w(name))
super(except: %w(age))
super({ except: %w(age) }.merge!(options))
options = { only: :name }.freeze
@mary = authors(:mary)
assert_match %r{"id":1}, json
assert_match %r{"name":"David"}, json
assert_match %r{"author_id":1}, json
assert_match %r{"body":"Such a lovely day"}, json
assert_match %r{"title":"So I was thinking"}, json
json = @david.to_json(include: { posts: { only: :title } })
assert_no_match %r{"body":"Such a lovely day"}, json
json = @david.to_json(include: { posts: { include: { comments: { only: :body } } } })
assert_match %r{\{"body":"Thank you again for the welcome"\}}, json
assert_match %r{\{"body":"Don't think too hard"\}}, json
assert_no_match %r{"post_id":}, json
json = @david.to_json(
include: {
posts: {
tag: { only: :name }
assert_match %r{"tag":\{"name":"General"\}}, json
only: :id,
only: :name,
posts: { only: :id }
authors_hash = {
1 => @david,
2 => @mary
def write(text = "")
create_table("horses") do |t|
change_table("horses") do |t|
create_table("new_horses") do |t|
revert { super }
up_only { execute "update horses set oldie = 1" }
migration.test = ->(dir) {
client.id = 1
firm = Firm.find(4)
firm.name << ", Inc."
firm.name = "Huey, Dewey, & Louie LLC"
firm.name = "a " * 100
assert_equal "4-a-a-a-a-a-a-a-a-a-a", firm.to_param
firm.name = "ab \n" * 100
firm.name = " "
assert_match(/\/#{dev.id}$/, dev.cache_key)
id = 1_000_000
Book.insert({ id: id, name: "Rework", author_id: 1 })
Book.upsert({ id: id, name: "Remote", author_id: 1 })
Book.insert!({ name: "Rework", author_id: 1 })
{ name: "Rework", author_id: 1 },
{ name: "Design of Everyday Things", author_id: 1 },
{ name: "Clean Code", author_id: 1 },
{ name: "Ruby Under a Microscope", author_id: 1 },
{ name: "Peopleware", author_id: 1 },
{ name: "About Face", author_id: 1 },
{ name: "Eloquent Ruby", author_id: 1 },
{ name: "Agile Web Development with Rails", author_id: 1 },
{ author_id: 8, name: "Refactoring" },
{ author_id: 8, name: "Refactoring" }
{ id: 200, author_id: 8, name: "Refactoring" },
{ id: 201, author_id: 8, name: "Refactoring" }
Book.insert({ author_id: 8, name: "Refactoring", format: "UNEXPECTED" })
book = Book.create!(external_id: "abc")
Book.insert({ name: "Rework", author_id: 1 })
Book.upsert({ name: "Remote", author_id: 1 })
has_subsecond_precision = (1..100).any? do |i|
Book.find(101 + i).created_at.usec > 0
travel_to(Date.new(2016, 4, 17)) { Ship.create! id: 101, name: "RSS Boaty McBoatface" }
{ city_id: "2", logdate: 2.days.ago, peaktemp: 2, unitsales: 2 },
on_duplicate: Arel.sql("status = #{operator}(books.status, 1)")
firm = Company.new(type: "Firm")
firm = Company.where(type: "Firm").create!(name: "Basecamp")
path = File.expand_path("../models/autoloadable", __dir__)
Client.update_all "name = 'I am a client'"
assert_equal 1, Client.all.merge!(where: "name = 'Summit'").to_a.size
assert_sql(/#{Regexp.escape(c.quote_table_name("companies.id"))} = (?:#{Regexp.escape(bind_param.to_sql)}|1)/i) do
assert_nothing_raised { s = SpecialSubscriber.new("name" => "And breaaaaathe!"); s.id = "roger"; s.save }
phone = Shop::Product::Type.new(name: "Phone")
if value =~ /\Aomg_(.+)\z/
record = @klass.create! foo: "foo"
record.foo = "bar"
record = @klass.create! bar: "bar"
sicp = Lesson.new(name: "SICP")
lesson = Lesson.new(name: "SICP")
person = Person.new(first_name: "Guille", gender: "m")
def call(_, _, _, _, values)
expected_sql = <<~EOS.chop
fixtures = {
{ "name" => "working_aircrafts", "wheels_count" => 2 },
{ "name" => "broken_aircrafts", "wheels_count" => nil },
{ "post_id" => 1, "body" => "a" * 450 },
{ "post_id" => 1, "body" => "a" * 200 },
{ "name" => "first", "wheels_count" => 2 },
{ "name" => "second", "wheels_count" => 3 }
badyaml.write "a: : "
first = Task.find(1)
assert_equal "fixture_no_#{i}", name
fixture_id > _max_id ? fixture_id : _max_id
@first = true
topic.title = "omg"
last = nil
last ||= current
:'admin/randomly_named_a9' =>
two: { writing: :default, reading: :readonly }
two: { writing: :default }
{ "default" => default_config, "readonly" => readonly_config }
{ "adapter" => "sqlite3", "database" => "test/fixtures/fixture_database.sqlite3" }
devs = Array.new(8) { |i| "dev_#{i + 3}" }
File.open(t.path) { |fh| fh.to_a }
File.open(t.path) { |fh| fh.model_class }
assert_equal golden, File.open(t.path) { |fh| fh.to_a }
File: <%= File.name %>
yaml1 = "<% def leaked_method; 'leak'; end %>\n"
File.open(t1.path) { |fh| fh.to_a }
File.open(t2.path) { |fh| fh.to_a }
Post.find_by_title_and_id("foo", limit: 1)
Topic.all.find(-> { raise "should happen" }) { |e| e.title == "non-existing-title" }
Topic.all.find(-> { raise "should not happen" }) { |e| e.title == topics(:first).title }
records = Topic.find(4, 2, 5)
records = Topic.find("4", "2", "5")
Post.where("title" => { "xxxqqqq" => "bar" })
authors = Author.includes(:posts).where(name: "David", posts: { id: post.id })
bob = authors(:bob)
assert_equal false, Author.select("COUNT(*) as total_posts", "authors.*").joins(:posts).group(:id).having("total_posts > 2").include?(bob)
assert_equal true, Author.select("COUNT(*) as total_posts", "authors.*").joins(:posts).group(:id).having("total_posts > 2").include?(mary)
assert_sql(/^((?!ORDER).)*$/) { Topic.find(1) }
Topic.where("author_name = 'Carl'").sole
Topic.find_sole_by("author_name = 'Carl'")
assert Topic.where("topics.approved" => false, topics: { author_name: "David" }).find(1)
assert_kind_of Firm, Company.where("name = '%s'", "37signals").first
Company.create("name" => "Ain't noth'n like' \#stuff")
p1, p2 = Post.limit(2).order("id asc").to_a
dog_alias = "Dog"
a = Account.where("firm_id = ?", 6).find_by_credit_limit(50)
assert_equal accounts(:unknown), Account.order("id DESC").where("id != ?", 3).find_by_credit_limit(50)
first = Firm.
Post.create!(title: "test", body: "it out")
Company.connection.select_rows("SELECT id, firm_id, client_of, name FROM companies WHERE id IN (1,2,3) ORDER BY id").map! { |i| i.map! { |j| j.to_s unless j.nil? } })
Company.connection.select_rows("SELECT id, name FROM companies WHERE id IN (1,2,3) ORDER BY id").map! { |i| i.map! { |j| j.to_s unless j.nil? } }
where.not(author_addresses: { id: nil }).
map(&:client_of)
includes: :author, select: 'posts.*, authors.id as "author_id"',
limit: 3, order: "posts.id"
model.find "Hello", "World!"
assert_equal posts(:eager_other), Post.find_by("id = #{posts(:eager_other).id}")
assert_equal posts(:eager_other), Post.find_by("id = ?", posts(:eager_other).id)
assert_nil Post.find_by("1 = 0")
assert_sql(/^((?!ORDER).)*$/) { Post.find_by(id: posts(:eager_other).id) }
assert_equal posts(:eager_other), Post.find_by!("id = #{posts(:eager_other).id}")
assert_equal posts(:eager_other), Post.find_by!("id = ?", posts(:eager_other).id)
assert_sql(/^((?!ORDER).)*$/) { Post.find_by!(id: posts(:eager_other).id) }
Post.find_by!("1 = 0")
honda = cars(:honda)
zyke = cars(:zyke)
actual = "".dup
Car.where(name: "honda").to_a
expected = sqls.map { |sql| "#{expected_explain_clause} #{sql}\nquery plan #{sql}" }.join("\n")
expected = <<~SQL
SUBSCRIBER.finish(nil, nil, name: "SQL", sql: "select_db yo_mama")
SUBSCRIBER.finish(nil, nil, name: "SQL", sql: "with s as (values(3)) select 1 from s")
SUBSCRIBER.finish(nil, nil, name: "SQL", sql: "/* comment */ select 1 from users")
setup { @post = posts(:welcome) }
@book = books(:awdr)
@book.cover = :hard
@book.cover = "hard"
Book.where(id: @book.id).update_all("status = NULL")
@book.status = ""
enum(:status, {}, **{})
enum status: { "" => 1, "active" => 2 }
def self.name; "Book"; end
book = books(:tlg)
enum :status, { proposed: 0, written: 1 }, prefix: true
enum :last_read, { unread: 0, reading: 1, read: 2 }, prefix: :being
enum :cover, { hard: 0, soft: 1 }, suffix: true
enum :difficulty, { easy: 0, medium: 1, hard: 2 }, suffix: :to_read
enum :status, default: 0, scopes: 1, prefix: 2, suffix: 3
enum breed: { "American Bobtail" => 0, "Balinese-Javanese" => 1 }
written = Struct.new(:to_s).new("written")
enum status: { proposed => 0, written => 1 }
auth_tag = "some auth tag"
@properties.add(key_1: "value 1", key_2: "value 2")
baseline = -> { EncryptedBook.where("id > 0").find_by(format: "paperback") } # not encrypted
baseline = -> { encrypted_books(:awdr).created_at }
body: "<p>the Starfleet is here, we are safe now!</p>"
@serializer.load JSON.dump({ some: "other data" })
headers = { key_1: "1" }
@keys = build_keys(3)
password = "some secret #{index}"
puts "#{output}#{error}"
test "where(...).first_or_create works" do
test "exists?(...) works" do
@secret_key = "This is my secret 256 bits key!!"
text = "The Starfleet is here #{'OMG! ' * 50}!".dup.force_encoding(Encoding::ISO_8859_1)
encrypts :name, encryptor: TestEncryptor.new("1" => "2")
encrypts :name, encryptor: TestEncryptor.new("2" => "3"), previous: { encryptor: TestEncryptor.new("1" => "2") }
post.title = "You sure?"
assert_encrypted_attribute(traffic_light, :state, { "color" => "red" })
title: title = "The Starfleet is here!",
body: body = "<p>the Starfleet is here, we are safe now!</p>"
ciphertext = "{\"p\":\"DIohhw==\",\"h\":{\"iv\":\"wEPaDcJP3VNIxaiz\",\"at\":\"X7+2xvvcu1k1if6Dy28Esw==\"}}"
book.update!(name: "Dune II")
book.update!(name: "A new title!")
body = "<p>the Starfleet is here, we are safe now!</p>"
EncryptedPost.insert_all 100.times.collect { |index| { title: "Article #{index} (#{thread_label})", body: "Body #{index} (#{thread_label})" } }
topic = Topic.new("title" => "Literature")
movie = Movie.new(name: "test")
parrot.name = "Sam"
pirate.parrot_id = "0"
pirate.parrot_id = ""
params = { topic: { approved: 1 } }
assert_queries(2) { 2.times { pirate.save! } }
assert_no_queries { 2.times { pirate.save! } }
assert_queries(2) { 2.times { person.save! } }
assert_no_queries { 2.times { person.save! } }
assert_queries(1) { person.first_name = "bar"; person.save! }
10.times do |i|
pirate.catchphrase = "*hic*" * i
topic = Topic.create!(content: { "a" => "a" })
topic = Topic.create!(author_name: "Bill", content: { "a" => "a" })
written_on = Time.utc(2012, 12, 1, 12, 0, 0).in_time_zone("Paris")
topic.written_on += 0.3
time_in_paris = Time.utc(2014, 1, 1, 12, 0, 0).in_time_zone("Paris")
jon = nil
binary = klass.create!(data: "\\\\foo")
binary.data << "bar"
define_method(:changed_in_place?) do |*|
model = klass.new(first_name: "Jim")
person = Person.create!(first_name: "Sean", gender: "M")
assert_equal manufactured_at.utc.strftime("%Y-%m-%d %H:%M:%S"), aircraft.manufactured_at.strftime("%Y-%m-%d %H:%M:%S")
%w(id name course_id).each do |name|
assert_match %r/t\.date\s+"modified_date",\s+default: -> { "CURRENT_DATE" }/, output
assert_match %r/t\.datetime\s+"modified_time",\s+default: -> { "CURRENT_TIMESTAMP" }/, output
assert_match %r/t\.date\s+"modified_date",\s+default: -> { "\('now'::text\)::date" }/, output
assert_match %r/t\.datetime\s+"modified_time",\s+default: -> { "now\(\)" }/, output
assert_match %r/t\.date\s+"modified_date_function",\s+default: -> { "now\(\)" }/, output
assert_match %r/t\.datetime\s+"modified_time_function",\s+default: -> { "now\(\)" }/, output
assert_match %r/t\.binary\s+"uuid",\s+limit: 36,\s+default: -> { "\(uuid\(\)\)" }/i, output
assert_match %r/t\.datetime\s+"modified_datetime",\s+precision: nil,\s+default: -> { "CURRENT_TIMESTAMP(?:\(\))?" }/i, output
assert_match %r/t\.datetime\s+"precise_datetime",\s+default: -> { "CURRENT_TIMESTAMP\(6\)" }/i, output
assert_match %r/t\.timestamp\s+"modified_timestamp",\s+default: -> { "CURRENT_TIMESTAMP(?:\(\))?" }/i, output
assert_match %r/t\.timestamp\s+"precise_timestamp",.+default: -> { "CURRENT_TIMESTAMP\(6\)" }/i, output
assert_match %r/t\.integer\s+"random_number",\s+default: -> { "random\(\)" }/, output
task.starting = ""
topic.last_read = ""
topic.bonus_time = ""
now = DateTime.civil(2017, 3, 1, 12, 0, 0)
string_value = "2017-07-04 14:19:00.5"
date = ::Time.utc(2014, 8, 17, 12, 30, 0, 999999)
date = ::Date.new(2001, 2, 3)
assert_match %r{t\.datetime\s+"created_at",\s+precision: 0,\s+null: false$}, output
assert_match %r{t\.datetime\s+"updated_at",\s+precision: 0,\s+null: false$}, output
time_value = Time.new(2016, 05, 11, 19, 0, 0)
string_value = "2016-05-11 19:00:00"
@session_store = {}
sleep(0.1)
}).find_db_config("primary")
pool_config = resolve_db_config :production, "production" => { "url" => "abstract://foo?encoding=utf8" }
hash = { "url" => "abstract://foo?encoding=utf8&", "adapter" => "sqlite3", "host" => "bar", "pool" => "3" }
hash = { "url" => "abstract:///?user=user&password=passwd&dbname=app" }
database: "bar",
password = "am@z1ng_p@ssw0rd#!"
pool_config = resolve_db_config :production, "production" => { "url" => "sqlite3:foo?encoding=utf8" }
database: "foo",
config = HashConfig.new("default_env", "primary", pool: "0")
config = HashConfig.new("default_env", "primary", {})
config = HashConfig.new("default_env", "primary", { schema_dump: "my_schema.rb" })
config = HashConfig.new("default_env", "primary", { schema_dump: nil })
config = HashConfig.new("default_env", "primary", { schema_dump: false })
@topic = Topic.find(1)
t1, t2 = topics(:first, :second)
_ = joanna # squelch a warning
assert_equal %(#<Topic id: 1>), Topic.all.merge!(select: "id", where: "id = 1").first.inspect
assert_equal %(#<Topic id: 1, title: "The First Topic">), Topic.all.merge!(select: "id, title", where: "id = 1").first.inspect
actual = +""
type: nil,
written_on: 2003-07-16 14:28:11(?:\.2233)? UTC,
assert_match(/\A#{expected}\z/, actual)
assert_match(/id: 1/, actual)
assert_difference -> { topic_find_by_cache.size }, +1 do
Topic.find_by(id: 1)
cs = @pool.size.times.map { @pool.checkout }
t = new_thread { @pool.checkout }
:@idle_since,
4.times do |i|
expected = (1..@pool.size).to_a.freeze
t = new_thread {
mutex.synchronize { order << i }
mutex.synchronize { errors << e }
conns.each { |conn| @pool.checkin(conn); sleep 0.1 }
conns = (1..10).map { @pool.checkout }
make_thread = proc do |i|
group1 = (1..5).map(&make_thread)
group2 = (6..10).map(&make_thread)
checkin = proc do |n|
c = conns.pop
assert_equal({ size: 1, connections: 1, busy: 1, dead: 0, idle: 0, waiting: 0, checkout_timeout: 5 }, stats)
assert_equal({ size: 1, connections: 1, busy: 0, dead: 0, idle: 1, waiting: 0, checkout_timeout: 5 }, stats)
assert_equal({ size: 1, connections: 1, busy: 0, dead: 1, idle: 0, waiting: 0, checkout_timeout: 5 }, stats)
def new_thread(...)
Thread.new(...)
resume while alive? && (!timeout || Time.now - now < timeout)
@calls << env
@env = {}
@app = App.new
_, _, body = @management.call(@env)
body.each { |bit| bits << bit }
app = Class.new(App) do
body = Class.new(String) { def to_path; "/path"; end }.new
app = lambda { |_| original_response }
a, b, c = executor.wrap { app.call(env) }
decimal: %w{decimal(2) decimal(2,0) numeric(2) numeric(2,0)},
integer: %w{number(2) number(2,0)}
{ decimal: %w{decimal(2) decimal(2,0) numeric(2) numeric(2,0) number(2) number(2,0)} }
coder = {
assert_lookup_type :string, "enum('one', 'two', 'three')"
assert_lookup_type :string, "ENUM('one', 'two', 'three')"
assert_lookup_type :string, "enum ('one', 'two', 'three')"
assert_lookup_type :string, "ENUM ('one', 'two', 'three')"
assert_lookup_type :string, "set('one', 'two', 'three')"
assert_lookup_type :string, "SET('one', 'two', 'three')"
assert_lookup_type :string, "set ('one', 'two', 'three')"
assert_lookup_type :string, "SET ('one', 'two', 'three')"
assert_lookup_type :string, "SET('unicode', '8bit', 'none', 'time')"
assert_lookup_type :string, "ENUM('unicode', '8bit', 'none', 'time')"
config = { "foo" => "bar" }
config = { "foo" => :bar }
expected = { adapter: "postgresql", database: "foo", host: "localhost" }
config = { "not_production" => { "adapter" => "not_postgres", "database" => "not_foo" } }
config = { "production" => { "adapter" => "not_postgres", "database" => "not_foo", "host" => "localhost" } }
expected = { adapter: "not_postgres", database: "not_foo", host: "localhost" }
expected = { adapter: "postgresql", database: "foo_test", host: "localhost" }
expect_prod = {
config = { "default_env" => { "adapter" => "not_postgres", "database" => "not_foo", "host" => "localhost" } }
expected = { adapter: "ibm_db", database: "foo", host: "localhost" }
config = { "default_env" => { "url" => "postgres://localhost/foo" } }
expected = { options: "-cmyoption=on", adapter: "postgresql", database: "foo", host: "localhost" }
config = { "production" => { "adapter" => "postgres", "database" => "foo" } }
host: "::1",
database: "baz",
other_env: {
pool: "5"
expected = { pool: 5 }
config = { "production" => { "adapter" => "not_postgres", "database" => "not_foo", "host" => "localhost" }, "default_env" => {} }
default: { writing: :primary },
ActiveRecord::Base.connects_to(database: { writing: :arunit }, shards: { shard_one: { writing: :arunit } })
SecondaryBase.connects_to shards: { one: { writing: { database: ":memory:", adapter: "sqlite3" } } }
SomeOtherBase.connects_to shards: { one: { writing: { database: ":memory:", adapter: "sqlite3" } } }
default: { writing: { database: ":memory:", adapter: "sqlite3" } },
one: { writing: { database: ":memory:", adapter: "sqlite3" } }
default: { writing: { database: tf_default.path, adapter: "sqlite3" } },
one: { writing: { database: tf_shard_one.path, adapter: "sqlite3" } }
one: { writing: { database: tf_shard_one.path, adapter: "sqlite3" }, secondary: { database: tf_shard_one_reading.path, adapter: "sqlite3" } }
one: { writing: { database: tf_shard_one2.path, adapter: "sqlite3" }, secondary: { database: tf_shard_one_reading2.path, adapter: "sqlite3" } }
SecondaryBase.connects_to database: { writing: { database: ":memory:", adapter: "sqlite3" }, secondary: { database: ":memory:", adapter: "sqlite3" } }
ActiveRecord::Base.connects_to(shards: { default: { also_writing: :arunit }, one: { also_writing: :arunit } })
config = { "primary" => { "adapter" => "sqlite3", "database" => "test/db/primary.sqlite3" } }
config = { "development" => { "adapter" => "sqlite3", "database" => "test/db/primary.sqlite3" } }
klass2 = Class.new(Base) { def self.name; "klass2"; end }
outer_pid = fork {
@connection.create_table("blank_comments", comment: " ", force: true) do |t|
t.index :space_comment, comment: " "
index = @connection.indexes("commenteds").find { |idef| idef.name == "idx_obvious" }
{ string: "varchar" }
assert_match(/\Adevelopers\/query-(\h+)-(\d+)-(\d+)\z/, Developer.collection_cache_key)
assert_match(/\Adevelopers\/query-(\h+)-(\d+)-(\d+)\z/, developers.cache_key)
/\Adevelopers\/query-(\h+)-(\d+)-(\d+)\z/ =~ developers.cache_key
assert_match(/\Adevelopers\/query-(\h+)-(\d+)-(\d+)\z/, developers_with_select.cache_key)
/\Adevelopers\/query-(\h+)-(\d+)-(\d+)\z/ =~ developers_with_select.cache_key
assert_match(/\Acomments\/query-(\h+)-(\d+)-(\d+)\z/, comments.cache_key)
other_relation = Developer.where(name: "David").where("1 = 1")
topics = Topic.where("title like ?", "%Topic%")
/\Adevelopers\/query-(\h+)\z/ =~ developers.cache_key
assert_match(/(\d+)-(\d+)\z/, developers.cache_version)
/(\d+)-(\d+)\z/ =~ developers.cache_version
assert_match(/\Adevelopers\/query-(\h+)-(\d+)-(\d+)\z/, key_with_version_1)
coder.dump("a")
assert_equal %{can't dump `tags`: was supposed to be a Array, but was a String. -- "a"}, error.to_s
coder.load "--- foo"
assert_equal %{can't load `tags`: was supposed to be a Array, but was a String. -- "foo"}, error.to_s
assert_nil coder.load "--- "
bad_yaml = "--- {"
david = CallbackDeveloper.create("name" => "David", "salary" => 1000000)
before_save(on: :create) { }
around_save(on: :create) { }
after_save(on: :create) { }
c = Account.group("firm_id", :credit_limit).count(:all)
c = Topic.group(:author_name, "COALESCE(type, title)").count(:all)
expected = { nil => 50, 1 => 50, 2 => 60, 6 => 105, 9 => 53 }
nil => 50,
1 => 50,
2 => 60,
6 => 105,
9 => 53
6 => 55,
6 => 50,
c = Account.group(:firm_id).order("firm_id").sum(:credit_limit)
c = Account.where("firm_id IS NOT NULL").group(:firm_id).order("firm_id").limit(2).sum(:credit_limit)
c = Account.where("firm_id IS NOT NULL").group(:firm_id).order("firm_id").
expected = { nil => 4, 1 => 1, 2 => 1, 4 => 1, 5 => 1, 7 => 1 }
expected = { nil => 6, 1 => 1, 2 => 1, 4 => 1, 5 => 1, 7 => 1 }
assert_equal({ 6 => 2 }, Account.group(:firm_id).distinct.order("1 DESC").limit(1).count)
c = Account.group(:firm_id).having("sum(credit_limit) > 50").sum(:credit_limit)
c = Account.where("firm_id > 1").group(:firm_id).sum(:credit_limit)
relation = Account.where("firm_id > 1").group(:firm_id).having("sum(credit_limit) > 60")
c = Account.group(:firm).count(:all)
c = companies(:rails_core).companies.group(:name).having("sum(id) > 7").sum(:id)
expected = { nil => 1, 1 => 1, 2 => 1, 6 => 2, 9 => 1 }
assert_equal({ "active" => 2, "trial" => 2, "suspended" => 1 }, counts)
expected = { 1 => 2, 2 => 1, 4 => 5, 5 => 3, 7 => 1 }
assert_equal 0, Account.where("1 = 2").sum("2 * credit_limit")
edges = Edge.from("edges /*! USE INDEX(unique_edge_index) */")
assert_equal Edge.where("sink_id < 5").count(:all), edges.where("sink_id < 5").count(:all)
.pluck(:"topics.last_read", :"books.last_read")
t = Topic.create!(content: { "foo" => "bar" })
expected = { "SpecialPost" => 1, "StiPost" => 2 }
expected = { "StiPost" => 3, "SpecialPost" => 1 }
expected = { "SpecialPost" => 1, "Post" => 8 }
expected = { "SpecialPost" => 1 }
expected = { "SpecialPost" => 1, "StiPost" => 1, "Post" => 9 }
assert_equal({ "has trinket" => part.id }, ShipPart.joins(:trinkets).group("ship_parts.name").sum(:id))
assert_equal({ "proposed" => 2, "published" => 2 }, Book.group(:status).count)
assert_equal({ "proposed" => 0, "published" => 4 }, Book.group(:status).sum(:status))
assert_equal({ "proposed" => 0, "published" => 1 }, Book.group(:status).sum(:difficulty))
assert_equal({ "proposed" => 0, "published" => 0 }, Book.group(:status).minimum(:difficulty))
assert_equal({ "proposed" => 0, "published" => 1 }, Book.group(:status).maximum(:difficulty))
assert_equal({ false => Date.new(2004, 4, 15), true => nil }, Topic.group(:approved).minimum(:last_read))
assert_equal({ false => Date.new(2004, 4, 15), true => nil }, Topic.group(:approved).maximum(:last_read))
assert_equal Time.utc(2003, 7, 16, 14, 28, 11, 223300), actual
assert_equal Time.utc(2013, 7, 13, 11, 11, 0, 9900), actual
false => Time.utc(2003, 7, 16, 14, 28, 11, 223300),
true => Time.utc(2004, 7, 15, 14, 28, 0, 9900),
true => Time.utc(2013, 7, 13, 11, 11, 0, 9900),
assert_equal Time.utc(2004, 7, 15, 14, 28, 0, 9900), actual
1 => Time.utc(2003, 7, 16, 14, 28, 11, 223300),
2 => Time.utc(2004, 7, 15, 14, 28, 0, 9900),
.group(:firm_id)
.take!
.group(:id)
Account.count(:firm_id) { true }
record_from_db.updated_at = { 1 => 2016, 2 => 11, 3 => 12, 4 => 1, 5 => 2, 6 => 3, 7 => 22 }
b_blank = Boolean.create!(value: "")
b_false = Boolean.create!(value: "0")
calls << args
assert_equal 1, Topic.find_by!(id: 1).id
topics = Topic.where("topics.id = ?", 1)
topics = Topic.where(id: (1 .. bind_params_length).to_a << 2**63)
topics = Topic.where.not(id: (1 .. bind_params_length).to_a << 2**63)
topics = Topic.where(id: (1 .. bind_params_length + 1).to_a)
topics = Topic.where.not(id: (1 .. bind_params_length + 1).to_a)
pk = "#{table}.#{Author.quoted_primary_key}"
bind_params = ids.map { |i| Arel::Nodes::BindParam.new(i) }
@connection.respond_to?(:sql_key, true) ? @connection.send(:sql_key, sql) : sql
sql: "select * from topics where id = ?",
@debugs << str
sql: "select * from topics where title = $1",
sql: "select * from users where auth_token = ?",
binary_data = "\xEE\x49\xC7".b
@posts = Post.order("id asc")
Post.select(:title).find_each(batch_size: 1) { |post|
Post.select("id, title, type").find_each(batch_size: 2) do |post|
limit = @total - 1
total = 0
total += 1
Post.order("title").find_each { |post| post }
Post.select(:title).find_each(batch_size: 1, order: :invalid) { |post|
not_a_post = +"not a post"
not_a_post.stub(:id, -> { raise StandardError.new("not_a_post had #id called on it") }) do
batch.map! { not_a_post }
enum = nil
ids = Post.order("id ASC").pluck(:id)
not_deleted_count = Post.where("id <= 2").count
Post.where("id > 2").in_batches(of: 2).delete_all
assert_equal 0, Post.where("id > 2").count
post = Post.order("id ASC").where("id >= ?", 2).first
post = Post.order("id DESC").where("id <= ?", 5).first
assert_sql(/WHERE #{quoted_posts_id} > .+ AND #{quoted_posts_id} <= .+/i) do
assert_sql(/#{quoted_posts_id} IN \(.+\)/i) do
Post.where("id < ?", 5).in_batches(of: 2) { |relation| assert_kind_of Post, relation.first }
assert_sql(/#{quoted_posts_id} > .+ AND #{quoted_posts_id} <= .+/i) do
Post.where("id < ?", 5).in_batches(of: 2, use_ranges: true) { |relation| assert_kind_of Post, relation.first }
assert_sql(/DELETE FROM #{c.quote_table_name("posts")} WHERE #{quoted_posts_id} > .+ AND #{quoted_posts_id} <=/i) do
assert_sql(/ORDER BY #{c.quote_table_name('posts')}\.#{c.quote_column_name('id')}/) do
Post.in_batches(of: 1, order: :desc) do |relation|
enum = Post.in_batches(of: 1)
Post.in_batches(of: 2) do |batch|
batch.where("author_id >= 1").update_all("author_id = author_id + 1")
posts.find_each { }
Post.find_each { }
Post.find_each(start: 1, finish: 1) do |post|
Post.in_batches { }
payload = { "foo" => 42 }
Topic.connection.stub(:lookup_cast_type_from_column, ->(_) { raise "Some Error" }) do
car = Car.new name: "<3<3<3"
20_000.times { car.engines_count += 1 }
Topic.limit("1, 7 procedure help()").to_a
topic_ids = Topic.select(:id).map(&:id).sort
topic.title = "<3<3<3"
topic = Topic.create("written_on" => time)
pet = Pet.create(name: "Bidu")
Topic.new("title" => "test",
cb = CustomBulb.create { |c| c.name = "Dude" }
topics = Topic.all.merge!(order: "id").to_a
topics = Topic.all.merge!(where: "author_name = 'Mary'").to_a
attributes = { "bonus_time" => "5:42:00AM" }
assert_equal Time.utc(2000, 1, 1, 5, 42, 0), topic.bonus_time
attributes = { "bonus_time(1i)" => "2000",
assert_equal Time.utc(2000, 1, 1, 10, 35, 50), topic.bonus_time
assert_equal Topic.where(id: "1-meowmeow".."2-hello"), Topic.where(id: 1..2)
one = Subscriber.new(id: "")
two = Subscriber.new(id: "")
weird = Weird.create("a$b" => "value")
weird.update_columns("a$b" => "value2")
Weird.create("a$b" => "value", :from => "aaron")
assert_equal Time.local(2000, 1, 1, 5, 42, 0), topic.bonus_time
topic.title = "a"
duped_topic.title = "b"
dup = nil
assert_equal Time.local(2004, 1, 1, 0, 0, 0, 0), default.fixed_time
assert_equal Time.utc(2004, 1, 1, 0, 0, 0, 0), default.fixed_time_with_time_zone
assert_equal Time.utc(2004, 1, 1, 0, 0, 0, 0), default.fixed_time
assert(auto.id > 0)
Topic.find("123456 OR id > 0")
author_name = "\\ \001 ' \n \\n \""
t1 = Topic.find(1)
t2 = Topic.find(1)
k = Class.new(Joke)
def k.name; "Foo"; end
def k.table_name; super + "ks"; end
k = Class.new(ak)
res5 = Post.where("p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id").joins("p, comments co").select("p.id").count
res7 = Post.where("p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id").joins("p, comments co").select("p.id").distinct.count
assert_queries(2) { 2.times { query.call } }
types = { "author_name" => typecast.new }
u = person.create!(first_name: "cool")
u.first_name = "nah"
@count ||= 0
@count += 1 if reflection.name == :parts
@count += 1 if reflection.name == :ship
@count += 1 if reflection.name == :pirate
firm = Firm.find(1)
firm = Firm.new("name" => "GlobalMegaCorp")
firm.account = a = Account.new("credit_limit" => 1000)
firm.name += "-changed"
assert_queries(1) { firm.save! }
assert_queries(Firm.partial_updates? ? 0 : 1) { firm.save! }
assert_queries(2) { firm.save! }
eye = Eye.create(iris_attributes: { color: "honey" })
eye.update(iris_attributes: { color: "blue" })
client = Client.new(name: "Joe (the Plumber)")
apple = Firm.new("name" => "Apple")
final_cut = Client.new("name" => "Final Cut")
mouse = Mouse.create!(name: "Will")
new_firm = Firm.new("name" => "A New Firm, Inc")
client = new_firm.clients.new("name" => "Apple")
client = Client.new("name" => "Apple")
{ content: "Best content" },
{ content: "Best content" }
c = Client.new("name" => "Apple")
firm = Firm.new("name" => "Apple")
company.name += "-changed"
firm = Firm.new("name" => "New Firm")
firm = Firm.create!("name" => "New Firm").dup
new_firm = Firm.new("name" => "some firm")
new_autosaved_firm = Firm.new("name" => "some firm")
firm = Firm.new("name" => "some firm")
id = @pirate.ship.id
@pirate.ship.name = ""
assert_difference("Ship.count", -1) { @pirate.save! }
def save(**)
raise "Oh noes!"
id = @ship.pirate.id
assert_difference("Pirate.count", -1) { @ship.save! }
2.times { |i| @pirate.birds.create!(name: "birds_#{i}") }
ids = @pirate.birds.map(&:id)
ids.each { |id| assert klass.find_by_id(id) }
ids.each { |id| assert_nil klass.find_by_id(id) }
@pirate.birds.each { |bird| bird.name = "" }
assert_difference("Bird.count", -2) { @pirate.save! }
before = @pirate.birds.map { |c| c.mark_for_destruction ; c }
3.times { |i| @pirate.birds.build(name: "birds_#{i}") }
3.times { |i| @pirate.birds.create(name: "unique_birds_#{i}") }
2.times { |i| @pirate.parrots.create!(name: "parrots_#{i}") }
@pirate.parrots.each { |parrot| parrot.name = "" }
before = @pirate.parrots.map { |c| c.mark_for_destruction ; c }
assert_no_queries { @ship.save! }
assert_queries(1) { @ship.save! }
2.times { |i| @pirate.ship.parts.create!(name: "part #{i}") }
@pirate.ship.parts.each { |part| part.name = "" }
assert_queries(1) { @pirate.catchphrase = "Arr"; @pirate.save! }
post = Post.create! author: author, title: "foo", body: "bar"
@ship.name = nil
@ship.name = ""
assert_queries(1) { @ship.name = "The Vile Serpent"; @ship.save! }
parent = Post.new title: "foo", body: "..."
child = parent.comments.build body: "..."
@pirate.public_send(@association_name).each { |child| child.name = "" }
{ @associated_model_name.to_s.to_sym => { blank: "cannot be blank" } }
assert_no_difference("#{ @association_name == :birds ? 'Bird' : 'Parrot' }.count") do
assert_difference("#{ @association_name == :birds ? 'Bird' : 'Parrot' }.count", 2) do
@child_1.name = "Changed"
@habtm = true
@author = Author.new(name: "DHH")
@pirate.parrot = Parrot.new(name: "")
post = Post.new(title: "Test", body: "...")
comment = post.comments.build(body: "...")
attribute :starts_at, :datetime, precision: 3, limit: 2, scale: 1, default: -> { Time.now.utc }
attribute :starts_at, :datetime, precision: 3, default: -> { Time.now.utc }
attribute :ends_at, default: -> { Time.now.utc }
def cast(*)
attribute :counter, :integer, default: -> { @@counter += 1 }
model.foo << "asdf"
model.foo = "lol"
assert_equal "foo", klass.new(no_type: "foo").no_type
t = topics(:first)
t.content = (1..11).to_a
t.title = "hello there!"
t.author_name = ""
topic.attributes = { title: "Budget", author_name: "Jason" }
test = AutoId.create(value: "")
topic = Topic.new do |t|
t.author_name = "Jason"
content = %w( one two three )
category_attrs = { "name" => "Test category", "id" => nil, "type" => nil, "categorizations_count" => nil }
bool = Boolean.create!("value" => false)
topic = Topic.new(title: "Hello")
topic.content = { "one" => 1, "two" => 2 }
tz = "Pacific Time (US & Canada)"
date_string = "2011-03-24"
topic.content = %w( one two three )
topic.content << "five"
new_topic = { "title" => "New Topic", "content" => { "key" => "First value" } }
new_topic_values = { "title" => "AnotherTopic", "content" => { "key" => "Second value" } }
topic = Topic.new(title: "a")
def topic.title() "b" end
topic = klass.new(user_defined_json: { key: "value" })
topic = klass.new(user_defined_json: {})
object.int_value = "0"
topic = @target.new(title: "Budget")
%w(default_ title_).each do |prefix|
meth = "#{prefix}title"
meth = "title#{suffix}"
meth = "#{prefix}title#{suffix}"
myobj = { "value1" => "value2" }
topic = Topic.all.merge!(select: "topics.*, 0 as is_test").first
topic = Topic.all.merge!(select: "topics.*, 1=2 as is_test").first
topic = Topic.all.merge!(select: "topics.*, 1 as is_test").first
topic = Topic.all.merge!(select: "topics.*, 2=2 as is_test").first
klass.class_eval "def #{method}() 'defined #{method}' end"
record.last_read = Time.utc(2010, 1, 1, 10)
utc_time = Time.utc(2008, 1, 1)
cst_time = utc_time.in_time_zone("Central Time (US & Canada)")
(-11..13).each do |timezone_offset|
record.written_on = " "
time_string = "Tue Jan 01 00:00:00 2008"
record = Topic.new(id: 1)
time_string = "10:00:00"
record.bonus_time = ""
time_string = "ABC"
record = @target.new(bonus_time: "10:00:00")
expected_time = Time.utc(2000, 01, 01, 10)
2.times { klass = Class.new(klass) }
dev = klass.new(name: "arthurnn")
def title; "omg"; end
topic.title = "lol"
def system; "omg"; end
super + "!"
model = @target.select("id").last!
model.id = "omg"
@target.class_eval(<<-private_method, __FILE__, __LINE__ + 1)
%w{ one two three }
part = ship.parts.create!(name: "Mast")
reader = Reader.create! person: person, post: Post.new(title: "foo", body: "bar")
firm = Firm.new("name" => "A New Firm, Inc")
client = Client.new("name" => "TheClient.com", "firm_id" => firm.id)
tag = Sharded::Tag.new(name: "Ruby on Rails", blog_id: blog_post.blog_id)
david.posts << (post = Post.new(title: "New on Edge", body: "More cool stuff!"))
josh = Author.new(name: "Josh")
josh.posts << Post.new(title: "New on Edge", body: "More cool stuff!")
post = authors(:david).posts.create(title: "New on Edge") { |p| p.body = "More cool stuff!" }
post = authors(:david).posts.create!(title: "New on Edge") { |p| p.body = "More cool stuff!" }
book = books(:awdr)
post = Post.create!(
title: "test post",
title: "test post 2",
title: "test post 3",
.where(name: "David")
bob_post = posts(:misc_by_bob)
.where(blog_id: tag.blog_id, tag_id: tag.id)
assert_sql(%r{/\* that tells jokes \*/}) do
assert_sql(%r{/\* that are very colorful \*/}) do
assert_sql(%r{/\* that is a rocket \*/}) do
assert_sql(%r{/\* that are also parrots \*/}) do
assert_sql(%r{/\* yarrr \*/}) do
Author.where("tags.id" => tags(:general).id),
blue = tags(:blue)
.left_outer_joins(agents: { agents: { primary_contact: :agents } }).to_a
assert queries.any? { |sql| /agents_people_4/i.match?(sql) }
all_post_ids = Post.pluck(:id)
assert queries.any? { |sql| /INNER JOIN/i.match?(sql) }
queries = capture_sql { Author.left_outer_joins({}).to_a }
assert_raise(ArgumentError) { Author.left_outer_joins('LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id"').to_a }
assert queries.any? { |sql| /writer_type.*?=.*?(Author|\?|\$1|:a1)/i.match?(sql) }
assert queries.none? { |sql| /WHERE/i.match?(sql) }
authors = Author.select("authors.name, #{%{(authors.author_address_id || ' ' || authors.author_address_extra_id) as addr_id}}").left_outer_joins(:posts)
post = Post.new title: "foo", body: "bar"
Tag.has_many :null_taggings, -> { none }, class_name: :Tagging
options = { where: "comments.#{QUOTED_TYPE}='SpecialComment'", order: "comments.id" }
new_tag = Tag.new(name: "new")
push = Tag.create!(name: "pushme")
assert_nil(wrong = post_thinking.tags.detect { |t| t.class != Tag },
tag = Tag.create!(name: "doomed")
doomed = Tag.create!(name: "doomed")
quaked = Tag.create!(name: "quaked")
p = Post.all.merge!(includes: { taggings: :taggable }).find(posts(:welcome).id)
comments = Comment.all.merge!(includes: :post, where: "post_id = 1").to_a
sub_sti_post = SubStiPost.create!(title: "test", body: "test", author_id: 1)
bulb = Bulb.create!(car: car)
car.bulb.color = "Blue"
bulb.color = "Red"
human.name = "Bongo"
human = Human.all.merge!(where: { name: "Gordon" }, includes: :face).first
human = Human.all.merge!(where: { name: "Gordon" }, includes: :face, order: "faces.id").first
human = Human.all.merge!(where: { name: "Gordon" }, includes: :interests).first
human = Human.all.merge!(where: { name: "Gordon" }, includes: :interests, order: "interests.id").first
comment.body = "OMG"
face = Face.all.merge!(includes: :human, order: "humans.id", where: { description: "trusting" }).first
iz = human.interests.detect { |_iz| _iz.id == interest.id }
face = Face.all.merge!(where: { description: "confused" }, includes: :human, order: "humans.id").first
iz = human.polymorphic_interests.detect { |_iz| _iz.id == interest.id }
sql = Person.joins(agents: { agents: :agents }).joins(agents: { agents: { primary_contact: :agents } }).to_sql
string_join = <<~SQL
sql = Author.joins({}).to_sql
assert_match(/writer_type.*?=.*?Author/i, sql)
real_count = Author.all.to_a.sum { |a| a.posts.count }
real_count = Author.all.to_a.select { |a| a.posts.any? { |p| p.title.start_with?("Welcome") } }.length
joins = capture_sql { @member.club }
club = Club.new(name: "Da Club")
@club = @member.club
apple = Firm.create("name" => "Apple")
author.update!(name: "J.R.R. Tolkien")
car = Car.create(name: "honda")
bulb = car.build_bulb car_id: car.id + 1
bulb = car.create_bulb car_id: car.id + 1
bulb = car.build_bulb { |b| b.color = "Red" }
bulb = car.create_bulb { |b| b.color = "Red" }
bulb = car.create_bulb! { |b| b.color = "Red" }
ship.name = "new name"
new_ship = Ship.create(name: "new name")
post = Post.create(id: 1234, title: "Some title", body: "Some content")
author = Author.new(id: 33, name: "Hank Moody")
post = Post.create!(author_id: 42, title: "foo", body: "bar")
post = Post.create! title: "foo", body: "bar"
where_clause = { books: { subscriptions: { subscriber_id: nil } } }
@post = @author.posts.create(title: "title", body: "body")
@post2 = @author.posts.create(title: "title", body: "body")
has_many :posts, -> { order("posts.id DESC") }, through: :readers
lesson, _, student = make_no_pk_hm_t
sicp = lesson.new(name: "SICP")
post = Post.create!(title: "Rails 6", body: "")
posts(:thinking).body += "-changed"
post = Post.new(title: "Hello", body: "world")
p = Post.new
post = Post.create!(author: author, title: "TITLE", body: "BODY")
john = Person.create!(first_name: "John", primary_contact_id: sarah.id, gender: "M", number1_fan_id: 1)
post = TaggedPost.create!(title: "Tagged", body: "Post")
tag = post.tags.create!(name: "Tag")
post = tags(:general).tagged_posts.create! title: "foo", body: "bar"
post1 = Post.create(title: "active", body: "sample")
post = Post.create!(title: "Beaches", body: "I like beaches!")
users = 3.times.map { User.create! }
raise "No pet!" if added.pet.nil?
fall = Session.new(name: "Fall")
tag_ids = blog_post.tags.to_a.map(&:id)
assert_match(/.* ON.* #{quoted_tags_blog_id} = #{quoted_posts_tags_blog_id} .* WHERE/, sql)
assert_match(/.* WHERE #{quoted_posts_tags_blog_id} = .*/, sql)
blog_post_ids = tag.blog_posts.to_a.map(&:id)
assert_match(/.* ON.* #{quoted_blog_posts_blog_id} = #{quoted_posts_tags_blog_id} .* WHERE/, sql)
:posts, :readers, :taggings, :cars, :tags,
assert_operator len, :>, 0
dev = self
counter += 1
where("id = :inc", inc: counter)
sql = capture_sql { post.comments.to_a }
bulb = car.bulbs.create!(name: "exotic")
car = Car.new(name: "honda")
author.posts.create!(title: "test", body: "body")
posts.create!(title: "test", body: "body")
bulb = car.bulbs.new car_id: car.id + 1
bulb = car.bulbs.build car_id: car.id + 1
bulb = car.bulbs.create car_id: car.id + 1
assert_equal 3, Firm.order(:id).find { |f| f.id > 0 }.clients.length
has_many :posts, -> { order(:id) }
firm = Firm.new(name: "Firm")
firm = Firm.new(name: "Firm", id: 100)
clients.each { |c| assert_equal firm.id, c.firm_id }
summit = firm.clients.where("name = 'Summit'").to_a
assert_equal summit, firm.clients.where("name = ?", "Summit").to_a
firm = Firm.create!(name: "firm name")
Developer.all.merge!(joins: :audit_logs, where: { "audit_logs.message" => nil, :name => "Smith" }).to_a
all_clients_of_firm1 = Client.all.merge!(where: "firm_id = 1").to_a
grouped_clients_of_firm1 = Client.all.merge!(where: "firm_id = 1", group: "firm_id", select: "firm_id, count(id) as clients_count").to_a
natural = Client.new("name" => "Natural Company")
good = Client.new(name: "Good")
firm.clients_of_firm << Client.new("name" => "Natural Company")
new_firm = Firm.new("name" => "A New Firm, Inc.")
{ title: "re: zoom", content: "speedy quick!" },
{ title: "re: zoom 2", content: "OMG lol!" },
reply1 = Reply.create!(title: "re: zoom", content: "speedy quick!")
reply2 = Reply.create!(title: "re: zoom 2", content: "OMG lol!")
client = Client.new("name" => "New Client")
post = posts.create!(title: "test", body: "body")
topic = Topic.create "title" => "neat and simple"
reply = topic.replies.create "title" => "neat and simple", "content" => "still digging it"
reply.replies.create "title" => "neat and simple", "content" => "ain't complaining"
assert_equal 3, Client.all.merge!(where: "firm_id=#{firm.id}").to_a.size
firm = Firm.create!(name: "Startup")
firm = Firm.create!(name: "Apple")
lambda { authors(:mary).comments << Comment.create!(body: "Yay", post_id: 424242) },
firm.clients.one? { true }
bulb = Bulb.new(color: "red")
post = SubStiPost.create! title: "fooo", body: "baa"
firm = Firm.create! name: "omg"
speedometer.minivans.create!(minivan_id: "a-van-red", name: "a van", color: "red")
Post.create!(title: "signed post by bob", body: "stuff", author: authors(:bob))
car = Car.create!(name: "honda") do |c|
c.bulbs << bulb
c.tyres << tyre
new_bulb.name = "foo"
car = Car.new
firm = Firm.create!(name: "Firm")
Bulb.before_save { |record| record.car.save && count += 1 }
before_destroy -> { throw :abort }
car = Car.create!(name: "Car")
firm = Firm.create!(name: "A New Firm, Inc")
firm = Firm.find(15)
has_and_belongs_to_many :developers, -> { unscope(where: "name") },
treaty.treaty_id = "t1"
new_project = Project.new("name" => "Grimetime")
developers = (0...amount_of_developers).reverse_each.map { |i| Developer.create(name: "JME #{i}") }
devel = Developer.create("name" => "Fred Wu")
proj = assert_queries(0) { devel.projects.build("name" => "Projekt") }
proj = assert_queries(0) { devel.projects.new("name" => "Projekt") }
proj = devel.projects.create("name" => "Projekt")
new_developer = Developer.new("name" => "Matz")
developer = Developer.new("name" => "Kano")
2,
g << "developers.#{c.name}"
g << "developers_projects_2.#{c.name}"
Project.columns.each { |c| group << "projects.#{c.name}" }
developer = Developer.new("name" => "Joe")
detect { |p| p.id == first_project.id }
assert_nil posts.detect { |p| p.author_id != authors(:david).id },
assertions = ->(firm) {
posts = Post.select("posts.*").from("authors, posts").eager_load(:comments).where("posts.author_id = authors.id").order("posts.id").to_a
popular_post = Post.create!(title: "foo", body: "I like cars!")
includes: { post: :comments }).to_a
car_post = Post.create!(title: "foo", body: "I like cars!")
categories = Category.all.merge!(where: { "posts.id" => car_post.id },
includes: { posts: :comments }).to_a
post = Post.create!(title: "foo", body: "I like cars!")
includes: { author: :posts },
where: "authors.id > 0"
where: "posts.id > 0"
titles = comments.map { |c| c.post.title }
comments = Comment.all.merge!(includes: :post, where: "post_id = 4", limit: 3, order: "comments.id").to_a
comments = Comment.all.merge!(includes: :post, where: "post_id = 4", limit: 3, offset: 1, order: "comments.id").to_a
comments = Comment.all.merge!(includes: :post, where: { posts: { id: 4 } }, limit: 3, order: "comments.id").to_a
Comment.includes(:post).references(:posts).where("#{quoted_posts_id} = ?", 4)
s = Subscriber.create! do |c|
c.id = "PL"
b = Book.create!
s.book_ids = s.book_ids
books = books(:awdr, :rfr)
Post.create!(author: author, title: "TITLE", body: "BODY")
author_a = Author.create!(name: "A")
author_b = Author.create!(name: "B")
post_a = StiPost.create!(author: author_a, title: "TITLE", body: "BODY")
post_b = SpecialPost.create!(author: author_b, title: "TITLE", body: "BODY")
assert_equal 3, posts.inject(0) { |sum, post| sum + post.comments.size }
posts = Post.includes(:author, :comments).limit(2).references("author").where("authors.name = ?", "David")
where: { "authors.name" => "David", "comments.body" => "go wild" }).to_a
posts = Post.all.merge!(includes: :categories, order: "posts.id", limit: 3).to_a
post1 = general.posts.to_a.find { |p| p == welcome }
post2 = technology.posts.to_a.find { |p| p == welcome }
.limit(2)
post1 = Post.create!(title: "Beaches", body: "I like beaches!")
post2 = Post.create!(title: "Pools", body: "I like pools!")
order: "UPPER(posts.title)", limit: 2, offset: 1
order: "UPPER(posts.title) DESC", limit: 2, offset: 1
people(:david, :susan),
order: "people.id", limit: 2, offset: 0
assert_equal(item1.sort { |a, b| a.id <=> b.id }, item2.sort { |a, b| a.id <=> b.id })
assert_equal(item3.sort { |a, b| a.id <=> b.id }, item2.sort { |a, b| a.id <=> b.id }) if item3
d1.each_index do |i|
Comment.all.merge!(where: "123.456 = 123.456", includes: :post).to_a
one = posts.detect { |p| p.id == 1 }
Post.all.merge!(includes: :author, joins: { taggings: :tag }, where: "tags.name = 'General'", order: "posts.id").to_a
Post.all.merge!(includes: :author, joins: { taggings: { tag: :taggings } }, where: "taggings_tags.super_tag_id=2", order: "posts.id").to_a
firm = Firm.all.merge!(includes: :account_using_primary_key, order: "accounts.id").to_a.detect { |f| f.id == 1 }
c = Client.create!(name: "Foo", client_of: Company.maximum(:id) + 1)
client = assert_queries(2) { Client.preload(:firm).find(c.id) }
t = Tagging.create!(taggable_type: "Post", taggable_id: Post.maximum(:id) + 1, tag: tags(:general))
firm = Firm.where(id: "1").eager_load(:account).first!
post = Post.where(id: "1").eager_load(:author).first!
post = Post.includes(:tags).references(:tags).where("tags.name = ?", "General").first
post = Post.eager_load(:tags).where("tags.name = ?", "General").first
sponsors.map(&:sponsorable).map { |s| s.respond_to?(:posts) ? s.post.author : s.membership }
post = posts.find { |post| post.id == sharded_blog_posts(:great_post_blog_one).id }
.pluck(:tag_id)
blog_post = blog_posts.find { |post| post.id == expected_blog_post.id }
res.each do |se|
authors = Author.joins(:posts).eager_load(:comments).where(posts: { tags_count: 1 }).order(:id).to_a
authors = Author.all.merge!(includes: { posts: :comments }, where: "authors.id=1", order: "authors.id").to_a
firms = Firm.all.merge!(includes: { account: { firm: :account } }, order: "companies.id").to_a
reply = Reply.new(title: "gaga", content: "boo-boo", parent_id: 1)
posts = Post.where(id: 3).preload(author: { comments: :post }).to_a
source = Vertex.all.merge!(includes: { sinks: { sinks: { sinks: :sinks } } }, order: "vertices.id").first
sink = Vertex.all.merge!(includes: { sources: { sources: { sources: :sources } } }, order: "vertices.id DESC").first
old_post = author.posts.create!(title: "first post", body: "test")
post = Post.create!(title: "hello", body: "abc")
post = Post.create!(title: "hello", body: "abc", author: author)
jack = Author.new name: "Jack"
firm = Firm.create! name: "Firm"
new_dev = nil
before_add: lambda { |o, r|
new_dev = r.new_record?
:essays, :posts, :tags, :taggings, :comments, :sponsors, :members, :nodes
sql_log = capture_sql { Client.find(3).firm }
def self.name; "Temp"; end
belongs_to :developer, default: -> { david }
create_table(:admin_regions, force: true) { |t| t.string :name }
Firm.create("name" => "Apple")
Client.create("name" => "Citibank", :firm_name => "Apple")
debate = Topic.create("title" => "debate")
trash = debate.replies.create("title" => "blah!", "content" => "world around!")
reply = Reply.create!(title: "blah!", content: "world around!", topic: topic)
debate2 = Topic.create("title" => "debate2")
topic1 = Topic.create("title" => "t1")
topic2 = Topic.create("title" => "t2")
reply1 = Reply.new("title" => "r1", "content" => "r1")
topic1 = Web::Topic.create("title" => "t1")
topic2 = Web::Topic.create("title" => "t2")
reply1 = Web::Reply.new("title" => "r1", "content" => "r1")
time = 1.day.ago
topic = Topic.create!(title: "37s")
client = Client.new("firm_id" => 1)
reply = Reply.create(title: "re: zoom", content: "speedy quick!")
firm = client.build_firm { |f| f.name = "Agency Company" }
firm = client.create_firm { |f| f.name = "Agency Company" }
firm = client.create_firm! { |f| f.name = "Agency Company" }
def self.name; "Post"; end
post = Post.new(title: "foo", body: "bar")
post = Post.create!(title: "title", body: "body")
node = nodes(:child_one_of_a)
@table = Table.new(:users)
_(sql).must_be_like "?"
_(sql).must_be_like "VALUES (?)"
{ Arel::Table => "hello" }
_(sql).must_be_like '"users".*'
_(sql).must_be_like %{ omg(*) = 2 }
_(sql).must_be_like %{ omg(*) IS NULL }
assert_equal "omg(*, *)", compile(function)
_(compile(test)).must_be_like %{
_(sql).must_be_like %{ 'f' = 'f' }
_(sql).must_be_like %{ "users"."name" IS NULL }
_(sql).must_equal "('foo')"
_(sql).must_be_like %{ "users"."active" != 'f' }
_(sql).must_be_like %{ "users"."name" IS NOT NULL }
Class.new(String).new(":'("),
Class.new(Class.new(String)).new(":'("),
_(sql).must_be_like %{ "users"."name" != ':\\'(' }
assert_match(/LIMIT 'omg'/, compile(sc))
assert_match(/WHERE "users"."name" = 0 LIMIT 1/, compile(sc))
_(sql).must_be_like %{"users"."created_at" = '#{dt.strftime("%Y-%m-%d %H:%M:%S")}'}
_(sql).must_be_like %{"products"."price" = 2.14}
sql = compile Nodes::Not.new(Arel.sql("foo"))
_(sql).must_be_like "NOT (foo)"
_(sql).must_be_like %{NOT ("users"."id" = 10 AND "users"."id" = 11)}
as = Nodes::As.new(Arel.sql("foo"), Arel.sql("bar"))
_(sql).must_be_like "foo AS bar"
_(sql).must_be_like %{"users"."created_at" = '#{dt.strftime("%Y-%m-%d")}'}
mgr = Table.new(:foo).project(:bar)
_(compile(mgr)).must_be_like '(SELECT bar FROM "foo")'
_(compile(node)).must_be_like %{
node = Nodes::Or.new @attr.eq(10), @attr.eq(11)
_(compile(test)).must_be_like %{ "users"."bool" = 't' }
_(compile(node)).must_equal "1=0"
node = @attr.between 1..3
node = @attr.between 1...3
_(compile(node)).must_be_like %{1=1}
_(compile(node)).must_equal %("products"."price" * "currency_rates"."rate")
node = Arel::Attribute.new(Table.new(:products), :price) / 5
_(compile(node)).must_equal %("products"."price" / 5)
node = Arel::Attribute.new(Table.new(:products), :price) + 6
_(compile(node)).must_equal %(("products"."price" + 6))
node = Arel::Attribute.new(Table.new(:products), :price) - 7
_(compile(node)).must_equal %(("products"."price" - 7))
_(compile(node)).must_equal %("users"."name" || "users"."name")
_(compile(node)).must_equal %("users"."name" @> "users"."name")
_(compile(node)).must_equal %("users"."name" && "users"."name")
_(compile(node)).must_equal %(("products"."bitmap" & 16))
_(compile(node)).must_equal %(("products"."bitmap" | 16))
_(compile(node)).must_equal %(("products"."bitmap" ^ 16))
node = Arel::Attribute.new(Table.new(:products), :bitmap) << 4
_(compile(node)).must_equal %(("products"."bitmap" << 4))
node = Arel::Attribute.new(Table.new(:products), :bitmap) >> 4
_(compile(node)).must_equal %(("products"."bitmap" >> 4))
_(compile(node)).must_equal %("products"."name" && "products"."name")
_(compile(node)).must_equal %( ~ "products"."bitmap")
_(compile(node)).must_equal %( ! "products"."active")
subnode = Nodes::Union.new Arel.sql("left"), Arel.sql("right")
_(compile(node)).must_equal "1=1"
node = @attr.not_between 1..3
%{("users"."id" < 1 OR "users"."id" > 3)}
node = @attr.not_between 1...3
%{("users"."id" < 1 OR "users"."id" >= 3)}
node = @attr.not_between(-Float::INFINITY...3)
_(compile(node)).must_be_like %{1=0}
id = ?
id = :0abc
id IN (?, ?, ?)
id IN (?, ?, ? * 2)
id IN (?, ?)
?, ?, ?
.when("foo").then(1)
.else(0)
.when("bar").then(2)
{ foo: 1, bar: 0 }.reduce(node) { |_node, pair| _node.when(*pair) }
_(compile(manager.ast)).must_be_like %{
sql = Arel.sql("SELECT foo, bar") + Arel.sql(" FROM customers")
sql += Arel.sql("FROM customers")
node = Nodes::True.new()
node = Nodes::False.new()
_(compile(Nodes::Lock.new(Arel.sql("FOR UPDATE")))).must_be_like %{
sc.orders << Arel.sql("xyz")
assert_match(/LIMIT 'omg'/, sql)
_(compile(subquery.lateral("bar"))).must_be_like %{
_(compile(query)).must_be_like %{
CUBE( "users"."name", "users"."bool" )
CUBE( ( "users"."name" ), ( "users"."bool", "users"."created_at" ) )
GROUPING SETS( ( "users"."name" ), ( "users"."bool", "users"."created_at" ) )
ROLLUP( "users"."name", "users"."bool" )
ROLLUP( ( "users"."name" ), ( "users"."bool", "users"."created_at" ) )
inner = Nodes.build_quoted('{"foo":"bar"}')
_(sql).must_be_like %{ "products"."metadata" @> '{"foo":"bar"}' }
_(sql).must_be_like %{ "products"."tags" && '{foo,bar,baz}' }
assert_equal("UPDATE \"users\" LIMIT 'omg'", compile(sc))
CONCAT("users"."name", "users"."name")
_(sql).must_be_like %{ "users"."name" <=> NULL }
NOT "users"."first_name" <=> "users"."last_name"
_(sql).must_be_like %{ NOT "users"."name" <=> NULL }
assert_match(/->.*label="#{edge_name}"/, dot_string)
define_method("test_#{klass.name.gsub('::', '_')}") do
op = klass.new(:a, "z")
Arel::Nodes::On,
op = klass.new(:a)
Arel::Nodes::In,
Arel::Nodes::Or,
Arel::Nodes::As,
binary = klass.new(:a, :b)
node = Arel::Nodes::Case.new(foo)
node = Arel::Nodes::UnaryOperation.new(:-, 1)
assert_edge("0", dot)
assert_edge("1", dot)
assert_edge("2", dot)
assert_edge("key", dot)
um.key = "id"
_(um.to_sql).must_be_like %{ UPDATE "users" SET foo = bar }
_(um.to_sql).must_be_like %{
_(um.to_sql).must_be_like %{ UPDATE "users" }
join = @relation.create_join "foo", "bar"
_(mgr.to_sql).must_be_like %{
it "noops on nil" do
_(mgr.to_sql).must_be_like %{ SELECT FROM "users" }
ON "users"."id" = "users_2"."id"
_(manager.to_sql).must_be_like %{
_(node.name).must_equal "users_2"
rel = Table.new :users, as: "foo"
rel = Table.new :users, as: "users"
_(manager.to_sql).must_be_like %{ SELECT * FROM "users" }
_(manager.to_sql).must_be_like %{ SELECT *, * FROM "users" }
_(column.name).must_equal "id"
@columns = {
Column.new("id", :integer),
Column.new("name", :string),
Column.new("bool", :boolean),
@columns_hash = {
@primary_keys = {
as = manager.as(Arel.sql("foo"))
as = manager.as("foo")
_(manager.to_sql).must_be_like 'SELECT "users"."id" FROM users'
as = manager2.as Arel.sql("omg")
_(manager1.to_sql).must_be_like %{
mgr.join(right).on("omg")
mgr.join(right).on("omg", "123")
table = Table.new :users, as: "foo"
m3 = m2.clone
_(m2.to_sql).must_be_like %{ SELECT EXISTS (#{manager.to_sql}) }
_(m2.to_sql).must_be_like %{ SELECT EXISTS (#{manager.to_sql}) AS foo }
node = @m1.union @m2
_(node.to_sql).must_be_like %{
node = @m1.union :all, @m2
node = @m1.except @m2
_(select_manager.to_sql).must_be_like %{
_(sql).must_be_like %{
SELECT "comments"."id", "comments"."parent_id" FROM "comments" WHERE "comments"."id" = 42
SELECT "comments"."id", "comments"."parent_id" FROM "comments" INNER JOIN "replies" ON "comments"."parent_id" = "replies"."id"
it "takes *args" do
ON "users"."id" = "users_2"."id" AND
join = relation.create_join "foo", "bar"
manager.join("")
assert_match 'INNER JOIN "users" "users_2" "users"."id" = "users_2"."id"',
assert_match 'LEFT OUTER JOIN "users" "users_2" "users"."id" = "users_2"."id"',
).as("counts")
_(joins.to_sql).must_be_like %{
it "can be empty" do
_(stmt.to_sql).must_be_like %{ DELETE FROM "users" }
_(stmt.to_sql).must_be_like %{
_(manager.where_sql).must_be_like %{ WHERE "users"."id" = 10 }
_(manager.where_sql).must_be_like %{ WHERE "users"."id" = 10 AND "users"."id" = 11}
_(manager.where_sql).must_be_like %{ WHERE "users"."id" = 10 AND "users"."name" ILIKE 'foo%' }
_(stmt.to_sql).must_be_like %{ UPDATE "users" SET foo = bar }
_(manager.to_sql).must_be_like %{ SELECT * }
_(manager.to_sql).must_be_like %{ SELECT foo, bar }
_(manager.to_sql).must_be_like %{ SELECT bar }
_(manager.to_sql).must_be_like 'SELECT "users"."id" FROM "users"'
SELECT "users"."id" FROM "users" /* selecting */ /* with */ /* comment */
eqeq_owner < Arel::Nodes::Node &&
eqeq_owner == eql_owner &&
sql = Arel.sql "foo"
node = SqlLiteral.new("*").count
_(compile(node)).must_be_like %{ COUNT(*) }
node = SqlLiteral.new("foo").eq(1)
_(compile(node)).must_be_like %{ foo = 1 }
_(compile(node)).must_be_like %{ (foo = 1 OR foo = 2) }
_(compile(node)).must_be_like %{ (foo = 1 AND foo = 2) }
sql + "Not a node"
Arel::Nodes::Over.new("foo", "bar"),
Arel::Nodes::Over.new("foo", "bar")
Arel::Nodes::Over.new("foo", "baz")
right = attr.eq(11)
}.grep(Class).each do |klass|
next if /^Arel::Nodes::(?:Test|.*Test$)/.match?(klass.name)
function = NamedFunction.new "omg", "zomg", "wth"
NamedFunction.new("omg", "zomg", "wth"),
NamedFunction.new("omg", "zomg", "wth")
NamedFunction.new("zomg", "zomg", "wth")
_(expr.to_sql).must_be_like %{
COALESCE("users"."nickname", "users"."name") IN (?, ?)
_(grouping.eq("foo").to_sql).must_be_like "('foo') = 'foo'"
def quote(*args) @quote_count += 1; super; end
test = attr.eq(10)
one = Casted.new 1, 2
also_one = Casted.new 1, 2
node = Case.new "foo"
node = Case.new nil, "bar"
as = node.as("bar")
_(BindParam.new("foo")).must_equal(BindParam.new("foo"))
eq = Equality.new("foo", "bar")
eq2 = Equality.new("foo", "bar")
eq3 = Equality.new("bar", "baz")
neq = NotEqual.new("foo", "bar")
node = Arel::Nodes::Bin.new(Arel.sql("zomg"))
as = attr.as(Arel.sql("foo"))
as = attr.as("foo")
%w{1 david},
%w{2 kir},
%w{david},
%w{kir},
self.class.new(target.gsub(/\s+/, " ").strip, ctx).must_equal other.gsub(/\s+/, " ").strip
_(dm.to_sql).must_be_like %{ DELETE FROM "users" }
@spec = self
@config = { adapter: "sqlite3" }
assert_equal 'SELECT FROM "users" WHERE "users"."age" = hello AND "users"."name" = world', sql
assert_equal 'SELECT FROM "users" WHERE "users"."age" = "hello" AND "users"."name" = "world"', sql
AVG("users"."id") #{math_operator} 2
COUNT("users"."id") #{math_operator} 2
MAX("users"."id") #{math_operator} 2
MIN("users"."id") #{math_operator} 2
(AVG("users"."id") #{math_operator} 2)
(COUNT("users"."id") #{math_operator} 2)
(MAX("users"."id") #{math_operator} 2)
(MIN("users"."id") #{math_operator} 2)
("users"."id" #{math_operator} 2)
it "should generate != in sql" do
_(mgr.to_sql).must_match %{"users"."name" > 'fake_name'}
_(mgr.to_sql).must_match %{"users"."created_at" > '#{current_time}'}
it "should generate >= in sql" do
_(mgr.to_sql).must_match %{"users"."name" >= 'fake_name'}
_(mgr.to_sql).must_match %{"users"."created_at" >= '#{current_time}'}
_(mgr.to_sql).must_match %{"users"."name" < 'fake_name'}
_(mgr.to_sql).must_match %{"users"."created_at" < '#{current_time}'}
it "should generate <= in sql" do
_(mgr.to_sql).must_match %{"users"."name" <= 'fake_name'}
_(mgr.to_sql).must_match %{"users"."created_at" <= '#{current_time}'}
node = attribute.between(0...)
_(node).must_equal Nodes::In.new(
it "should generate @> in sql" do
_(mgr.to_sql).must_be_like %{ SELECT "products"."id" FROM "products" WHERE "products"."tags" @> '{foo,bar}' }
it "should generate && in sql" do
_(mgr.to_sql).must_be_like %{ SELECT "products"."id" FROM "products" WHERE "products"."tags" && '{foo,bar}' }
_(condition.to_sql).must_equal '"users"."id" = 1'
table = Table.new(:foo)
_(condition.to_sql).must_equal %("foo"."id" = '1')
if attr_name == "id"
_(condition.to_sql).must_equal %("foo"."id" = 1 AND "foo"."other_id" = '2')
_(condition.to_sql).must_equal %("foo"."id" = (select 1))
if attr_name == "tags"
assert_sql(%r{SELECT #{quoted_posts_id} FROM #{quoted_posts} /\* foo \*/}i) do
posts = Post.select(:id).annotate("foo")
assert_sql(%r{SELECT #{quoted_posts_id} FROM #{quoted_posts} /\* \* /foo/ \* \*/}i) do
posts = Post.select(:id).annotate("*/foo/*")
assert_sql(%r{SELECT #{quoted_posts_id} FROM #{quoted_posts} /\* \*\* //foo// \*\* \*/}i) do
posts = Post.select(:id).annotate("**//foo//**")
assert_sql(%r{SELECT #{quoted_posts_id} FROM #{quoted_posts} /\* \* \* //foo// \* \* \*/}i) do
posts = Post.select(:id).annotate("* *//foo//* *")
assert_sql(%r{SELECT #{quoted_posts_id} FROM #{quoted_posts} /\* \* /foo/ \* \*/ /\* \* /bar \*/}i) do
posts = Post.select(:id).annotate("*/foo/*").annotate("*/bar")
customers(:barney).fullname = { first: "Barney", last: "Stinson" }
assert_equal({ first: "Barney", last: "Stinson" }.to_s, customers(:barney).name)
conn1.create_table(:zines) { |t| t.column(:title, :string) } if in_memory_db?
open(filename, "w") { |f| f.puts("select datetime('now', 'localtime');") }
url = "sqlite3:#{tf.path}"
url = "sqlite3::memory:"
select = Owner.columns.map { |c| "typeof(#{c.name})" }.join ", "
@conn.exec_insert("insert into ex (number) VALUES (?)", "SQL", vals)
str = (+"\x80").force_encoding("ASCII-8BIT")
assert_equal "''", @conn.quote_string("'")
name = "foo"
id = @conn.insert(sql, nil, nil, idval)
sql = "select * from ex"
count_sql = "select count(*) from ex"
assert_equal %w{ ex }, @conn.tables
columns = @conn.columns("ex").sort_by(&:name)
column = @conn.columns("ex").find { |x|
x.name == "number"
column = @conn.columns("ex").find { |x| x.name == "number" }
column = @conn.columns("ex").find { |x| x.name == "name" }
@conn.indexes("ex")
@conn.add_index "ex", "id", unique: true, name: "fun"
index = @conn.indexes("ex").find { |idx| idx.name == "fun" }
@conn.add_index "ex", "id"
@conn.add_index "ex", "id", if_not_exists: true
@conn.add_index "ex", "id", name: "fun"
@conn.add_index "ex", %w{ id number }, name: "fun"
@conn.add_index "ex", "max(id, number)", name: "expression"
index = @conn.indexes("ex").find { |idx| idx.name == "expression" }
@conn.execute "CREATE INDEX expression on ex (number % 10) /* comment */"
@conn.add_index "ex", "id % 10, max(id, number)", name: "expression", where: "id > 1000"
assert_equal "id % 10, (CASE WHEN number > 0 THEN max(id, number) END)", index.columns
assert_equal "(id > 1000)", index.where
@conn.add_index "ex", "id, max(id, number)", name: "expression"
assert_equal "id", @conn.primary_key("ex")
region = "US"
t.index :code, unique: true, name: "unique"
t.index :code, where: :bool_attr, name: "partial"
t.index :code, name: "ordered", order: { code: :desc }
partial_index = indexes.find { |idx| idx.name == "partial" }
unique_index = indexes.find { |idx| idx.name == "unique" }
ordered_index = indexes.find { |idx| idx.name == "ordered" }
pk_column = connection.columns("barcodes").find { |col| col.name == "id" }
statement.stub(:step, -> { raise ::SQLite3::BusyException.new("busy") }) do
definition ||= <<~SQL
bd = BigDecimal "10.0"
value = "hello".encode("ascii-8bit")
value = ::Time.utc(2000, 1, 1, 12, 30, 0, 999999)
value = ::Time.utc(2018, 3, 11, 12, 30, 0, 999999)
expected = expected.getutc.to_fs(:db).sub(/\A\d\d\d\d-\d\d-\d\d /, "2000-01-01 ")
expected = expected.getlocal.to_fs(:db).sub(/\A\d\d\d\d-\d\d-\d\d /, "2000-01-01 ")
t.json "payload", default: {}
Pathname(__dir__).join("../../../..")
def test_copy_table(from = "customers", to = "customers2", options = {})
rename: { "name" => "person_name" }) do |from, to, options|
original_id = @connection.columns("goofy_string_id").detect { |col| col.name == "id" }
copied_id = @connection.columns("goofy_string_id2").detect { |col| col.name == "id" }
def copy_table(from, to, options = {})
column = @connection.columns(:collation_table_sqlite3).find { |c| c.name == "title" }
assert_match %r{t\.text\s+"text_rtrim",\s+collation: "RTRIM"$}, output
count = Post.where("title = ?", "Welcome to the weblog").count
count = Post.where("title = ?", 0).count
count = Post.where("title = ?", 0.0).count
count = Post.where("title = ?", false).count
count = Post.where("title = ?", BigDecimal(0)).count
count = Post.where("title = ?", Rational(0)).count
data = XmlDataType.new(payload: "<foo>bar</foo>")
t.virtual :column2, type: :integer, as: "column1 + 1", stored: true
t.virtual :lower_name, type: :string, as: "LOWER(name)", stored: true
message = <<~MSG
assert_match(/t\.virtual\s+"upper_name",\s+type: :string,\s+as: "upper\(\(name\)::text\)", stored: true$/i, output)
assert_match(/t\.virtual\s+"name_length",\s+type: :integer,\s+as: "length\(\(name\)::text\)", stored: true$/i, output)
assert_match(/t\.virtual\s+"name_octet_length",\s+type: :integer,\s+as: "octet_length\(\(name\)::text\)", stored: true$/i, output)
assert_match(/t\.virtual\s+"column2",\s+type: :integer,\s+as: "\(column1 \+ 1\)", stored: true$/i, output)
t.uuid "guid"
@uuid = uuid
0,
0.0,
assert_match %r{t\.uuid "guid"}, output
connection.create_table("pg_uuids", id: :uuid, default: "uuid_generate_v1()") do |t|
t.uuid "other_uuid", default: "uuid_generate_v4()"
connection.create_table("pg_uuids_2", id: :uuid, default: "my_uuid_generator()") do |t|
t.uuid "other_uuid_2", default: "my_uuid_generator()"
connection.create_table("pg_uuids_3", id: :uuid, **uuid_default) do |t|
assert_match(/\bcreate_table "pg_uuids", id: :uuid, default: -> { "uuid_generate_v1\(\)" }/, schema)
assert_match(/t\.uuid "other_uuid", default: -> { "uuid_generate_v4\(\)" }/, schema)
assert_match(/\bcreate_table "pg_uuids_2", id: :uuid, default: -> { "my_uuid_generator\(\)" }/, schema)
assert_match(/t\.uuid "other_uuid_2", default: -> { "my_uuid_generator\(\)" }/, schema)
assert_match(/\bcreate_table "pg_uuids_3", id: :uuid, default: -> { "gen_random_uuid\(\)" }/, schema)
assert_match(/\bcreate_table "pg_uuids_3", id: :uuid, default: -> { "uuid_generate_v4\(\)" }/, schema)
create_table("pg_uuids_4", id: :uuid)
assert_match(/\bcreate_table "pg_uuids_4", id: :uuid, default: -> { "uuid_generate_v4\(\)" }/, schema)
create_table("pg_uuids_4", id: :uuid, default: nil)
assert_match(/\bcreate_table "pg_uuids_4", id: :uuid, default: nil/, schema)
has_many :uuid_posts, -> { order("title DESC") }
%("schema"."table_name") => %w{schema table_name},
}.each do |given, expect|
obj = Name.new("public", "articles")
obj = Name.new(nil, "articles")
name = Name.new('"quoted_schema"', '"quoted_table"')
assert_equal Name.new("access", "users"), Name.new("access", "users")
assert_equal Name.new(nil, "users"), Name.new(nil, "users")
assert_not_equal Name.new(nil, "users"), Name.new("access", "users")
assert_not_equal Name.new("access", "users"), Name.new("public", "users")
assert_not_equal Name.new("public", "users"), Name.new("public", "articles")
hash = { Name.new("schema", "article_seq") => "success" }
s = Sample.create!(value: 1)
sleep(0.5)
assert_equal Time.utc(2010, 1, 1, 11, 0, 0), timestamp.time
keys.each { |k| assert_kind_of Time, k }
d = Developer.create!(name: "aaron", updated_at: 1.0 / 0.0)
assert_equal(1.0 / 0.0, d.updated_at)
d = Developer.create!(name: "aaron", updated_at: -1.0 / 0.0)
assert_equal(-1.0 / 0.0, d.updated_at)
date = Time.new(0) - 1.week
date = Time.utc(-4, 2, 29)
date = Time.utc(0, 4, 7)
assert_equal({ "data_type" => "timestamp without time zone" },
assert_equal({ "data_type" => "timestamp with time zone" },
assert_equal({ "data_type" => "USER-DEFINED", "udt_name" => "custom_time_format" },
pg_connection.stub(:get_last_result, -> { raise "random error" }) do
t.integer :serials_id, default: -> { "nextval('postgresql_serials_id_seq')" }
assert_match %r{t\.serial\s+"seq",\s+null: false$}, output
assert_match %r{t\.integer\s+"serials_id",\s+default: -> \{ "nextval\('postgresql_serials_id_seq'::regclass\)" \}$}, output
t.bigint :serials_id, default: -> { "nextval('postgresql_big_serials_id_seq')" }
assert_match %r{t\.bigserial\s+"seq",\s+null: false$}, output
assert_match %r{t\.bigint\s+"serials_id",\s+default: -> \{ "nextval\('postgresql_big_serials_id_seq'::regclass\)" \}$}, output
assert_match %r{t\.serial\s+"bar_id",\s+null: false$}, output
assert_match %r{t\.bigserial\s+"bar_baz_id",\s+null: false$}, output
INDEX_C_COLUMN = "(to_tsvector('english', coalesce(things.name, '')))"
new_name = "#{old_name}_new"
index_a, index_b, index_c, index_d, index_e = indexes
assert_match(/opclass: \{ position: :text_pattern_ops \}/, output)
assert_match(/order: \{ name: "NULLS FIRST" \}/, output)
t.text "text_col", default: "some value"
st = SchemaThing.new id: 5, name: "TEST2"
assert_changes(-> { num_indices_named("before_rename_pkey") }, from: 1, to: 0) do
assert_changes(-> { num_indices_named("after_rename_pkey") }, from: 0, to: 1) do
JOIN "pg_class" ON "pg_index"."indexrelid" = "pg_class"."oid"
WHERE "pg_class"."relname" = '#{name}'
assert_equal Date.new(2012, 1, 2)...Date.new(2012, 1, 5), @first_range.date_range
assert_equal Date.new(2012, 1, 2)...Date.new(2012, 1, 4), @second_range.date_range
assert_equal Time.public_send(tz, 2010, 1, 1, 14, 30, 0)..Time.public_send(tz, 2011, 1, 1, 14, 30, 0), @first_range.ts_range
assert_equal Time.public_send(tz, 2010, 1, 1, 14, 30, 0)...Time.public_send(tz, 2011, 1, 1, 14, 30, 0), @second_range.ts_range
assert_equal Time.public_send(tz, 2010, 1, 1, 14, 30, 0)...nil, @third_range.ts_range
to_time_string = (from_time + 1.hour).to_s
tstzrange = Time.parse("2010-01-01 14:30:00 +0100")...Time.parse("2011-02-02 14:30:00 CDT")
Time.parse("2010-01-01 14:30:00 CDT")...Time.parse("2011-02-02 14:30:00 CET"))
Time.parse("2010-01-01 14:30:00 +0100")...Time.parse("2010-01-01 13:30:00 +0000"))
Time.parse("-1000-01-01 14:30:00 CDT")...Time.parse("2020-02-02 14:30:00 CET"))
Time.public_send(tz, 2010, 1, 1, 14, 30, 0)...Time.public_send(tz, 2011, 2, 2, 14, 30, 0))
Time.public_send(tz, 2010, 1, 1, 14, 30, 0)...Time.public_send(tz, 2010, 1, 1, 14, 30, 0))
Time.public_send(tz, -1000, 1, 1, 14, 30, 0)...Time.public_send(tz, 2020, 2, 2, 14, 30, 0))
assert_equal_round_trip @first_range, :ts_range, Time.public_send(tz, 2010, 1, 1, 14, 30, 0)...nil
assert_equal_round_trip @first_range, :ts_range, nil..Time.public_send(tz, 2010, 1, 1, 14, 30, 0)
Time.parse("2010-01-01 14:30:00.245124 CDT")...Time.parse("2011-02-02 14:30:00.451274 CET"))
Time.parse("2010-01-01 14:30:00.245124 +0100")...Time.parse("2010-01-01 13:30:00.245124 +0000"))
Time.public_send(tz, 2010, 1, 1, 14, 30, 0, 125435)...Time.public_send(tz, 2011, 2, 2, 14, 30, 0, 225435))
Time.public_send(tz, 2010, 1, 1, 14, 30, 0, 142432)...Time.public_send(tz, 2011, 2, 2, 14, 30, 0, 224242))
Time.public_send(tz, 2010, 1, 1, 14, 30, 0, 142432)...Time.public_send(tz, 2010, 1, 1, 14, 30, 0, 142432))
BigDecimal("0.5")...BigDecimal("1"))
BigDecimal("0.5")...BigDecimal("0.5"))
Range.new(Date.new(2012, 1, 1), Date.new(2013, 1, 1), true))
Date.new(2012, 2, 3)...Date.new(2012, 2, 10))
Date.new(2012, 2, 3)...Date.new(2012, 2, 3))
range = 1..100
assert_equal('ca"t'...'do\\g', escaped_range.string_range)
int4_range: 1..,
int8_range: 10..,
float_range: 0.5..
id,
nan = 0.0 / 0
assert_equal "'NaN'", @conn.quote(nan)
infinity = 1.0 / 0
value = "user posts"
merge("encoding" => "latin")
merge("collation" => "ja_JP.UTF8", "ctype" => "ja_JP.UTF8")
@connection.add_index "ex", %w{ id number }, name: "partial", where: "number > 100"
index = @connection.indexes("ex").find { |idx| idx.name == "partial" }
@connection.add_index "ex", %w{ id }, name: "include", include: :number
index = @connection.indexes("ex").find { |idx| idx.name == "include" }
expr = "mod(id, 10), abs(number)"
index = @connection.indexes("ex").find { |idx| idx.name == "expression" }
index = @connection.indexes("ex").find { |idx| idx.name == "index_ex_on_data" }
assert_not @connection.indexes("ex").find { |idx| idx.name == "index_ex_on_data" }
self.table_name = "ex"
assert_sql(%r{\ASELECT /\*\+ SeqScan\(posts\) \*/}) do
posts = Post.optimizer_hints("/*+ SeqScan(posts) */")
posts = Post.optimizer_hints("**// \"posts\".*, //**")
assert_equal({ "id" => 1 }, posts.first.as_json)
assert_sql(%r{\ASELECT "posts"\."id"}) do
t.column "single", "REAL"
t.inet "inet_address", default: "192.168.1.1"
t.cidr "cidr_address", default: "192.168.1.0/24"
t.macaddr "mac_address", default: "ff:ff:ff:ff:ff:ff"
inet_address: "172.16.1.254/32",
mac_address: "01:23:45:67:89:0a")
address.cidr_address = "10.1.2.3/32"
address.inet_address = "10.0.0.0/8"
assert_match %r{t\.inet\s+"inet_address",\s+default: "192\.168\.1\.1"}, output
assert_match %r{t\.cidr\s+"cidr_address",\s+default: "192\.168\.1\.0/24"}, output
assert_match %r{t\.macaddr\s+"mac_address",\s+default: "ff:ff:ff:ff:ff:ff"}, output
t.money "depth", default: "150.55"
assert_equal(-1.15, type.cast(+"-$1.15"))
assert_equal(-2.25, type.cast(+"($2.25)"))
assert_equal(-1.15, type.cast(+"-1.15"))
assert_equal(-2.25, type.cast(+"(2.25)"))
assert_equal(0.0, type.cast("$" + "," * 100000 + ".11!"))
assert_equal(0.0, type.cast("$" + "." * 100000 + ",11!"))
assert_match %r{t\.money\s+"wealth",\s+scale: 2$}, output
assert_match %r{t\.money\s+"depth",\s+scale: 2,\s+default: "150\.55"$}, output
ltree = Ltree.new(path: "1.2.3.4")
t.public_send column_type, "payload", default: {} # t.json 'payload', default: {}
def write(*); end
using: :gin,
t.enum :best_color, enum_type: "color", default: "blue", null: false
maximum_term: 6.year + 5.month + 4.days + 3.hours + 2.minutes + 1.seconds,
minimum_term: 1.year + 2.month + 3.days + 4.hours + 5.minutes + (6.234567).seconds,
t.hstore "tags", default: ""
@connection.add_column "hstores", "permissions", :hstore, default: '"users"=>"read", "articles"=>"write"'
assert_equal({ "users" => "read", "articles" => "write" }, Hstore.new.permissions)
t.hstore "users", default: ""
change_table("hstores") do |t|
x = Hstore.new tags: { "bool" => true, "number" => 5 }
assert_equal({ "bool" => true, "number" => 5 }, x.tags_before_type_cast)
assert_equal({ "bool" => "true", "number" => "5" }, x.tags)
assert_equal({ "bool" => "true", "number" => "5" }, x.reload.tags)
assert_equal({ "1" => "2" }, @type.deserialize("\"1\"=>\"2\""))
assert_equal({}, @type.deserialize(""))
assert_cycle("key" => nil)
assert_cycle("c" => "}", '"a"' => 'b "a b')
x = Hstore.new(language: "fr", timezone: "GMT")
x.language = "de"
x = Hstore.new(language: "de")
hstore = Hstore.create!(settings: { "one" => "two" })
settings = { "alongkey" => "anything", "key" => "value" }
hstore.settings = { "key" => "value", "alongkey" => "anything" }
assert_cycle(" " => " ")
assert_cycle("," => "")
assert_cycle("=" => ">")
assert_cycle({ "a" => nil, "b" => nil, "c" => "NuLl", "null" => "c" })
assert_cycle("=a" => "q=w")
assert_cycle("\"a" => "q>w")
assert_cycle("\"a" => "q\"w")
x.tags = { '"a\'' => "b" }
assert_equal({ "1" => "2" }, x.tags)
@connection.execute "insert into hstores (tags) VALUES ('1=>2,2=>3')"
assert_equal({ "1" => "2", "2" => "3" }, x.tags)
assert_cycle("a" => "b", "1" => "2")
assert_cycle("a" => nil)
assert_cycle("a" => 'b"ar', '1"foo' => "2")
assert_cycle("a b" => "b ar", '1"foo' => "2")
assert_cycle('a\\b' => 'b\\ar', '1"foo' => "2")
assert_cycle('a\\"' => 'b\\ar', '1"foo' => "2")
assert_cycle("a\\" => "bar\\", '1"foo' => "2")
assert_cycle("a, b" => "bar", '1"foo' => "2")
assert_cycle("a=>b" => "bar", '1"foo' => "2")
assert_cycle("a\nb" => "c\nd")
assert_equal({ "one" => "two" }, record.tags.to_hash)
record.tags = TagCollection.new("three" => "four")
assert_equal({ "one" => "two" }, dupe.tags.to_hash)
assert_equal "\"hi\"=>\"hi\"", @type.serialize(ProtectedParams.new("hi" => "hi"))
x = Hstore.create!(tags: hash)
x = Hstore.create!(tags: {})
x.tags = hash
t.point :x
t.point :z, default: "(14.4,15.5)"
t.point :legacy_z, default: "(14.4,15.5)"
assert_match %r{t\.point\s+"x"$}, output
p.x.y = 25
p = PostgresqlPoint.new(x: "(1, 2)")
p = PostgresqlPoint.new(x: "")
assert_match %r{t\.point\s+"legacy_x"$}, output
a_line_segment: "(2.0, 3), (5.5, 7.0)",
a_box: "2.0, 3, 5.5, 7.0",
a_polygon: "((2.0, 3), (5.5, 7.0), (8.5, 11.0))",
a_circle: "<(5.3, 10.4), 2>"
assert_equal "((2,3),(5.5,7),(8.5,11))", h.a_polygon
assert_equal "<(5.3,10.4),2>", h.a_circle
a_line_segment: "((2.0, 3), (5.5, 7.0))",
a_box: "(2.0, 3), (5.5, 7.0)",
a_path: "((2.0, 3), (5.5, 7.0), (8.5, 11.0))",
a_polygon: "2.0, 3, 5.5, 7.0, 8.5, 11.0",
a_circle: "((5.3, 10.4), 2)"
assert_equal "((2,3),(5.5,7),(8.5,11))", h.a_path
assert_match %r{t\.lseg\s+"a_line_segment"$}, output
assert_match %r{t\.box\s+"a_box"$}, output
assert_match %r{t\.path\s+"a_path"$}, output
assert_match %r{t\.polygon\s+"a_polygon"$}, output
assert_match %r{t\.circle\s+"a_circle"$}, output
a_line: "{2.0, 3, 5.5}"
assert_equal "{2,3,5.5}", h.a_line
a_line: "(2.0, 3), (4.0, 6.0)"
assert_equal "{1.5,-1,0}", h.a_line
assert_match %r{t\.line\s+"a_line"$}, output
column = connection.columns(table_name).find { |c| c.name == column_name.to_s }
tsvector.text_vector = "'new' 'text' 'vector'"
sad: "sad",
happy: "happy",
}, _prefix: true
record.price = "34.15"
def run(*)
database: "db",
host: "host",
topic = Topic.create!(last_read: 1.0 / 0.0)
assert_equal(1.0 / 0.0, topic.last_read)
topic = Topic.create!(last_read: -1.0 / 0.0)
assert_equal(-1.0 / 0.0, topic.last_read)
date = Date.new(0) - 1.week
date = Time.utc(-4, 2, 29).to_date
date = Time.utc(0, 4, 7).to_date
column = @connection.columns("ex").find { |col| col.name == "data" }
(classid::bigint << 32) | objid::bigint AS lock_id
FullAddress.new($1, $2)
column = @connection.columns(:postgresql_collations).find { |c| c.name == "string_c" }
column = @connection.columns(:postgresql_collations).find { |c| c.name == "title" }
assert_match %r{t\.string\s+"string_c",\s+collation: "C"$}, output
assert_match %r{t\.text\s+"text_posix",\s+collation: "POSIX"$}, output
x = Citext.new(cival: "Some CI Text")
type = OID::Cidr.new
ip = IPAddr.new("255.0.0.0/8")
ip2 = IPAddr.new("127.0.0.1")
column = connection.columns(:strings).find { |c| c.name == "somedate" }
data = "\u001F\x8B"
data = (+"\u001F\x8B").force_encoding("BINARY")
data = "\u001F"
data = "'\u001F\\"
data = File.read(File.join(__dir__, "..", "..", "..", "assets", "example.log"))
def load(str); str; end
def dump(str); str; end
t.bit :a_bit, default: "00000011", limit: 8
assert_match %r{t\.bit\s+"a_bit",\s+limit: 8,\s+default: "00000011"$}, output
assert_match %r{t\.bit_varying\s+"a_bit_varying",\s+limit: 4,\s+default: "0011"$}, output
Post.where("title = ?", 0).count
Post.where("title = ?", 0.0).count
Post.where("title = ?", false).count
Post.where("title = ?", BigDecimal(0)).count
Post.where("title = ?", Rational(0)).count
t.string "tags", array: true, limit: 255
def to_a; @tags end
@connection.execute "insert into pg_arrays (tags) VALUES ('{1,2,3}')"
@connection.insert_fixture({ "tags" => tag_values }, "pg_arrays")
record = PgArray.new { |a| a.ratings = (1..10).to_a }
record = PgArray.new { |a| a.ratings = (1..11).to_a }
unknown = 'foo\\",bar,baz,\\'
x = PgArray.create!(tags: %w(one two))
x.tags << "three"
record = PgArray.new(tags: "")
record = PgArray.new(tags: "{1,2,3}")
x = PgArray.create!(field => array)
x.public_send("#{field}=", array)
expected = %(CREATE INDEX "index_people_on_last_name" ON "people" USING #{type} ("last_name"))
t.virtual :lower_name, type: :string, as: "LOWER(name)"
assert_match(/t\.virtual\s+"upper_name",\s+type: :string,\s+as: "(?:UPPER|UCASE)\(`name`\)"$/i, output)
assert_match(/t\.virtual\s+"name_length",\s+type: :integer,\s+as: "(?:octet_length|length)\(`name`\)",\s+stored: true$/i, output)
assert_match(/t\.virtual\s+"name_octet_length",\s+type: :integer,\s+as: "(?:octet_length|length)\(`name`\)",\s+stored: true$/i, output)
assert_match(/t\.virtual\s+"profile_email",\s+type: :string,\s+as: "json_extract\(`profile`,\w*?'\$\.email'\)", stored: true$/i, output)
@connection.columns("unsigned_types").select { |c| /^unsigned_/.match?(c.name) }.each do |column|
expected = /create_table "mysql_table_options", charset: "utf8mb4"(?:, collation: "\w+")?, options: "ENGINE=MyISAM", force: :cascade/
expected = /create_table "mysql_table_options", charset: "latin1"(?:, collation: "\w+")?, force: :cascade/
@connection.execute("SET @@SESSION.sql_mode='#{new_sql_mode}'")
@connection.execute("SET @@SESSION.sql_mode='#{old_sql_mode}'")
expected = /create_table "mysql_table_options", charset: "utf8mb4"(?:, collation: "\w+")?(:?, options: "ENGINE=InnoDB ROW_FORMAT=DYNAMIC")?, force: :cascade/
expected = /create_table "mysql_table_options", charset: "utf8mb4"(?:, collation: "\w+")?, force: :cascade/
rows = @connection.select_rows("CALL ten();")
t.column :set_column, "set('text','blob','tiny','medium','long','unsigned','bigint')"
assert_match %r{t\.column "set_column", "set\('text','blob','tiny','medium','long','unsigned','bigint'\)"$}, schema
self.table_name = "#{db}.#{table}"
column_no_limit = @connection.columns(:mysql_doubles).find { |c| c.name == "float_no_limit" }
column_short = @connection.columns(:mysql_doubles).find { |c| c.name == "float_short" }
column_long = @connection.columns(:mysql_doubles).find { |c| c.name == "float_long" }
column_23 = @connection.columns(:mysql_doubles).find { |c| c.name == "float_23" }
column_24 = @connection.columns(:mysql_doubles).find { |c| c.name == "float_24" }
column_25 = @connection.columns(:mysql_doubles).find { |c| c.name == "float_25" }
table = "key_tests"
assert_equal "'4.2'", expected
assert_sql(%r{\ASELECT /\*\+ \*\* // `posts`\.\*, // \*\* \*/}) do
posts = Post.optimizer_hints("**// `posts`.*, //**")
assert_sql(%r{\ASELECT `posts`\.`id`}) do
@configuration.merge("sslca" => "ca.crt"),
def query(*)
%r/Column `old_car_id` on table `engines` does not match column `id` on `old_cars`, which has type `int(\(11\))?`\./,
%r/To resolve this issue, change the type of the `old_car_id` column on `engines` to be :integer\. \(For example `t.integer :old_car_id`\)\./,
@conn.execute(<<~SQL)
%r/Column `old_car_id` on table `foos` does not match column `id` on `old_cars`, which has type `int(\(11\))?`\./,
%r/To resolve this issue, change the type of the `old_car_id` column on `foos` to be :integer\. \(For example `t.integer :old_car_id`\)\./,
%r/Column `car_id` on table `foos` does not match column `id` on `cars`, which has type `bigint(\(20\))?`\./,
%r/To resolve this issue, change the type of the `car_id` column on `foos` to be :bigint\. \(For example `t.bigint :car_id`\)\./,
result = @conn.execute('SELECT 1 + "foo"')
@conn.execute('SELECT 1 + "foo"')
@conn.execute("SET @@SESSION.sql_mode='#{old_sql_mode}'")
super(@conn, "ex", definition, &block)
@conn.update("UPDATE `engines` SET `engines`.`car_id` = '9989' WHERE `engines`.`car_id` = '138853948594'")
@conn.execute("REPLACE INTO `engines` SET `engines`.`car_id` = '249823948'")
assert_equal 1, @conn.execute("/*action:index*/(\n( SELECT `engines`.* FROM `engines` WHERE `engines`.`car_id` = '138853948594' ) )").entries.count
assert_nil @conn.execute("USE #{db_name}")
assert_match %r(posts |.* ALL), explain
conn.database_version >= "6.0"
conn.mariadb? && conn.database_version >= "10.1.0"
enum state: {
start: 0,
middle: 1,
t.column :enum_column, "enum('text','blob','tiny','medium','long','unsigned','bigint')"
assert_match %r{t\.column "enum_column", "enum\('text','blob','tiny','medium','long','unsigned','bigint'\)"$}, schema
config = make_db_config(adapter: "mysql2", database: "db", username: "user", password: "qwerty")
stub_version "5.6.4" do
stub_version "5.6.3" do
Bulb.create!(name: "Jimmy", color: "blue")
@connection.send(:rename_column_for_alter, "bar_baz", "foo", "foo2")
lock_name = "test lock'n'name"
lock_name = "fake lock'n'name"
column = @connection.columns(:charset_collations).find { |c| c.name == "title" }
BooleanType.columns.find { |c| c.name == "archived" }
BooleanType.columns.find { |c| c.name == "published" }
str = "foo?bar"
str = "foo\0bar"
assert_match(/t\.integer\s+"id",\s+null: false,\s+auto_increment: true$/, output)
sql: sql,
expected = "CREATE INDEX `index_people_on_last_name` ON `people` (`last_name`(10))"
expected = "CREATE INDEX `index_people_on_last_name_and_first_name` ON `people` (`last_name`(15), `first_name`(15))"
expected = "CREATE INDEX `index_people_on_last_name_and_first_name` ON `people` (`last_name`(15), `first_name`(10))"
expected = "CREATE #{type} INDEX `index_people_on_last_name` ON `people` (`last_name`)"
%w(btree hash).each do |using|
expected = /\ACREATE TABLE `people` \(#{type} INDEX `index_people_on_last_name` \(`last_name`\)\)/
expected = "ALTER TABLE `people` ADD #{type} INDEX `index_people_on_last_name` (`last_name`)"
b = Book.create(name: "my \x00 book")
b.update(name: "my other \x00 book")
id = @connection.insert("INSERT INTO events(id) VALUES (#{bind_param.to_sql})", nil, nil, nil, nil, binds)
assert_equal({ "id" => 1, "title" => "foo" }, result.first)
Post.create!(author: author, title: "foo", body: "bar")
assert_equal({ "title" => "foo" }, @connection.select_one(query))
Post.create!(title: "foo", body: "bar")
@connection.execute "INSERT INTO fk_test_has_fk (id,fk_id) VALUES (#{id_value},#{fk_id})"
sub.id = "bob drake"
if attempts == 0
attempts += 1
sleep(0.2)
require_relative "../../../tools/test_common"
tag = Tag.create!(name: "Der be treasure")
tag2 = Tag.create!(name: "Der be rum")
assert_difference -> { Tag.count }, -2 do
assert_difference -> { Tag.count }, -1 do
assert_difference -> { Content.count }, -1 do
assert_no_difference -> { Tag.count } do
@primary_keys = {}
def merge_column(table_name, name, sql_type = nil, options = {})
name.to_s,
template "model.rb", File.join("app/models", class_path, "#{file_name}.rb")
template "module.rb", File.join("app/models", "#{class_path.join('/')}.rb") if behavior == :invoke
attributes.select { |a| !a.reference? && a.has_index? }
when /^(add)_.*_to_(.*)/, /^(remove)_.*?_from_(.*)/
when /^create_(.+)/
def over(expr = nil)
@dispatch_cache ||= Hash.new do |hash, klass|
collector << " FROM "
collect_nodes_for o.wheres, collector, " WHERE ", " AND "
collector << " ("
collector << ", " unless i == 0
collector << ")"
collector = visit(o.expressions, collector) << ")"
collector << " AS "
collector << "("
collector << ", " unless k == 0
collector << " "
collector = o.cores.inject(collector) { |c, x|
if o.source && !o.source.empty?
collect_nodes_for o.havings, collector, " HAVING ", " AND "
hints = o.expr.map { |v| sanitize_as_sql_comment(v) }.join(" ")
collector << "/*+ #{hints} */"
collector << o.values.map { |v| "/* #{sanitize_as_sql_comment(v)} */" }.join(" ")
collector << "WITH "
collector << "( "
infix_value(o, collector, " INTERSECT ") << " )"
infix_value(o, collector, " EXCEPT ") << " )"
collector << " " if o.partitions.any?
collector << " " if o.partitions.any? || o.orders.any?
collector << "ROWS "
visit(o.left, collector) << " OVER ()"
visit(o.left, collector) << " OVER #{quote_column_name o.right.to_s}"
visit(o.expr, collector) << ")"
if o.type == :in
collector << " IN ("
visit(o.ast, collector) << ")"
visit(o.expr, collector) << " ASC"
visit(o.expr, collector) << " DESC"
collector = inject_join(o.expressions, collector, ", ") << ")"
return collector << "1=0"
return collector << "1=1"
collector << " >= "
collector << " > "
collector << " <= "
collector << " < "
collector << " LIKE "
collector << " " if o.left
collector << "ON "
collector << "NOT ("
collector << quote_table_name(o.name) << " " << quote_table_name(o.table_alias)
attr, values = o.left, o.right
if Array === values
visit(attr, collector) << " IN ("
visit(values, collector) << ")"
visit(attr, collector) << " NOT IN ("
if o.is_a?(Arel::Nodes::Or)
collector << " OR " unless stack.empty?
collector << " = "
collector << " = 0"
collector << " = 1"
collector << " != "
collector << "CASE "
collector << "END"
collector << "WHEN "
collector << " THEN "
collector << "ELSE "
collector << quote_table_name(join_name) << "." << quote_column_name(o.name)
collector << o.to_s
if value.none? { |v| Arel.arel_node?(v) }
if $1
collector << $1
bind_index += 1
if $2
collector << $2
collector << " #{o.operator} "
inject_join o, collector, ", "
list.each_with_index do |x, i|
collector << join_str unless i == 0
o.limit || o.offset || !o.orders.empty?
!o.groups.empty? && !o.havings.empty?
if o.key && (has_limit_or_offset_or_orders?(o) || has_join_sources?(o))
collector << "#{name}("
collector << " OR ("
o.limit = Arel::Nodes::Limit.new(-1) if o.offset && !o.limit
collector << "1"
collector << "0"
collector << " IS "
op = o.case_sensitive ? " ~ " : " ~* "
op = o.case_sensitive ? " !~ " : " !~* "
visit(o.expr, collector) << " )"
collector << " )"
collector << "CAST("
if o.offset && !o.limit
o.froms ||= Arel.sql("DUAL")
collector << ", "
collector << ") "
collector << " <=> "
collector << "NOT "
if o.offset || has_group_by_and_having?(o) ||
class Node # :nodoc:
class Edge < Struct.new :name, :from, :to # :nodoc:
visit_edge o, "expr"
visit_edge o, "left"
visit_edge o, "name"
visit_edge o, "rows"
visit_edge o, "lock"
visit_edge o, "with"
visit_edge o, "key"
visit_edge o, "type"
edge(i) { visit child }
visit_edge(o, "value")
o.each_with_index do |pair, i|
edge("pair_#{i}") { visit pair }
edge(i) { visit member }
visit_edge(o, "values")
visit_edge(o, "case")
@nodes << node
@edges << edge
string.to_s.gsub('"', '\"')
@nodes.map { |node|
label = "<f0>#{node.name}"
label += "|<f#{i + 1}>#{quote field}"
}.join("\n") + "\n" + @edges.map { |edge|
}.join("\n") + "\n}"
if String === values
@ast.values = values.map { |column, value|
@ast.havings << expr
def key=(key)
@ast.wheres << expr
@ast = @ast.clone
@engine = nil
@name = name.to_s
if as.to_s == @name
as = nil
def alias(name = "#{self.name}_2")
name = name.to_s if name.is_a?(Symbol)
self.class == other.class &&
self.name == other.name &&
alias :== :eql?
@ctx = @ast.cores.last
@ast.limit && @ast.limit.expr
@ast.cores.filter_map { |x| x.from }
@ctx.havings << expr
@ast.orders.concat expr.map { |x|
@ctx.wheres << expr
base = table_name.nil? ? ast : as(table_name)
@ast.limit = nil
exprs.map! { |expr|
if String === expr
if exprs.length == 1
if unboundable?(other.begin) == 1 || unboundable?(other.end) == -1
if infinity?(other.begin) == 1 || infinity?(other.end) == -1
others.map { |v| quoted_node(v) }
nodes = others.map { |expr| send(method_id, expr, *extras) }
value.nil? || infinity?(value) || unboundable?(value)
@orders.concat expr.map { |x|
String === x || Symbol === x ? Nodes::SqlLiteral.new(x.to_s) : x
def rows(expr = nil)
@orders = @orders.map { |x| x.clone }
self.orders == other.orders &&
super && self.name == other.name
self.wheres == other.wheres &&
self.values == other.values &&
self.groups == other.groups &&
self.limit == other.limit &&
self.offset == other.offset &&
super(:~, operand)
@expr = expr
}.each do |name|
self.cores == other.cores &&
self.lock == other.lock &&
alias :froms= :from=
self.source == other.source &&
!left && right.empty?
self.select == other.select &&
super(:*, left, right)
super(:/, left, right)
super(:+, left, right)
super(:-, left, right)
super(:"||", left, right)
super(:"@>", left, right)
super(:"&&", left, right)
super(:&, left, right)
super(:|, left, right)
super(:^, left, right)
super(:<<, left, right)
super(:>>, left, right)
super || (self.class == other.class && self.ivars == other.ivars)
type == :in
Arel::Nodes::HomogeneousIn.new(values, attribute, type == :in ? :notin : :in)
self.alias == other.alias &&
super &&
@limit = nil
@offset = nil
@key = nil
def nil?; value.nil?; end
self.value == other.value &&
class Quoted < Arel::Nodes::Unary # :nodoc:
@case = @case.clone if @case
@conditions = @conditions.map { |x| x.clone }
self.case == other.case &&
class When < Binary # :nodoc:
class Else < Unary # :nodoc:
if !(missing = (tokens_in_string - tokens_in_hash)).empty?
if missing.size == 1
other.is_a?(BindParam) &&
self.left == other.left &&
def &(other)
def |(other)
def ^(other)
def <<(other)
def >>(other)
def ~@
def values=(val); @ast.values = val; end
if String === fields
super("#{message} in: #{sql.inspect}")
key = nil,
um.key = key
dm.key = key
self << binds.map { |bind| quoter.quote(bind) }.join(", ")
@bind_index = 1
self << yield(@bind_index)
@bind_index += 1
self << (@bind_index...@bind_index += binds.size).map(&block).join(", ")
@str = +""
@str << str
@left = left
left << str
right << str
@binds << bind
def self.star # :nodoc:
sql "*"
def self.arel_node?(value) # :nodoc:
value.is_a?(Arel::Nodes::Node) || value.is_a?(Arel::Attribute) || value.is_a?(Arel::Nodes::SqlLiteral)
@covered ||= self.attributes.map(&:to_s).select do |attr|
index.where.nil? &&
if !options.key?(:case_sensitive) || bind.nil?
if Array(value).reject { |r| valid_object?(r) }.any?
def save!(**options)
new_record? ? :create : :update
class Map # :nodoc:
super * 2
@mapping = {}
lookup("#{target_key}#{metadata}")
key === lookup_key
value.__getobj__
raw_old_value.nil? != raw_new_value.nil? ||
@cache = Concurrent::Map.new do |h, key|
register_type(type) { |_, *args| lookup(alias_type, *args) }
block = proc { |_, *args| klass.new(*args) }
def call(_registry, *args, adapter: nil, **kwargs)
def matches?(type_name, *args, **kwargs)
type_name == name && matches_adapter?(**kwargs)
result = 0
result |= 1
result |= 2
(self.adapter.nil? || adapter == self.adapter)
(override.nil? && other.adapter) ||
def matches?(*args, **kwargs)
super | 4
def before_commit(*args, &block) # :nodoc:
-> { transaction_include_any_action?(fire_on) },
def save(**) # :nodoc:
def save!(**) # :nodoc:
def touch(*, **) # :nodoc:
@_start_transaction_state ||= {
id: id,
def touch_later(*names) # :nodoc:
@_defer_touch_attrs |= names.map! do |name|
if r.macro == :belongs_to
elsif r.macro == :has_one
def touch(*names, time: nil) # :nodoc:
@_defer_touch_attrs, @_touch_time = nil, nil
attribute_names |= names.map(&:to_s)
@_touch_record = nil
key = fs_name.to_s.include?("/") ? -fs_name.to_s.tr("/", "_") : fs_name
key = -key.to_s if key.is_a?(Symbol)
fs_name = -fs_name.to_s if fs_name.is_a?(Symbol)
@fixture_cache = {}
@@already_loaded_fixtures ||= {}
f_name = f_name.to_s if f_name.is_a?(Symbol)
db_config._database = "#{db_config.database}-#{i}"
file = File.absolute_path?(db_path) ? db_path : File.join(root, db_path)
condition = ignore_tables.map { |table| connection.quote(table) }.join(", ")
args << ".schema"
msg = +"failed to execute:\n"
msg << "#{cmd} #{args.join(' ')}\n\n"
search_path = \
args += search_path.split(",").map do |part|
run_cmd("pg_dump", args, "dumping")
File.open(filename, "a") { |f| f << "SET search_path TO #{connection.schema_search_path};\n\n" }
run_cmd("psql", args, "loading")
{}.tap do |env|
args += ignore_tables.map { |table| "--ignore-table=#{db_config.database}.#{table}" }
run_cmd("mysql", args, "loading")
sslcapath: "--ssl-capath",
sslcipher: "--ssl-cipher",
msg = +"failed to execute: `#{cmd}`\n"
@tasks ||= {}
File.join(root, "test", "fixtures")
@root ||= Rails.root
@env ||= Rails.env
@name ||= "primary"
dbs_list << "#{command}:#{db.name}"
puts "-" * 50
File.open(filename, "w:utf-8") do |file|
File.open(filename, "a") do |f|
f.print "\n"
next if name && name != db_config.name
if stored && stored != current
define_method("#{accessor_key}=") do |value|
prev_store&.dig(key) != new_store&.dig(key)
parent.merge!(local_stored_attributes) { |k, a, b| a | b }
@coder =
obj.respond_to?(:to_hash) ? obj.to_hash : {}
@sql = sql
}.map(&:last)
@indexes.each do |i|
@parts << str
@binds << obj
@parts << ", " unless i == 0
@indexes << i
@bind_map = bind_map
options = options ? options.dup : {}
!has_attribute?(name) && has_attribute?("#{name}_digest")
end.map(&:to_h)
return if passwords.any? { |name, value| value.nil? || value.empty? }
raise ArgumentError, "You tried to define a scope named \"#{name}\" " \
scope = all._exec_scope(*args, &body)
scope = body.call(*args) || all
def default_scope(scope = nil, all_queries: nil, &block) # :doc:
if scope.is_a?(Relation) || !scope.respond_to?(:call)
@ignore_default_scope = {}
@global_current_scope = {}
versions.map(&:to_i)
stringified.insert(4, "_").insert(7, "_").insert(10, "_")
@version ? "version: #{formatted_version}" : ""
tbl.print ", primary_key: #{pk.inspect}" unless pk == "id"
pkcol = columns.detect { |c| c.name == pk }
pkcolspec = { id: { type: pkcolspec.delete(:id), **pkcolspec }.compact }
tbl.print ", primary_key: #{pk.inspect}"
tbl.print ", id: false"
tbl.puts ", force: :cascade do |t|"
parts << "name: #{foreign_key.name.inspect}"
options.map { |key, value| "#{key}: #{value.inspect}" }.join(", ")
table.sub(/\A#{prefix}(.+)#{suffix}\z/, "\\1")
def define(info = {}, &block)
def define(info, &block) # :nodoc:
@class_for_version ||= {}
if condition.is_a?(Array) && condition.first.to_s.include?("?")
if string.include?(escape_character) && escape_character != "%" && escape_character != "_"
if values.first.is_a?(Hash) && /:\w+/.match?(statement)
next if arg.is_a?(Symbol) || Arel.arel_node?(arg) || permit.match?(arg.to_s.strip)
statement.gsub(/\?/) do
if $1 == ":" # skip postgresql casts
if value.respond_to?(:map) && !value.acts_like?(:string)
values = value.map { |v| v.respond_to?(:id_for_database) ? v.id_for_database : v }
values.map! { |v| c.quote(c.cast_bound_value(v)) }.join(",")
hash_rows.to_enum { @rows.size }
alias :to_a :to_ary
def last(n = nil)
n ? hash_rows.last(n) : hash_rows.last
def result # :nodoc:
def cancel # :nodoc:
def cast_values(type_overrides = {}) # :nodoc:
rows.map do |(value)|
def freeze # :nodoc:
@hash_rows ||=
columns = @columns.map(&:-@)
@rows.map { |row|
index = -1
index = 0
index += 1
delegate :any?, :empty?, to: :predicates
left = self - other
common = self - left
if left.empty? || right.empty?
alias :eql? :==
Array === x.right && x.right.empty?
each_attributes { |attr, _| attrs << attr }
!node.is_a?(String) && node.equality?
attrs = columns.extract! { |node| node.is_a?(Arel::Attribute) }
non_attrs = columns.extract! { |node| node.is_a?(Arel::Predications) }
if ::String === node
elsif Array === node
node.map { |v| extract_node_value(v) }
def spawn # :nodoc:
def merge!(other, *rest) # :nodoc:
if other.is_a?(Hash)
def not(opts, *rest)
def includes!(*args) # :nodoc:
def eager_load!(*args) # :nodoc:
def preload!(*args) # :nodoc:
def _select!(*fields) # :nodoc:
def with!(*args) # :nodoc:
def reselect!(*args) # :nodoc:
def group!(*args) # :nodoc:
def regroup!(*args) # :nodoc:
def order!(*args) # :nodoc:
def reorder!(*args) # :nodoc:
def unscope!(*args) # :nodoc:
if key != :where
def joins!(*args) # :nodoc:
def left_outer_joins!(*args) # :nodoc:
elsif args.length == 1 && args.first.blank?
def where!(opts, *rest) # :nodoc:
def and!(other) # :nodoc:
def or!(other) # :nodoc:
opts.blank? ? self : spawn.having!(opts, *rest)
def having!(opts, *rest) # :nodoc:
def limit!(value) # :nodoc:
def offset!(value) # :nodoc:
def lock!(locks = true) # :nodoc:
def none! # :nodoc:
def readonly!(value = true) # :nodoc:
def strict_loading!(value = true) # :nodoc:
def create_with!(value) # :nodoc:
def from!(value, subquery_name = nil) # :nodoc:
def distinct!(value = true) # :nodoc:
def extending!(*modules, &block) # :nodoc:
def skip_query_cache!(value = true) # :nodoc:
def annotate!(*args) # :nodoc:
values.uniq! if values.is_a?(Array) && !values.empty?
def arel(aliases = nil) # :nodoc:
@arel ||= build_arel(aliases)
@async = true
name ||= "subquery"
if join.is_a?(Arel::Nodes::Join)
if klass.columns_hash.key?(field) && (!from || table_name_matches?(from))
elsif field.match?(/\A\w+\.\w+\z/)
table, column = field.split(".")
/(?:\A|(?<!FROM)\s)(?:\b#{table_name}\b|#{quoted_table_name})(?!\.)/i.match?(from.to_s)
o.split(",").map! do |s|
s.gsub!(/\sasc\Z/i, " DESC") || s.gsub!(/\sdesc\Z/i, " ASC") || (s << " DESC")
(order.include?(",") && order.split(",").find { |section| section.count("(") != section.count(")") }) ||
/\bnulls\s+(?:first|last)\b/i.match?(order)
arg.each do |_key, value|
order_args.flat_map { |a| a.is_a?(Hash) ? a.keys : a },
arg.map { |field, dir|
key if key.is_a?(String) || key.is_a?(Symbol)
references.map! { |arg| arg =~ /^\W?(\w+)\W?\./ && $1 }.compact!
if attr_name == "count" && !group_values.empty?
attr = attr.to_s
if attr.include?(".")
table, column = attr.split(".", 2)
if field.is_a?(Hash)
arel_column("#{key}.#{column}") do
arel_column("#{key}.#{column}", &:itself)
).freeze # :nodoc:
if v1.is_a?(Array)
v1 = v1.uniq
v2 = v2.uniq
serializable? { |value| @_unboundable = value <=> 0 } && @_unboundable = nil
query = {}
value.map { |v| convert_to_id(v) }
values = value.map { |x| x.is_a?(Base) ? x.id : x }
nils = values.extract!(&:nil?)
ranges = values.extract! { |v| v.is_a?(Range) }
result << Arel.sql(key)
elsif key.include?(".")
result << Arel.sql(key.split(".").first)
if value.is_a?(Hash) && !table.has_column?(key)
if mapping.length == 1 || values.empty?
queries.map! { |query| query.reduce(&:and) }
k.include?(".") && !v.is_a?(Hash)
table_name, column_name = key.split(".")
@handlers.detect { |klass, _| klass === object }.last
k = :_select if k == :select
if Array === v
other.public_send("#{k}!", *v)
other.public_send("#{k}!", v)
unless value.nil? || (value.blank? && false != value)
relation.public_send(:"#{name}!", *value)
end || return
self.class == other.class && value == other.value && name == other.name
@empty ||= new(nil, nil).freeze
def find_by(arg, *args)
def find_by!(arg, *args)
where(arg, *args).take!
if loaded? || offset_value || limit_value || having_clause.any?
record.is_a?(klass) && exists?(record.id)
error = +"Couldn't find #{name}"
error = "Couldn't find #{name} with '#{key}'=#{ids}#{conditions}"
error = +"Couldn't find all #{name.pluralize} with '#{key}': "
error << "(#{ids.join(", ")})#{conditions} (found #{result_size} results, but was looking for #{expected_size})."
error << " Couldn't find #{name.pluralize(not_found_ids.size)} with #{key.to_s.pluralize(not_found_ids.size)} #{not_found_ids.join(', ')}." if not_found_ids
relation = except(:select, :distinct, :order)._select!(ONE_AS_ONE).limit!(1)
if eager_loading && has_limit_or_offset? && !(
), nil
result.in_order_of(:id, ids.map { |id| @klass.type_for_attribute(primary_key).cast(id) })
@take ||= limit(1).records.first
@offsets ||= {}
if limit > 0
mangled_name = klass.name.gsub("::", "_")
def #{method}(...)
scoping { klass.#{method}(...) }
delegate :to_xml, :encode_with, :length, :each, :join,
:to_sentence, :to_fs, :to_formatted_s, :as_json,
:shuffle, :split, :slice, :index, :rindex, to: :records
scoping { @klass.public_send(method, *args, &block) }
@aliases = Hash.new(0)
column_alias.gsub!(/\*/, "all")
column_alias.gsub!(/\W+/, " ")
column_alias.gsub!(/ +/, "_")
eager_loading? || (includes_values.present? && column_name && column_name != :all)
if operation == "count"
if column_name == :all
Arel.sql(column_name == :all ? "*" : name)
if operation == "count" && (column_name == :all && distinct || has_limit_or_offset?)
if operation != "count"
type = column.try(:type_caster) ||
key_types = group_columns.each_with_object({}) do |(aliaz, col_name), types|
key = key.first if key.size == 1
field_name = field.respond_to?(:name) ? field.name.to_s : field.to_s.split(".").last
when "sum"
else # "minimum", "maximum"
select_values.join(", ")
def initialize(of: 1000, start: nil, finish: nil, relation:, order: :asc, use_ranges: nil) # :nodoc:
@of
@relation.to_enum(:in_batches, of: @of, start: @start, finish: @finish, load: true, order: @order).each do |relation|
enum = @relation.to_enum(:in_batches, of: @of, start: @start, finish: @finish, load: false, order: @order, use_ranges: @use_ranges)
(total - 1).div(batch_size) + 1
ids = records.map(&:id)
elsif (empty_scope && use_ranges != false) || use_ranges
scoping { _new(attributes, &block) }
scoping { _create!(attributes, &block) }
def first_or_create!(attributes = nil, &block) # :nodoc:
def none?(*args)
def any?(*args)
def one?(*args)
@cache_keys ||= {}
@cache_versions ||= {}
if size > 0
select_values = "COUNT(*) AS #{connection.quote_column_name("size")}, MAX(%s) AS timestamp"
size = 0
def _exec_scope(...) # :nodoc:
_scoping(nil, registry) { instance_exec(...) || self }
def update(id = :all, attributes) # :nodoc:
if id == :all
def update!(id = :all, attributes) # :nodoc:
updates = {}
names = touch if touch != true
method == :distinct ? value : value&.any?
if !loaded? || scheduled?
@to_sql = @arel = @loaded = @should_eager_load = nil
@offsets = @take = nil
@to_sql ||= if eager_loading?
@should_eager_load ||=
other.to_sql == to_sql
def empty_scope? # :nodoc:
-> record do
expr = value < 0 ? expr - bind : expr + bind
name = -name.to_s
@__reflections ||= begin
ref = {}
@__reflections = nil
if has_inverse? && inverse_of == self
message = +"`#{owner}` is marked for strict_loading."
message << " The #{polymorphic? ? "polymorphic association" : "#{klass} association"}"
message << " named `:#{name}` cannot be lazily loaded."
super ||
if error.name.match?(/(?:\A|::)#{name}\z/)
key = self
def join_id_for(owner) # :nodoc:
reflection != self &&
def has_one?; true; end
names = names.find_all { |n|
:name, :scope_for, to: :@reflection
lambda { |object| where(type => source_type) }
if operation == :perform && block
messages << ("ActiveRecord: %.1fms" % db_runtime.to_f) if db_runtime
def initialize(...) # :nodoc:
self.db_runtime = (db_runtime || 0) + db_rt_before_render
configs.each do |k, v|
setter = "#{k}="
if Class === value && ActiveRecord::Base > value
:find, :find_by, :find_by!, :take, :take!, :sole, :find_sole_by, :first, :first!, :last, :last!,
:second, :second!, :third, :third!, :fourth, :fourth!, :fifth, :fifth!,
:forty_two, :forty_two!, :third_to_last, :third_to_last!, :second_to_last, :second_to_last!,
:exists?, :any?, :many?, :none?, :one?,
:destroy_all, :delete_all, :update_all, :touch_all, :destroy_by, :delete_by,
:select, :reselect, :order, :regroup, :in_order_of, :reorder, :group, :limit, :offset, :joins, :left_joins, :left_outer_joins,
:having, :create_with, :distinct, :references, :none, :unscope, :merge, :except, :only,
:count, :average, :minimum, :maximum, :sum, :calculate,
:pluck, :pick, :ids, :async_ids, :strict_loading, :excluding, :without, :with,
def _load_from_sql(result_set, &block) # :nodoc:
column_types = column_types.reject { |k, _| attribute_types.key?(k) }
@key_value_separator = ":"
pairs.map! do |key, value|
end.join(",")
@key_value_separator = "="
pairs.sort_by!(&:first)
comment.gsub!(%r{\A\s*/\*\+?\s?|\s?\*/\s*\Z}, "")
comment.gsub!("*/", "* /")
comment.gsub!("/*", "/ *")
undef_method :==, :!, :!=
@value = if @block
Promise.new(@future_result, @block ? @block >> block : block)
def pretty_print(q) # :nodoc:
if id.is_a?(Array)
id.map { |one_id| find(one_id) }.each_with_index { |object, idx|
elsif id == :all
!new_record? && destroyed?
!(@new_record || @destroyed)
def save!(**options, &block)
public_send("#{name}=", value)
name = key.to_s
attributes = attributes.each_with_object({}) do |(k, v), h|
change = public_send(attribute) - (public_send(:"#{attribute}_in_database") || 0)
_find_record((options || {}).merge(all_queries: true))
end.map(&:first)
{ @primary_key => id }
{ @primary_key => id_in_database }
def create_or_update(**, &block)
result = new_record? ? _create_record(&block) : _update_record(&block)
self.id ||= new_id if @primary_key
group_values.any? ? Hash.new : 0
def apply_to(klass) # :nodoc:
def applied_to?(klass) # :nodoc:
klasses.any? { |k| k >= klass }
def touch_later(*) # :nodoc:
REJECT_ALL_BLANK_PROC = proc { |attributes| attributes.all? { |key, value| key == "_destroy" || value.blank? } }
generated_association_methods.module_eval <<-eoruby, __FILE__, __LINE__ + 1
limit = \
model, "id", record_id)
value = value && value.to_s
(@sequence_name ||= nil) || base_class.sequence_name
c.name == primary_key ||
c.name.end_with?("_id", "_count")
contained += "_"
def find_join_table_name(table_1, table_2, options = {})
name = "V#{version.tr('.', '_')}"
class V7_0 < V7_1
class << t
class V6_1 < V7_0
type.to_sym == :datetime ? :timestamp : type
if type == :datetime
class V6_0 < V6_1
class V5_1 < V5_2
class V5_0 < V5_1
type = :integer if type == :primary_key
super(*args, type: :integer, **options)
if type == :primary_key
class V4_2 < V5_0
@commands << (command << block)
method = :"invert_#{command}"
}.each do |cmd, inv|
if args.size == 1 && block == nil
unless options.is_a?(Hash) && options.has_key?(:from) && options.has_key?(:to)
message = "\n\n#{message}\n\n" if message
message += " RAILS_ENV=#{::Rails.env}" if defined?(Rails.env) && !Rails.env.local?
message += "\n\n"
message += "You have #{pending_migrations.size} pending #{pending_migrations.size > 1 ? 'migrations:' : 'migration:'}\n\n"
msg << "You are running in `#{ current }` environment. "
super("#{msg}\n\n")
/\A\d(_?\d)*\z/ # integer with optional underscores
def method_missing(name, *args, &block) # :nodoc:
time = nil
text = "#{version} #{name}: #{message}"
say "%.4fs" % time.real, :subitem
say("#{result} rows", :subitem) if result.is_a?(Integer)
arg_list = arguments.map(&:inspect) * ", "
say_with_time "#{method}(#{arg_list})" do
if method == :rename_table ||
(method == :remove_foreign_key && !arguments.second.is_a?(Hash))
magic_comments = +""
source.sub!(/\A(?:#.*\b(?:en)?coding:\s*\S+|#\s*frozen_string_literal:\s*(?:true|false)).*\n/) do |magic_comment|
end || break
if !magic_comments.empty? && source.start_with?("\n")
magic_comments << "\n"
when current_version == 0 && target_version == 0
def rollback(steps = 1) # :nodoc:
def forward(steps = 1) # :nodoc:
move(:up, steps)
def up(target_version = nil, &block) # :nodoc:
def down(target_version = nil, &block) # :nodoc:
def open # :nodoc:
status = db_list.delete(version) ? "up" : "down"
(db_list + file_list).sort_by { |_, version, _| version.to_i }
if up?
runnable.reject { |m| ran?(m) }
runnable.find_all { |m| ran?(m) }
@target_version && @target_version != 0 && !target
msg = +"An error has occurred, "
msg << "all later migrations canceled:\n\n#{e}"
up? ? 0 : (migrations.index(current) || 0)
name, = migrations.group_by(&:name).find { |_, v| v.length > 1 }
version, = migrations.group_by(&:version).find { |_, v| v.length > 1 }
@direction == :up
@direction == :down
time.to_i * 1000 + time.usec / 1000
timestamp ? Time.at(timestamp / 1000, (timestamp % 1000) * 1000) : Time.at(0)
def self.call(context, options = {})
attr = nil
when /select .*for update/mi, /\A\s*lock/mi
when /\A\s*select/i
when /\A\s*insert/i
when /\A\s*update/i
when /\A\s*delete/i
def lock!(lock = true)
raise(<<-MSG.squish)
Changed attributes: #{changed.map(&:inspect).join(', ')}.
lock = args.present? ? args.first : true
def increment!(*, **) # :nodoc:
def define_attribute(name, cast_type, **) # :nodoc:
self === subtype ? subtype : super
sm.limit = 1
if (default = super()) &&
(result = send(method_name).to_s).present? &&
timestamp.is_a?(String) &&
key = timestamp.delete("- :.")
key.ljust(20, "0")
@keys = @keys.to_set
message = +"#{model} "
message << "Bulk " if inserts.many?
message << (on_duplicate == :update ? "Upsert" : "Insert")
match = Array(name_or_columns).map(&:to_s)
if index = unique_indexes.find { |i| match.include?(i.name) || i.columns == match }
return if !value.is_a?(String) || Arel.arel_node?(value)
sql = +"(#{format_columns(index.columns)})"
sql << " WHERE #{index.where}" if index.where
columns.respond_to?(:map) ? quote_columns(columns).join(",") : columns
if abstract_class? || self == Base
if self == Base
:true == (@finder_needs_type_condition ||= descends_from_active_record? ? :false : :true)
def dup # :nodoc:
if type_name.start_with?("::")
name.scan(/::|$/) { candidates.unshift "#{$`}::#{type_name}" }
@base_class = if self == Base
if attrs.is_a?(Hash)
delegate :empty?, :to_a, to: :result
def instrument(name, payload = {}, &block)
@pool = pool
@error = nil
@result = nil
@pending && (!@session || @session.active?)
@session && !@session.active?
@lock_wait = 0.0
@result = exec_query(connection, *@args, **@kwargs, async: async)
def exec_query(*, **)
if column_type == :uuid
fixtures_map = {}
set.each { |fs| conn.reset_pk_sequence!(fs.table_name) }
).to_hash
if class_name.is_a?(Class) # TODO: Should be an AR::Base type class, or any?
::File.file?(f)
@tables.transform_values { |rows| rows.map(&:to_hash) }
now: now,
@now = now
@row.each do |key, value|
next if !model_metadata.has_column?(pk) || @row.include?(pk)
targets = targets.is_a?(Array) ? targets : targets.split(/\s*,\s*/)
%(!!binary "#{Base64.strict_encode64(File.binread(path))}")
@column_type ||= {}
@column_names ||= @model_class ? @model_class.columns.map(&:name).to_set : Set.new
class File # :nodoc:
x = new file
block_given? ? yield(x) : x
@rows ||= raw_rows.reject { |fixture_name, _| fixture_name == "_fixture" }
@config_row ||= begin
row = raw_rows.find { |fixture_name, _| fixture_name == "_fixture" }
{ 'model_class': nil, 'ignore': nil }
@raw_rows ||= begin
unless Hash === data
unless Hash === data || YAML::Omap === data
invalid = data.reject { |_, row| Hash === row }
EXPLAINED_SQLS = /\A\s*(\/\*.*\*\/)?\s*(with|select|update|delete|insert)\b/i
str = queries.map do |sql, binds|
msg = +"#{build_explain_clause(options)} #{sql}"
msg << " "
msg << binds.map { |attr| render_bind(attr) }.inspect
msg << "\n"
def initialize(message = nil, model = nil, primary_key = nil, id = nil)
super "Wanted only one #{record&.name || "record"}"
super(message || $!&.message)
sql: nil,
msg = <<~EOM.squish
Column `#{foreign_key}` on table `#{table}` does not match column `#{primary_key}` on `#{target_table}`,
To resolve this issue, change the type of the `#{foreign_key}` column on `#{table}` to be :#{type}.
(For example `t.#{type} :#{foreign_key}`).
msg << "\nOriginal message: #{message}"
if @query_parser && !@sql
).tap do |exception|
def initialize(message = nil, code = nil, level = nil, sql = nil)
@code = code
def load_schema! # :nodoc:
raise "Unknown enum attribute '#{name}' for #{self.name}" if Enum::EnumType === cast_type
raise ArgumentError, "'#{value}' is not a valid #{name}"
def enum(name = nil, values = nil, **options)
definitions.each { |name, values| _enum(name, values, **options) }
detect_enum_conflict!(name, "#{name}=")
prefix == true ? "#{name}_" : "#{prefix}_"
suffix == true ? "_#{name}" : "_#{suffix}"
value_method_name = "#{prefix}#{label}#{suffix}"
define_method("#{value_method_name}?") { public_send(:"#{name}_for_database") == value }
define_method("#{value_method_name}!") { update!(name => value) }
klass.scope value_method_name, -> { where(name => value) }
klass.scope "not_#{value_method_name}", -> { where.not(name => value) }
if values.keys.any?(&:blank?)
if values.any?(&:blank?)
method_names.select { |m| m.start_with?("not_") }.each do |potential_not|
inverted_form = potential_not.sub("not_", "")
logger.warn "Enum element '#{potential_not}' in #{self.name} uses the prefix 'not_'." \
compressed: "c",
iv: "iv",
auth_tag: "at",
encoding: "e"
define_method "#{name}=" do |value|
if level > 2
unless data.is_a?(Hash) && data.has_key?("p")
@keys = Array(keys)
@encryption_key ||= @keys.last.tap do |key|
@keys_grouped_by_id ||= @keys.group_by(&:id)
if args.is_a?(Array) && (options = args.first).is_a?(Hash)
@clean_values = {}
if default && default == value
raise if index == keys.length - 1
match && match.valid? || super
klass = matchers.find { |k| k.pattern.match?(name) }
def self.#{name}(#{signature})
attribute_names.map { |name| "_#{name}" }.join(", ")
@ids = ids.uniq
define_method "build_#{role}" do |*params|
public_send("#{role}=", public_send("#{role}_class").new(*params))
scope_name = type.tableize.tr("/", "_")
scope scope_name, -> { where(role_type => type) }
if url.nil? || url.start_with?("jdbc:", "http:", "https:")
{ url: url }
def socket # :nodoc:
def primary? # :nodoc:
@env_name = env_name
@adapter = @uri.scheme && @uri.scheme.tr("-", "_")
@adapter = "postgresql" if @adapter == "postgres"
@uri.opaque, @query = @uri.opaque.split("?", 2)
@query = @uri.query
@uri_parser ||= URI::Parser.new
if @adapter == "sqlite3"
.find do |db_config|
db_config.env_name == env.to_s ||
(db_config.for_current_env? && db_config.name == env.to_s)
def primary?(name) # :nodoc:
names = config.map(&:name)
raise InvalidConfigurationError, "'{ #{env_name} => #{config} }' is not a valid configuration. Expected '#{config}' to be a URL string or a Hash."
id = super
@find_by_statement_cache = { true => Concurrent::Map.new, false => Concurrent::Map.new }
def find(*ids) # :nodoc:
raise(RecordNotFound.new("Couldn't find #{name} with '#{primary_key}'=#{id}", name, primary_key, id))
def find_by(*args) # :nodoc:
hash = hash.each_with_object({}) do |(key, value), h|
def find_by!(*args) # :nodoc:
attr_list = attribute_types.map { |name, type| "#{name}: #{type.type}" } * ", "
def ===(object) # :nodoc:
@arel_table ||= Arel::Table.new(table_name, klass: self)
!id.nil? &&
id = self.id
def <=>(other_object)
to_key <=> other_object.to_key
def present? # :nodoc:
def blank? # :nodoc:
pp.seplist(attr_names, proc { pp.text "," }) do |attr_name|
pp.breakable " "
pp.text ":"
pp.text __getobj__
def connects_to(database: {}, shards: {})
if self != Base && !abstract_class
if self != Base || classes.include?(Base)
current_role == role.to_sym && current_shard == shard.to_sym
def clear_cache! # :nodoc:
gem "sqlite3", "~> 1.4"
when ":memory:"
when /\Afile:/
database_version >= "3.9.0"
database_version >= "3.8.3"
database_version >= "3.24.0"
fk_info = exec_query("PRAGMA foreign_key_list(#{quote(table_name)})", "SCHEMA")
fk_info.map do |row|
sql = +"INSERT #{insert.into} #{insert.values_list}"
sql << insert.updatable_columns.map { |column| "#{column}=excluded.#{column}" }.join(",")
if database_version < "3.8.0"
limit || 8
TYPE_MAP = Type::TypeMap.new.tap { |m| initialize_type_map(m) }
when /^null$/i
when /^'(.*)'$/m
$1.gsub("''", "'")
when /^"(.*)"$/m
$1.gsub('""', '"')
when /\A-?\d+(\.\d*)?\z/
$&
when /x'(.*)'/
def move_table(from, to, options = {}, &block)
def copy_table_indexes(from, to, rename = {})
if to == "a#{from}"
name = "t#{name}"
elsif from == "a#{to}"
options = { name: name.gsub(/(^|_)(#{from})_/, "\\1#{to}_"), internal: true }
quoted_columns = columns.map { |col| quote_column_name(col) } * ","
quoted_from_columns = from_columns_to_copy.map { |col| quote_column_name(col) } * ","
if exception.message.match?(/(column(s)? .* (is|are) not unique|UNIQUE constraint failed: .*)/i)
collation_hash = {}
auto_increments = {}
WHERE type = 'table' AND name = #{quote(table_name)}
columns_string = result.split("(", 2).last
orders = {}
index_sql.scan(/"(\w+)" DESC/).flatten.each { |order_column|
table = to_table || begin
end || raise(ArgumentError, "Table '#{from_table}' has no foreign key for #{to_table || options}")
WHERE name = #{quote(table_name)} AND type = 'table'
type = \
scope = {}
value = value.change(year: 2000, month: 1, day: 1)
quoted_date(value).sub(/\A\d\d\d\d-\d\d-\d\d /, "2000-01-01 ")
if value.is_a?(Proc)
if value.match?(/\A\w+\(.*\)\z/)
def type_cast(value) # :nodoc:
(?:
((?:\w+\.|"\w+"\.)?(?:\w+|"\w+") | \w+\((?:|\g<2>)\))
(?:(?:\s+AS)?\s+(?:\w+|"\w+"))?
(?:\s*,\s*\g<1>)*
\z
/ix
row.join("|")
end.join("\n") + "\n"
) # :nodoc:
def write_query?(sql) # :nodoc:
def execute(sql, name = nil, allow_retry: false) # :nodoc:
def initialize(*, auto_increment: nil, **)
other.is_a?(Column) &&
@sql_type = sql_type
sql_type == other.sql_type &&
type == other.type &&
limit == other.limit &&
precision.hash >> 1 ^
scale.hash >> 2
@sql_type = -sql_type
if File.extname(filename) == ".gz"
@columns_hash = {}
@data_sources = {}
tables_to_cache.each { |table| add(table) }
open(filename) { |f|
@indexes ||= {}
value.map { |i| deep_deduplicate(i) }
gem "pg", "~> 1.1"
rescue ::PG::Error => error
end.join(" ")
bit_varying: { name: "bit varying" },
database_version >= 11_00_00 # >= 11.0
database_version >= 12_00_00 # >= 12.0
database_version >= 9_05_00 # >= 9.5
@counter = 0
@type_map = nil
def discard! # :nodoc:
database_version >= 9_04_00 # >= 9.4
unless lock_id.is_a?(Integer) && lock_id.bit_length <= 63
schema, name = name.to_s.split(".").values_at(-2, -1)
sql << " SCHEMA #{schema}" if schema
sql_values = values.map { |s| quote(s) }.join(", ")
$$;
index.using == :btree || super
if database_version < 9_03_00 # < 9.3
m.alias_type "char", "varchar"
m.alias_type "name", "varchar"
m.register_type "numeric" do |_, fmod, sql_type|
if fmod && (fmod - 4 & 0xffff).zero?
if $1 == "now" && $2 == "date"
when "true", "false"
when /\A\(?(-?\d+(\.\d*)?)\)?(::bigint)?\z/
$1
when /\A-?\d+\z/
def get_oid_type(oid, fmod, column_name, sql_type = "")
if !type_map.key?(oid)
yield query + "WHERE t.oid IN (%s)" % oids.join(", ")
sql_key = sql_key(sql)
variables.map do |k, v|
if v == ":default" || v == :default
elsif !v.nil?
$1.strip if $1
@case_insensitive_cache ||= { "citext" => false }
) OR exists(
coders_by_name = {
known_coder_types = coders_by_name.keys.map { |n| quote(n) }
query = <<~SQL % known_coder_types.join(", ")
@timestamp_decoder = coders.find { |coder| coder.name == "timestamp" }
def decode(value, tuple = nil, field = nil)
class Name # :nodoc:
def ==(o)
o.class == self.class && o.parts == parts
alias_method :eql?, :==
@oid = oid
@fmod = fmod
__getobj__ == other.__getobj__ &&
oid == other.oid &&
__getobj__.hash ^
oid.hash ^
__setobj__(__getobj__.deduplicate)
def recreate_database(name, options = {}) # :nodoc:
option_string = options.each_with_object(+"") do |(key, value), memo|
memo << case key
opclasses = {}
WHERE a.attrelid = #{oid}
AND a.attnum IN (#{indkey.join(",")})
{ comment: comment }
WHERE nspname !~ '^pg_.*'
def default_sequence_name(table_name, pk = "id") # :nodoc:
PostgreSQL::Name.new(nil, "#{table_name}_#{pk}_seq").to_s
query_value("SELECT pg_get_serial_sequence(#{quote(table)}, #{quote(column)})", "SCHEMA")
query_value("SELECT setval(#{quote(quoted_sequence)}, #{value})", "SCHEMA")
def reset_pk_sequence!(table, pk = nil, sequence = nil) # :nodoc:
pk ||= default_pk
if @logger && pk && !sequence
max_pk = query_value("SELECT MAX(#{quote_column_name pk}) FROM #{quote_table_name(table)}", "SCHEMA")
query_value("SELECT setval(#{quote(quoted_sequence)}, #{max_pk || minvalue}, #{max_pk ? true : false})", "SCHEMA")
WHEN split_part(pg_get_expr(def.adbin, def.adrelid), '''', 2) ~ '.' THEN
substr(split_part(pg_get_expr(def.adbin, def.adrelid), '''', 2),
strpos(split_part(pg_get_expr(def.adbin, def.adrelid), '''', 2), '.')+1)
ELSE split_part(pg_get_expr(def.adbin, def.adrelid), '''', 2)
AND cons.contype = 'p'
) i
idx = "#{table_name}_pkey"
new_idx = "#{new_name}_pkey"
if seq && seq.identifier == "#{table_name}_#{pk}_seq"
new_seq = "#{new_name}_#{pk}_seq"
sqls, procs = Array(change_column_for_alter(table_name, column_name, type, **options)).partition { |v| v.is_a?(String) }
execute "ALTER TABLE #{quote_table_name(table_name)} #{sqls.join(", ")}"
exclusion_info = exec_query(<<-SQL, "SCHEMA")
method_and_elements_parts = method_and_elements.match(/EXCLUDE(?: USING (?<using>\S+))? \((?<expression>.+)\)/)
def type_to_sql(type, limit: nil, precision: nil, scale: nil, array: nil, enum_type: nil, **) # :nodoc:
sql = \
when 1, 2; "smallint"
when nil, 3, 4; "integer"
when 5..8; "bigint"
}.compact_blank.map.with_index { |column, i| "#{column} AS alias_#{i}" }
(order_columns << super).join(", ")
if match = default_function&.match(/\Anextval\('"?(?<sequence_name>.+_(?<suffix>seq\d*))"?'::regclass\)\z/)
when "c"; :cascade
when "n"; :nullify
when "r"; :restrict
deferrable && (deferred ? :deferred : true)
identifier = "#{table_name}_#{column_name}_unique"
parts << "name: #{unique_key.name.inspect}"
column.type == :uuid || (column.type == :integer && !column.serial?)
if type == :uuid
:hstore, :inet, :interval, :int4range, :int8range, :jsonb, :ltree, :macaddr,
:money, :numrange, :oid, :point, :line, :lseg, :box, :path, :polygon, :circle,
def initialize(*, **)
sql << o.unique_key_adds.map { |con| visit_AddUniqueKey con }.join(" ")
sql << o.unique_key_drops.map { |con| visit_DropUniqueKey con }.join(" ")
super.dup.tap { |sql| sql << " NOT VALID" unless o.validate? }
sql << o.name
sql << "USING #{o.using}" if o.using
sql << "(#{o.expression})"
sql << "WHERE (#{o.where})" if o.where
sql.join(" ")
column_name = Array(o.columns).map { |column| quote_column_name(column) }.join(", ")
sql << "(#{column_name})"
change_column_sql << " USING CAST(#{quoted_column_name} AS #{cast_as_type})"
sql = +"ALTER COLUMN #{quote_column_name(o.column.name)} "
String === o ? o : quoted_include_columns_for_index(o)
do $$
def quote(value) # :nodoc:
def quote_string(s) # :nodoc:
if value.year <= 0
bce_year = format("%04d", -value.year + 1)
super.sub(/^-?\d+/, bce_year) + " BC"
elsif column.type == :uuid && value.is_a?(String) && value.include?("()")
{ value: value.to_s, format: 1 }
super(query_value("SELECT #{quote(sql_type)}::regtype::oid", "SCHEMA").to_i)
infinity?(value) ? "" : type_cast(value)
module OID # :nodoc:
class Xml < Type::String # :nodoc:
class Vector < Type::Value # :nodoc:
class Uuid < Type::Value # :nodoc:
new_value && old_value.casecmp(new_value) != 0
new_value && raw_old_value.casecmp(new_value) != 0
known_type_names = @store.keys.map { |n| "'#{n}'" }
<<~SQL % known_type_names.join(", ")
t.typname IN (%s)
known_type_types = %w('r' 'e' 'd')
<<~SQL % known_type_types.join(", ")
t.typtype IN (%s)
known_type_oids = @store.keys.reject { |k| k.is_a?(String) }
t.typelem IN (%s)
register(oid) do |_, *args|
if is_utc?
class Range < Type::Value # :nodoc:
return if value == "empty"
other.is_a?(Range) &&
def map(value) # :nodoc:
value.is_a?(::Range)
exclude_start: value.start_with?("("),
if value.start_with?('"') && value.end_with?('"')
unquoted_value.gsub!('""', '"')
unquoted_value.gsub!("\\\\", "\\")
Point = Struct.new(:x, :y)
class Point < Type::Value # :nodoc:
if value.start_with?("(") && value.end_with?(")")
x, y = value.split(",")
value = value.sub(/^\((.+)\)$/, '-\1') # (4)
cast(value.split(","))
value.map { |v| Float(v) }
if value.is_a?(::Array)
class Jsonb < Type::Json # :nodoc:
class Inet < Cidr # :nodoc:
class Hstore < Type::Value # :nodoc:
unless scanner.skip(/"=>?/)
key.gsub!('\"', '"')
key.gsub!("\\\\", "\\")
value.gsub!('\"', '"')
value.gsub!("\\\\", "\\")
unless scanner.skip(/, /) || scanner.eos?
if value.is_a?(::Hash)
value.map { |k, v| "#{escape_hstore(k)}=>#{escape_hstore(v)}" }.join(", ")
if value == ""
class Enum < Type::Value # :nodoc:
def infinity(options = {})
when / BC$/
value = value.sub(/^\d+/) { |year| format("%04d", -year.to_i + 1) }
class Date < Type::Date # :nodoc:
class Cidr < Type::Value # :nodoc:
if IPAddr === value
class Bytea < Type::Binary # :nodoc:
class Bit < Type::Value # :nodoc:
if ::String === value
when /^0x/i
class Array < Type::Value # :nodoc:
Data = Struct.new(:encoder, :values) # :nodoc:
if value.is_a?(::String)
other.is_a?(Array) &&
value.map { |v| subtype.map(v, &block) }
value.is_a?(::Array)
value.map { |item| type_cast_array(item, method) }
pp << "-" * width
pp += lines.map { |line| " #{line}" }
rows_label = nrows == 1 ? "row" : "rows"
pp << "(#{nrows} #{rows_label})"
pp.join("\n") + "\n"
def query(sql, name = nil) # :nodoc:
:close, :declare, :fetch, :move, :set, :show
types = {}
def sql_for_insert(sql, pk, binds) # :nodoc:
if pk.nil?
sql = "#{sql} RETURNING #{quote_column_name(pk)}"
if use_insert_returning? || pk == false
exec_query("SELECT currval(#{quote(sequence_name)})", "SQL")
def initialize(*, serial: nil, generated: nil, **)
super && !virtual?
type == :enum
@role = role
@pool = nil
gem "mysql2", "~> 0.5"
!mariadb? && database_version >= "5.7.8"
def each_hash(result, &block) # :nodoc:
lengths: {},
orders: {},
expression = +"(#{expression})" unless expression.start_with?("(")
).values.join(", ")
def type_to_sql(type, limit: nil, precision: nil, scale: nil, size: limit_to_size(limit, type), unsigned: nil, **)
sql =
if (0..0xfff) === limit
sql = "#{sql} unsigned" if unsigned && type != :primary_key
database_version >= "10.2.2"
database_version >= "5.7.9"
if query_value("SELECT @@innodb_file_per_table = 1 AND @@innodb_file_format = 'Barracuda'") == 1
if default_pre == "'"
elsif default_pre&.match?(/^\d+$/)
default = +"(#{default})" unless default.start_with?("(")
elsif type_metadata.type == :text && default&.start_with?("'")
elsif default&.match?(/\A\d/)
when nil, "tiny", "medium", "long"
when "text", "blob", "binary"
when nil, 4; "int"
if /\A(?<size>tiny|medium|long)(?:text|blob)/ =~ column.sql_type
spec = { size: size.to_sym.inspect }.merge!(spec)
when /\A(?:enum|set)\b/
super unless /\A(?:tiny|medium|long)?(?:text|blob)\b/.match?(column.sql_type)
if /\Atime(?:stamp)?\b/.match?(column.sql_type) && column.precision == 0
column.precision == 0 ? "nil" : super
@table_collation_cache ||= {}
if %r/#{column_name} #{Regexp.quote(column.sql_type)}(?: COLLATE \w+)? AS \((?<expression>.+?)\) #{column.extra}/ =~ create_table_info
@connection.query_value(sql, "SCHEMA").gsub("\\'", "'").inspect
when /\Aunsigned_(?<type>.+)\z/
change_column_sql = +"CHANGE #{quote_column_name(o.name)} #{accept(o.column)}"
if o.default.nil? && !o.column.null
sql << " #{o.algorithm}" if o.algorithm
index_type = o.type&.to_s&.upcase || o.unique && "UNIQUE"
sql << "ON #{quote_table_name(o.table)}" if create
sql << "(#{quoted_columns(o)})"
add_sql_comment!(sql.join(" "), o.comment)
sql << " AS (#{as})"
super.sub(/\.\d{6}\z/, "")
((?:\w+\.|`\w+`\.)?(?:\w+|`\w+`) | \w+\((?:|\g<2>)\))
(?:(?:\s+AS)?\s+(?:\w+|`\w+`))?
pp << build_cells(row, widths)
item = "NULL" if item.nil?
justifier = item.is_a?(Numeric) ? "rjust" : "ljust"
def select_all(*, **) # :nodoc:
:desc, :describe, :set, :show, :use
explain_clause = "EXPLAIN #{options.join(" ").upcase}"
previous_packet << ";\n"
mariadb? && database_version >= "10.1.0"
/\bunsigned(?: zerofill)?\z/.match?(sql_type)
collation && !collation.end_with?("_ci")
@registry ||= {}
def new(*, **)
@null = null
/\Abigint\b/.match?(sql_type)
name == other.name &&
null == other.null &&
@name = -name
host: "--host",
port: "--port",
socket: "--socket",
username: "--user",
sslca: "--ssl-ca",
sslcert: "--ssl-cert",
sslkey: "--ssl-key",
ssl_mode: "--ssl-mode"
args << "-p"
def mariadb? # :nodoc:
!mariadb? && database_version >= "8.0.1"
!mariadb? && database_version >= "8.0.13"
database_version >= "10.3.10" || (database_version < "10.3" && database_version >= "10.2.22")
database_version >= "8.0.16"
mariadb? || database_version >= "5.6.4"
mariadb? || database_version >= "5.7.5"
!mariadb? && database_version >= "5.7.7"
database_version >= "10.2.1"
database_version >= "8.0.1"
query_value("SELECT GET_LOCK(#{quote(lock_name.to_s)}, #{timeout})") == 1
def execute_and_free(sql, name = nil, async: false) # :nodoc:
comment = "" if comment.nil?
sql << " COMMENT #{quote(comment)}" if comment.present?
chk_info = exec_query(sql, "SCHEMA")
raw_table_options = create_table_info.sub(/\A.*\n\) ?/m, "").sub(/\n\/\*!.*\*\/\n\z/m, "").strip
table_options = {}
raw_table_options = $` + $' # before part + after part
if raw_table_options.sub!(/ COMMENT='.+'/, "")
sql << insert.touch_model_timestamps_unless { |column| "#{column}<=>VALUES(#{column})" }
sql << insert.updatable_columns.map { |column| "#{column}=VALUES(#{column})" }.join(",")
if database_version < "5.5.8"
m.register_type %r(^tinyint\(1\))i, Type::Boolean.new
m.register_type(%r(char)i) do |sql_type|
m.register_type %r(mediumtext)i, Type::Text.new(limit: 2**24 - 1)
m.alias_type %r(year)i, "integer"
if /\A(?:date)?time(?:stamp)?\b/.match?(sql_type)
super || 0
warning.level == "Note" || super
database_version >= "10.5.2"
database_version >= "5.7.6"
database_version >= "8.0.3"
sql_mode_assignment = "@@SESSION.sql_mode = #{sql_mode}, " if sql_mode
encoding << ", "
/Referencing column '(\w+)' and referenced/i =~ message ? $1 : '\w+'
match = %r/
FOREIGN\s+KEY\s*\(`?(?<foreign_key>#{foreign_key_pat})`?\)\s*
REFERENCES\s*(`?(?<target_table>\w+)`?)\s*\(`?(?<primary_key>\w+)`?\)
Type::ImmutableString.new(true: "1", false: "0", **args)
Type::String.new(true: "1", false: "0", **args)
if config == "false"
when "utc", "local"
parts = parts.map { |part| /#{part}/i }
@quoted_column_names ||= {}
@quoted_table_names ||= {}
commands = commands.map { |cmd| "#{cmd}#{ext}" }
abort("Couldn't find database client: #{commands.join(', ')}. Check your $PATH and try again.")
@config = (deprecated_config || {}).symbolize_keys
@lock =
@version = version_string.split(".").map(&:to_i)
def <=>(version_string)
@version <=> version_string.split(".").map(&:to_i)
@version.join(".")
def valid_type?(type) # :nodoc:
if in_use?
msg << "it is already in use by a different thread: #{@owner}. " \
def steal! # :nodoc:
def create_enum(*) # :nodoc:
def drop_enum(*) # :nodoc:
def clean! # :nodoc:
if scale == 0
when /\((\d+)\)/ then 0
when /\((\d+)(,(\d+))\)/ then $3.to_i
$1.to_i if sql_type =~ /\((\d+)(,\d+)?\)/
$1.to_i if sql_type =~ /\((.*)\)/
(@verified && @raw_connection) ||
message = "#{e.class.name}: #{e.message}"
columns(table_name).detect { |c| c.name == column_name } ||
@state == :committed || @state == :fully_committed
@state == :rolledback || @state == :fully_rolledback
@children&.each { |c| c.rollback! }
@children&.each { |c| c.invalidate! }
@state = nil
def add_record(record, _ = true); end
@dirty = true
joinable? && !dirty?
ite&.each do |i|
ite&.each { |i| i.committed!(should_run_callbacks: false) }
def open?; !closed?; end
records.uniq(&:__id__)
@stack.each(&:restore!)
@stack.none?(&:dirty?)
indexes(table_name).any? { |i| i.defined_for?(column_name, **options) }
checks << lambda { |c| c.name == column_name }
checks << lambda { |c| c.type == type.to_sym rescue nil } if type
pk = pk.first unless pk.size > 1
def add_columns(table_name, *column_names, type:, **options) # :nodoc:
if type == :datetime && !options.key?(:precision)
old_index_def = indexes(table_name).detect { |i| i.name == old_name }
if Hash === options
indexes(table_name).detect { |i| i.name == index_name }
if !options.key?(:name) && !options.key?(:expression)
{ primary_key: true }
inserting = (versions - migrated).select { |v| v < version }
if (duplicate = inserting.detect { |v| inserting.count(v) > 1 })
def type_to_sql(type, limit: nil, precision: nil, scale: nil, **) # :nodoc:
column_type_sql << "(#{precision},#{scale})"
column_type_sql << "(#{precision})"
if (0..6) === precision
column_type_sql << "(#{limit})"
execute "ALTER TABLE #{quote_table_name(table_name)} #{fragments.join(', ')}"
index_name = name&.to_s
method = :"#{command}_for_alter"
sqls, procs = Array(send(method, table, *arguments)).partition { |v| v.is_a?(String) }
unless value == true || value == false
checks << lambda { |i| index_name(table_name, i.columns) == index_name(table_name, column_names) }
column_names = column_names.scan(/\w+/).join("_")
column_name.is_a?(String) && /\W/.match?(column_name)
table_name.to_s =~ /#{prefix}(.+)#{suffix}/ ? $1 : table_name.to_s
identifier = "#{table_name}_#{options.fetch(:column)}_fk"
identifier = "#{table_name}_#{expression}_chk"
column_name.nil? && options.key?(:name) && options.except(:name, :algorithm).empty?
sql << versions.reverse.map { |v| "(#{quote(v)})" }.join(",\n")
sql << ";"
spec = {}
attr_reader :table, :name, :unique, :columns, :lengths, :orders, :opclasses, :where, :type, :using, :include, :comment, :valid
opclasses: {},
def defined_for?(columns = nil, name: nil, unique: nil, valid: nil, include: nil, **options)
(columns.nil? || Array(self.columns) == Array(columns).map(&:to_s)) &&
(name.nil? || self.name == name.to_s) &&
(unique.nil? || self.unique == unique) &&
(valid.nil? || self.valid == valid) &&
(include.nil? || Array(self.include) == Array(include))
:null,
def #{option_name}=(value)
(to_table.nil? || to_table.to_s == self.to_table) &&
(validate.nil? || validate == self.options.fetch(:validate, validate)) &&
self.name == name.to_s &&
value.is_a?(Hash) ? value : {}
:float, :integer, :json, :string, :text, :time, :timestamp, :virtual
def #{column_type}(*names, **options)
names.each { |name| column(name, :#{column_type}, **options) }
as: nil,
@conn = conn
@as = as
if id && !as
if id.is_a?(Hash)
id = id.fetch(:type, :primary_key)
if pk.is_a?(Array)
primary_key(pk, id, **options)
def primary_keys(name = nil) # :nodoc:
index_options = index.is_a?(Hash) ? index : {}
to_table = "#{prefix}#{to_table}#{suffix}"
def name; @td.name; end
@base = base
key == :if_exists || key == :if_not_exists
conditional = unrecognized_option == :if_exists ? "if" : "unless"
message = <<~TXT
send m, o
to: :@conn, private: true
sql << o.adds.map { |col| accept col }.join(" ")
sql << o.foreign_key_adds.map { |fk| visit_AddForeignKey fk }.join(" ")
sql << o.foreign_key_drops.map { |fk| visit_DropForeignKey fk }.join(" ")
o.sql_type = type_to_sql(o.type, **o.options)
column_sql = +"#{quote_column_name(o.name)} #{o.sql_type}"
+"ADD #{accept(o.column)}"
create_sql << "#{quote_table_name(o.name)} "
statements = o.columns.map { |c| accept c }
create_sql << "(#{statements.join(', ')})" if statements.present?
create_sql << " AS #{to_sql(o.as)}" if o.as
sql << " #{action_sql('DELETE', o.on_delete)}" if o.on_delete
sql << " #{action_sql('UPDATE', o.on_update)}" if o.on_update
sql << "#{quote_column_name(index.name)} ON #{quote_table_name(index.table)}"
sql << "USING #{index.using}" if supports_index_using? && index.using
sql << "(#{quoted_columns(index)})"
create_sql << " #{o.options}" if o.options
sql = sql.to_sql if sql.respond_to?(:to_sql)
when Type::Time::Value then "'#{quoted_time(value)}'"
when Date, Time then "'#{quoted_date(value)}'"
Consider Arel.sql(".. ? ..", value) or #sanitize_sql instead.
s.gsub("\\", '\&\&').gsub("'", "''") # ' (for ruby-mode)
quote_table_name("#{table}.#{attr}")
result = value.to_fs(:db)
if value.respond_to?(:usec) && value.usec > 0
result << "." << sprintf("%06d", value.usec)
quoted_date(value).sub(/\A\d\d\d\d-\d\d-\d\d /, "")
((?:\w+\.)?\w+ | \w+\((?:|\g<2>)\))
(?:(?:\s+AS)?\s+\w+)?
Record.where("duration = ?", 1.hour.to_i)
base.class_eval <<-end_code, __FILE__, __LINE__ + 1
def #{method_name}(*)
if @query_cache_enabled && !(arel.respond_to?(:locked) && arel.locked)
type_casted_binds: -> { type_casted_binds(binds) },
sql, _ = to_sql_and_binds(arel_or_sql_string, binds)
if Arel.arel_node?(arel_or_sql_string) && !(String === arel_or_sql_string)
def query_value(sql, name = nil) # :nodoc:
def query_values(sql, name = nil) # :nodoc:
query(sql, name).map(&:first)
sql, binds = sql_for_insert(sql, pk, binds)
def exec_insert_all(sql, name) # :nodoc:
if limit.is_a?(Integer) || limit.is_a?(Arel::Nodes::SqlLiteral)
if value.is_a?(Hash) || value.is_a?(Array)
raise Fixture::FixtureError, %(table "#{table_name}" has no columns named #{unknown_columns.map(&:inspect).join(', ')}.)
total_sql.join(";\n")
row && row.first
@pools = {}
@threads = {}
@lock = lock
@cond = @lock.new_cond
@num_waiting = 0
@num_waiting > 0
no_wait_poll || (timeout && wait_poll(timeout))
@num_waiting += 1
@num_waiting -= 1
@num_waiting_on_real_cond -= 1
@num_waiting_on_real_cond += 1
def checkin(_); end
def remove(_); end
conn.in_use? && !conn.owner.alive?
!conn.in_use? && conn.seconds_idle >= minimum_idle
flush(-1)
busy: @connections.count { |c| c.in_use? && c.owner.alive? },
dead: @connections.count { |c| c.in_use? && !c.owner.alive? },
idle: @connections.count { |c| !c.in_use? },
thread_report << "#{conn} is owned by #{conn.owner}"
msg << " (#{thread_report.join(', ')})" if thread_report.any?
@now_connecting += 1
@now_connecting -= 1
elsif role == :all
role = nil if role == :all
message = "No connection pool for '#{connection_name}' found for the '#{role}' role."
if owner_name.is_a?(String) || owner_name.is_a?(Symbol)
if Gem::Version.new(Psych::VERSION) >= Gem::Version.new("5.1")
@coder ||= begin
if @object_class != ::Object
def increment!(attribute, by = 1, touch: nil) # :nodoc:
touch ? _run_touch_callbacks { super } : super
result = true; @_already_called ||= {}
if autosave != false && (new_record_before_save || record.new_record?)
:id
prev_cast_type = -> subtype { subtype }
name = @primary_key if name == "id" && @primary_key
map(value) do |v|
def serialize(attr_name, class_name_or_coder = nil, coder: nil, type: Object, yaml: {}, **options)
Coders::YAMLColumn.new(attr_name, type, **(yaml || {}))
elsif coder.respond_to?(:new) && !coder.respond_to?(:load)
elsif type && type != Object
cast_type.is_a?(ActiveRecord::Type::Json) && coder == ::JSON ||
cast_type.respond_to?(:type_cast_array, true) && type == ::Array
name = @primary_key if name == "id" && @primary_key && !@primary_key.is_a?(Array)
key = id
@primary_key.map { |pk| _read_attribute(pk) }
attr_name == "id" || super
value.map { |v| -v.to_s }.freeze
def reload(*)
changes = {}
).map { |m| -m.to_s }.to_set.freeze
super || (table_exists? && column_names.include?(attribute.to_s.delete_suffix("=")))
def _has_attribute?(attr_name) # :nodoc:
!value.nil? && !(value.respond_to?(:empty?) && value.empty?)
(pk_attribute?(name) && id.nil?) ||
elsif value.is_a?(Date) || value.is_a?(Time)
%("#{value.to_fs(:inspect)}")
name == @primary_key
key = k.to_s
if key.include?("(")
elsif v.is_a?(Hash)
pairs.each { |k, v| _assign_attribute(k, v) }
send("#{name}=", values)
if inverse && target && !target.is_a?(Array)
if !loaded? || stale_target?
map(&:klass)
owners.all? { |owner| loaded?(owner) } ||
through_preloaders.all?(&:run?) && source_preloaders.all?(&:run?)
root? || (@loaders && @loaders.all?(&:run?))
@loaders ||=
@keys_to_load = Set.new
keys_to_load << key
loaders.each { |l| l.set_inverse(record) }
@run = false
@run = true
@owners_by_key ||= owners.each_with_object({}) do |owner, result|
@scope ||= build_scope
if i == 0 # Set inverse on first owner
if key.is_a?(Array)
@tree = Branch.new(
@table ||= table
if nodes.is_a?(Arel::Nodes::And)
@alias_cache = tables.each_with_object({}) { |table, h|
@columns_cache = tables.each_with_object({}) { |table, h|
Table = Struct.new(:node, :columns) do # :nodoc:
@joined_tables = {}
@references = {}
seen = Hash.new { |i, parent|
column_names << name unless /\At\d+_r\d+\z/.match?(name)
column_types = {}
column_types = column_types.slice(*column_names).delete_if { |k, _| attribute_types.key?(k) }
relation._select!(-> { aliases.columns })
column_names = if join_part == join_root && !join_root_alias
Aliases::Column.new column_name, "t#{i}_r#{j}"
if table && (!root || !terminated)
root ? name : "#{name}_join"
}.partition(&:first)
joins = intersection.flat_map { |l, r| r.table = l.table; walk(l, r, join_type) }
if save && !record.save
a - b
a & b
def build(attributes = {}, &block)
def create(attributes = {}, &block)
def create!(attributes = {}, &block)
def <<(*records)
alias_method :push, :<<
alias_method :append, :<<
alias_method :concat, :<<
def prepend(*args) # :nodoc:
@scope = nil
:scoping, :values, :insert, :insert_all, :insert!, :insert_all!, :upsert, :upsert_all, :load_async
ids.map! { |i| pk_type.cast(i) }
if !find_target? || loaded?
loaded? ||
owner.new_record? ||
target.any? { |record| record.new_record? || record.changed? }
@_was_loaded = loaded?
@_was_loaded = true
elsif @_was_loaded || !loaded?
@_was_loaded = nil
} || target.include?(record)
if ids.size == 1
record = load_target.detect { |r| id == r.id.to_s }
load_target.select { |r| ids.include?(r.id.to_s) }
def build_#{name}(*args, &block)
association(:#{name}).build(*args, &block)
def create_#{name}(*args, &block)
association(:#{name}).create(*args, &block)
def create_#{name}!(*args, &block)
association(:#{name}).create!(*args, &block)
touch != true ?
callback = -> (record) { HasOne.touch_record(record, name, touch) }
join_model.table_name_resolver = -> { table_name }
middle_options = {}
rhs_options = {}
full_callback_name = "#{callback_name}_for_#{name}"
->(method, owner, record) { owner.send(callback, record) }
->(method, owner, record) { callback.call(owner, record) }
->(method, owner, record) { callback.send(method, owner, record) }
if touch != true
}}
model.generated_association_methods.class_eval <<-CODE, __FILE__, __LINE__ + 1
if scope && scope.arity == 0
proc { instance_exec(&scope) }
!loaded? && foreign_key_present? && klass
if force || reflection_fk.map { |fk| owner._read_attribute(fk) } != target_key_values
block ||= lambda { |val| val }
scope.where!(key => value)
scope.where!(table.name => { key => value })
@target = nil
loaded? && @stale_state != stale_state
@target = find_target if (@stale_state && stale_target?) || find_target?
!loaded? && (!owner.new_record? || foreign_key_present?) && klass
record &&
((!record.persisted? || !owner.persisted?) || matches_foreign_key?(record))
aliases ||= Hash.new(0)
default_proc = aliases.default_proc || proc { 0 }
aliases.default_proc = proc { |h, k|
aliases = Hash.new { |h, k|
/JOIN(?:\s+\w+)?\s+(?:\S+\s+)?(?:#{quoted_name}|#{name})\sON/i
).size
join.left.name == name ? 1 : 0
aliased_name = "#{truncate(aliased_name)}_#{count}" if count > 1
@association_cache = {}
def has_one(name, scope = nil, **options)
hm_options = {}
scoping { klass.#{method}(attributes, **kwargs) }
@aggregation_cache = {}
def composed_of(part_id, options = {})
attrs = mapping.collect { |key, _| read_attribute(key) }
define_method("#{name}=") do |part|
unless part.is_a?(klass) || converter.nil? || part.nil?
part = klass.new(*part.sort.map(&:last))
if part.nil? && allow_nil
mapping.each { |key, _| write_attribute(key, nil) }
->(warning) do
warning_message += " (#{warning.code})" if warning.code
->(warning) { raise warning }
self.queues = {}
bob = Person.create!(name: "bob")
conn = { adapter: "sqlite3", database: ":memory:" }
def progress_bar(int); print "." if (int % 100).zero? ; end
LOREM.grep(/^\w*$/).sort_by { rand }.first(2).join " "
LOREM.grep(/^\w*$/).sort_by { rand }.first(2).join("@") + ".com"
puts "Done!\n"
attrs_second = { name: "tom" }
x.report("Model#id") do
Exhibit.find_by_sql("SELECT * FROM exhibits WHERE id = #{(rand * 1000 + 1).to_i}").first
Exhibit.connection.send(:log, "hello", "world") { }
ActiveRecord::Base.connection.execute("SELECT * FROM exhibits WHERE id = #{(rand * 1000 + 1).to_i}")
public_send "#{key}=", value
instance_variable_get(:"@#{attr}")
errors.add(:title, "is Empty") unless title && title.size > 0
if title && content && content == "Mismatch"
errors.add(:title, "is Wrong Create") if title && title == "Wrong Create"
errors.add(:title, "is Wrong Update") if title && title == "Wrong Update"
{ git: :github }
options.each { |name, value| public_send("#{name}=", value) }
instance_variable_set("@#{k}", v)
r = Reply.new
r.title = "There's no content!"
r.content = ""
hits = 0
hits += 1
t = Topic.new("title" => "valid", "content" => "whatever")
t = CustomReader.new("title" => "valid", "content" => "whatever")
t = Topic.new("title" => "Title", "content" => "whatever")
Topic.validate(if: opts, on: :create) { }
@call_sequence << :a
@call_sequence << :b
@call_sequence << :c
klass.validate :validator_a, if: -> { true }
klass.validate :validator_c, unless: -> { true }
t = Topic.new("title" => "")
t = Topic.new title: ""
Topic.validates_presence_of :title, if: Proc.new { |x| x.author_name = "bad"; true }, on: :update
t = Topic.new(title: "")
assert t.author_name == "bad"
t = Topic.new(title: "Valid title")
options = { presence: true }
raise "boom!"
topic = Topic.new content: ""
topic = Topic.new title: "foo"
Person.validates :title, presence: { message: "" }
person.gender = "m"
p.karma = "Cold"
t = Topic.new(title: "something")
t.title = ""
t.title = nil
FLOAT_STRINGS = %w(0.0 +0.0 -0.0 10.0 10.5 -10.5 -0.0001 -090.1 90.1e1 -90.1e5 -90.1e-5 90e-5)
topic = Topic.new("title" => "numeric test", "approved" => 10)
topic = Topic.new("title" => "numeric test", "approved" => 1)
p.karma = "Pix"
p.karma = "1234"
topic.approved = (base + 1).to_s
assert_predicate Topic.new("title" => "ab"), :invalid?
assert_predicate Topic.new("title" => ""), :invalid?
assert_predicate Topic.new("title" => "abcde"), :valid?
assert_predicate Topic.new("title" => ""), :valid?
t.title = "not"
t.title = "notvalid"
t = Topic.new("title" => "a!", "content" => "I'm ooooooooh so very long")
t.title = "abe"
t.content = "mad"
t = Topic.new("title" => "9 chars!!")
t.title = "Now I'm 10"
t.title = "Four"
t = Topic.new("title" => "a" * 10)
t.title = "a" * invalid_length
t = Topic.new("title" => "abc", "content" => "abcd")
bigmin = 2**30
bigmax = 2**32
t = Topic.new("title" => "uhoh", "content" => "whatever")
t = Topic.new("title" => "uhohuhoh", "content" => "whatever")
Topic.validates_length_of(:title, in: 10..20, message: "hoo %{count}")
t = Topic.new(title: "a")
t = Topic.new(title: "aaaaaa")
Topic.validates_length_of(:title, is: 5, message: "boo %{count}")
Topic.validates_length_of(:title, is: 5, wrong_length: "hoo %{count}")
t = Topic.new("title" => "uhohuhoh", "content" => "whatever", approved: 1)
t = Topic.new("title" => "uhohuhoh", "content" => "whatever", approved: 1234)
p.karma = "The Smiths"
t = Topic.new("title" => "1234")
t.title = "12345"
Topic.validates_length_of(:title, is: 5, if: Proc.new { false })
assert_predicate Topic.new("title" => "david"), :valid?
Topic.validates_length_of :title, maximum: ->(model) { 5 }
Topic.validates_length_of :title, maximum: -> { 5 }
assert_predicate Topic.new("title" => "bbc", "content" => "abc"), :invalid?
assert_predicate Topic.new("title" => "aa", "content" => "abc"), :invalid?
assert_predicate Topic.new("title" => "aaab", "content" => "abc"), :invalid?
assert_predicate Topic.new("title" => "aaa", "content" => "abc"), :valid?
assert_predicate Topic.new("title" => "abc", "content" => "abc"), :valid?
assert_predicate Topic.new("title" => "bbb", "content" => "abc"), :valid?
Topic.validates_inclusion_of(:title, in: %w( a b c d e f g ))
assert_predicate Topic.new("title" => "a!", "content" => "abc"), :invalid?
assert_predicate Topic.new("title" => "a b", "content" => "abc"), :invalid?
assert_predicate Topic.new("title" => nil, "content" => "def"), :invalid?
t = Topic.new("title" => "a", "content" => "I know you are but what am I?")
t.title = "uhoh"
Topic.validates_inclusion_of(:title, in: %w( a b c d e f g ), allow_nil: true)
Topic.validates_inclusion_of(:title, in: %w( a b c d e f g ), message: "option %{value} is not in the list")
assert_predicate Topic.new("title" => "a", "content" => "abc"), :valid?
t = Topic.new("title" => "uhoh", "content" => "abc")
Topic.validates_inclusion_of(:title, within: %w( a b c d e f g ))
p.karma = "Lifo"
p.karma = "monkey"
Topic.validates_inclusion_of :title, in: lambda { |topic| topic.author_name == "sikachu" ? %w( monkey elephant ) : %w( abe wasabi ) }
t.title = "wasabi"
t.title = "elephant"
%w()
%w(Lifo)
p.karma = %w(Lifo monkey)
p.karma = %w(abe monkey)
@person.errors.add("name", "empty")
errors: { models: { person: { attributes: { name: { format: "%{message}" } } } } } })
errors: { models: { person: { attributes: { gender: "Gender" } } } },
attributes: { "person/contacts": { gender: "Gender" } }
errors: { models: { person: { format: "%{message}" } } } })
errors: { models: { 'person/contacts/addresses': { attributes: { street: { format: "%{message}" } } } } } })
errors: { models: { 'person/contacts/addresses': { format: "%{message}" } } } })
@person.title = "72x"
@person.title = "z"
@person.title = "a"
@person.title = "0.0"
I18n.backend.store_translations "en", activemodel: { errors: { models: { person: { attributes: { attribute => { error_type => "custom message" } } } } } }
yield(@person, {})
I18n.backend.store_translations "en", activemodel: { errors: { models: { person: { attributes: { attribute => { error_type => "custom message with %{extra}" } } } } } }
yield(@person, { extra: "extra information" })
person.title = "a"
person.title = "1.0"
I18n.backend.store_translations "en", activemodel: { errors: { models: { person: { attributes: { title: { custom_error: "I am a custom error" } } } } } }
I18n.backend.store_translations "en", activemodel: { errors: { models: { person: { custom_error: "I am a custom error" } } } }
t = Topic.new("title" => "i'm incorrect", "content" => "Validation macros rule!")
t = Topic.new("title" => "72x", "content" => "6789")
t.title = "-11"
t.title = "03"
t.title = "z44"
t.title = "5v7"
t.title = "1"
Topic.validates_format_of(:title, with: /\AValid Title\z/, message: "can't be %{value}")
t.title = "foobar"
Topic.validates_format_of :content, with: lambda { |topic| topic.title == "digit" ? /\A\d+\z/ : /\A\S+\z/ }
t.title = "digit"
t.content = "Pixies"
t.content = "1234"
Topic.validates_format_of :content, without: lambda { |topic| topic.title == "characters" ? /\A\d+\z/ : /\A\S+\z/ }
Person.validates_format_of :karma, with: /\A\d+\z/
p.karma = "Pixies"
assert_predicate Topic.new("title" => "something", "content" => "abc"), :valid?
assert_predicate Topic.new("title" => "monkey", "content" => "abc"), :invalid?
assert Topic.new("title" => "something", "content" => "abc")
t = Topic.new("title" => "monkey")
p.karma = "abe"
Topic.validates_exclusion_of :title, in: lambda { |topic| topic.author_name == "sikachu" ? %w( monkey elephant ) : %w( abe wasabi ) }
t.title = "monkey"
Topic.validates_exclusion_of :content, in: ("a".."g")
%w(abe)
t = Topic.new("title" => "We should be confirmed", "title_confirmation" => "")
p.karma = "None"
activemodel: { attributes: { topic: { title: "Test Title" } } })
if: Proc.new { |r| r.content.size > 4 })
unless: Proc.new { |r| r.content.size > 4 })
if: Proc.new { |r| r.title != "uhohuhoh" })
unless: Proc.new { |r| r.title != "uhohuhoh" })
Date.parse("2019-08-03"),
Date.parse("2020-07-03"),
Date.parse("2020-08-01"),
Date.parse("2020-08-02"),
DateTime.new(2020, 8, 1, 12, 34),
Date.parse("2020-08-03"),
Topic.define_method(:requested) { Date.new(2020, 8, 1) }
custom = Struct.new(:amount) {
amount % 100 <=> other.amount % 100
d.valid?(:save)
d.valid?(:context_a)
d.valid?(:context_b)
before_validation(if: opts, on: :create) { }
after_validation(if: opts, on: :create) { }
t = klass.new("title" => "We should not be confirmed")
t = klass.new("title" => "We should be confirmed", "terms_of_service" => "")
t.terms_of_service = "1"
t = klass.new("title" => "We should be confirmed", "eula" => "")
t.eula = "1"
t.terms_of_service = "I agree."
t.terms_of_service = "I concur."
p = klass.new
p.karma = ""
p.karma = "1"
t.title = "foo"
t.content = "bar"
t.content = ""
p.karma = "good"
p.karma = nil
assert_equal type.new({}), ActiveModel::Type.lookup(:foo, {})
assert_nil type.cast(" " * 129)
time_string = ::Time.now.utc.strftime("%T")
::Time.use_zone("Pacific Time (US & Canada)") do
assert_nil type.user_input_in_time_zone(" " * 129)
s = +"foo"
f = -"foo"
s = "foo"
mod = Module.new { def serialize(value); super; end }
assert_equal 1, type.cast("1")
assert_nil type.cast(1 => 2)
assert_nil type.cast(1.0 / 0.0)
assert_equal(-5, type.serialize(" -5"))
assert type.changed?(0, 0, "wibble")
assert type.changed?(5, 0, "wibble")
assert_not type.changed?(5, 5, "5")
assert_not type.changed?(5, 5, "5.0")
assert_not type.changed?(5, 5, "+5")
assert_not type.changed?(5, 5, "+5.0")
assert_not type.changed?(-5, -5, "-5")
assert_not type.changed?(-5, -5, "-5.0")
assert_equal 1.0, type.cast("1")
assert type.changed?(0.0, 0, "wibble")
assert type.changed?(5.0, 0, "wibble")
assert_not type.changed?(5.0, 5.0, "5wibble")
assert_not type.changed?(5.0, 5.0, "5")
assert_not type.changed?(5.0, 5.0, "5.0")
assert_not type.changed?(500.0, 500.0, "0.5E+4")
assert_not type.changed?(0.0 / 0.0, 0.0 / 0.0, 0.0 / 0.0)
assert type.changed?(0.0 / 0.0, BigDecimal("0.0") / 0, BigDecimal("0.0") / 0)
assert_equal BigDecimal("1"), type.cast(:"1")
type = Decimal.new(precision: ::Float::DIG + 2)
assert_not type.changed?(5.0, 5.0, "5.0wibble")
assert_not type.changed?(-5.0, -5.0, "-5.0")
assert_not type.changed?(5.0, 5.0, "0.5e+1")
assert_not type.changed?(BigDecimal("0.0") / 0, BigDecimal("0.0") / 0, BigDecimal("0.0") / 0)
assert type.changed?(BigDecimal("0.0") / 0, 0.0 / 0.0, 0.0 / 0.0)
datetime_string = ::Time.now.utc.strftime("%FT%T")
assert_equal ::Time.utc(2013, 9, 4, 0, 0, 0), type.cast("Wed, 04 Sep 2013 03:00:00 EAT")
assert_equal ::Time.utc(2018, 10, 15, 0, 0, 0), type.cast(1 => 2018, 2 => 10, 3 => 15)
assert_nil type.cast(" ")
now = ::Time.now.utc
values_hash = { 1 => now.year, 2 => now.mon, 3 => now.mday }
date_string = now.strftime("%F")
time = ::Time.utc(1, 1, 1)
date = ::Date.new(time.year, time.mon, time.mday)
values_hash_for_multiparameter_assignment = { 1 => 1, 2 => 1, 3 => 1 }
assert type.cast(" ")
assert type.cast("\u3000\r\n")
assert type.cast(:"1")
assert_equal "1", type.cast("1")
person: { gender: "person gender" },
options = { default: "person model" }
options = { default: "Cool gender" }
@contact.created_at = Time.utc(2006, 8, 1)
@contact.preferences = { "shows" => "anime" }
assert_no_match %r{^\{"contact":\{}, json
assert_match %r{^\{"json_contact":\{}, json
options = { except: :name }
json = @contact.to_json(root: :true)
assert_no_match %r{"awesome":}, json
@name, @email, @gender = name, email, gender
if method_name == :bar
@user = User.new("David", "david@example.com", "male")
@user.address.state = "CA"
expected = { "name" => "David", "gender" => "male", "email" => "david@example.com" }
expected = { "name" => "David" }
expected = { "gender" => "male", "email" => "david@example.com" }
expected = { "foo" => "i_am_foo", "bar" => "i_am_bar" }
expected = { "gender" => "male", "foo" => "i_am_foo", "bar" => "i_am_bar" }
expected = { "name" => "Jon" }
expected = { "name" => "David", "gender" => "male", "email" => "david@example.com",
expected = { "email" => "david@example.com", "gender" => "male", "name" => "David",
expected = { "name" => "David", "email" => "david@example.com",
@user.password = "a" * 72
@user.password = " " * 72
@user.password = ""
@user.password = "a" * 73
@existing_user.password = "a" * 72
@existing_user.password = "a" * 73
@user.password_digest = " "
@app ||= Class.new(::Rails::Application) do
@model_name = ActiveModel::Name.new(Blog::Post, nil, "Uzivatel", :cs)
@record = @klass.new
@plural = "contacts"
@route_key = "contacts"
@param_key = "contact"
@attr ||= "default value"
params = ProtectedParams.new("a" => "b")
params = ProtectedParams.new("a" => "b").permit!
assert_equal({ "a" => "b" }, Account.new.sanitize_for_mass_assignment(params))
assert_equal({ a: "b" }, Account.new.sanitize_for_mass_assignment(a: "b"))
errors.add(:name, :blank, message: "cannot be nil") if name == nil
errors.add(:foo, "omg")
assert errors.any? { |_| true }, "any? should return true"
errors.add(:name, "omg")
errors.add(:baz, "zomg")
errors.add(:foo, "zomg")
msg = "custom msg"
type = Proc.new { msg }
type = Proc.new { :blank }
person.errors.add(:name, :too_long, if: -> { true })
person.errors.add(:name, :too_long, message: proc { "foo" })
message = Proc.new { "cannot be blank" }
I18n.backend.store_translations("en", errors: { attributes: { name: { wrong: "is wrong", used: "is wrong" } } })
@errors.add(:name, "bar")
errors.add("foo", "bar")
errors.add(:age, :invalid, count: 3, message: "%{count} is too low")
base: *1
options: {}
error = ActiveModel::Error.new(base, :name, :too_long, foo: :bar)
assert_equal({ foo: :bar }, error.options)
options = { message: "bar" }
foo: "foo",
bar: "bar",
baz: Proc.new { "baz" },
I18n.with_locale(:pl) {
attributes: { reports: { name: { presence: "must be present" } } } } } } })
e1 = ActiveModel::Error.new(person, :name, foo: :bar)
e2 = ActiveModel::Error.new(person, :name, foo: :bar)
foo: :bar,
if: :foo,
unless: :bar,
on: :baz,
{ error: :too_short, foo: :bar }
assert_equal(error.details, { error: :invalid, foo: :bar })
@color = nil
@size = nil
@name = val
@color = val
@size = val
@status = val
@model.name = "Ringo"
@model.name = "Paul"
@model.name = "John"
assert_not @model.name_changed?(from: "Pete", to: "Ringo")
@model.name = "David"
@model.name = "Rafael"
@model.instance_variable_set("@name", +"Yam")
@model.name = "Bob"
@model.color = "red"
@model.name = "Alf"
assert_equal({ "name" => nil, "status" => "initialized" }, @model.changed_attributes)
assert_equal({ "name" => "Paul", "status" => "waiting" }, @model.changed_attributes)
@model.name = "Otto"
@model.size = 1
@model.name = "Dmitry"
@model.color = "Red"
@model.color = "White"
assert_equal "{\"name\":\"Dmitry\",\"color\":null,\"size\":null,\"status\":\"initialized\"}", @model.to_json
assert_equal "{\"color\":null,\"size\":null,\"status\":\"initialized\"}", @model.to_json(except: "name")
after_create(if: opts) { }
run_callbacks(:create) { }
attribute :date_field, :date, default: -> { Date.new(2016, 1, 1) }
def attribute=(_, _)
integer_field: "2.3",
decimal_field: "12.3",
string_field: "1.1",
date_field: Date.new(2016, 1, 1),
@model.name = "Yam"
assert_equal({ "name" => nil }, @model.changed_attributes)
assert_equal({ "name" => "Paul" }, @model.changed_attributes)
@model.size = "2.3"
@model.size = "2.1"
@model.size = "5.1"
value + " from user"
block = proc { |name| name.to_s + "!" }
attribute.value << "!"
if value == 1
attribute.value << "1"
attributes = builder.build_from_database(foo: "1.1", bar: "2.2")
attributes = builder.build_from_database({ foo: "3.3", bar: "4.4" }, { bar: Type::Integer.new })
assert_equal({ foo: 1, bar: 2.2 }, attributes.to_hash)
assert_equal({ foo: 1, bar: 2.2 }, attributes.to_h)
attributes = builder.build_from_database(foo: "2.2", bar: "3.3")
assert_equal({ foo: "1.1", bar: "2.2" }, attributes.values_before_type_cast)
value = attributes.fetch_value(:bar) { |n| n.to_s + "!" }
defaults = { foo: Attribute.from_user(:foo, nil, nil) }
assert_equal({ foo: "1" }, attributes.to_hash)
attributes = builder.build_from_database(foo: "1", bar: "2")
klass = class_with { attribute :foo, TYPE_1 }
child = class_with(parent) { attribute :foo, TYPE_1 }
parent = class_with { attribute :foo, TYPE_1 }
child = class_with(parent) { attribute :foo, TYPE_2 }
{ foo: "value of foo", baz: "value of baz" }
def attribute_test(name, attrs = {})
{ 'foo bar': "value of foo bar" }
define_method(:'c?d') do
{ 'a?b': "value of a?b" }
{ begin: "value of begin", end: "value of end" }
assert_equal({ "bar" => "foo" }, klass.attribute_aliases)
m.attributes = { "foo" => "bar" }
attrs = {}
assert_equal "bar", m.foo_kw(kw: 2)
m.attributes = { "private_method" => "<3", "protected_method" => "O_o" }
model.attributes = { name: "hello", description: "world" }
model = Model.new(name: "Guille", description: "m")
@point = Point.new(123, 456, 789)
expected = { z: @point.z, x: @point.x }.with_indifferent_access
actual = @point.slice(:z, :x)
{ in: options }
{ with: options }
if value.arity == 0
unless value.is_a?(Numeric) || value.is_a?(Proc) || value.is_a?(Symbol)
came_from_user = :"#{attr_name}_came_from_user?"
if range = (options.delete(:in) || options.delete(:within))
unless (value.is_a?(Integer) && value >= 0) ||
value.is_a?(Symbol) || value.is_a?(Proc)
if !value.nil? || skip_nil_check?(key)
source.start_with?("^") || (source.end_with?("$") && !source.end_with?("\\$"))
if value.nil? || value.blank?
COMPARE_CHECKS = { greater_than: :>, greater_than_or_equal_to: :>=,
equal_to: :==, less_than: :<, less_than_or_equal_to: :<=,
other_than: :!= }.freeze
if options.key?(:on)
->(o) {
mod = self
attr_name = method_name.to_s.chomp("=")
attributes.any? { |name| name == attr_name }
attr_writers = attributes.reject { |name| klass.attribute_method?("#{name}=") }
@lock = nil
@errors = nil
@errors ||= Errors.new(self)
def binary? # :nodoc:
scale == other.scale &&
def cast_value(value) # :doc:
defaults: { 1 => 2000, 2 => 1, 3 => 1, 4 => 0, 5 => 0 }
value = "2000-01-01 #{value}"
::Date._parse(value)
value = value.change(year: 2000, day: 1, month: 1)
dummy_time_value = value.sub(/\A\d{4}-\d\d-\d\d(?:T|\s)|/, "2000-01-01 ")
new_time(*time_hash.values_at(:year, :mon, :mday, :hour, :min, :sec, :sec_fraction, :offset))
if new_value.is_a?(::String)
true: @true,
@registrations = {}
@range = min_value...max_value
in_range?(cast_value) || begin
!value || range.member?(value)
1 << (_limit * 8 - 1) # 8 bits per byte with one bit for sign
@false = -(args.delete(:false)&.to_s || "f")
::Time.zone_default.nil? || ::Time.zone_default.match?("UTC")
is_utc? ? :utc : :local
def new_time(year, mon, mday, hour, min, sec, microsec, offset = nil)
return if year.nil? || (year == 0 && mon == 0 && mday == 0)
time = ::Time.utc(year, mon, mday, hour, min, sec, microsec) rescue nil
time -= offset unless offset == 0
is_utc? ? time : time.getlocal
/x
::Time.at(::Time.new(string, in: "UTC"))
usec = $7.to_i
usec_len = $7&.length
if usec_len&.< 6
usec *= 10**(6 - usec_len)
if $8
offset = $8 == "Z" ? 0 : $8.to_i * 3600 + $9.to_i * 60
new_time($1.to_i, $2.to_i, $3.to_i, $4.to_i, $5.to_i, $6.to_i, usec, offset)
value = if value <=> 0
(old_value.is_a?(::Float) || old_value.is_a?(BigDecimal)) &&
old_value.nan? &&
defaults.each do |k, v|
return "::Float::NAN" if value.try(:nan?)
casted_value = \
if precision.to_i > ::Float::DIG + 1
defaults: { 4 => 0, 5 => 0 }
new_date $1.to_i, $2.to_i, $3.to_i
new_date(*parts.values_at(:year, :mon, :mday)) if parts
unless year.nil? || (year == 0 && mon == 0 && mday == 0)
false, 0,
def type # :nodoc:
if value.is_a?(Data)
@value = value.to_s
@value.unpack1("H*")
other == to_s || super
def lookup(...) # :nodoc:
registry.lookup(...)
ancestors.select { |x| x.respond_to?(:model_name) }
if attribute.include?(".")
namespace.tr!(".", "/")
defaults << :"#{i18n_scope}.attributes.#{namespace}.#{attribute}"
root = if options && options.key?(:root)
{ root => hash }
attribute_names &= Array(only).map(&:to_s)
delegate :==, :===, :<=>, :=~, :"!~", :eql?, :match?, :to_s,
:to_str, :as_json, to: :name
@name = name || klass.name
@route_key << "_index" if @uncountable
def human(options = {})
@_model_name ||= begin
@_model_name = nil
assert result == true || result == false, "#{name} should be a boolean"
def_delegators :@errors, :each, :clear, :empty?, :size, :uniq!
def copy!(other) # :nodoc:
@errors.each { |error|
@errors.any? { |error|
def added?(attribute, type = :invalid, options = {})
super("unknown attribute '#{attribute}' for #{@record.class}.")
parts = attribute.split(".")
defaults << "%{attribute} %{message}"
attr_name = attribute.tr(".", "_").humanize
defaults << :"#{i18n_scope}.errors.messages.#{type}"
defaults << :"errors.attributes.#{attribute}.#{type}"
defaults << :"errors.messages.#{type}"
@raw_type = type
@type = type || :invalid
@raw_type = @raw_type.dup
@type = @type.dup
if @attribute != attribute || (type && @type != type)
def ==(other) # :nodoc:
def hash # :nodoc:
def as_json(options = {}) # :nodoc:
__send__("#{attr_name}=", attribute_was(attr_name))
key = respond_to?(:id) && id
(persisted? && key = to_key) ? key.join("-") : nil
def _to_partial_path # :nodoc:
@_to_partial_path ||= begin
set_callback(:"#{callback}", :before, *args, options, &block)
set_callback(:"#{callback}", :around, *args, options, &block)
v != false
set_callback(:"#{callback}", :after, *args, options, &block)
def attribute(name, ...)
def build_from_database(values = {}, additional_types = {})
@casted_values = {}
delegate_hash.key?(key) || values.key?(key) || types.key?(key)
alias :to_h :to_hash
if key?(key)
def attribute(name, type = nil, default: (no_default = true), **options)
@pending_attributes ||= {}
attr_names.any? { |attr| changed?(attr) }
(OPTION_NOT_GIVEN == from || original_value(attr_name) == type_cast(attr_name, from)) &&
(OPTION_NOT_GIVEN == to || fetch_value(attr_name) == type_cast(attr_name, to))
@forced_changes ||= {}
def changed?(attr_name, **)
mangled_name = "__temp__#{target_name.unpack1("h*")}"
body <<
ActiveSupport::CodeGenerator.batch(_owner, __FILE__, __LINE__) do |owner|
mangled_name = "__temp__#{name.unpack1("h*")}"
call_args.unshift(":'#{proxy_target}'")
def initialize(prefix: "", suffix: "", parameters: nil)
@regex = /\A(?:#{Regexp.escape(@prefix)})(.*)(?:#{Regexp.escape(@suffix)})\z/
@proxy_target = "#{@prefix}attribute#{@suffix}"
@method_name = "#{prefix}%s#{suffix}"
__send__(match.proxy_target, match.attr_name, *args, &block)
__send__(attr)
method_name = "#{attr_name}#{'=' if writer}"
yield method_name, "'#{attr_name}'"
safe_name = attr_name.unpack1("h*")
const_name = "ATTR_#{safe_name}"
temp_method_name = "__temp__#{safe_name}#{'=' if writer}"
setter = :"#{k}="
def type_cast(*)
I18n.load_path << File.expand_path("active_model/locale/en.yml", __dir__)
worker = new(nil, nil, {})
receiver_str, _, message = method.rpartition(".")
@id = "AJ-#{SecureRandom.uuid}"
def job_executed(id = @id)
def job_executed_at(id = @id)
@@managers = {}
initializer "i18n.rb", <<-CODE
file "app/jobs/test_job.rb", <<-CODE
File.open(Rails.root.join("tmp/\#{x}.new"), "wb+") do |f|
File.rename(Rails.root.join("tmp/\#{x}.new"), Rails.root.join("tmp/\#{x}"))
vhost: "/",
if Gem::Version.new(Sidekiq::VERSION) >= Gem::Version.new("7")
w.work(0.5)
args << "psql -X -U #{user} -t template1"
args << "-h #{host}" if host
args << "-p #{port}" if port
%x{#{psql} -c 'drop database if exists "#{db}"'}
%x{#{psql} -c 'create database "#{db}"'}
@thread = Thread.new { @worker.start }
def initialize(hash = {})
self.id = (self.class.id += 1)
hash.each { |k, v| send(:"#{k}=", v) }
def self.create(attrs = {})
new(attrs).tap(&:save)
def self.create!(*args); create(*args); end
all.select { |j| j.locked_by == worker_name }.each { |j| j.locked_by = nil; j.locked_at = nil }
jobs = all.select do |j|
j.run_at <= db_time_now &&
(j.locked_at.nil? || j.locked_at < db_time_now - max_run_time || j.locked_by == worker_name) &&
!j.failed?
attrs.each { |k, v| send(:"#{k}=", v) }
def save!; save; end
def ==(other_person)
other_person.is_a?(Person) && id.to_s == other_person.id.to_s
translations = { en: "Hello", de: "Guten Tag" }
JobBuffer.add("#{greeter} says #{hello}")
new_year = localtime(2018, 1, 1)
if now >= new_year
JobBuffer.add("Just #{(new_year - now).div(3600)} hours to go")
Time.zone ? Time.zone.local(*args) : Time.utc(*args)
logger.info "Dummy, here is it: #{dummy}"
if (arguments.first || :abort) == :abort
Time.zone = "Hawaii"
assert_job_executed "#{@id}.1"
assert_job_executed "#{@id}.2"
assert_job_executed_before("#{@id}.2", "#{@id}.1")
TestJob.set(priority: 20).perform_later "#{@id}.1"
TestJob.set(priority: 10).perform_later "#{@id}.2"
GlobalID.app = "aj"
puts "Using #{@adapter}"
@job.locale = :de
job.timezone = "Eastern Time (US & Canada)"
assert_match(/2 .* but 1/, error.message)
assert_match(/1 .* but 2/, error.message)
assert_match(/0 .* but 1/, error.message)
assert_enqueued_jobs(1, only: ->(job) { job.fetch(:job).name == "HelloJob" }) do
assert_enqueued_jobs(1, except: ->(job) { job.fetch(:job).name == "LoggingJob" }) do
assert_match(/`:only` and `:except`/, error.message)
assert_match(/1 .* but 0/, error.message)
assert_match(/5 .* but 1/, error.message)
facets = {
matcher = ->(job_value) { job_value == value }
refuser = ->(job_value) { false }
assert_enqueued_with(**{ facet => matcher })
assert_enqueued_with(**{ facet => refuser })
now = Time.now.in_time_zone("Tokyo")
Time.utc(1999, 12, 31, 23, 59, "59.123456789".to_r),
date_time = DateTime.new(2001, 2, 3, 4, 5, 6.123456, "+03:00")
assert_performed_jobs(1, only: ->(job) { job.is_a?(HelloJob) }) do
assert_performed_jobs(1, only: ->(job) { job.fetch(:job).name == "HelloJob" })
assert_performed_jobs(1, except: ->(job) { job.is_a?(HelloJob) }) do
assert_performed_jobs(1, except: ->(job) { job.fetch(:job).name == "HelloJob" })
assert_performed_with(**{ facet => matcher })
assert_performed_with(**{ facet => refuser })
super({ "value" => object.value })
{ "_aj_serialized" => "SerializersTest::DummySerializer", "value" => 123 },
hash = { "_aj_serialized" => "DoNotExist", "value" => 123 }
hash = { "_aj_serialized" => "SerializersTest::DummySerializer", "value" => 123 }
HelloJob.queue_with_priority { arguments.first == "1" ? 99 : 11 }
HelloJob.queue_as { arguments.first == "1" ? :one : :two }
def enqueue(*); end
def enqueue_at(*); end
ActiveSupport::Notifications.subscribed(-> (*args) { events << args }, /enqueue.*\.active_job/, &block)
assert_match(/to .*?\(php_jobs\).*/, @logger.messages)
assert_match(%r{Dummy, here is it: #<Person:.*>}, @logger.messages)
assert_match(%r{Dummy, here is it: .*#<Person:.*>}, @logger.messages)
assert_match(/Enqueued HelloJob \(Job ID: .*?\) to .*?:.*Cristian/, @logger.messages)
key, * = events.first
assert_match(/Performing LoggingJob \(Job ID: .*?\) from .*? with arguments:.*Dummy/, @logger.messages)
assert_match(/Performed LoggingJob \(Job ID: .*?\) from .*? in .*ms/, @logger.messages)
assert_match(/Performed DisableLogJob \(Job ID: .*?\) from .*? in .*ms/, @logger.messages)
assert_match(/Enqueued HelloJob \(Job ID: .*\) to .*? at.*Cristian/, @logger.messages)
assert_match(/Performing RescueJob \(Job ID: .*?\) from .*? with arguments:.*other/, @logger.messages)
assert_match(/Error performing RescueJob \(Job ID: .*?\) from .*? in .*ms: RescueJob::OtherError \(Bad hair\):\n.*\brescue_job\.rb:\d+:in `perform'/, @logger.messages)
assert_match(/Performing RescueJob \(Job ID: .*?\) from .*? with arguments:.*david/, @logger.messages)
assert_no_match(/Error performing RescueJob \(Job ID: .*?\) from .*? in .*ms: ArgumentError \(Hair too good\):\n.*\brescue_job\.rb:\d+:in `perform'/, @logger.messages)
assert_match(/Retrying RescueJob \(Job ID: .*?\) after \d+ attempts in 0 seconds\./, @logger.messages)
job.deserialize "locale" => "es"
delay_for_jitter = -> (delay) { random_amount * delay * ActiveJob::Base.retry_jitter }
arguments = { "some" => { "job" => "arguments" } }
@person = Person.find("5")
:a,
1.day,
Date.new(2001, 2, 3),
Time.new(2002, 10, 31, 2, 2, 2.123456789r, "+02:00"),
DateTime.new(2001, 2, 3, 4, 5, 6.123456r, "+03:00"),
{ "a" => 1 },
1..,
1...,
1..5,
1...5,
Date.new(2001, 2, 3)..,
Time.new(2002, 10, 31, 2, 2, 2.123456789r, "+02:00")..,
DateTime.new(2001, 2, 3, 4, 5, 6.123456r, "+03:00")..,
{ "a" => 1, "_aj_hash_with_indifferent_access" => true },
symbol_key = { a: 1 }
string_key = { "a" => 1 }
another_string_key = { "a" => 1 }
indifferent_access = { "a" => 1, "_aj_hash_with_indifferent_access" => true }
{ a: 1 },
time_with_zone = Time.new(2002, 10, 31, 2, 2, 2).in_time_zone
$LOAD_PATH << File.expand_path("../support/delayed_job", __dir__)
template "job.rb", File.join("app/jobs", class_path, "#{file_name}_job.rb")
expected = { job: job, args: args, at: at, queue: queue, priority: priority }.compact
message << "\n\nPotential matches: #{matching_class.join("\n")}"
def jobs_with(jobs, only: nil, except: nil, queue: nil, at: nil)
->(job) { Array(filter).include?(job.fetch(:job)) }
super("value" => argument.to_s)
def klass # :doc:
super("value" => date.iso8601)
super("value" => big_decimal.to_s)
options.each do |k, v|
send(k, v)
if @queue_name.is_a?(Proc)
def enqueue(job) # :nodoc:
def job_to_hash(job, extras = {})
->(job) { Array(filter).include?(job.class) }
gem "sidekiq", ">= 4.1.0"
def enqueue_at(*) # :nodoc:
@job_data = job_data
if delay > 0
around_enqueue(prepend: true) { |_, block| tag_logger(&block) }
job.arguments.map { |arg| format(arg).inspect }.join(", ")
arg.map { |value| format(value) }
def perform_now(...)
self.executions = (executions || 0) + 1
def retry_job(options = {})
jitter = jitter == JITTER_DEFAULT ? self.class.retry_jitter : (jitter || 0.0)
def perform_later(...)
job = job_or_instantiate(...)
args.first.is_a?(self) ? args.first : new(*args)
def enqueue(options = {})
def set(options = {})
def set(options = {}) # :nodoc:
@job_class.new(...).set(@options).perform_now
@job_class.new(...).enqueue @options
when -> (arg) { arg.respond_to?(:permitted?) }
argument.each_with_object({}) do |(key, value), hash|
match "/echo" => "tests#echo", via: :all
names = names.map { |name| "/test/#{name}.js" }
payload = JSON.generate(data).gsub("<", "&lt;").gsub(">", "&gt;")
if (window.top && window.top !== window)
</script>
get "/" => "foo#bar"
get "/other" => "foo#other"
get "/article/:id" => "foo#article", :as => :article
get "/category/:category" => "foo#category"
def hash_for(options = {})
{ controller: "foo", action: "bar" }.merge!(options)
assert_equal "/?a=b&c=d", url_for(hash_for(a: :b, c: :d))
assert_equal "/", url_for(hash_for(a: {}))
@controller = Struct.new(:request).new(Struct.new(:env).new({ "HTTP_REFERER" => referer }))
@controller = Struct.new(:request).new(Struct.new(:env).new({}))
to_form_params("name" => "David", :nationality => "Danish")
to_form_params(country: { name: "Denmark" })
to_form_params({ name: "Denmark" }, "country")
%{<form method="post" action="http://www.example.com" class="button_to"><button type="submit">Hello</button></form>},
button_to("Hello", "http://www.example.com")
assert_dom_equal %{<form method="post" action="http://www.example.com" class="button_to"><button type="submit">Hello</button></form>}, button_to("Hello", "http://www.example.com")
%{<form method="post" action="/article/Hello" class="button_to"><button type="submit">Hello</button></form>},
%{<form method="post" class="button_to"><button type="submit">Hello</button></form>},
button_to(false) { "Hello" }
%{<form method="post" action="/workshops" class="button_to"><button type="submit">Create</button></form>},
button_to(workshop) { "Create" }
%{<form method="post" action="/workshops/1" class="button_to"><input type="hidden" name="_method" value="patch" autocomplete="off" /><button type="submit">Update</button></form>},
button_to(workshop) { "Update" }
session = Session.new("1")
%{<form method="post" action="http://www.example.com" class="button_to"><button data-confirm="Are you sure?" type="submit">Hello</button></form>},
button_to("Hello", "http://www.example.com", data: { confirm: "Are you sure?" })
%{<form method="post" action="http://www.example.com" class="button_to"><button data-disable-with="Greeting..." type="submit">Hello</button></form>},
button_to("Hello", "http://www.example.com", data: { disable_with: "Greeting..." })
button_to("Hello", "http://www.example.com", remote: true, form: { class: "custom-class", "data-type" => "json" })
button_to("Hello", "http://www.example.com", remote: true, data: { confirm: "Are you sure?" })
button_to("Hello", "http://www.example.com", remote: true, data: { disable_with: "Greeting..." })
button_to("Hello", "http://www.example.com", remote: false)
button_to("Hello", "http://www.example.com", disabled: true)
%{<form method="post" action="http://www.example.com" class="button_to"><input type="hidden" name="_method" value="delete" autocomplete="off" /><button type="submit">Hello</button></form>},
button_to("Hello", "http://www.example.com", method: :delete)
%{<form method="get" action="http://www.example.com" class="button_to"><button type="submit">Hello</button></form>},
button_to("Hello", "http://www.example.com", method: :get)
%{<form method="post" action="http://www.example.com" class="button_to"><button type="submit"><span>Hello</span></button></form>},
button_to("http://www.example.com") { content_tag(:span, "Hello") }
button_to("Hello", "http://www.example.com", params: { foo: :bar, baz: "quux" })
%{<form action="/other" class="button_to" method="post"><button class="button" type="submit">Hello</button></form>},
button_to({ controller: "foo", action: "other" }, class: "button") { "Hello" }
%{<form method="post" action="http://www.example.com" class="button_to"><input type="submit" value="Save"/></form>},
button_to("Save", "http://www.example.com")
{ foo: :bar, baz: "quux" }
button_to("Hello", "http://www.example.com", params: { foo: { bar: "baz" } })
assert_dom_equal %{<a href="http://www.example.com">Hello</a>}, link_to("Hello", "http://www.example.com")
assert_dom_equal(%{<a href="/">Test Link</a>}, link_to("Test Link", url_hash))
hash = hash_for(host: "www.example.com")
expected = %{<a href="http://www.example.com/">Test Link</a>}
expected = %{<a href="http://www.example.com?q1=v1&amp;q2=v2">Hello</a>}
expected = %{<a href="http://www.example.com?q1=v1&amp;q2=v2">http://www.example.com?q1=v1&amp;q2=v2</a>}
env = { "HTTP_REFERER" => "http://www.example.com/referer" }
link = link_to("go back", :back)
assert_dom_equal %{<a href="javascript:history.back()">go back</a>}, link
link = link_to(raw("<img src='/favicon.jpg' />"), "/")
expected = %{<a href="/"><img src='/favicon.jpg' /></a>}
link = link_to("Hello", url_hash, nil)
assert_dom_equal %{<a href="/">Hello</a>}, link
link = link_to("Hello", "http://www.example.com", onclick: "alert('yay!')")
expected = %{<a href="http://www.example.com" onclick="alert(&#39;yay!&#39;)">Hello</a>}
%{<a href="http://www.example.com" data-confirm="Are you sure?">Hello</a>},
link_to("Hello", "http://www.example.com", data: { confirm: "Are you sure?" })
%{<a href="http://www.example.com" data-confirm="You can't possibly be sure, can you?">Hello</a>},
link_to("Hello", "http://www.example.com", data: { confirm: "You can't possibly be sure, can you?" })
%{<a href="http://www.example.com" data-confirm="You can't possibly be sure,\n can you?">Hello</a>},
link_to("Hello", "http://www.example.com", data: { confirm: "You can't possibly be sure,\n can you?" })
%{<a href="http://www.example.com" data-remote="true">Hello</a>},
link_to("Hello", "http://www.example.com", remote: true)
%{<a href="http://www.example.com">Hello</a>},
link_to("Hello", "http://www.example.com", remote: false)
%{<a href="/" data-remote="true">Hello</a>},
link_to("Hello", hash_for(remote: true), {})
link_to("Hello", hash_for("remote" => true), {})
%{<a href="http://www.example.com" data-method="post" rel="nofollow">Hello</a>},
link_to("Hello", "http://www.example.com", method: :post)
%{<a href="http://www.example.com" rel="nofollow" data-method="delete">Destroy</a>},
link_to("Destroy", "http://www.example.com", method: :delete)
%{<a href="\#" rel="nofollow" data-method="delete">Destroy</a>},
link_to("Destroy", "http://www.example.com", method: :delete, href: "#")
%{<a href="http://www.example.com" data-method="post" rel="example nofollow">Hello</a>},
link_to("Hello", "http://www.example.com", method: :post, rel: "example")
%{<a href="http://www.example.com" data-method="post" rel="nofollow" data-confirm="Are you serious?">Hello</a>},
link_to("Hello", "http://www.example.com", method: :post, data: { confirm: "Are you serious?" })
%{<a href="\#" rel="nofollow" data-confirm="Are you serious?" data-method="delete">Destroy</a>},
link_to("Destroy", "http://www.example.com", method: :delete, href: "#", data: { confirm: "Are you serious?" })
assert_dom_equal %{<a href="/"><span>Example site</span></a>},
link_to("/") { content_tag(:span, "Example site") }
assert_dom_equal %{<a class="special" href="/"><span>Example site</span></a>},
link_to("/", class: "special") { content_tag(:span, "Example site") }
%{<a href="/"><span>Example site</span></a>},
link_to(url_hash) { content_tag(:span, "Example site") }
out = render_erb %{<%= link_to('/') do %>Example site<% end %>}
assert_equal '<a href="/">Example site</a>', out
assert_dom_equal %{<a href="/">Malicious &lt;script&gt;content&lt;/script&gt;</a>},
link_to("Malicious <script>content</script>", "/")
assert_dom_equal %{<a href="/">Malicious <script>content</script></a>},
link_to(raw("Malicious <script>content</script>"), "/")
assert_dom_equal %{<a href="/workshops/1">Workshop 1</a>}, link
assert_dom_equal %{<a href="/">Listing</a>},
link_to_unless(true, "Showing", url_hash) { |name|
raw "<strong>#{name}</strong>"
link_to_unless(true, "Showing", url_hash) {
assert_equal %{&lt;b&gt;Showing&lt;/b&gt;}, link_to_unless(true, "<b>Showing</b>", url_hash)
assert_equal %{<a href="/">&lt;b&gt;Showing&lt;/b&gt;</a>}, link_to_unless(false, "<b>Showing</b>", url_hash)
assert_equal %{<b>Showing</b>}, link_to_unless(true, raw("<b>Showing</b>"), url_hash)
assert_equal %{<a href="/"><b>Showing</b></a>}, link_to_unless(false, raw("<b>Showing</b>"), url_hash)
assert_dom_equal %{<a href="/">Listing</a>}, link_to_if(true, "Listing", url_hash)
assert_equal "Fallback", link_to_if(false, "Showing", url_hash) { "Fallback" }
assert_dom_equal %{<a href="/">Listing</a>}, link_to_if(true, "Listing", url_hash) { "Fallback" }
def request_for_url(url, opts = {})
env = Rack::MockRequest.env_for("http://www.example.com#{url}", opts)
@request = request_for_url("/", method: :head)
@request = request_for_url("/")
@request = request_for_url("/?order=desc&page=1")
assert current_page?(hash_for(order: "desc", page: "1"))
@request = request_for_url("/engine/")
@request = request_for_url("/posts")
@request = request_for_url("/events", method: :post)
@request = request_for_url("/?order=desc")
link_to_unless_current("Showing", hash_for(order: "desc", page: "1"))
assert_equal %{<a href="/?order=asc">Showing</a>},
assert_equal %{<a href="http://www.example.com/?order=asc">Showing</a>},
assert_equal %{<a href="/?order=desc&amp;page=2\">Showing</a>},
assert_equal %{<a href="http://www.example.com/?order=desc&amp;page=2">Showing</a>},
@request = request_for_url("/show")
assert_equal %{<a href="/">Listing</a>},
assert_equal %{<a href="http://www.example.com/">Listing</a>},
assert_dom_equal %{<a href="/">Showing</a>}, link_to_unless(false, "Showing", url_hash) { "Fallback" }
%{<a href="mailto:%23%21%24%25%26%27%2A%2B-%2F%3D%3F%5E_%60%7B%7D%7C@example.org">#!$%&amp;&#39;*+-/=?^_`{}|@example.org</a>},
mail_to("#!$%&'*+-/=?^_`{}|@example.org")
mail_to("me@example.com", "My email", cc: "", bcc: "", subject: "This is an example email", body: "This is the body of the message.")
assert_dom_equal %{<a href="mailto:feedback@example.com"><img src="/feedback.png" /></a>},
mail_to("feedback@example.com", raw('<img src="/feedback.png" />'))
%{<a href="mailto:"></a>},
assert_dom_equal %{<a href="mailto:me@example.com"><span>Email me</span></a>},
mail_to("me@example.com") { content_tag(:span, "Email me") }
mail_to("me@example.com", cc: "ccaddress@example.com", class: "special") { content_tag(:span, "Email me") }
options = { class: "special" }
mail_to "me@example.com", "ME!", options
assert_equal({ class: "special" }, options)
assert_dom_equal %{<a href="sms:15155555785;">Jim Jones</a>}, sms_to("15155555785", "Jim Jones")
%{<a class="admin" href="sms:15155555785;">Jim Jones</a>},
sms_to("15155555785", "Jim Jones", "class" => "admin")
assert_equal sms_to("15155555785", "Jim Jones", "class" => "admin"),
sms_to("15155555785", "Jim Jones", class: "admin")
sms_to("5155555785", "Text me", class: "simple-class", country_code: "01", body: "Hello from Jim")
sms_to("5155555785", class: "simple-class", country_code: "01", body: "Hello from Jim")
sms_to("5155555785", "Text me", body: "This is the body of the message.")
assert_dom_equal %{<a href="sms:15155555785;"><img src="/feedback.png" /></a>},
sms_to("15155555785", raw('<img src="/feedback.png" />'))
%{<a href="sms:1%2B5155555785;">1+5155555785</a>},
%{<a href="sms:;"></a>},
assert_dom_equal %{<a href="sms:15155555785;"><span>Text me</span></a>},
sms_to("15155555785") { content_tag(:span, "Text me") }
sms_to("15155555785", body: "Hello from Jim", class: "special") { content_tag(:span, "Text me") }
sms_to "15155555785", "ME!", options
assert_dom_equal %{<a href="tel:1234567890">Bob</a>},
phone_to("1234567890", "Bob")
%{<a class="phoner" href="tel:1234567890">Bob</a>},
phone_to("1234567890", "Bob", "class" => "phoner")
assert_equal phone_to("1234567890", "Bob", "class" => "admin"),
phone_to("1234567890", "Bob", class: "admin")
%{<a class="example-class" href="tel:+011234567890">Phone</a>},
phone_to("1234567890", "Phone", class: "example-class", country_code: "01")
%{<a href="tel:+011234567890">Phone</a>},
phone_to("1234567890", "Phone", country_code: "01")
assert_dom_equal %{<a href="tel:1234567890"><img src="/feedback.png" /></a>},
phone_to("1234567890", raw('<img src="/feedback.png" />'))
%{<a href="tel:1%2B234567890">1+234567890</a>},
%{<a href="tel:"></a>},
assert_dom_equal %{<a href="tel:1234567890"><span>Phone</span></a>},
phone_to("1234567890") { content_tag(:span, "Phone") }
assert_dom_equal %{<a class="special" href="tel:+011234567890"><span>Phone</span></a>},
phone_to("1234567890", country_code: "01", class: "special") { content_tag(:span, "Phone") }
as: :show
get "/:controller(/:action(/:id))"
render inline: "<%= url_for(nil) %>"
render inline: "<%= url_for(action: :show_url_for) %>"
render inline: "<%= override_url_helper_path %>"
get :show_named_route, params: { kind: "url" }
get :show_named_route, params: { kind: "path" }
{ host: "testtwo.host" }
get :show, params: { id: "123" }
get :show, params: { name: "123" }
render inline: "<%= link_to_unless_current('tasks', tasks_path) %>\n" \
get :show, params: { id: 1 }
assert_equal %{<a href="/tasks">tasks</a>\n} +
%{<a href="#{@request.protocol}#{@request.host_with_port}/tasks">tasks</a>},
render inline: "<%= url_for(@workshop) %>\n<%= link_to('Workshop', @workshop) %>"
render inline: "<%= current_page?(@workshop) %>"
render inline: "<%= url_for(@url) %>\n<%= link_to('Session', @url) %>"
get :edit, params: { id: 1 }
get :index, params: { workshop_id: 1 }
get :show, params: { workshop_id: 1, id: 1 }
found: { foo: "Foo" },
found_yield_single_argument: { foo: "Foo" },
found_yield_block: { foo: "Foo" },
array: { foo: { bar: "Foo Bar" } },
default: { foo: "Foo" },
partial: { foo: "Partial foo" }
foo: "Foo",
hello: "<a>Hello World</a>",
html: "<a>Hello World</a>",
hello_html: "<a>Hello World</a>",
interpolated_html: "<a>Hello %{word}</a>",
array_html: %w(foo bar),
array: %w(foo bar),
count_html: {
one: "<a>One %{count}</a>",
other: "<a>Other %{count}</a>"
matcher = ->(key, options) do
@time = Time.utc(2008, 7, 8, 12, 18, 38)
assert_equal "Tue, 08 Jul 2008 12:18:38 +0000", localize(@time, locale: "en")
assert_equal expected, translate(:"translations.missing", name: "Kir", year: "2015", vulnerable: %{" onclick="alert()"})
expected = %w(foo bar)
assert_equal "<a>One 1</a>", translate(:'translations.count_html', count: 1)
assert_equal "<a>Other &lt;One&gt;</a>", translate(:'translations.count_html', count: "<One>")
hash = { one: "%{count} thing", other: "%{count} things" }
@_cycles = nil if defined?(@_cycles)
assert_equal "<p></p>", simple_format(nil)
assert_equal "<p>A paragraph</p>\n\n<p>and another one!</p>", simple_format("A paragraph\n\nand another one!")
assert_equal "<p>A\n<br />B\n<br />C\n<br />D</p>", simple_format(text)
assert_equal '<p class="test">This is a classy test</p>', simple_format("This is a classy test", class: "test")
assert_equal %Q(<p class="test">para 1</p>\n\n<p class="test">para 2</p>), simple_format("para 1\n\npara 2", class: "test")
assert_equal "<p><b> test with unsafe string </b>code!</p>", simple_format("<b> test with unsafe string </b><script>code!</script>")
assert_equal "<p><b> test with unsafe string </b>code!</p>",
simple_format("<b> test with unsafe string </b><script>code!</script>", {}, { sanitize: true })
assert_equal "<p><b> test with unsafe string </b><script>code!</script></p>", simple_format("<b> test with unsafe string </b><script>code!</script>", {}, { sanitize: false })
assert_equal "<div></div>", simple_format(nil, {}, { wrapper_tag: "div" })
text = "<b>Ok</b><script>code!</script>"
options = { class: "foobar" }
options = { wrapper_tag: :div, sanitize: false }
assert_equal "Hello Wor...", truncate("Hello World!!", length: 12)
assert_equal "Hello W...", truncate("Hello World!", length: 10)
options = { length: 10 }
assert_equal "Here is a long test and ...<a href=\"#\">Continue</a>",
truncate("Here is a long test and I need a continue to read link", length: 27) { link_to "Continue", "#" }
assert_equal "Hello &lt;sc...", truncate("Hello <script>code!</script>World!!", length: 12)
assert_equal "Hello <sc...", truncate("Hello <script>code!</script>World!!", length: 12, escape: false)
truncated = truncate("Here's a long test and I need a continue to read link", length: 27) { link_to "Continue", "#" }
assert_equal "&lt;script&gt;code!&lt;/script&gt;He...<a href=\"#\">Continue</a>",
truncate("<script>code!</script>Here's a long test and I need a continue to read link", length: 27) { link_to "Continue", "#" }
assert_equal "<script>code!</script>He...<a href=\"#\">Continue</a>",
truncate("<script>code!</script>Here's a long test and I need a continue to read link", length: 27, escape: false) { link_to "Continue", "#" }
truncated = truncate("<script>code!</script>Here's a long test and I need a continue to read link", length: 27, escape: false) { link_to "Continue", "#" }
assert_equal "Here is a long test and ...&lt;script&gt;alert(&#39;foo&#39;);&lt;/script&gt;",
truncate("Here is a long test and I need a continue to read link", length: 27) { "<script>alert('foo');</script>" }
assert_equal %(<em>wow</em> <em>em</em>), highlight("wow em", %w(wow em), highlighter: '<em>\1</em>')
highlight("<p>This is a <em class=\"error\">beautiful</em> morning, but also a beautiful <span class=\"last\">day</span></p>", "beautiful")
highlight("<div>abc div</div>", "div", highlighter: '<b>\1</b>')
options = { highlighter: '<b>\1</b>', sanitize: false }
highlight("<div>abc div</div>", "div", passed_options)
assert_equal("...is a beautiful morn...", excerpt("This is a beautiful morning", "beautiful", radius: 5))
assert_equal("This is a...", excerpt("This is a beautiful morning", "this", radius: 5))
assert_equal("...is a beautiful! mor...", excerpt("This is a beautiful! morning", "beautiful", radius: 5))
assert_equal("...is a beautiful? mor...", excerpt("This is a beautiful? morning", "beautiful", radius: 5))
assert_equal("...is a beautiful? mor...", excerpt("This is a beautiful? morning", /\bbeau\w*\b/i, radius: 5))
assert_equal("...is a beautiful? mor...", excerpt("This is a beautiful? morning", /\b(beau\w*)\b/i, radius: 5))
assert_equal("...judge Allen and...", excerpt("This day was challenging for judge Allen and his colleagues.", /\ballen\b/i, radius: 1, separator: " "))
assert_equal("...was challenging for...", excerpt("This day was challenging for judge Allen and his colleagues.", /\b(\w*allen\w*)\b/i, radius: 5))
assert_equal("", excerpt("", "", radius: 0))
assert_equal("a", excerpt("a", "a", radius: 0))
assert_equal("...b...", excerpt("abc", "b", radius: 0))
assert_equal("abc", excerpt("abc", "b", radius: 1))
assert_equal("abc...", excerpt("abcd", "b", radius: 1))
assert_equal("...abc", excerpt("zabc", "b", radius: 1))
assert_equal("...abc...", excerpt("zabcd", "b", radius: 1))
assert_equal("zabcd", excerpt("zabcd", "b", radius: 2))
options = { separator: " ", radius: 1 }
assert_equal("...a very beautiful...", excerpt("This is a very beautiful morning", "very", options))
options = { separator: "\n", radius: 0 }
assert_equal("...very long...", excerpt("my very\nvery\nvery long\nstring", "long", options))
options = { separator: "\n", radius: 1 }
assert_equal "123-+1234-+12-+12-+123-+1 1-+1-+123", word_wrap(input, line_width: 3, break_sequence: "-+")
input = "1\n1 1 1\n1"
assert_equal "1\n1 1\n1\n1", word_wrap(input, line_width: 3)
assert_equal "1-+1 1-+1-+1", word_wrap(input, line_width: 3, break_sequence: "-+")
input = "1\n\n\n1 1 1\n\n\n1"
assert_equal "1\n\n\n1 1\n1\n\n\n1", word_wrap(input, line_width: 3)
assert_equal "1-+-+-+1 1-+1-+-+-+1", word_wrap(input, line_width: 3, break_sequence: "-+")
input = "1\n1 1 1\n1\n\n\n"
assert_equal("1 count", pluralize(1, "count"))
assert_equal("1 count", pluralize("1", "count"))
assert_equal("2 counts", pluralize("2", "count"))
assert_equal("1,066 counts", pluralize("1,066", "count"))
assert_equal("1.25 counts", pluralize("1.25", "count"))
assert_equal("1.0 count", pluralize("1.0", "count"))
assert_equal("1.00 count", pluralize("1.00", "count"))
assert_equal("1 berry", pluralize(1, "berry"))
value = Cycle.new("one", 2, "3")
assert_equal("2", value.to_s)
assert_equal("3", value.to_s)
assert_equal("one", cycle("one", 2, "3"))
assert_equal("2", cycle("one", 2, "3"))
assert_equal("3", cycle("one", 2, "3"))
assert_equal("even", cycle("even", "odd"))
assert_equal("odd", cycle("even", "odd"))
assert_equal("1", cycle(1, 2, 3))
assert_equal("2", cycle(1, 2, 3))
assert_equal("3", cycle(1, 2, 3))
assert_equal("1", cycle(1, 2, 3, name: "numbers"))
assert_equal("red", cycle("red", "blue", name: "colors"))
assert_equal("2", cycle(1, 2, 3, name: "numbers"))
assert_equal("blue", cycle("red", "blue", name: "colors"))
assert_equal("3", cycle(1, 2, 3, name: "numbers"))
cycle("even", "odd")
cycle("red", "blue", name: "colors")
cycle(1, 2, 3)
assert_equal("2", cycle(1, 2, 3, name: "default"))
assert_equal("red", cycle("red", "blue"))
assert_equal("blue", cycle("red", "blue"))
assert_equal "<h1>Ruby on Rails</h1>", title("Ruby on Rails")
person = Struct.new(:name) {
}.new "David"
assert_equal '<a href="/people/1">David</a>', link_to_person(person)
get "people", to: "people#index", as: :people
render(layout: "test/layout_for_partial", locals: { name: "ChrisCruft" }) { "!" }
@controller.singleton_class.class_eval <<-EOF, __FILE__, __LINE__ + 1
@a = "b"
@c = "d"
assert_equal({ a: "b", c: "d" }, view_assigns)
from_test_case(suffix: "!")
def from_test_case(suffix: "?"); "Word#{suffix}"; end
set.draw {
get :foo, to: "foo#index"
get :bar, to: "bar#index"
routes.draw { get "bar", to: lambda { } }
def self.call(*)
set.draw { mount app => "/foo", :as => "foo_app" }
content_for :foo, "bar"
form_tag("/foo") do
safe_concat render(plain: "<ul><li>foo</li></ul>")
assert_select "li", text: "foo"
concat form_tag("/foo")
concat content_tag(:b, "Strong", class: "foo")
def new_template(body = "<%= hello %>", details = {})
def render(locals = {})
@template = new_template("<%= apostrophe %>")
@template = new_template("<%= apostrophe %> <%== apostrophe %>", format: :text)
assert_equal "<%= hello %>", render
assert_equal "<%= hello %>", @template.source
assert_equal "I am a local", render(my_local: "I am a local")
@template = new_template("<%= @virtual_path %>" \
@template = new_template("<%# locals: () -%>")
render(foo: "bar")
@template = new_template("<%# locals: (foo) -%>")
assert_equal "bar", render(foo: "bar")
@template = new_template("<%# locals: (message:) -%>\n<%= message %>")
@template = new_template("<%# locals: (message: 'Hello') -%>\n<%= message %>")
@template = new_template("<%# locals: (message:) -%>")
render(message: "Hi", foo: "bar")
@template = new_template("<%# encoding: ISO-8859-1 %>hello \xFCmlat", virtual_path: nil)
@template = new_template("<%# encoding: ISO-8859-1 %>\n<%# locals: (message: 'Hi!') %>\nhello \xFCmlat\n<%= message %>", virtual_path: nil)
assert_equal "<br />", tag("br")
assert_equal "<br clear=\"left\" />", tag(:br, clear: "left")
assert_equal "<br>", tag("br", nil, true)
assert_equal "<span></span>", tag.span
assert_equal "<span class=\"bookmark\"></span>", tag.span(class: "bookmark")
assert_equal "<br>", tag.br
assert_equal "<br class=\"some_class\">", tag.br(class: "some_class")
assert_equal "<br>some content</br>", tag.br("some content")
assert_equal "<svg><use href=\"#cool-icon\" /></svg>", tag.svg { tag.use("href" => "#cool-icon") }
assert_equal "<svg><circle cx=\"5\" cy=\"5\" r=\"5\" /></svg>", tag.svg { tag.circle(cx: "5", cy: "5", r: "5") }
assert_equal "<svg><circle><desc>A circle</desc></circle></svg>", tag.svg { tag.circle { tag.desc "A circle" } }
str = tag("p", "class" => "show", :class => "elsewhere")
assert_match(/class="show"/, str)
assert_equal("<input value=\"123 456\" />", str)
assert_equal("<input value=\"hello\" />", str)
assert_equal "<p />", tag("p", ignored: nil)
assert_equal "<p></p>", tag.p(ignored: nil)
assert_equal "<p value=\"false\" />", tag("p", value: false)
assert_equal "<p value=\"false\"></p>", tag.p(value: false)
assert_equal "<p included=\"\" />", tag("p", included: "")
assert_equal "<p included=\"\"></p>", tag.p(included: "")
assert_equal "<p value=\"symbol\" />", tag("p", { value: :symbol }, false, false)
assert_equal "<p value=\"42\" />", tag("p", { value: 42 }, false, false)
html = tag.with_options(id: "with-options") { |t| t.p("content") }
html_safe_str = '"'.html_safe
assert_equal "<p value=\"&quot;\" />", tag("p", value: html_safe_str)
assert_equal "<the-name aria-#{escaped_dangerous_chars}=\"the value\" />",
assert_equal "<the-name aria-#{escaped_dangerous_chars}=\"the value\"></the-name>",
assert_equal "<the-name data-#{escaped_dangerous_chars}=\"the value\" />",
assert_equal "<the-name data-#{escaped_dangerous_chars}=\"the value\"></the-name>",
assert_equal "<the-name #{escaped_dangerous_chars}=\"the value\" />",
assert_equal "<the-name #{escaped_dangerous_chars}=\"the value\"></the-name>",
assert_equal "<a href=\"create\">Create</a>", content_tag("a", "Create", "href" => "create")
assert_predicate content_tag("a", "Create", "href" => "create"), :html_safe?
assert_equal content_tag("a", "Create", "href" => "create"),
content_tag("a", "Create", href: "create")
assert_equal "<p>&lt;script&gt;evil_js&lt;/script&gt;</p>",
content_tag(:p, "<script>evil_js</script>")
assert_equal "<p><script>evil_js</script></p>",
content_tag(:p, "<script>evil_js</script>", nil, false)
assert_equal "<div @click=\"triggerNav()\">test</div>",
content_tag(:div, "test", "@click": "triggerNav()")
assert_equal "<div id=\"post_1\">Content</div>", tag.div("Content", id: "post_1")
assert_predicate tag.div("Content", id: "post_1"), :html_safe?
assert_equal tag.div("Content", id: "post_1"),
tag.div("Content", "id": "post_1")
tag.p("<script>evil_js</script>")
tag.p("<script>evil_js</script>", escape: false)
assert_equal '<input pattern="\w+">', tag.input(pattern: /\w+/)
tag.div { "content" }
assert_equal "<div id=\"header\"><span>hello</span></div>",
tag.div(id: "header") { |tag| tag.span "hello" }
assert_equal "<div id=\"header\"><div class=\"world\"><span>hello</span></div></div>",
tag.div(id: "header") { |tag| tag.div(class: "world") { tag.span "hello" } }
buffer = render_erb("<%= content_tag(:div) do %>Hello world!<% end %>")
buffer = render_erb("<%= tag.div do %>Hello world!<% end %>")
buffer = render_erb("<%= content_tag(:p) do %><% 1 %><% end %>")
assert_dom_equal "<p></p>", buffer
buffer = render_erb("<%= tag.p do %><% 1 %><% end %>")
buffer = render_erb("<%= content_tag(:div, :class => 'green') do %>Hello world!<% end %>")
buffer = render_erb("<%= tag.div(class: 'green') do %>Hello world!<% end %>")
assert_dom_equal %(<div class="green">Hello world!</div>), content_tag(:div, class: "green") { "Hello world!" }
assert_dom_equal %(<div class="green">Hello world!</div>), tag.div(class: "green") { "Hello world!" }
assert_equal content_tag("a", "Create", href: "create"),
content_tag("a", "href" => "create") { "Create" }
assert_equal tag.a("Create", href: "create"),
tag.a("href": "create") { "Create" }
content_tag("p") { 3.times { "do_something" } }
tag.p { 3.times { "do_something" } }
assert_equal content_tag("p", content_tag("b", "Hello")),
content_tag("p") { content_tag("b", "Hello") },
assert_equal tag.p(tag.b("Hello")),
tag.p { tag.b("Hello") },
assert_equal "<p class=\"song play&gt;\">limelight</p>", str
assert_equal "<p class=\"song play\">limelight</p>", str
assert_equal "<p class=\"song play>\">limelight</p>", str
assert_equal '<p class="">limelight</p>', str
str = content_tag("p", "limelight", class: { "song": true, "play": false })
assert_equal "<p class=\"song\">limelight</p>", str
str = content_tag("p", "limelight", class: { song: true, play: false })
assert_equal "<p class=\"1 2 3\">limelight</p>", str
assert_equal "<p class=\"1\">limelight</p>", str
str = content_tag("p", "limelight", class: { "song": true, "play": true })
str = content_tag("p", "limelight", class: { "song": false, "play": false })
str = tag.p "limelight", class: { "song": true, "play": false }
str = tag.p "limelight", class: { song: true, play: false }
str = tag.p "limelight", class: { "song": true, "play": true }
str = tag.p "limelight", class: { "song": false, "play": false }
str = content_tag("p", "limelight", { class: { "song": true, "play>": true } }, false)
str = tag.p "limelight", class: { "song": true, "play>": true }, escape: false
helper = ->(*arguments) { public_send(helper_method, *arguments) }
assert_equal "song", helper.({ "song": true, "play": false })
assert_equal "song", helper.({ song: true, play: false })
assert_equal "song play", helper.({ "song": true, "play": true })
assert_equal "", helper.({ "song": false, "play": false })
assert_equal "123", helper.(nil, "", false, 123, { "song": false, "play": false })
assert_equal "song", helper.("song", "song")
content_tag("p", "limelight", data: { number: 1, string: "hello", string_with_quotes: 'double"quote"party"' })
tag.p("limelight", data: { number: 1, string: "hello", string_with_quotes: 'double"quote"party"' })
assert_equal "1 &lt; 2 &amp; 3", escape_once("1 < 2 &amp; 3")
<input type="text" <%= tag.attributes value: nil, name: "name", "aria-hidden": false, aria: { label: "label" }, data: { input_value: "data" }, required: true %>>
<input type="text" xss="&quot;&gt;&lt;script&gt;alert()&lt;/script&gt;">
<input type="text" <%= tag.attributes xss: '"><script>alert()</script>' %>>
assert_equal %(<input type="text" >), render_erb(%(<input type="text" <%= tag.attributes nil %>>))
assert_equal %(<input type="text" >), render_erb(%(<input type="text" <%= tag.attributes({}) %>>))
assert_equal %(<a href="#{escaped}" />), tag("a", href: escaped.html_safe)
assert_equal %(<a href="#{escaped}"></a>), tag.a(href: escaped.html_safe)
assert_dom_equal '<p title="&quot;">content</p>',
content_tag("p", "content", title: '"'.html_safe)
assert_dom_equal '<p data-title="&quot;">content</p>',
content_tag("p", "content", data: { title: '"'.html_safe })
assert_equal %(<a href="#{escaped.gsub(/&/, '&amp;')}" />), tag("a", href: escaped)
assert_equal %(<a href="#{escaped.gsub(/&/, '&amp;')}"></a>), tag.a(href: escaped)
assert_equal '<a href="&amp;" />', tag("a", { href: "&amp;" }, false, false)
assert_equal '<a href="&amp;"></a>', tag.a(href: "&amp;", escape: false)
assert_equal '<a href="&amp;">cnt</a>', tag.a(href: "&amp;", escape: false) { "cnt" }
assert_equal '<br data-hidden="&amp;">', tag.br("data-hidden": "&amp;", escape: false)
assert_equal '<a href="&amp;">content</a>', tag.a("content", href: "&amp;", escape: false)
assert_equal '<a href="&amp;">content</a>', tag.a(href: "&amp;", escape: false) { "content" }
div_type1 = content_tag(:div, "test", "data-tooltip" => nil)
div_type2 = content_tag(:div, "test", data: { tooltip: nil })
div_type1 = tag.div "test", 'data-tooltip': nil
div_type2 = tag.div "test", data: { tooltip: nil }
assert_equal "<foo></foo>", tag.method(:foo).call
@assigns = { secret: "in the sauce", name: nil }
assert_equal %(<title></title>\nHello world!\n),
assert_equal %(<title>title</title>\n\n<div id="column">column</div>\n<div id="content">content</div>\n),
assert_equal %(\n<title>title</title>\n\n),
assert_equal "?Yes, \n\nthis works\n\n? like a charm.",
assert_equal "Yes, \n this works\n like a charm.",
I18n.locale = "da"
assert_equal "on my mind\nall day long", strip_links("<a href='almost'>on my mind</a>\n<A href='almost'>all day long</A>")
assert_equal "Magic", strip_links("<a href='http://www.rubyonrails.com/'>Mag<a href='http://www.ruby-lang.org/'>ic")
assert_equal "My mind\nall <b>day</b> long", strip_links("<a href='almost'>My mind</a>\n<A href='almost'>all <b>day</b> long</A>")
assert_equal "&lt;malformed &amp; link", strip_links('<<a href="https://example.org">malformed & link</a>')
assert_equal "", sanitize("<form action=\"/foo/bar\" method=\"post\"><input></form>")
expected = %r(\Adisplay:\s?block;\s?width:\s?100%;\s?height:\s?100%;\s?background-color:\s?black;\s?background-x:\s?center;\s?background-y:\s?center;\z)
assert_equal("Don't touch me", strip_tags("Don't touch me"))
assert_equal("This is a test.", strip_tags("<p>This <u>is<u> a <a href='test.html'><strong>test</strong></a>.</p>"))
assert_equal("Jekyll &amp; Hyde", strip_tags("Jekyll & Hyde"))
assert_equal "", strip_tags("<script>")
assert_equal "test\r\n\r\ntest", strip_tags("test\r\n\r\ntest")
frag = "<div>&lt;<span>script</span>&gt;xss();&lt;<span>/script</span>&gt;</div>"
with_file "#{dir}/hello_world", "Hello funky path!"
with_file "test/hello_world.html.erb", %q{<%# locals: (message: "hello")%>\n<%= message %>}
@assigns = { secret: "in the sauce" }
assert_equal({ "format" => "HTML",
template_path = File.expand_path("../fixtures/test/hello_world", __dir__)
assert_match(/File (.+) does not exist/, e.message)
assert_equal "<%= hello_world %>\n", @view.render(template: "plain_text")
assert_equal %q;Here are some characters: !@#$%^&*()-="'}{`; + "\n", @view.render(template: "plain_text_with_characters")
assert_equal buffer, "<%= hello_world %>\n"
assert_equal "4", @view.render(inline: "(2**2).to_s", type: :ruby)
old_locale, @view.locale = @view.locale, :"pt-BR"
locals = { secret: "in the sauce" }
assert File.exist?(File.expand_path("../../test/abstract_unit.rb", __dir__))
@view.render(template: "../\\../test/abstract_unit.rb")
e = assert_raises(ArgumentError) { @view.render(partial: "test/partial_only", as: "a-in", object: nil) }
e = assert_raises(ArgumentError) { @view.render(partial: "test/a-in", as: "a-in", object: nil) }
e = assert_raises(ActionView::Template::Error) { @view.render(inline: "<%= undefined %>") }
a = {}
b = {}
assert_equal '<b class="amazon">Hello: Amazon</b><b class="yahoo">Hello: Yahoo</b>',
assert_equal '<b data-counter="0">Hello: Amazon</b><b data-counter="1">Hello: Yahoo</b>',
assert_equal '<b class="amazon">Hello: Amazon</b>',
assert_equal "Before (Josh)\n\nAfter", @view.render(partial: "test/layout_for_partial", locals: { name: "Josh" })
render = @view.render(layout: "test/layout_with_partial_and_yield") { "Yield!" }
assert_equal "Hello, Josh!", @view.render(inline: "Hello, <%= name %>!", locals: { name: "Josh" })
assert_equal "Hello, World!", @view.render(inline: "Hello, World!", type: :bar)
assert_equal "3", @view.render(inline: "(1 + 2).to_s", type: :ruby_handler)
assert_equal 'source: "Hello, World!"', @view.render(inline: "Hello, World!", type: :foo)
assert_equal 'source: "Hello, <%= name %>!"', @view.render(inline: "Hello, <%= name %>!", locals: { name: "Josh" }, type: :foo)
assert_equal "Hello, World!", @view.render(inline: "Hello, World!", type: :foo)
@view.render(layout: "layouts/yield_with_params") { |param| "#{param} Content from block!" }
@view.render(partial: "test/partial", layout: "test/layout_for_partial", locals: { name: "Foo!" })
@view.render(partial: "test/partial_with_layout", layout: "test/layout_for_partial", locals: { name: "Foo!" })
assert_equal @view.render(inline: +"Hello, World!", type: :foo1), @view.render(inline: +"Hello, World!", type: :foo2)
%(Hello, World!),
assert_equal "foobar", @view.render(inline: "'foo' << 'bar'", type: :ruby)
@view.render(inline: "'foo' << 'bar'", type: :ruby)
@plural = "comments"
assert_equal "new_#{@singular}", dom_id(@klass)
assert_equal "new_#{@singular}", dom_id(@record)
assert_equal "#{@singular}_1", dom_id(@record)
assert_equal "edit_#{@singular}_1", dom_id(@record, :edit)
@string = "hello"
assert_equal "", raw(nil)
assert_equal "<p>foo</p>&lt;br /&gt;&lt;p&gt;bar&lt;/p&gt;", joined
assert_equal "<p>foo</p><br /><p>bar</p>", joined
assert_equal "&quot;a&quot; &lt;br/&gt; &lt;b&gt; &lt;br/&gt; &lt;c&gt;", joined
$, = nil
$, = "|"
actual = to_sentence(%w(< > & ' "))
assert_equal("&lt;, &gt;, &amp;, &#39;, and &quot;", actual)
actual = to_sentence(%w(<script>))
ptag = content_tag("p") do
url = "https://example.com"
expected = %(<a href="#{url}">#{url}</a> and <p>&lt;marquee&gt;shady stuff&lt;/marquee&gt;<br /></p>)
separator_was = $,
$, = separator_was
assert_equal "1,234,567,890.50 - K&#269;", number_to_currency("-1234567890.50", unit: raw("K&#269;"), format: "%n %u", negative_format: "%n - %u")
assert_equal "&lt;b&gt;1,234,567,890.50&lt;/b&gt; $", number_to_currency("1234567890.50", format: "<b>%n</b> %u")
assert_equal "&lt;b&gt;1,234,567,890.50&lt;/b&gt; $", number_to_currency("-1234567890.50", negative_format: "<b>%n</b> %u")
assert_equal "&lt;b&gt;1,234,567,890.50&lt;/b&gt; $", number_to_currency("-1234567890.50", "negative_format" => "<b>%n</b> %u")
assert_equal "100.000 %", number_to_percentage(100, format: "%n %")
assert_equal "&lt;b&gt;100.000&lt;/b&gt; %", number_to_percentage(100, format: "<b>%n</b> %")
assert_equal "<b>100.000</b> %", number_to_percentage(100, format: raw("<b>%n</b> %"))
assert_equal "1.000,000%", number_to_percentage(1000, delimiter: ".", separator: ",")
volume = { unit: "<b>ml</b>", thousand: "<b>lt</b>", million: "<b>m3</b>", trillion: "<b>km3</b>", quadrillion: "<b>Pl</b>" }
assert_equal "123 &lt;b&gt;lt&lt;/b&gt;", number_to_human(123456, units: volume)
assert_equal "12 &lt;b&gt;ml&lt;/b&gt;", number_to_human(12, units: volume)
assert_equal "1.23 &lt;b&gt;m3&lt;/b&gt;", number_to_human(1234567, units: volume)
assert_equal "1.23 &lt;b&gt;km3&lt;/b&gt;", number_to_human(1_234_567_000_000, units: volume)
assert_equal "1.23 &lt;b&gt;Pl&lt;/b&gt;", number_to_human(1_234_567_000_000_000, units: volume)
distance = { mili: "<b>mm</b>", centi: "<b>cm</b>", deci: "<b>dm</b>", unit: "<b>m</b>",
ten: "<b>dam</b>", hundred: "<b>hm</b>", thousand: "<b>km</b>",
micro: "<b>um</b>", nano: "<b>nm</b>", pico: "<b>pm</b>", femto: "<b>fm</b>" }
assert_equal "1.23 &lt;b&gt;mm&lt;/b&gt;", number_to_human(0.00123, units: distance)
assert_equal "1.23 &lt;b&gt;cm&lt;/b&gt;", number_to_human(0.0123, units: distance)
assert_equal "1.23 &lt;b&gt;dm&lt;/b&gt;", number_to_human(0.123, units: distance)
assert_equal "1.23 &lt;b&gt;m&lt;/b&gt;", number_to_human(1.23, units: distance)
assert_equal "1.23 &lt;b&gt;dam&lt;/b&gt;", number_to_human(12.3, units: distance)
assert_equal "1.23 &lt;b&gt;hm&lt;/b&gt;", number_to_human(123, units: distance)
assert_equal "1.23 &lt;b&gt;km&lt;/b&gt;", number_to_human(1230, units: distance)
assert_equal "$1&lt;script&gt;&lt;/script&gt;01", number_to_currency(1.01, separator: "<script></script>")
assert_equal "1&lt;script&gt;&lt;/script&gt;01", number_to_human(1.01, separator: "<script></script>")
assert_equal "&lt;script&gt;&lt;/script&gt;", number_to_phone("<script></script>")
number_to_human("x", raise: true)
number_to_phone("x", raise: true)
number_to_human("3.33", raise: true)
number_to_phone("3.33", raise: true)
test "handles */* formats" do
template = @lookup_context.find("hello", %w(test))
template = @lookup_context.find("foo", %w(test), true)
old_template = @lookup_context.find("foo", %w(test), true)
@lookup_context.find("foo", %w(test), true)
@view.render(inline: "<%= 'TEXT' %>")
@view.render(layout: "layouts/yield_only") { "hello" }
assert_match(/Rendered test\/_nested_cached_customer\.erb \(Duration: .*?ms \| Allocations: .*?\)$/, uncached_outer)
assert_difference -> { @logger.logged(:debug).size }, +1 do
locals: { greeting: "hi" })
assert_equal %(This \\"thing\\" is really\\n netos\\'), escape_javascript(%(This "thing" is really\n netos'))
assert_equal %(don\\'t <\\/close> tags), escape_javascript(%(don't </close> tags))
assert_equal %(don\\'t <\\/close> tags), j(%(don't </close> tags))
assert_equal "\\`", escape_javascript("`")
assert_equal "\\$", escape_javascript("$")
given = %('quoted' "double-quoted" new-line:\n </closed>)
expect = %(\\'quoted\\' \\"double-quoted\\" new-line:\\n <\\/closed>)
assert_dom_equal "<script src='/foo.bar'></script>", javascript_include_tag("/foo", extname: ".bar")
javascript_tag("alert('hello')", id: "the_js_tag")
foo = Mime::Type.lookup("text/foo")
(+"").tap do |txt|
txt << %{<input name="utf8" type="hidden" value="&#x2713;" autocomplete="off" />}
if method && !%w(get post).include?(method.to_s)
txt << %{<input name="_method" type="hidden" value="#{method}" autocomplete="off" />}
def form_text(action = "http://www.example.com", options = {})
method = method.to_s == "get" ? "get" : "post"
txt << %{ data-remote="true"} if remote
txt << %{ class="#{html_class}"} if html_class
txt << %{ id="#{id}"} if id
txt << %{ method="#{method}">}
def whole_form(action = "http://www.example.com", options = {})
out << yield << "</form>"
expected = %(<input id="admin" name="admin" type="checkbox" value="1" />)
actual = check_box_tag "admin", "1", false, disabled: true
expected = %(<input id="admin" disabled="disabled" name="admin" type="checkbox" value="1" />)
actual = check_box_tag "admin", "1", true
expected = %(<input id="admin" checked="checked" name="admin" type="checkbox" value="1" />)
actual = check_box_tag "admin", "yes", checked: true
expected = %(<input id="admin" checked="checked" name="admin" type="checkbox" value="yes" />)
actual = check_box_tag "admin", "1", checked: false
expected = %(<input id="admin" name="admin" type="checkbox" value="1" disabled="disabled" />)
actual = check_box_tag "admin", value: "0", checked: true
expected = %(<input id="admin" name="admin" type="checkbox" value="0" checked="checked" />)
actual = form_tag({}, { "multipart" => true })
actual = form_tag({}, { method: :patch })
actual = form_tag({}, { method: :put })
actual = form_tag({}, { method: :delete })
actual = form_tag({}, { remote: true })
actual = form_tag({}, { remote: false })
actual = form_tag({}, action: false)
actual = form_tag({}, { enforce_utf8: true })
actual = form_tag({}, { enforce_utf8: false })
actual = form_tag({})
output_buffer = render_erb("<%= form_tag('http://www.example.com') do %>Hello world!<% end %>")
expected = whole_form { "Hello world!" }
output_buffer = render_erb("<%= form_tag('http://www.example.com', :method => :put) do %>Hello world!<% end %>")
expected = whole_form("http://www.example.com", method: "put") do
value = field_id(:post, :title)
value = field_id(:post, :title, :error)
value = field_id(:post, :title, :error, index: 1)
value = field_name("", :title)
value = field_name("", :title, multiple: true)
value = field_name(:post, :title)
value = field_name(:post, :title, index: 1)
value = field_name(:post, :title, index: 1, multiple: true)
value = field_name(:post, :title, :subtitle, index: 1)
value = field_name(:post, :title, :subtitle, index: 1, multiple: true)
actual = hidden_field_tag "id", 3
expected = %(<input id="id" name="id" type="hidden" value="3" autocomplete="off" />)
assert_dom_equal "<input name=\"picsplz\" type=\"file\" id=\"picsplz\" />", file_field_tag("picsplz")
assert_dom_equal "<input name=\"picsplz\" type=\"file\" id=\"picsplz\" class=\"pix\"/>", file_field_tag("picsplz", class: "pix")
original_options = { class: "pix", direct_upload: true }
expected = %(<input id="password" name="password" type="password" />)
options = { class: "important" }
assert_dom_equal %(<input name="title" type="file" id="title" class="important"/>), file_field_tag("title", options)
assert_dom_equal %(<input type="password" name="title" id="title" value="Hello!" class="important" />), password_field_tag("title", "Hello!", options)
assert_dom_equal %(<input type="text" name="title" id="title" value="Hello!" class="important" />), text_field_tag("title", "Hello!", options)
expected = %(<input id="people_david" name="people" type="radio" value="david" />)
expected = %(<input id="num_people_5" name="num_people" type="radio" value="5" />)
actual = radio_button_tag("gender", "m") + radio_button_tag("gender", "f")
expected = %(<input id="gender_m" name="gender" type="radio" value="m" /><input id="gender_f" name="gender" type="radio" value="f" />)
actual = radio_button_tag("opinion", "-1") + radio_button_tag("opinion", "1")
expected = %(<input id="opinion_-1" name="opinion" type="radio" value="-1" /><input id="opinion_1" name="opinion" type="radio" value="1" />)
expected = %(<input id="ctrlname_apache2.2" name="ctrlname" type="radio" value="apache2.2" />)
expected = %(<input id="people_david" name="people" type="radio" value="david" checked="checked" />)
expected = %(<input id="people_david" name="people" type="radio" value="david" disabled="disabled" />)
actual = select_tag "people", raw("<option>david</option>")
expected = %(<select id="people" name="people"><option>david</option></select>)
expected = %(<select id="places" name="places"><option value="" label=" "></option><option>Home</option><option>Work</option><option>Pub</option></select>)
options = { include_blank: true, prompt: "string" }
expected = %(<select name="places" id="places"><option value="">string</option><option value="" label=" "></option><option>Home</option><option>Work</option><option>Pub</option></select>)
expected = %(<select id="places" name="places"><option value="" label=" "></option></select>)
expected = %(<select id="places" name="places"><option value="">string</option></select>)
actual = text_area_tag "body", "hello world", "size" => "20x40"
expected = %(<textarea cols="20" id="body" name="body" rows="40">\nhello world</textarea>)
actual = text_area_tag "body", "hello world", size: "20x40"
actual = text_area_tag "body", "hello world", size: 20
expected = %(<textarea id="body" name="body">\nhello world</textarea>)
actual = text_area_tag "body", "<b>hello world</b>", size: "20x40"
expected = %(<textarea cols="20" id="body" name="body" rows="40">\n&lt;b&gt;hello world&lt;/b&gt;</textarea>)
actual = text_area_tag "body", "<b>hello world</b>", size: "20x40", escape: false
expected = %(<textarea cols="20" id="body" name="body" rows="40">\n<b>hello world</b></textarea>)
expected = %(<textarea id="body" name="body">\n</textarea>)
actual = text_field_tag "title", "Hello!"
expected = %(<input id="title" name="title" type="text" value="Hello!" />)
actual = text_field_tag "title", "Hello!", "class" => "admin"
expected = %(<input class="admin" id="title" name="title" type="text" value="Hello!" />)
actual = text_field_tag "title", "Hello!", size: 75
expected = %(<input id="title" name="title" size="75" type="text" value="Hello!" />)
expected = %(<input id="title" name="title" type="text" value="{&quot;key&quot;=&gt;&quot;value&quot;}" />)
actual = text_field_tag "title", "Hello!", "size" => "75"
actual = text_field_tag "title", "Hello!", maxlength: 75
expected = %(<input id="title" name="title" maxlength="75" type="text" value="Hello!" />)
actual = text_field_tag "title", "Hello!", "maxlength" => "75"
expected = %(<input id="title" name="title" disabled="disabled" type="text" value="Hello!" />)
actual = text_field_tag "title", "Hello!", placeholder: "Enter search term..."
expected = %(<input id="title" name="title" placeholder="Enter search term..." type="text" value="Hello!" />)
actual = text_field_tag "title", "Hello!", size: 70, maxlength: 80
expected = %(<input id="title" name="title" size="70" maxlength="80" type="text" value="Hello!" />)
expected = %(<label for="title">Title</label>)
actual = label_tag "title", "My Title"
expected = %(<label for="title">My Title</label>)
actual = label_tag "title", "My Title", "class" => "small_label"
expected = %(<label for="title" class="small_label">My Title</label>)
assert_dom_equal("<label>Blocked</label>", label_tag { "Blocked" })
output = label_tag("clock") { "Grandfather" }
output = label_tag("clock", id: "label_clock") { "Grandfather" }
assert_dom_equal %(<input checked="checked" id="admin" name="admin" type="checkbox" value="1" />), check_box_tag("admin", 1, true, disabled: false, readonly: nil)
assert_dom_equal %(<input type="checkbox" />), tag(:input, type: "checkbox", checked: false)
assert_dom_equal %(<select id="people" name="people"><option>david</option></select>), select_tag("people", raw("<option>david</option>"), multiple: nil)
actual = text_field_tag "title", "Hello!", id: "admin"
expected = %(<input id="admin" name="title" type="text" value="Hello!" />)
%(<input name='commit' data-disable-with="Saving..." onclick="alert(&#39;hello!&#39;)" type="submit" value="Save" />),
submit_tag("Save", onclick: "alert('hello!')", data: { disable_with: "Saving..." })
%(<input data-disable-with="Save" name='commit' type="submit" value="Save" />),
%(<input name='commit' type="submit" value="Save" />),
submit_tag("Save", data: { disable_with: false })
%(<input data-disable-with="Processing..." data-confirm="Are you sure?" name='commit' type="submit" value="Save" />),
submit_tag("Save", "data-disable-with" => "Processing...", "data-confirm" => "Are you sure?")
%(<input data-confirm="Are you sure?" name='commit' type="submit" value="Save" />),
submit_tag("Save", "data-disable-with" => false, "data-confirm" => "Are you sure?")
submit_tag("Save", data: { confirm: "Are you sure?", disable_with: false })
%(<input name='commit' data-disable-with="Saving..." type="submit" value="Save" />),
submit_tag("Save", data: { disable_with: "Saving..." })
%(<input name='commit' type='submit' value='Save' data-confirm="Are you sure?" data-disable-with="Save" />),
submit_tag("Save", data: { confirm: "Are you sure?" })
%(<input type="submit" name="commit" value="Save" data-confirm="Are you sure?" data-disable-with="Processing..." />),
%(<input type="submit" name="commit" value="Save" data-disable-with="Processing..." />),
submit_tag("Save", data: { disable_with: "Processing..." })
%(<button name="button" type="submit">Button</button>),
%(<button name="button" type="submit">Save</button>),
button_tag("Save", type: "submit")
%(<button name="button" type="button">Button</button>),
button_tag("Button", type: "button")
%(<button name="button" type="reset">Reset</button>),
button_tag("Reset", type: "reset")
button_tag("Reset", type: "reset", disabled: true)
%(<button name="button" type="reset" disabled="disabled">&lt;b&gt;Reset&lt;/b&gt;</button>),
button_tag("<b>Reset</b>", type: "reset", disabled: true)
output = button_tag(name: "temptation", type: "button") { content_tag(:strong, "Do not press me") }
output = button_tag(name: "temptation", value: "within") { content_tag(:strong, "Do not press me") }
%(<button name="button" type="submit" data-confirm="Are you sure?">Save</button>),
button_tag("Save", type: "submit", data: { confirm: "Are you sure?" })
button_tag("Checkout", data: { disable_with: "Please wait..." })
%(<input type="image" src="/images/save.gif" data-confirm="Are you sure?" />),
image_submit_tag("save.gif", data: { confirm: "Are you sure?" })
expected = %{<input id="car" name="car" type="color" />}
expected = %{<input id="query" name="query" type="search" />}
expected = %{<input id="cell" name="cell" type="tel" />}
expected = %{<input id="cell" name="cell" type="date" />}
expected = %{<input id="cell" name="cell" type="time" />}
expected = %{<input id="birthday" name="birthday" type="month" />}
expected = %{<input id="birthday" name="birthday" type="week" />}
expected = %{<input id="homepage" name="homepage" type="url" />}
expected = %{<input id="address" name="address" type="email" />}
expected = %{<input name="quantity" max="9" id="quantity" type="number" min="1" />}
expected = %{<input name="volume" step="0.1" max="11" id="volume" type="range" min="0" />}
assert_dom_equal(expected, range_field_tag("volume", nil, in: 0..11, step: 0.1))
output_buffer = render_erb("<%= field_set_tag('Your details') do %>Hello world!<% end %>")
output_buffer = render_erb("<%= field_set_tag do %>Hello world!<% end %>")
output_buffer = render_erb("<%= field_set_tag('') do %>Hello world!<% end %>")
output_buffer = render_erb("<%= field_set_tag('', :class => 'format') do %>Hello world!<% end %>")
output_buffer = render_erb("<%= field_set_tag %>")
expected = %(<fieldset></fieldset>)
output_buffer = render_erb("<%= field_set_tag('You legend!') %>")
options = { option: "random_option" }
expected = %(<!-- '"` --><!-- </textarea></xmp> --></option></form>#{whole_form})
def to_s; name; end
def =~(_re); end
def match?(_re); end
class << base
options_from_collection_for_select(dummy_posts, "author_name", "title", lambda { |p| p.author_name == "Babe" })
options_for_select("$" => "Dollar", "<DKR>" => "<Kroner>").split("\n").join("\n")
options_for_select({ "$" => "Dollar", "<DKR>" => "<Kroner>" }, "Dollar").split("\n").join("\n")
quack = Struct.new(:first, :last)
%(<option selected="selected" value="1">rap</option>\n<option value="2">pop</option>),
%(<option value="1.0">rap</option>\n<option value="2.0" selected="selected">pop</option>),
%(<option value="1.0">rap</option>\n<option value="2.0">pop</option>),
%(<option disabled="disabled" value="1.0">rap</option>\n<option disabled="disabled" value="2.0">pop</option>),
group_proc = Proc.new { |c| c.countries }
label_proc = Proc.new { |c| c.continent_name }
assert_dom_equal "<option value=\"A\">A</option>\n" \
assert_dom_equal "<option value=\"B\">B</option>\n" \
@post = Post.new
@post.category = "<mus>"
select("post", "category", %w( abe <mus> hest))
select(:post, :category, "", {}, { multiple: false })
select("post", "allow_comments", %w( true false ))
output_buffer = fields_for :post, @post do |f|
concat f.select(:category, %w( abe <mus> hest))
map = Map.new
output_buffer = fields_for :map, map do |f|
output_buffer = fields_for :post, @post, index: 108 do |f|
options = raw("<option value=\"abe\">abe</option><option value=\"mus\">mus</option><option value=\"hest\">hest</option>")
concat(f.select(:category) { })
output_buffer = select(:post, :category, "", {}, { multiple: true })
output_buffer = select(:post, :category, "", { include_hidden: false }, { multiple: true })
output_buffer = select(:post, :category, "", {}, { multiple: true, disabled: true })
select("post", "category", %w( abe <mus> hest), include_blank: true)
e = assert_raises(ArgumentError) { select("post", "category", %w( abe <mus> hest), { include_blank: false }, { required: "required" }) }
select("post", "category", %w( abe <mus> hest), include_blank: "None")
select("post", "category", %w( abe <mus> hest), include_blank: "<None>")
@post.category = ""
select("post", "category", %w( abe <mus> hest), prompt: true)
select("post", "category", %w( abe <mus> hest), prompt: "The prompt")
select("post", "category", %w( abe <mus> hest), prompt: "<The prompt>")
select("post", "category", %w( abe <mus> hest), prompt: true, include_blank: true)
select("post", "category", { none: nil, programming: 1, economics: 2 }, { selected: nil })
assert_dom_equal(expected, select("post", "category", %w(abe mus hest), {}, { required: true }))
assert_dom_equal(expected, select("post", "category", %w(abe mus hest), { include_blank: "Select one" }, { required: true }))
assert_dom_equal(expected, select("post", "category", %w(abe mus hest), { prompt: "Select one" }, { required: true }))
assert_dom_equal(expected, select("post", "category", %w(abe mus hest), {}, { required: true, size: 1 }))
assert_dom_equal(expected, select("post", "category", %w(abe mus hest), {}, { required: true, size: 2 }))
assert_dom_equal(expected, select("post", "category", %w(abe mus hest), {}, { required: true, multiple: true }))
select("post", "category", %w( abe <mus> hest ), selected: "abe")
@album.id = 1
select("post", "title", "<script>alert(1)</script>")
select("post", "category", %w( abe <mus> hest ), selected: nil)
select("post", "category", %w( abe <mus> hest ), disabled: "hest")
select("post", "locale", %w( en ru ), selected: "ru")
select("post", "category", %w( one two ), selected: "two", prompt: true)
select("post", "category", 1..3)
@post.author_name = "Babe"
output_buffer = fields_for :post, @post, index: 815 do |f|
collection_select("post", "author_name", dummy_posts, "author_name", "author_name", { include_blank: true }, { "style" => "width: 200px" })
collection_select("post", "author_name", dummy_posts, "author_name", "author_name", { include_blank: "No Selection" }, { "style" => "width: 200px" })
collection_select("post", "author_name", dummy_posts, lambda { |p| p.author_name }, "title")
collection_select("post", "author_name", dummy_posts, "author_name", lambda { |p| p.title })
@firm = Firm.new("D")
html = time_zone_select("firm", "time_zone")
output_buffer = fields_for :firm, @firm do |f|
output_buffer = fields_for :firm, @firm, index: 305 do |f|
html = time_zone_select("firm", "time_zone", nil, include_blank: true)
html = time_zone_select("firm", "time_zone", nil, include_blank: "No Zone")
html = time_zone_select("firm", "time_zone", nil, {},
{ "style" => "color: red" })
assert_dom_equal html, time_zone_select("firm", "time_zone", nil, {},
{ style: "color: red" })
html = time_zone_select("firm", "time_zone", nil,
{ include_blank: true }, { "style" => "color: red" })
{ include_blank: true }, { style: "color: red" })
{ include_blank: "No Zone" }, { "style" => "color: red" })
{ include_blank: "No Zone" }, { style: "color: red" })
html = time_zone_select("firm", "time_zone", zones)
def tz.=~(re); %(A D).include?(name) end
def tz.match?(re); %(A D).include?(name) end
html = time_zone_select("firm", "time_zone", /A|D/)
def tz.===(zone); raise Exception; end
assert_dom_equal "<div class=\"field_with_errors\">" \
@firm = Firm.new()
html = time_zone_select("firm", "time_zone", nil, default: "B")
{ class: "fancy" },
{ :class => "fancy", "onclick" => "alert('Hello World');" },
options1 = { class: "fancy" }
options2 = { onclick: "alert('Hello World');" }
assert_equal({ class: "fancy" }, options1)
assert_equal({ onclick: "alert('Hello World');" }, options2)
@post.origin = "dk"
Post.new("Babe went home", "Babe", "To a little house", "shh!"),
def form_for(*)
post: {
helpers: {
label: {
color: {
red: "Rojo"
tag: {
value: "Tag"
submit: {
create: "Create %{model}",
update: "Update your %{model}"
uk: "Pounds"
title: "What is this about?",
written_on: {
def @post.id; 0; end
def @post.to_param; "123"; end
@post.author_name = ""
@post.tags << Tag.new
@car = Car.new("#000FFF")
get "/foo", to: "controller#action"
assert_dom_equal('<label for="post_title">Title</label>', label("post", "title"))
label("post", "title", "The title goes here")
label("post", "title", nil, class: "title_label")
assert_dom_equal('<label for="post_secret">Secret?</label>', label("post", "secret?"))
assert_dom_equal('<label for="post_title">Title</label>', label(:post, :title))
assert_dom_equal('<label for="post_secret">Secret?</label>', label(:post, :secret?))
assert_dom_equal('<label for="post_body">Write entire text here</label>', label("post", "body"))
assert_dom_equal('<label for="post_cost">Total cost</label>', label(:post, :cost))
label(:post, :body, class: "post_body")
assert_dom_equal('<label for="post_color_red">Rojo</label>', label(:post, :color, value: "red"))
form_for(@post, html: { id: "create-post" }) do |f|
expected = whole_form("/posts/123", "create-post", "edit_post", method: "patch") do
f.fields_for(:tags) do |cf|
form_for(OpenStruct.new(name: "ok"), as: "person", url: "/an", html: { id: "create-person" }) do |f|
expected = whole_form("/an", "create-person", "new_person", method: "post") do
assert_dom_equal('<label for="my_for">Title</label>', label(:post, :title, nil, for: "my_for"))
assert_dom_equal('<label for="my_for">Title</label>', label(:post, :title, nil, "for" => "my_for"))
assert_dom_equal("<label>Title</label>", label(:post, :title, for: nil))
label(:post, :title, nil, id: "my_id")
label(:post, :title, nil, "id" => "my_id")
label(:post, :title, nil, for: "my_for", id: "my_id")
label(:post, :title, nil, "for" => "my_for", "id" => "my_id")
label("post", "title", "The title goes here", value: "great_title")
label("post", "title", "The title goes here", value: "great title")
label(:post, :title) { "The title, please:" }
label(:post, :terms) { raw('Accept <a href="/terms">Terms</a>.') }
label(:post, :title, "for" => "my_for") { "The title, please:" }
label(:post, :body) { |b| raw("<b>#{b.translation}</b>") }
text_field("post", "title")
@post.title = "<b>Hello World</b>"
@post.title = "The HTML Entity for & is &amp;"
assert_dom_equal expected, text_field("post", "title", "size" => 35)
assert_dom_equal expected, text_field("post", "title", "maxlength" => 35)
assert_dom_equal expected, text_field("post", "title", "maxlength" => 35, "size" => nil)
expected = '<input id="post_title" type="text" value="Hello World" />'
expected = '<input id="import_file" multiple="multiple" name="custom" type="file" />'
expected = '<input type="hidden" name="custom" autocomplete="off" value="">' \
hidden_field("post", "title")
hidden_field("post", "secret?")
text_field("user", "email", type: "email")
check_box("post", "secret")
@post.secret = 0
check_box("post", "secret", "checked" => "checked")
check_box("post", "secret?")
@post.secret = "on"
check_box("post", "secret", {}, "on", "off")
@post.secret = "off"
check_box("post", "secret", {}, false, true)
check_box("post", "secret", {}, 0, 1)
@post.secret = 1
@post.secret = 2
@post.secret = 0.0
@post.secret = 1.1
@post.secret = 2.2
@post.secret = BigDecimal(2.2, 1)
check_box("post", "secret", {}, "on", nil)
assert_predicate check_box("post", "secret", {}, "on", nil), :html_safe?
check_box("post", "comment_ids", { multiple: true }, 1)
check_box("post", "comment_ids", { multiple: true }, 3)
check_box("post", "comment_ids", { multiple: true, index: "foo" }, 1)
check_box("post", "comment_ids", { multiple: true, index: "bar" }, 3)
check_box("post", "secret", disabled: true)
check_box("post", "secret", form: "new_form")
radio_button("post", "title", "Hello World")
radio_button("post", "title", "Goodbye World")
radio_button("post", "secret", "1")
radio_button("post", "secret", "-1"))
radio_button("post", "secret", "1", id: "foo")
radio_button("post", "secret", true)
text_area(:post, :cost, placeholder: "HOW MUCH?")
text_area("post", "body")
@post.body = "Back to <i>the</i> hill and over it again!"
text_area("post", "body", value: nil)
text_area("post", "id")
class << @post
class << @post; undef id_came_from_user?; end
@post.body = "The HTML Entity for & is &amp;"
text_area("post", "body", size: "183x820")
@car.color = "#1234TR"
assert_dom_equal(expected, color_field("car", "color", value: "#00FF00"))
@post.written_on = DateTime.new(2004, 6, 15, 1, 2, 3)
step = 2
value = Date.new(2013, 6, 29)
value = DateTime.new(2013, 6, 29)
min_value = "2000-06-15"
max_value = "2010-08-15"
min_value = "foo"
max_value = "bar"
min_value = DateTime.new(2000, 6, 15, 20, 45, 30)
max_value = DateTime.new(2010, 8, 15, 10, 25, 00)
step = 60
value = DateTime.new(2004, 6, 15, 1, 2, 3)
min_value = "20:45:30.000"
max_value = "10:25:00.000"
value = DateTime.new(2013, 6, 29, 13, 37)
min_value = "2000-06-15T20:45:30"
max_value = "2010-08-15T10:25:00"
@post.written_on = DateTime.new(2015, 1, 1, 1, 2, 3)
assert_dom_equal(expected, number_field("order", "quantity", in: 1...10))
assert_dom_equal(expected, number_field("order", "quantity", size: 30, in: 1...10))
assert_dom_equal(expected, range_field("hifi", "volume", in: 0..11, step: 0.1))
assert_dom_equal(expected, range_field("hifi", "volume", size: 30, in: 0..11, step: 0.1))
text_field("post", "title", "name" => "dont guess")
%{<textarea id="post_body" name="really!">\nBack to the hill and over it again!</textarea>},
text_area("post", "body", "name" => "really!")
check_box("post", "secret", "name" => "i mean it")
text_field("post", "title", "name" => "dont guess"),
text_field("post", "title", name: "dont guess")
text_area("post", "body", "name" => "really!"),
text_area("post", "body", name: "really!")
check_box("post", "secret", "name" => "i mean it"),
check_box("post", "secret", name: "i mean it")
text_field("post", "title", "id" => "dont guess")
text_area("post", "body", "id" => "really!")
check_box("post", "secret", "id" => "i mean it")
text_field("post", "title", "id" => "dont guess"),
text_field("post", "title", id: "dont guess")
text_area("post", "body", "id" => "really!"),
text_area("post", "body", id: "really!")
check_box("post", "secret", "id" => "i mean it"),
check_box("post", "secret", id: "i mean it")
text_field("post", "title", "id" => nil)
text_area("post", "body", "id" => nil)
check_box("post", "secret", "id" => nil)
radio_button("post", "secret", "0", "id" => nil)
text_field("post", "title", "id" => nil),
text_field("post", "title", id: nil)
text_area("post", "body", "id" => nil),
text_area("post", "body", id: nil)
check_box("post", "secret", "id" => nil),
check_box("post", "secret", id: nil)
radio_button("post", "secret", "0", "id" => nil),
radio_button("post", "secret", "0", id: nil)
text_field("post", "title", "index" => 5)
text_area("post", "body", "index" => 5)
check_box("post", "secret", "index" => 5)
text_field("post", "title", "index" => 5),
text_area("post", "body", "index" => 5),
check_box("post", "secret", "index" => 5),
text_field("post", "title", "index" => 5, "id" => nil)
text_area("post", "body", "index" => 5, "id" => nil)
check_box("post", "secret", "index" => 5, "id" => nil)
text_field("post", "title", "index" => 5, "id" => nil),
text_field("post", "title", index: 5, id: nil)
text_area("post", "body", "index" => 5, "id" => nil),
text_area("post", "body", index: 5, id: nil)
check_box("post", "secret", "index" => 5, "id" => nil),
check_box("post", "secret", index: 5, id: nil)
pid = 123
%{<label for="post_#{pid}_title">Title</label>},
form_for(@post, html: { id: "create-post" })
form_for(nil, html: { id: "create-post" }) do
concat f.label(:title) { "The Title" }
expected = whole_form("/posts", "new_post", "new_post") do
form_for(Post.new, url: false) do |form|
expected = whole_form(false, "new_post", "new_post")
form_for(Post.new, html: { action: false }) do |form|
value = field_id(Post.new, :secret?)
concat tag.span("is blank", id: form.field_id(:title, :error))
form_for(Post.new, index: 1) do |form|
form_for(Post.new, as: "") do |form|
expected = whole_form("/posts", "new_", "new_") do
%(<input id="title" name="title" type="text">)
expected = whole_form("/posts", "special_new_post", "new_post") do
form_for(post) do |f|
b.label { b.radio_button + b.text }
def post.id; 1; end
expected = whole_form("/posts", "new_post_1", "new_post") do
form_for(post, namespace: "foo") do |f|
expected = whole_form("/posts", "foo_new_post", "new_post") do
form_for(post, index: "1") do |f|
b.label { b.check_box + b.text }
form_for(post_form) { }
expected = whole_form("/posts/123", "edit_post_123", "edit_post", method: :patch) { "" }
expected = whole_form("/posts", "new_post", "new_post", method: :post) { "" }
expected = whole_form("/posts/123", "create-post", "edit_post", method: "patch", multipart: true) do
form_for(@post) do |f|
concat f.fields_for(:comment, @post) { |c|
expected = whole_form("/posts/123", "edit_post_123", "edit_post", method: "patch", multipart: true) do
form_for(@post, format: :json, html: { id: "edit_post_123", class: "edit_post" }) do |f|
expected = whole_form("/posts/123.json", "edit_post_123", "edit_post", method: "patch") do
form_for(@post, html: { id: "edit_post_123", class: "edit_post" }) do |f|
expected = whole_form("/posts/123", "edit_post_123", "edit_post", method: "patch") do
blog_post = Blog::Post.new("And his name will be forty and four.", 44)
form_for(blog_post) do |f|
expected = whole_form("/posts/44", "edit_post_44", "edit_post", method: "patch") do
form_for(@post, as: "other_name", html: { id: "create-post" }) do |f|
expected = whole_form("/posts/123", "create-post", "edit_other_name", method: "patch") do
form_for(obj, as: "other_name", url: "/", html: { id: "edit-other-name" }) do |f|
form_for(@post, url: "/", html: { id: "create-post", method: :delete }) do |f|
expected = whole_form("/", "create-post", "edit_post", method: "delete") do
form_for(@post, url: "/", method: :delete, html: { id: "create-post" }) do |f|
form_for(Post.new, url: "/search", html: { id: "search-post", method: :get }) do |f|
expected = whole_form("/search", "search-post", "new_post", method: "get") do
form_for(@post, url: "/", remote: true, html: { id: "create-post", method: :patch }) do |f|
expected = whole_form("/", "create-post", "edit_post", method: "patch", remote: true) do
form_for(:post, enforce_utf8: true) do |f|
expected = whole_form("/", nil, nil, enforce_utf8: true) do
form_for(:post, enforce_utf8: false) do |f|
expected = whole_form("/", nil, nil, enforce_utf8: false) do
form_for(:post) do |f|
form_for(@post, url: "/", html: { remote: true, id: "create-post", method: :patch }) do |f|
@post.stub(:to_key, nil) do
form_for(@post, remote: true) do |f|
expected = whole_form("/posts", "new_post", "new_post", remote: true) do
form_for(:post, html: { id: "create-post" }) do |f|
expected = whole_form("/", "create-post") do
concat f.label(:author_name, "Name", class: "label")
concat f.label(:author_name, class: "label") { "Name" }
form_for(@post, namespace: "namespace") do |f|
expected = whole_form("/posts/123", "namespace_edit_post_123", "edit_post", method: "patch") do
form_for(@post, namespace: "namespace", as: "custom_name") do |f|
form_for(@post, namespace: "namespace_1") do |f|
expected_1 = whole_form("/posts/123", "namespace_1_edit_post_123", "edit_post", method: "patch") do
form_for(@post, namespace: "namespace_2") do |f|
expected_2 = whole_form("/posts/123", "namespace_2_edit_post_123", "edit_post", method: "patch") do
concat f.fields_for(@comment) { |c|
form_for(@post, as: :another_post) do |f|
form_for(@post) do |form|
form_for(:posts) do |f|
form_for(@post, index: 1) do |c|
concat c.fields_for("comment", @comment, index: 1) { |r|
@rendered = form_for(@post, index: 1) do |f|
form_for(@post, index: 1) do |f|
concat f.fields_for(:comment, @post, index: 5) { |c|
form_for(@post, as: :post, index: 1) do |f|
expected = whole_form("/posts/123", "edit_post", "edit_post", method: "patch") do
concat f.fields_for(:author) { |af|
f.fields_for(:author, Author.new(123)) do |af|
form_for(@post, include_id: false) do |f|
concat f.fields_for(:author, include_id: true) { |af|
@post.comments = Array.new(2) { |id| Comment.new(id + 1) }
@post.comments = Array.new(11) { |id| Comment.new(id + 1) }
I18n.stub(:t, mock) do
comments = Array.new(2) { |id| Comment.new(id + 1) }
concat f.fields_for(:comments, Comment.new(321), child_index: "abc") { |cf|
concat f.fields_for(:comments, Comment.new(321), child_index: -> { "abc" }) { |cf|
f.fields_for(:comments, comment) { |cf|
expected += 1
f.fields_for(:comments, @post.comments) { |cf|
f.fields_for(:comments, Comment.new(321), child_index: "abc") { |cf|
concat f.fields_for(:author, @author) { |af|
concat f.fields_for(:author, @author, {}) { |af|
expected = whole_form("/posts/123", "edit_post_123", "edit_post", method: "patch")
@rendered = fields_for(:post, @post) do |f|
fields_for(:post, @post) do |fields|
fields_for(:post, @post, index: 1) do |fields|
@rendered = fields_for(:post) do |f|
@rendered = fields_for(@post) do |f|
assert_dom_equal "<label for=\"author_post_1_title\">Title</label>" \
form_for(@post, as: :post, html: { id: "create-post" }) do |post_form|
concat f.fields_for(:category) { |c|
def #{selector}(field, *args, &proc)
("<label for='\#{field}'>\#{field.to_s.humanize}:</label> " + super + "<br/>").html_safe
path = nil
form_for(@post, html: { id: "some_form", class: "some_class", multipart: true }) do |f| end
expected = whole_form("/posts/123", "some_form", "some_class", method: "patch", multipart: "multipart/form-data")
form_for(@post, url: "http://www.otherdomain.com") do |f| end
form_for(@post, url: { controller: "controller", action: "action" }) do |f| end
form_for(@post, url: @post) do |f| end
form_for(@post) do |f| end
form_for(post) do |f| end
expected = whole_form("/posts", "new_post", "new_post")
form_for(@post, url: "/super_posts") do |f| end
expected = whole_form("/super_posts", "edit_post_123", "edit_post", method: "patch")
form_for(@post) { }
form_for(@post, data: { behavior: "stuff" }, remote: true) { }
output = fields_for(Post.new) { |f| "fields" }
form_for(@post, builder: builder_class) { }
txt = +%{<input name="utf8" type="hidden" value="&#x2713;" autocomplete="off" />}
txt = +""
def form_text(action = "/", id = nil, html_class = nil, remote = nil, multipart = nil, method = nil)
def whole_form(action = "/", id = nil, html_class = nil, options = {})
contents = block_given? ? yield : ""
def form_text(action = "http://www.example.com", local: false, **options)
txt << %{ data-remote="true"} unless local
actual = form_with(html: { action: false })
@rendered = render_erb("<%= form_with(url: 'http://www.example.com') do %>Hello world!<% end %>")
@rendered = render_erb("<%= form_with(url: 'http://www.example.com', method: :put) do %>Hello world!<% end %>")
@rendered = render_erb("<%= form_with(url: 'http://www.example.com', local: true) do %>Hello world!<% end %>")
def form_with(*, **)
form_with(model: @post, id: "create-post") do |f|
expected = whole_form("/posts/123", "create-post", method: "patch") do
form_with(model: post_form) { }
expected = whole_form("/posts/123", method: :patch) { "" }
expected = whole_form("/posts", method: :post) { "" }
form_with(model: @post) do |f|
form_with(url: "/posts") do |f|
form_with(url: "/posts/123") do |f|
form_with(model: obj, scope: "other_name", url: "/", id: "edit-other-name") do |f|
form_with(model: post) do |f|
form_with(model: post, index: "1") do |f|
concat f.fields(:comment, model: @post) { |c|
form_with(model: @post, format: :json, id: "edit_post_123", class: "edit_post") do |f|
form_with(model: @post, format: :json, url: "/") do |f|
expected = whole_form("/", method: "patch") do
expected = whole_form("/posts/44", method: "patch") do
form_with(model: @post, scope: "other_name", id: "create-post") do |f|
form_with(model: @post, url: "/", id: "create-post", html: { method: :delete }) do |f|
expected = whole_form("/", "create-post", method: "delete") do
form_with(model: @post, url: "/", method: :delete, id: "create-post") do |f|
form_with(model: Post.new, url: "/search", id: "search-post", method: :get) do |f|
expected = whole_form("/search", "search-post", method: "get") do
form_with(model: @post, url: "/", id: "create-post", method: :patch) do |f|
expected = whole_form("/", "create-post", method: "patch") do
expected = whole_form("/", "create-post", method: "patch", local: true) do
form_with(scope: :post) do |f|
form_with(scope: :post, id: "create-post") do |f|
expected = whole_form("/posts/123", method: "patch") do
form_with(model: Post.new) do |f|
f.label(:title) do |label|
%(<label for="post_title"><span>Title</span></label>)
%(<label for="post_title"><span class="new_record">Title</span></label>)
form_with(model: @post, scope: :another_post) do |f|
concat f.fields(:comment) { |c|
form_with(scope: :posts) do |f|
concat f.fields(model: @comment) { |c|
form_with(model: @post, index: 1) do |c|
concat c.fields("comment", model: @comment, index: 1) { |r|
form_with(model: @post, index: 1) do |f|
concat f.fields(:comment, model: @post, index: 5) { |c|
concat f.fields(:author) { |af|
f.fields(:author, model: Author.new(123)) do |af|
concat f.fields(:author, skip_id: true) { |af|
form_with(model: @post, skip_id: true) do |f|
concat f.fields(:author, skip_id: false) { |af|
concat f.fields(:comments) { |cf|
concat f.fields(:comments, model: Comment.new(321), child_index: "abc") { |cf|
concat f.fields(:comments, model: Comment.new(321), child_index: -> { "abc" }) { |cf|
f.fields(:comments, model: comment) { |cf|
f.fields(:comments, model: @post.comments) { |cf|
f.fields(:comments, model: Comment.new(321), child_index: "abc") { |cf|
concat f.fields(:author, model: @author) { |af|
@rendered = fields(:post, model: @post) do |f|
@rendered = fields(:post) do |f|
@rendered = fields(model: @post) do |f|
form_with(model: @post, scope: :post, id: "create-post") do |post_form|
concat f.fields(:category) { |c|
form_with(model: @post, html: { id: "some_form", class: "some_class", multipart: true }) do |f| end
form_with(model: @post, url: "http://www.otherdomain.com") do |f| end
form_with(model: @post, url: { controller: "controller", action: "action" }) do |f| end
form_with(model: @post, url: @post) do |f| end
expected = whole_form("/posts/123", method: "patch")
form_with(model: @post) do |f| end
form_with(model: post) { }
form_with(model: @post, url: "/super_posts") do |f| end
form_with(model: @post) { }
form_with(model: @post, data: { behavior: "stuff" }) { }
output = fields(model: Post.new) { |f| "fields" }
form_with(model: Post.new, id: "new_special_post") do |form|
form_with(model: Post.new, html: { id: "new_special_post" }) do |form|
form_with(model: Post.new, id: "ignored", html: { id: "new_special_post" }) do |form|
def form_text(action = "/", id = nil, html_class = nil, local = nil, multipart = nil, method = nil)
def whole_form(action = "/", id = nil, html_class = nil, local: false, **options)
Category = Struct.new(:id, :name)
with_collection_radio_buttons :user, :active, collection, :last, :first, {}, { class: "special-radio" }
b.label { b.radio_button }
b.label("data-value": b.value) { b.radio_button + b.text }
b.label(class: b.object) { b.radio_button + b.text }
@rendered = fields_for(:post) do |p|
@rendered = fields_for(:user, user) do |p|
with_collection_check_boxes :user, :category_ids, collection, :first, :last, disabled: proc { |i| i.first == 1 }
with_collection_check_boxes :user, :category_ids, collection, :first, :last, readonly: proc { |i| i.first == 1 }
with_collection_check_boxes :user, :category_ids, collection, :first, :last, {}, { class: "check" }
b.label { b.check_box }
b.label(class: "check_box") + b.check_box(class: "check_box")
b.label("data-value": b.value) { b.check_box + b.text }
b.label(class: b.object) { b.check_box + b.text }
define_method "test_html_escape_#{expected.gsub(/\W/, '')}" do
define_method "test_json_escape_#{expected.gsub(/\W/, '')}" do
escaped = h("<p>")
assert_equal "&lt;p&gt;", escaped
escaped = h("<p>".html_safe)
(0..127).to_a.map(&:chr).each do |chr|
next if %('"&<>).include?(chr)
assert_equal "1 &lt;&gt;&amp;&quot;&#39; 2 &amp; 3", html_escape_once('1 <>&"\' 2 &amp; 3')
value = html_escape_once("1 < 2 &amp; 3")
value = html_escape_once("1 < 2 &amp; 3".html_safe)
expected_output = %r{<form.*action="/foo".*method="post">.*hello*</form>}
assert_match expected_output, render_content("form_tag('/foo')", "<%= 'hello' %>")
assert_equal expected_output, render_content("field_set_tag('foo')", "<%= 'hello' %>")
rs.draw { }
get "/blah/update", to: "blah#update"
output = render_content "form_for(:staticpage, :url => {:controller => 'blah', :action => 'update'})", "", routes
assert_match %r{<form.*action="/blah/update".*method="post">.*</form>}, output
template = <<~ERB
<%= "foo".upcase %>
<%== "foo".length %>
FIXTURES_DIR = File.expand_path("../fixtures/digestor", __dir__)
def self.build(details = {})
variant = "+#{variant}" if variant.present?
File.open("digestor/#{template_name}.html#{variant}.erb", "w") do |f|
if handler == :erb
template = FakeTemplate.new("<%= render 'messages/message123' %>", :erb)
template = FakeTemplate.new("<%= render partial: 'messages/show', layout: 'messages/layout' %>", :erb)
template = FakeTemplate.new("<%= render layout: 'messages/layout' do %>", :erb)
template = FakeTemplate.new("<%= render(message.topic) %>", :erb)
template = FakeTemplate.new("<%= render(message_type.messages) %>", :erb)
template = FakeTemplate.new("<%= render'messages/message' %>", :erb)
template = FakeTemplate.new("<%= rendering 'it useless' %>", :erb)
template = FakeTemplate.new("<%= surrender 'to reason' %>", :erb)
partial: 'posts' %>", :erb)
<%= render('shared/header', title: 'Title') %>
<%= render@section %>
<%= render $globals %>
<%= render @instance_variables %>
<%= render @@class_variables %>
<%= render "single/quote's" %>
<%= render 'double/quote"s' %>
}, :erb)
<%= render ( @message.events ) %>
<%= render SomeConstant.message(this: "that") %>
<%= render "double/#{quote}" %>
<%= render 'single/#{quote}' %>
<%# render "messages/legacy_message" %>
Post = Struct.new("Post", :id, :written_on, :updated_at)
to ||= from
from = Time.utc(2004, 6, 6, 21, 45, 0)
from = Time.mktime(2004, 6, 6, 21, 45, 0)
start_date = Date.new 1975, 1, 31
end_date = Date.new 1977, 1, 31
start_date = Date.new 1982, 12, 3
end_date = Date.new 2010, 11, 30
expected << "</select>\n"
assert_dom_equal expected, select_day(Time.mktime(2003, 8, 16), {}, { class: "selector" })
assert_dom_equal expected, select_day(16, {}, { class: "selector" })
format_string = "%{name} (%<number>02d)"
assert_dom_equal expected, select_month(Time.mktime(2003, 8, 16), {}, { class: "selector", accesskey: "M" })
travel_to Time.new(2019, 1, 1) do
assert_dom_equal expected, select_year({ year: nil, month: 4, day: nil }, { end_year: 2018 })
expected = +%(<select id="date_year" name="date_year">\n)
Time.mktime(2003, 8, 16), prefix: "date_year", discard_type: true, start_year: 2003, end_year: 2005)
assert_dom_equal expected, select_year(Time.mktime(2003, 8, 16), { start_year: 2003, end_year: 2005 }, { class: "selector", accesskey: "M" })
expected << %(<option value="">Year</option>\n<option value="2003">2003</option>\n<option value="2004">2004</option>\n<option value="2005">2005</option>\n)
expected << %(<option value="2003">2003</option>\n<option value="2004">2004</option>\n<option value="2005">2005</option>\n)
year_format_lambda = ->year { "Heisei #{ year - 1988 }" }
assert_dom_equal expected, select_hour(Time.mktime(2003, 8, 16, 8, 4, 18), {}, { class: "selector", accesskey: "M" })
assert_dom_equal expected, select_hour(Time.mktime(2003, 8, 16, 8, 4, 18), with_css_classes: { hour: "my-hour" })
assert_dom_equal expected, select_minute(Time.mktime(2003, 8, 16, 8, 4, 18), {}, { class: "selector", accesskey: "M" })
assert_dom_equal expected, select_minute(Time.mktime(2003, 8, 16, 8, 4, 18), with_css_classes: { minute: "my-minute" })
assert_dom_equal expected, select_second(Time.mktime(2003, 8, 16, 8, 4, 18), {}, { class: "selector", accesskey: "M" })
assert_dom_equal expected, select_second(Time.mktime(2003, 8, 16, 8, 4, 18), with_css_classes: { second: "my-second" })
(Date.today.year - 5).upto(Date.today.year + 1) do |y|
if y == Date.today.year
expected << %(<option value="#{y}" selected="selected">#{y}</option>\n)
expected << %(<option value="#{y}">#{y}</option>\n)
2003.upto(2008) do |y|
if y == 2003
(Date.today.year - 5).upto(Date.today.year + 5) do |y|
(Date.today.year - 5).upto(Date.today.year + 1) { |y| expected << %(<option value="#{y}">#{y}</option>\n) }
last_year = Time.now.year + 5
2003.upto(last_year) { |y| expected << %(<option value="#{y}">#{y}</option>\n) }
(Date.today.year - 5).upto(Date.today.year + 5) { |y| expected << %(<option value="#{y}">#{y}</option>\n) }
expected << " / "
assert_dom_equal expected, select_date(Time.mktime(2003, 8, 16), start_year: 2003, end_year: 2005, with_css_classes: { year: "my-year", month: "my-month", day: "my-day" })
assert_dom_equal expected, select_date(Time.mktime(2003, 8, 16), { start_year: 2003, end_year: 2005, with_css_classes: { month: "my-month custom-grid" } }, { class: "date optional" })
expected << " &mdash; "
expected << " : "
expected << "/"
expected << "&mdash;"
expected << ":"
prompt: { day: "Choose day", month: "Choose month", year: "Choose year", hour: "Choose hour", minute: "Choose minute" })
assert_dom_equal expected, select_time(Time.mktime(2003, 8, 16, 8, 4, 18), time_separator: " : ")
assert_dom_equal expected, select_time(Time.mktime(2003, 8, 16, 8, 4, 18), include_seconds: true, time_separator: " : ")
assert_dom_equal expected, select_time(Time.mktime(2003, 8, 16, 8, 4, 18), {}, { class: "selector" })
assert_dom_equal expected, select_time(Time.mktime(2003, 8, 16, 8, 4, 18), { include_seconds: false }, { class: "selector" })
prompt: { hour: "Choose hour", minute: "Choose minute", second: "Choose seconds" })
prompt: { hour: true, minute: "Choose minute", second: "Choose seconds" })
assert_dom_equal expected, select_time(Time.mktime(2003, 8, 16, 8, 4, 18), include_seconds: true, with_css_classes: { hour: "my-hour", minute: "my-minute", second: "my-second" })
@post.written_on = Date.new(2004, 6, 15)
assert_dom_equal expected, date_select("post", "written_on", selected: { day: 10, month: 07, year: 2004 })
@post.written_on = Date.new(2004, 2, 29)
id = 27
output_buffer = fields_for :post, @post, index: id do |f|
id = nil
id = 456
id = 123
1.upto(31) { |i| expected << %(<option value="#{i}"#{' selected="selected"' if i == 15}>#{i}</option>\n) }
1999.upto(2009) { |i| expected << %(<option value="#{i}"#{' selected="selected"' if i == 2004}>#{i}</option>\n) }
start_year = Time.now.year - 5
start_year.upto(end_year) { |i| expected << %(<option value="#{i}"#{' selected="selected"' if i == Time.now.year}>#{i}</option>\n) }
1.upto(31) { |i| expected << %(<option value="#{i}"#{' selected="selected"' if i == Time.now.day}>#{i}</option>\n) }
expected << "<option value=\"\" label=\" \"></option>\n"
start_year.upto(end_year) { |i| expected << %(<option value="#{i}">#{i}</option>\n) }
1.upto(31) { |i| expected << %(<option value="#{i}">#{i}</option>\n) }
assert_dom_equal expected, date_select("post", "written_on", {}, { class: "selector" })
concat f.date_select(:written_on, {}, { class: "selector" })
assert_dom_equal expected, date_select("post", "written_on", date_separator: " / ")
assert_dom_equal expected, date_select("post", "written_on", prompt: { year: "Choose year", month: "Choose month", day: "Choose day" })
assert_dom_equal expected, date_select("post", "written_on", with_css_classes: { year: "my-year", month: "my-month", day: "my-day" })
@post.written_on = Time.local(2004, 6, 15, 15, 16, 35)
0.upto(23) { |i| expected << %(<option value="#{sprintf("%02d", i)}">#{sprintf("%02d", i)}</option>\n) }
0.upto(59) { |i| expected << %(<option value="#{sprintf("%02d", i)}">#{sprintf("%02d", i)}</option>\n) }
assert_dom_equal expected, time_select("post", "written_on", {}, { class: "selector" })
concat f.time_select(:written_on, {}, { class: "selector" })
expected << " - "
expected << %(<option value="">Hour</option>\n)
expected << %(<option value="">Minute</option>\n)
expected << %(<option value="">Choose hour</option>\n)
expected << %(<option value="">Choose minute</option>\n)
assert_dom_equal expected, time_select("post", "written_on", with_css_classes: { hour: "my-hour", minute: "my-minute" })
assert_dom_equal expected, time_select("post", "written_on", {}, { disabled: true })
@post.updated_at = Time.local(2004, 6, 15, 16, 35)
concat f.datetime_select(:updated_at, {}, { class: "selector" })
@post.updated_at = Time.local(2004, 6, 15, 15, 16, 35)
expected << " , "
assert_dom_equal expected, datetime_select("post", "updated_at", date_separator: " / ", datetime_separator: " , ", time_separator: " - ", include_seconds: true)
@post.updated_at = 3
@post.updated_at = (-1.0 / 0)
id = @post.id
2001.upto(2011) { |i| expected << %(<option value="#{i}"#{' selected="selected"' if i == 2006}>#{i}</option>\n) }
1.upto(31) { |i| expected << %(<option value="#{i}"#{' selected="selected"' if i == 19}>#{i}</option>\n) }
expected << %(<option value="" label=" "></option>\n)
(Time.now.year - 5).upto(Time.now.year + 5) { |i| expected << %(<option value="#{i}">#{i}</option>\n) }
assert_dom_equal expected, datetime_select("post", "updated_at", default: { month: 10, minute: 42, hour: 9 })
assert_dom_equal expected, datetime_select("post", "updated_at", {}, { class: "selector" })
@post.updated_at = Time.local(2008, 7, 16, 23, 30)
default: { year: 2008, month: 7, day: 16, hour: 23, minute: 30, second: 1 },
}, options)
assert_predicate select_time(Time.mktime(2003, 8, 16, 8, 4, 18), {}, { class: "selector" }), :html_safe?
assert_predicate date_select("post", "written_on", default: Time.local(2006, 9, 19, 15, 16, 35), include_blank: true), :html_safe?
date = Date.new(2013, 2, 20)
time = Time.new(2013, 2, 20, 0, 0, 0, "+00:00")
assert_match(/<time.*>Right now<\/time>/, time_tag(Time.now, "Right now"))
assert_match(/<time.*><span>Right now<\/span><\/time>/, time_tag(Time.now) { raw("<span>Right now</span>") })
expected = '<time datetime="2013-02-20T00:00:00+00:00">20 Feb 00:00</time>'
@from = Time.utc(2004, 6, 6, 21, 45, 0)
}.each do |args, expected|
key, count = *args
to = @from + diff
select_month(8, locale: "en")
prompt_defaults = { year: "Year", month: "Month", day: "Day", hour: "Hour", minute: "Minute", second: "Seconds" }
prompts_check = -> (prompt, x) do
@prompt_called ||= 0
datetime_select("post", "updated_at", locale: "en")
<meta name="csrf-token" content="secret" />
assert_equal "<meta name=\"csp-nonce\" content=\"iyhD0Yc0W+c=\" />", csp_meta_tag
assert_equal "<meta property=\"csp-nonce\" name=\"csp-nonce\" content=\"iyhD0Yc0W+c=\" />", csp_meta_tag(property: "csp-nonce")
@controller.params = {}
locals = {
foo: "bar",
Foo: "bar",
_: "one",
arg: "two",
args: "three",
block: "four",
@av.output_buffer << "foo"
@av.output_buffer << "bar"
string = @av.capture("foo", "bar") do |a, b|
a + b
assert_nil @av.capture { 1 }
string = @av.capture { "<em>bar</em>" }
assert_equal "&lt;em&gt;bar&lt;/em&gt;", string
string = @av.capture { raw("&lt;em&gt;bar&lt;/em&gt;") }
content_for :foo, "foo"
content_for(:bar) { "bar" }
output_buffer << "foo"
output_buffer << "bar"
assert_nil content_for(:title) { output_buffer << "bar"; nil }
assert_nil content_for(:title, flush: true) { output_buffer << "bar"; nil }
content_tag(:p, "title")
content_for :title, "", flush: true
provide :title, "hi"
provide :title, "<p>title</p>"
assert_equal "hi&lt;p&gt;title&lt;/p&gt;", content_for(:title)
provide :title, raw("<p>title</p>")
assert_equal "hi<p>title</p>", content_for(:title)
@av.output_buffer << "."
assert_equal ".", buffer.to_s
assert_equal "..", buffer.to_s
assert_equal "", @av.with_output_buffer { }.to_s
Scroll = Struct.new(:id, :to_param, :title, :body, :updated_at, :created_at) do
atom_feed(:schema_date => '2008') do |feed|
entry.content(scroll.body, :type => 'html')
feed.entry(scroll, :url => "/otherstuff/" + scroll.to_param.to_s, :updated => Time.utc(2007, 1, scroll.id)) do |entry|
feed.entry(scroll, :type => 'text/xml') do |entry|
feed.entry(scroll, :url => false) do |entry|
atom_feed({'xmlns:app' => 'http://www.w3.org/2007/app',
atom_feed({:id => 'tag:test.rubyonrails.org,2008:test/'}) do |feed|
atom_feed(:schema_date => '2008',
:instruct => {'xml-stylesheet' => { :href=> 't.css', :type => 'text/css' }}) do |feed|
entry.summary(:type => 'xhtml') do |xhtml|
xhtml.p "before #{scroll.id}"
xhtml.p {xhtml << scroll.body}
xhtml.p "after #{scroll.id}"
new_xml = Builder::XmlMarkup.new(:target=>''.dup)
atom_feed(:xml => new_xml) do |feed|
Scroll.new(1, "1", "Hello One", "Something <i>COOL!</i>", Time.utc(2007, 12, 12, 15), Time.utc(2007, 12, 12, 15)),
Scroll.new(2, "2", "Hello Two", "Something Boring", Time.utc(2007, 12, 12, 15)),
get :index, params: { id: "defaults" }
assert_match(%r{xml:lang="en-US"}, @response.body)
get :index, params: { id: "provide_builder" }
get :index, params: { id: "entry_options" }
get :index, params: { id: "xml_block" }
assert_match %r{xmlns="http://www\.w3\.org/2005/Atom"}, @response.body
assert_match %r{xmlns:app="http://www\.w3\.org/2007/app"}, @response.body
get :index, params: { id: "feed_with_overridden_ids" }
assert_match %r{<\?target1 (a="1" b="2"|b="2" a="1")\?>}, @response.body
assert_match %r{<\?target1 (c="3" d="4"|d="4" c="3")\?>}, @response.body
get :index, params: { id: "entry_type_options" }
get :index, params: { id: "entry_url_false_option" }
def protocol() "http://" end
def ssl?() false end
def base_url() "http://www.example.com" end
@headers ||= {}
%(asset_path("/dir/xml.png")) => %(/dir/xml.png),
%(asset_path("http://www.outside.com/image.jpg")) => %(http://www.outside.com/image.jpg),
%(asset_path("HTTP://www.outside.com/image.jpg")) => %(HTTP://www.outside.com/image.jpg),
%(asset_path("style", type: :stylesheet)) => %(/stylesheets/style.css),
%(asset_path("xmlhr", type: :javascript)) => %(/javascripts/xmlhr.js),
%(auto_discovery_link_tag) => %(<link href="http://www.example.com" rel="alternate" title="RSS" type="application/rss+xml" />),
%(auto_discovery_link_tag(:rss)) => %(<link href="http://www.example.com" rel="alternate" title="RSS" type="application/rss+xml" />),
%(auto_discovery_link_tag(:atom)) => %(<link href="http://www.example.com" rel="alternate" title="ATOM" type="application/atom+xml" />),
%(auto_discovery_link_tag(:json)) => %(<link href="http://www.example.com" rel="alternate" title="JSON" type="application/json" />),
%(auto_discovery_link_tag(:rss, :action => "feed")) => %(<link href="http://www.example.com" rel="alternate" title="RSS" type="application/rss+xml" />),
%(auto_discovery_link_tag(:rss, "http://localhost/feed")) => %(<link href="http://localhost/feed" rel="alternate" title="RSS" type="application/rss+xml" />),
%(auto_discovery_link_tag(:rss, "//localhost/feed")) => %(<link href="//localhost/feed" rel="alternate" title="RSS" type="application/rss+xml" />),
%(auto_discovery_link_tag(nil, {}, {:type => "text/html"})) => %(<link href="http://www.example.com" rel="alternate" title="" type="text/html" />),
%(javascript_path("xmlhr")) => %(/javascripts/xmlhr.js),
%(javascript_path("super/xmlhr")) => %(/javascripts/super/xmlhr.js),
%(javascript_path("/super/xmlhr.js")) => %(/super/xmlhr.js),
%(javascript_path("xmlhr.min")) => %(/javascripts/xmlhr.min.js),
%(javascript_path("xmlhr.min.js")) => %(/javascripts/xmlhr.min.js),
%(javascript_path("xmlhr.js?123")) => %(/javascripts/xmlhr.js?123),
%(javascript_path("xmlhr.js?body=1")) => %(/javascripts/xmlhr.js?body=1),
%(javascript_path("xmlhr.js#hash")) => %(/javascripts/xmlhr.js#hash),
%(javascript_path("xmlhr.js?123#hash")) => %(/javascripts/xmlhr.js?123#hash)
%(path_to_javascript("xmlhr")) => %(/javascripts/xmlhr.js),
%(path_to_javascript("super/xmlhr")) => %(/javascripts/super/xmlhr.js),
%(path_to_javascript("/super/xmlhr.js")) => %(/super/xmlhr.js)
%(javascript_url("xmlhr")) => %(http://www.example.com/javascripts/xmlhr.js),
%(javascript_url("/super/xmlhr.js")) => %(http://www.example.com/super/xmlhr.js)
%(url_to_javascript("xmlhr")) => %(http://www.example.com/javascripts/xmlhr.js),
%(url_to_javascript("/super/xmlhr.js")) => %(http://www.example.com/super/xmlhr.js)
%(javascript_include_tag("bank")) => %(<script src="/javascripts/bank.js" ></script>),
%(javascript_include_tag("bank.js")) => %(<script src="/javascripts/bank.js" ></script>),
%(javascript_include_tag("bank", :lang => "vbscript")) => %(<script lang="vbscript" src="/javascripts/bank.js" ></script>),
%(javascript_include_tag("bank", :host => "assets.example.com")) => %(<script src="http://assets.example.com/javascripts/bank.js"></script>),
%(javascript_include_tag("http://example.com/all")) => %(<script src="http://example.com/all"></script>),
%(javascript_include_tag("http://example.com/all.js")) => %(<script src="http://example.com/all.js"></script>),
%(javascript_include_tag("//example.com/all.js")) => %(<script src="//example.com/all.js"></script>),
%(stylesheet_path("bank")) => %(/stylesheets/bank.css),
%(stylesheet_path("bank.css")) => %(/stylesheets/bank.css),
%(stylesheet_path('/subdir/subdir.css')) => %(/subdir/subdir.css),
%(stylesheet_path("style.min")) => %(/stylesheets/style.min.css),
%(stylesheet_path("style.min.css")) => %(/stylesheets/style.min.css)
%(path_to_stylesheet("style")) => %(/stylesheets/style.css),
%(path_to_stylesheet("style.css")) => %(/stylesheets/style.css),
%(path_to_stylesheet('dir/file')) => %(/stylesheets/dir/file.css),
%(path_to_stylesheet('/dir/file.rcss', :extname => false)) => %(/dir/file.rcss),
%(path_to_stylesheet('/dir/file', :extname => '.rcss')) => %(/dir/file.rcss)
%(stylesheet_url("bank")) => %(http://www.example.com/stylesheets/bank.css),
%(stylesheet_url("bank.css")) => %(http://www.example.com/stylesheets/bank.css),
%(stylesheet_url('/subdir/subdir.css')) => %(http://www.example.com/subdir/subdir.css)
%(url_to_stylesheet("style")) => %(http://www.example.com/stylesheets/style.css),
%(url_to_stylesheet("style.css")) => %(http://www.example.com/stylesheets/style.css),
%(url_to_stylesheet('dir/file')) => %(http://www.example.com/stylesheets/dir/file.css),
%(url_to_stylesheet('/dir/file.rcss', :extname => false)) => %(http://www.example.com/dir/file.rcss),
%(url_to_stylesheet('/dir/file', :extname => '.rcss')) => %(http://www.example.com/dir/file.rcss)
%(stylesheet_link_tag("bank")) => %(<link href="/stylesheets/bank.css" rel="stylesheet" />),
%(stylesheet_link_tag("bank.css")) => %(<link href="/stylesheets/bank.css" rel="stylesheet" />),
%(stylesheet_link_tag("/elsewhere/file")) => %(<link href="/elsewhere/file.css" rel="stylesheet" />),
%(stylesheet_link_tag("subdir/subdir")) => %(<link href="/stylesheets/subdir/subdir.css" rel="stylesheet" />),
%(stylesheet_link_tag("bank", :media => "all")) => %(<link href="/stylesheets/bank.css" media="all" rel="stylesheet" />),
%(stylesheet_link_tag("bank", :host => "assets.example.com")) => %(<link href="http://assets.example.com/stylesheets/bank.css" rel="stylesheet" />),
%(stylesheet_link_tag("http://www.example.com/styles/style")) => %(<link href="http://www.example.com/styles/style" rel="stylesheet" />),
%(stylesheet_link_tag("http://www.example.com/styles/style.css")) => %(<link href="http://www.example.com/styles/style.css" rel="stylesheet" />),
%(stylesheet_link_tag("//www.example.com/styles/style.css")) => %(<link href="//www.example.com/styles/style.css" rel="stylesheet" />),
%(image_path("/dir/xml.png")) => %(/dir/xml.png)
%(path_to_image("/dir/xml.png")) => %(/dir/xml.png)
%(image_url("/dir/xml.png")) => %(http://www.example.com/dir/xml.png)
%(url_to_image("/dir/xml.png")) => %(http://www.example.com/dir/xml.png)
%(image_tag("xml.png")) => %(<img src="/images/xml.png" />),
%(image_tag("rss.gif", :alt => "RSS syndication")) => %(<img alt="RSS syndication" src="/images/rss.gif" />),
%(image_tag("gold.png", :size => "20")) => %(<img height="20" src="/images/gold.png" width="20" />),
%(image_tag("gold.png", :size => 20)) => %(<img height="20" src="/images/gold.png" width="20" />),
%(image_tag("silver.png", :size => "90.9")) => %(<img height="90.9" src="/images/silver.png" width="90.9" />),
%(image_tag("silver.png", :size => 90.9)) => %(<img height="90.9" src="/images/silver.png" width="90.9" />),
%(image_tag("gold.png", :size => "45x70")) => %(<img height="70" src="/images/gold.png" width="45" />),
%(image_tag("gold.png", "size" => "45x70")) => %(<img height="70" src="/images/gold.png" width="45" />),
%(image_tag("silver.png", :size => "67.12x74.09")) => %(<img height="74.09" src="/images/silver.png" width="67.12" />),
%(image_tag("silver.png", "size" => "67.12x74.09")) => %(<img height="74.09" src="/images/silver.png" width="67.12" />),
%(image_tag("bronze.png", :size => "10x15.7")) => %(<img height="15.7" src="/images/bronze.png" width="10" />),
%(image_tag("bronze.png", "size" => "10x15.7")) => %(<img height="15.7" src="/images/bronze.png" width="10" />),
%(image_tag("platinum.png", :size => "4.9x20")) => %(<img height="20" src="/images/platinum.png" width="4.9" />),
%(image_tag("platinum.png", "size" => "4.9x20")) => %(<img height="20" src="/images/platinum.png" width="4.9" />),
%(image_tag("error.png", "size" => "45 x 70")) => %(<img src="/images/error.png" />),
%(image_tag("error.png", "size" => "1,024x768")) => %(<img src="/images/error.png" />),
%(image_tag("error.png", "size" => "768x1,024")) => %(<img src="/images/error.png" />),
%(image_tag("error.png", "size" => "x")) => %(<img src="/images/error.png" />),
%(image_tag("google.com.png")) => %(<img src="/images/google.com.png" />),
%(image_tag("slash..png")) => %(<img src="/images/slash..png" />),
%(image_tag(".pdf.png")) => %(<img src="/images/.pdf.png" />),
%(image_tag("http://www.rubyonrails.com/images/rails.png")) => %(<img src="http://www.rubyonrails.com/images/rails.png" />),
%(image_tag("//www.rubyonrails.com/images/rails.png")) => %(<img src="//www.rubyonrails.com/images/rails.png" />),
%(image_tag("mouse.png", :alt => nil)) => %(<img src="/images/mouse.png" />),
%(image_tag("")) => %(<img src="" />),
%(image_tag("gold.png", data: { title: 'Rails Application' })) => %(<img data-title="Rails Application" src="/images/gold.png" />),
%(favicon_link_tag) => %(<link href="/images/favicon.ico" rel="icon" type="image/x-icon" />),
%(favicon_link_tag 'favicon.ico') => %(<link href="/images/favicon.ico" rel="icon" type="image/x-icon" />),
%(favicon_link_tag 'favicon.ico', :rel => 'foo') => %(<link href="/images/favicon.ico" rel="foo" type="image/x-icon" />),
%(favicon_link_tag 'favicon.ico', :rel => 'foo', :type => 'bar') => %(<link href="/images/favicon.ico" rel="foo" type="bar" />),
%(preload_link_tag '/application.js', type: 'module') => %(<link rel="modulepreload" href="/application.js" as="script" type="module" >),
%(preload_link_tag '/styles/custom_theme.css') => %(<link rel="preload" href="/styles/custom_theme.css" as="style" type="text/css" />),
%(preload_link_tag '/videos/video.webm') => %(<link rel="preload" href="/videos/video.webm" as="video" type="video/webm" />),
%(preload_link_tag '/posts.json', as: 'fetch') => %(<link rel="preload" href="/posts.json" as="fetch" type="application/json" />),
%(preload_link_tag '/users', as: 'fetch', type: 'application/json') => %(<link rel="preload" href="/users" as="fetch" type="application/json" />),
%(preload_link_tag '//example.com/font.woff2') => %(<link rel="preload" href="//example.com/font.woff2" as="font" type="font/woff2" crossorigin="anonymous"/>),
%(preload_link_tag '/media/audio.ogg', nopush: true) => %(<link rel="preload" href="/media/audio.ogg" as="audio" type="audio/ogg" />),
%(preload_link_tag '/sprite.svg') => %(<link rel="preload" href="/sprite.svg" as="image" type="image/svg+xml">),
%(preload_link_tag '/mb-icon.png') => %(<link rel="preload" href="/mb-icon.png" as="image" type="image/png">)
%(video_path("/dir/xml.ogg")) => %(/dir/xml.ogg)
%(path_to_video("/dir/xml.ogg")) => %(/dir/xml.ogg)
%(video_url("/dir/xml.ogg")) => %(http://www.example.com/dir/xml.ogg)
%(url_to_video("/dir/xml.ogg")) => %(http://www.example.com/dir/xml.ogg)
%(video_tag("xml.ogg")) => %(<video src="/videos/xml.ogg"></video>),
%(video_tag("rss.m4v", :autoplay => true, :controls => true)) => %(<video autoplay="autoplay" controls="controls" src="/videos/rss.m4v"></video>),
%(video_tag("rss.m4v", :preload => 'none')) => %(<video preload="none" src="/videos/rss.m4v"></video>),
%(video_tag("gold.m4v", :size => "160x120")) => %(<video height="120" src="/videos/gold.m4v" width="160"></video>),
%(video_tag("gold.m4v", "size" => "320x240")) => %(<video height="240" src="/videos/gold.m4v" width="320"></video>),
%(video_tag("silver.m4v", :size => "100.3x200.6")) => %(<video height="200.6" src="/videos/silver.m4v" width="100.3"></video>),
%(video_tag("silver.m4v", "size" => "100.3x200.6")) => %(<video height="200.6" src="/videos/silver.m4v" width="100.3"></video>),
%(video_tag("bronze.m4v", :size => "50x12.7")) => %(<video height="12.7" src="/videos/bronze.m4v" width="50"></video>),
%(video_tag("bronze.m4v", "size" => "50x12.7")) => %(<video height="12.7" src="/videos/bronze.m4v" width="50"></video>),
%(video_tag("platinum.m4v", :size => "10.1x24")) => %(<video height="24" src="/videos/platinum.m4v" width="10.1"></video>),
%(video_tag("platinum.m4v", "size" => "10.1x24")) => %(<video height="24" src="/videos/platinum.m4v" width="10.1"></video>),
%(video_tag("trailer.ogg", :poster => "screenshot.png")) => %(<video poster="/images/screenshot.png" src="/videos/trailer.ogg"></video>),
%(video_tag("error.avi", "size" => "100")) => %(<video height="100" src="/videos/error.avi" width="100"></video>),
%(video_tag("error.avi", "size" => 100)) => %(<video height="100" src="/videos/error.avi" width="100"></video>),
%(video_tag("error.avi", "size" => "100 x 100")) => %(<video src="/videos/error.avi"></video>),
%(video_tag("error.avi", "size" => "1,024x768")) => %(<video src="/videos/error.avi"></video>),
%(video_tag("error.avi", "size" => "768x1,024")) => %(<video src="/videos/error.avi"></video>),
%(video_tag("error.avi", "size" => "x")) => %(<video src="/videos/error.avi"></video>),
%(video_tag("http://media.rubyonrails.org/video/rails_blog_2.mov")) => %(<video src="http://media.rubyonrails.org/video/rails_blog_2.mov"></video>),
%(video_tag("//media.rubyonrails.org/video/rails_blog_2.mov")) => %(<video src="//media.rubyonrails.org/video/rails_blog_2.mov"></video>),
%(video_tag("multiple.ogg", "multiple.avi")) => %(<video><source src="/videos/multiple.ogg" /><source src="/videos/multiple.avi" /></video>),
%(audio_path("/dir/xml.wav")) => %(/dir/xml.wav)
%(path_to_audio("/dir/xml.wav")) => %(/dir/xml.wav)
%(audio_url("/dir/xml.wav")) => %(http://www.example.com/dir/xml.wav)
%(url_to_audio("/dir/xml.wav")) => %(http://www.example.com/dir/xml.wav)
%(audio_tag("xml.wav")) => %(<audio src="/audios/xml.wav"></audio>),
%(audio_tag("rss.wav", :autoplay => true, :controls => true)) => %(<audio autoplay="autoplay" controls="controls" src="/audios/rss.wav"></audio>),
%(audio_tag("http://media.rubyonrails.org/audio/rails_blog_2.mov")) => %(<audio src="http://media.rubyonrails.org/audio/rails_blog_2.mov"></audio>),
%(audio_tag("//media.rubyonrails.org/audio/rails_blog_2.mov")) => %(<audio src="//media.rubyonrails.org/audio/rails_blog_2.mov"></audio>),
%(audio_tag("audio.mp3", "audio.ogg")) => %(<audio><source src="/audios/audio.mp3" /><source src="/audios/audio.ogg" /></audio>),
%(font_path("font.eot")) => %(/fonts/font.eot),
%(font_path("font.eot#iefix")) => %(/fonts/font.eot#iefix),
%(font_path("font.woff")) => %(/fonts/font.woff),
%(font_path("font.ttf")) => %(/fonts/font.ttf),
%(font_path("font.ttf?123")) => %(/fonts/font.ttf?123)
%(font_url("font.eot")) => %(http://www.example.com/fonts/font.eot),
%(font_url("font.eot#iefix")) => %(http://www.example.com/fonts/font.eot#iefix),
%(font_url("font.woff")) => %(http://www.example.com/fonts/font.woff),
%(font_url("font.ttf")) => %(http://www.example.com/fonts/font.ttf),
%(font_url("font.ttf?123")) => %(http://www.example.com/fonts/font.ttf?123),
%(font_url("font.ttf", host: "http://assets.example.com")) => %(http://assets.example.com/fonts/font.ttf)
%(url_to_font("font.eot")) => %(http://www.example.com/fonts/font.eot),
%(url_to_font("font.eot#iefix")) => %(http://www.example.com/fonts/font.eot#iefix),
%(url_to_font("font.woff")) => %(http://www.example.com/fonts/font.woff),
%(url_to_font("font.ttf")) => %(http://www.example.com/fonts/font.ttf),
%(url_to_font("font.ttf?123")) => %(http://www.example.com/fonts/font.ttf?123),
%(url_to_font("font.ttf", host: "http://assets.example.com")) => %(http://assets.example.com/fonts/font.ttf)
expected = %(<link href="/feed.xml" rel="alternate" title="XML" type="application/xml" />)
assert_dom_equal("http://host/foo", asset_path("foo"))
%(<link rel="stylesheet" href="/stylesheets/foo.css" />),
assert_dom_equal %(<link href="/file.css" media="&lt;script&gt;" rel="stylesheet" />), stylesheet_link_tag("/file", media: "<script>")
assert_dom_equal %(<link href="/file.css" media="screen" rel="stylesheet" />), stylesheet_link_tag("/file")
assert_dom_equal %(<link href="/file.css" media="all" rel="stylesheet" />), stylesheet_link_tag("/file", media: "all")
100.times do |i|
options = { size: "16x10" }
assert_equal({ size: "16x10" }, options)
image_tag("gold.png", height: "100", width: "200", size: "45x70")
assert_dom_equal %(<img src="" loading="lazy" />), image_tag("")
assert_dom_equal %(<img src="" loading="eager" />), image_tag("", loading: "eager")
assert_dom_equal %(<img src="" decoding="async" />), image_tag("")
assert_dom_equal %(<img src="" decoding="sync" />), image_tag("", decoding: "sync")
options = { autoplay: true }
def to_s; "no-image-yet.png"; end
end.new("gopher://", "gopher://www.example.com")
assert_equal "/foo", @module.asset_path("foo")
assert_equal "/foo", @module.asset_url("foo")
Struct.new(:base_url, :script_name).new("http://www.example.com", nil)
@post.errors.add(:body, "foo")
@post.errors.add(:updated_at, "bar")
text_field("post", "author_name")
time_select("post", "updated_at", minute_step: 60)
%(<div class="field_with_errors"><label for="post_body">Body</label></div>),
label("post", "body")
check_box("post", "published")
check_box("post", "published") + check_box("post", "published")
radio_button("post", "category", "rails")
radio_button("post", "category", "rails") + radio_button("post", "category", "java")
Customer = Struct.new(:name, :id) do
def to_js(options = {})
Post = Struct.new(:title, :author_name, :body, :secret, :persisted, :written_on, :cost) do
def initialize(id = nil, post_id = nil); @id, @post_id = id, post_id end
def save; @id = 1; @post_id = 1 end
def to_param; @id && @id.to_s; end
@id.nil? ? "new #{self.class.name.downcase}" : "#{self.class.name.downcase} ##{@id}"
def initialize(id = nil, comment_id = nil); @id, @comment_id = id, comment_id end
def save; @id = 1; @comment_id = 1 end
def initialize(id = nil, tag_id = nil); @id, @tag_id = id, tag_id end
def save; @id = 1; @tag_id = 1 end
Post = Struct.new(:title, :id) do
a = Array.new(2) { |id| Comment.new(id + 1) }
belongs_to :topic, -> { includes(:replies) }
has_and_belongs_to_many :developers, -> { uniq }
def bare_a() end
errors.add("rating", "rating should not be 2") if rating == 2
@buffer << "<script>alert('pwned!')</script>"
assert_equal "&lt;script&gt;alert(&#39;pwned!&#39;)&lt;/script&gt;", output
@buffer.safe_append = "<p>This is fine</p>"
assert_equal "<p>This is fine</p>", output
raw_buffer << "<script>alert('pwned!')</script>"
@buffer << "George!"
@buffer << " World!"
raw_buffer << "George!"
copy << " World!"
@raw_buffer = +""
Game = Struct.new(:name, :id) do
Routes.draw { }
@task = Task.new
@step = Step.new
@bid = Bid.new
@tax = Tax.new
@fax = Fax.new
assert_url "http://example.com/posts/#{@blog_post.id}", @blog_post
assert_url "http://example.com/blogs/#{@blog_blog.id}", @blog_blog
define_method("projects_url") { |*args|
define_method("projects_path") { |*args|
assert_url "http://example.com/taxes/#{@tax.id}", @tax
assert_equal url.delete_prefix("http://#{host}"), url_for(args)
@category = Category.new("1")
@product = Product.new("3")
assert_includes first_req.last, %(WHERE "replies"."topic_id" IN (?, ?, ?))
assert_includes second_req.last, %(WHERE "replies"."topic_id" = ?)
assert_includes second_req.last, %(WHERE "replies"."topic_id" IN (?, ?, ?))
@project.name = "project #321"
def whole_form(action = "/", id = nil, html_class = nil, options = nil)
obj = -> { }
render inline: "<%= Project.all %>"
redirect_to "/"
PATH_TO_AR = File.expand_path("../../activerecord/lib", __dir__)
defaults = { database: ":memory:" }
File.read(File.expand_path("fixtures/db_definitions/sqlite.sql", __dir__)).split(";").each do |sql|
Dir.glob(File.expand_path("fixtures/*.rb", __dir__)).each { |f| require f }
array.map { |x| File.expand_path(x.to_s) }
@path_set = path_set
Question = Struct.new(:name, :id) do
render file: File.expand_path("../../fixtures/actionpack/hello.html", __dir__)
@person = "david"
render plain: "hello #{@person}"
@variable_for_layout = ", I am here!"
@secret = "in the sauce"
render file: Pathname.new(__dir__).join("..", "..", "fixtures", "test", "dot.directory", "render_template_with_ivar.erb")
@path = File.expand_path("../../fixtures/test/render_template_with_ivar.erb", __dir__)
render inline: "Hello: <%= request.host %>"
render inline: "<%= logger.class %>"
render inline: "<%= action_name %>"
render inline: "<%= controller_name %>"
@name = "David"
render plain: " "
render inline: "<%= 'Goodbye, ' + local_name %>",
locals: { local_name: name }
@before = "i'm before the render"
@after = "i'm after the render"
render plain: "Hi web users! #{@stuff}"
render_to_string inline: "<%= 'dlrow olleh'.reverse %>"
render inline: "<%= @hello %>", assigns: { hello: "world" }
locals: { greeting: "Bonjour" }
render partial: "hash_object", object: { first_name: "Sam" }
(request.xhr? ? "layouts/xhr" : "layouts/standard")
get :"hyphen-ated", to: "test#hyphen-ated"
get :clone, to: "test#clone"
assert(line =~ %r{:(\d+):})
assert_equal "1", $1,
assert_equal "{{hello world, I am here!}}\n", @response.body
assert_equal "The secret is <%= @secret %>\n", @response.body
assert_equal "The secret is &lt;%= @secret %&gt;\n", @response.body
assert_equal "<p>This is grand!</p>\n", @response.body
assert_equal "The value of foo is: ::this is a test::\n", @response.body
<div class="errors"><label for="post_title">Title</label></div>
render inline: <<~ERB, locals: { html_tag: html_tag, instance: instance }
assert_includes @response.body, "<!-- END"
get :hello, to: "views#hello"
layout proc { nil }
layout "item", only: "hello"
@title = nil
@todo = "some todo"
render inline: "With <%= :Inline %>"
render template: "some/template", locals: { foo: "less than 3" }
render inline: "Module <%= included_method %>"
render inline: "Hello <%= helpery_test %>"
render inline: "I respond to bare_a: <%= respond_to?(:bare_a) %>"
def render(options = {})
@my_ivar = "Hello"
def render_to_body(options = {})
action_name.to_s != "fail" && action_name
$:.unshift File.expand_path("lib", __dir__)
Dir.glob("#{helpers_dir}/**/*_helper.rb") do |helper_file|
@view ||= begin
def _prefixes # :nodoc:
@_prefixes ||= begin
@_lookup_context ||=
locals: locals.map(&:to_s)
super("")
@path = ""
@hash.keys.join(", ")
Module === constant && !(Class === constant)
_helpers_for_modification.module_eval <<~end_eval, __FILE__, __LINE__ + 1
ruby2_keywords(:'#{method}')
def new(*)
@rendered = +""
def render(options = {}, local_assigns = {}, &block)
def render(options = {}, local_assigns = {})
:@__io__,
:@_result,
:@_routes,
:@_request,
:@_config,
:@_layouts,
:@_files,
:@_partials,
:@passed,
:@request,
:@routes,
:@_templates,
:@options,
:@view,
:@view_flow,
if routes &&
routes &&
if nameidx = virtual.rindex("/")
prefix = ""
partial = name.start_with?("_")
def eql?(other) # :nodoc:
alias :== :eql? # :nodoc:
ANY_HASH = Hash.new(1).merge(nil => 0).freeze
if variants == :any
if type.is_a?(self)
def ==(type)
class Text # :nodoc:
(?:(?<prefix>.*)/)?
(?<partial>_)?
(?<action>.*?)
(?:\.(?<locale>#{locales}))??
(?:\.(?<format>#{formats}))??
(?:\+(?<variant>#{variants}))??
(?:\.(?<handler>#{handlers}))?
@path.to_s
alias :to_path :to_s
paths = template_glob("**/*")
if path.name.include?(".")
paths = template_glob("#{escape_entry(path.to_s)}*")
path_with_slash = File.join(@path, "")
extname = ::File.extname(filename).delete(".")
Finalizer = proc do |method_name, mod| # :nodoc:
class HTML # :nodoc:
ERB::Util.h(@string)
if text == "\n"
src << ".safe_append='"
src << "\n" * @newline_pending if @newline_pending > 0
if (indicator == "==") || @escape
src << ".safe_expr_append="
src << ".append="
src << " " << code
src << "(" << code << ")"
with_buffer { src << ".safe_append='#{"\n" * @newline_pending}" << @text_end }
encoding = $2
trim: (self.class.erb_trim_mode == "-")
tok_name, str = *tok
@required ||= begin
@@template_handlers = {}
@results.map(&:path)
@results.sort_by!(&:score)
@cause = $!
@sub_templates.collect(&:inspect).join(", ")
num = num.to_i
source_code = @template.encode!.split("\n")
@line_number ||=
regexp = /#{Regexp.escape File.basename(file_name)}:(\d+)/
$1 if message =~ regexp || backtrace.find { |line| line =~ regexp }
indent_template = "%#{indent}s: %s"
@offending_code_string.split("\n").map.with_index(1) { |line, index|
indentation = " " * 4
base = @virtual_path.end_with?("/") ? "" : ::File.basename(@virtual_path)
base =~ /\A_?(.*?)(?:\.\w+)*\z/
$1.to_sym
node = find_node_by_id(ast, node_id)
@strict_locals = $1
@strict_locals = "**nil" if @strict_locals.blank?
@method_name ||= begin
m = +"_#{identifier_method_name}__#{@identifier.hash}_#{__id__}"
m.tr!("-", "_")
source = +<<-end_src
@virtual_path = #{@virtual_path.inspect};#{locals_code};#{code}
short_identifier.tr("^a-z_", "_")
method = _generate_paths_by_default ? :path : :url
class Node < ::Array # :nodoc:
def initialize(type, arr, opts = {})
typeinfo = type && type != :list ? ":" + type.to_s + ", " : ""
type == :command || type == :fcall
fcall? &&
type == :var_ref
type == :vcall
type == :call
type == :bare_assoc_hash || type == :hash
type == :@label || type == :symbol_literal
raise "not a symbol?: #{self.inspect}"
if arity == 0 && event.to_s.end_with?("_new")
module_eval(<<-eof, __FILE__, __LINE__ + 1)
def on_#{event}(*args)
Node.new(:list, args, lineno: lineno(), column: column())
elsif event.to_s.match?(/_add(_.+)?\z/)
def on_#{event}(list, item)
Node.new(:#{event}, args, lineno: lineno(), column: column())
def on_#{event}(tok)
class I18nProxy < ::I18n::Config # :nodoc:
def process(...) # :nodoc:
def _normalize_args(action = nil, options = {})
key = action.include?(?/) ? :template : :action
template.render(view, locals) { |*name| view._layout_for(*name) }
layout.render(view, locals) { |*name| view._layout_for(*name) }
if layout.start_with?("/")
class Body # :nodoc:
message = +"\n#{exception.class} (#{exception.message}):\n"
logger.fatal("#{message}\n\n")
def render_template(view, template, layout_name = nil, locals = {}) # :nodoc:
locals ||= {}
yielder = lambda { |*name| view._layout_for(*name) }
@cache_hits ||= {}
key.frozen? ? key.dup : key # #read_multi & #write may require mutability, Dalli 2.6.0.
) do |payload|
@index = 0
index == 0
index == size - 1
def iterate! # :nodoc:
@index += 1
@collection.each { |o| yield(o, variables) }
paths = collection.map { |o| partial_path(o, context) }
base = path.end_with?("/") ? "" : File.basename(path)
raise_invalid_identifier(path) unless base =~ /\A_?(.*?)(?:\.\w+)*\z/
if prefix.include?(?/) && object_path.include?(?/)
(prefixes << object_path).join("/")
@body = body
nodes.map { |n| send(:parse_render, n) }
if path.include?("/")
{ partial: string }
if node.length == 1
node.hash? && node.to_hash
dependency = node.variable_name.sub(/\A(?:\$|@{1,2})/, "")
if render_type != :layout && options_hash.key?(:layout)
if render_type == :partial || render_type == :layout
prefix ? "#{prefix}#{JOIN}#{singular}" : singular
key ? key.join(JOIN) : key
send "#{k}=", v
def +(array)
@view_paths_by_class = {}
value = value.present? ? Array(value) : default_#{name}
alias :eql? :equal?
old_value, @cache = @cache, false
def _set_detail(key, value) # :doc:
@detail_args_for_any ||= begin
details = {}
if k == :variants
idx = name.rindex("/")
name = name.from(idx + 1)
prefixes = prefixes.map { |p| "#{p}/#{path_prefix}" }
@cache = true
values << :html
@root = nil
string = string.sub(rails_root, "")
def rails_root # :doc:
@root ||= "#{Rails.root}/"
raise ArgumentError, "Your layout method :#{_layout} returned \#{layout}. It " \
result = _layout_from_proc(#{_layout.arity == 0 ? '' : 'self'})
def _layout(*); end
value.is_a?(String) && !value.match?(/\blayouts/) ? "layouts/#{value}" : value
def url_for(options = nil) # :nodoc:
def _back_url # :nodoc:
def link_to(name = nil, options = nil, html_options = nil, &block)
content_tag("a", name || url, html_options, &block)
def button_to(name = nil, options = nil, html_options = nil, &block)
html_options ||= {}
url =
form_options = html_options.delete("form") || {}
content_tag("button", name || url, html_options, &block)
def link_to_unless_current(name, options = {}, html_options = {}, &block)
def link_to_unless(condition, name, options = {}, html_options = {}, &block)
def link_to_if(condition, name, options = {}, html_options = {}, &block)
def mail_to(email_address, name = nil, html_options = {}, &block)
html_options, name = name, nil if name.is_a?(Hash)
html_options = (html_options || {}).stringify_keys
extras = %w{ cc bcc body subject reply_to }.map! { |item|
extras = extras.empty? ? "" : "?" + extras.join("&")
encoded_email_address = ERB::Util.url_encode(email_address).gsub("%40", "@")
if %r{^\w+://}.match?(url_string)
def current_page?(*args) # :nodoc:
options.is_a?(Hash) ? _current_page?(*args, **options) : _current_page?(*args, options)
def sms_to(phone_number, name = nil, html_options = {}, &block)
country_code = country_code ? "+#{ERB::Util.url_encode(country_code)}" : ""
body = body ? "?&body=#{ERB::Util.url_encode(body)}" : ""
content_tag("a", name || phone_number, html_options, &block)
def phone_to(phone_number, name = nil, html_options = {}, &block)
country_code = country_code.nil? ? "" : "+#{ERB::Util.url_encode(country_code)}"
link_to_remote_options?(options) ? { "data-remote" => "true" } : {}
if name.respond_to?(:model_name) && options.is_a?(Hash) && options.empty?
def token_tag(token = nil, form_options: {})
if token == true || token.nil?
tag("input", type: "hidden", name: "_method", value: method.to_s, autocomplete: "off")
trailing_index = (url_string.index("?") || 0) - 1
return key.map { |k| translate(k, **options) } if key.is_a?(Array)
key = key&.to_s unless key.is_a?(Symbol)
first_key ||= key
if key.nil? && !first_key.nil?
if key&.start_with?(".")
@_scope_key_by_partial_cache ||= {}
title = +"translation missing: #{keys.join(".")}"
title << ", " << name.to_s << ": " << ERB::Util.html_escape(value)
def truncate(text, options = {}, &block)
def highlight(text, phrases, options = {}, &block)
text || ""
patterns = Array(phrases).map { |phrase| Regexp === phrase ? phrase : Regexp.escape(phrase) }
pattern = /(#{patterns.join("|")})/i
if !segment.start_with?("<")
def excerpt(text, phrase, options = {})
separator = options.fetch(:separator, nil) || ""
regex = /#{Regexp.escape(phrase)}/i
word = if count == 1 || count.to_s.match?(/^1(\.0+)?$/)
def simple_format(text, html_options = {}, options = {})
}.join("\n\n").html_safe
(@index + n) % @values.size
text.to_str.gsub(/\r\n?/, "\n").split(/\n\n+/).map! do |t|
return "", "" unless part
omission = options.fetch(:omission, "...")
if separator != ""
part.delete("")
affix = part.length > radius ? omission : ""
part =
value&.strftime("%Y-W%V")
@model = object.respond_to?(:to_model) ? object.to_model : nil
value&.strftime("%T.%L")
value&.strftime("%H:%M")
@field_type ||= name.split("::").last.sub("Field", "").downcase
class Select < Base # :nodoc:
@choices = block_given? ? template_object.capture { yield || "" } : choices
@choices = @choices.to_a if @choices.is_a?(Range)
selected: @options.fetch(:selected) { value.nil? ? "" : value },
!@choices.blank? && @choices.first.respond_to?(:second) && Array === @choices.first.second
value.to_s == @tag_value.to_s
method_and_value = tag_value.is_a?(TrueClass) ? @method_name : "#{@method_name}.#{tag_value}"
@options = { value: nil }.merge!(@options)
if range = options.delete("in") || options.delete("within")
options.update("min" => range.min, "max" => range.max)
value&.strftime("%Y-%m")
class Label < Base # :nodoc:
method_and_value = @tag_value.present? ? "#{@method_name}.#{@tag_value}" : @method_name
@field_type ||= "datetime-local"
value&.strftime("%Y-%m-%dT%T")
value&.strftime("%Y-%m-%dT%H:%M")
@select_type ||= name.split("::").last.sub("Select", "").downcase
@auto_index ||= nil
value&.strftime("%Y-%m-%d")
@text = text
def label(label_html_options = {}, &block)
checked == true || checked == "checked"
value == !!@checked_value
value.to_i == @checked_value.to_i
class Base # :nodoc:
method_name = "#{@method_name}_came_from_user?"
def tag_id(index = nil, namespace = nil)
value = options.fetch(:selected) { value() }
label = (" " unless content)
option_tags = tag_builder.content_tag_string("option", content, value: "", label: label) + "\n" + option_tags
tag_options = { value: "" }.tap do |prompt_opts|
options.delete("index") || ""
@auto_index || ""
def p(*arguments, **options, &block)
tag_string(:p, *arguments, **options, &block)
if type == :data && value.is_a?(Hash)
value.each_pair do |k, v|
output << sep
output << prefix_tag_option(key, k, v, escape)
elsif type == :aria && value.is_a?(Hash)
v = safe_join(tokens, " ")
v = v.to_s
%(#{key}="#{key}")
value = escape ? safe_join(value, " ") : value.join(" ")
value = value.gsub('"', "&quot;") if value.include?('"')
%(#{key}="#{value}")
key = "#{prefix}-#{key.to_s.dasherize}"
unless value.is_a?(String) || value.is_a?(Symbol) || value.is_a?(BigDecimal)
def tag(name = nil, options = nil, open = false, escape = true)
tokens = build_tag_values(*args).flat_map { |value| CGI.unescape_html(value.to_s).split(/\s+/) }.uniq
safe_join(tokens, " ")
tag_values << key.to_s if val && key.present?
def sanitize(html, options = {})
def render(options = {}, locals = {}, &block)
def _layout_for(*args, &block)
if block && !name.is_a?(Symbol)
def safe_join(array, sep = $,)
def to_sentence(array, options = {})
def form_tag(url_for_options = {}, options = {}, &block)
def select_tag(name, option_tags = nil, options = {})
option_tags ||= ""
options_for_blank_options_tag = { value: "" }
include_blank = ""
content_tag "select", option_tags, { "name" => html_name, "id" => sanitize_to_id(name) }.update(options.stringify_keys)
def text_field_tag(name, value = nil, options = {})
tag :input, { "type" => "text", "name" => name, "id" => sanitize_to_id(name), "value" => value }.update(options.stringify_keys)
def hidden_field_tag(name, value = nil, options = {})
def file_field_tag(name, options = {})
def password_field_tag(name = "password", value = nil, options = {})
def text_area_tag(name, content = nil, options = {})
escape = options.delete("escape") { true }
content_tag :textarea, content.to_s.html_safe, { "name" => name, "id" => sanitize_to_id(name) }.update(options)
if args.length >= 4
html_options = { "type" => "checkbox", "name" => name, "id" => sanitize_to_id(name), "value" => value }.update(options.stringify_keys)
if args.length >= 3
def submit_tag(value = "Save changes", options = {})
tag_options = { "type" => "submit", "name" => "commit", "value" => value }.update(options)
options = { "name" => "button", "type" => "submit" }.merge!(options.stringify_keys)
tag :input, { "type" => "image", "src" => src }.update(options)
def color_field_tag(name, value = nil, options = {})
def search_field_tag(name, value = nil, options = {})
def telephone_field_tag(name, value = nil, options = {})
def date_field_tag(name, value = nil, options = {})
def time_field_tag(name, value = nil, options = {})
def datetime_field_tag(name, value = nil, options = {})
def month_field_tag(name, value = nil, options = {})
def week_field_tag(name, value = nil, options = {})
def url_field_tag(name, value = nil, options = {})
def email_field_tag(name, value = nil, options = {})
def number_field_tag(name, value = nil, options = {})
def range_field_tag(name, value = nil, options = {})
method_tag = \
when "get"
when "post", ""
html = tag(:form, html_options, true) + extra_tags
output.safe_concat("</form>")
data = tag_options.fetch("data", {})
tag_options.deep_merge!("data" => { "disable_with" => disable_with_text })
def select(object, method, choices = nil, options = {}, html_options = {}, &block)
def time_zone_select(object, method, priority_zones = nil, options = {}, html_options = {})
def weekday_select(object, method, options = {}, html_options = {}, &block)
Array(r).map(&:to_s)
end.join("\n").html_safe
body = "".html_safe
zone_options.safe_concat content_tag("option", "-------------", value: "", disabled: true)
if Array === element
element.select { |e| Hash === e }.reduce({}, :merge!)
if !option.is_a?(String) && option.respond_to?(:first) && option.respond_to?(:last)
option = option.reject { |e| Hash === e } if Array === option
def select(method, choices = nil, options = {}, html_options = {}, &block)
def time_zone_select(method, priority_zones = nil, options = {}, html_options = {})
def weekday_select(method, options = {}, html_options = {})
def form_for(record, options = {}, &block)
action = object.respond_to?(:persisted?) && object.persisted? ? :edit : :new
def form_with(model: nil, scope: nil, url: nil, format: nil, **options, &block)
if url != false
url ||= if format.nil?
def fields_for(record_name, record_object = nil, options = {}, &block)
def fields(scope = nil, model: nil, **options, &block)
def check_box(object_name, method, options = {}, checked_value = "1", unchecked_value = "0")
@_to_partial_path ||= name.demodulize.underscore.sub!(/_builder$/, "")
@nested_child_index = {}
object_name = @options.fetch(:as) { @object_name }
fields_options ||= {}
def label(method, text = nil, options = {}, &block)
def check_box(method, options = {}, checked_value = "1", unchecked_value = "0")
@emitted_hidden_id = true if method == :id
def file_field(method, options = {})
def submit(value = nil, options = {})
def button(value = nil, options = {}, &block)
value, options = nil, { name: field_name(value), id: field_id(value) }.merge!(options.to_h)
if formmethod.present? && !/post|get/i.match?(formmethod) && !options.key?(:name) && !options.key?(:value)
@emitted_hidden_id ||= nil
defaults << :"helpers.submit.#{object.model_name.i18n_key}.#{key}"
defaults << :"helpers.submit.#{object_name}.#{key}"
defaults << :"helpers.submit.#{key}"
defaults << "#{key.to_s.humanize} #{model}"
def distance_of_time_in_words(from_time, to_time = 0, options = {})
distance_in_minutes = ((to_time - from_time) / 60.0).round
when 0..1
locale.t(:less_than_x_minutes, count: 1) :
from_year += 1 if from_time.month >= 3
to_year -= 1 if to_time.month < 3
leap_years = (from_year > to_year) ? 0 : (from_year..to_year).count { |x| Date.leap?(x) }
def time_ago_in_words(from_time, options = {})
def date_select(object_name, method, options = {}, html_options = {})
def time_select(object_name, method, options = {}, html_options = {})
def datetime_select(object_name, method, options = {}, html_options = {})
def select_date(date = Date.current, options = {}, html_options = {})
def select_time(datetime = Time.current, options = {}, html_options = {})
def select_second(datetime, options = {}, html_options = {})
def select_minute(datetime, options = {}, html_options = {})
def select_hour(datetime, options = {}, html_options = {})
def select_day(date, options = {}, html_options = {})
def select_month(date, options = {}, html_options = {})
def select_year(date, options = {}, html_options = {})
year: 1, month: 2, day: 3, hour: 4, minute: 5, second: 6
def initialize(datetime, options = {}, html_options = {})
build_hidden(:day, day || 1)
build_hidden(:month, month || 1)
options = { value: month_number }
month_options << content_tag("option", month_name(month_number), options) + "\n"
if !year || @datetime == 0
val = "1"
%w( sec min hour day month year ).each do |method|
@month_names ||= begin
start.step(stop, step) do |i|
value = leading_zeros ? sprintf("%02d", i) : i
tag_options = { value: value }
(select_options.join("\n") + "\n").html_safe
(1..31).each do |value|
}.merge!(@html_options)
select_html = +"\n"
prompt = \
prompt ? content_tag("option", prompt_text(prompt, type), value: "") : ""
type: "hidden",
tag(:input, select_options) + "\n".html_safe
select = +""
select.insert(0, separator.to_s + public_send("select_#{type}").to_s)
when :year, :month, :day
def date_select(method, options = {}, html_options = {})
def time_select(method, options = {}, html_options = {})
def datetime_select(method, options = {}, html_options = {})
tag("meta", options)
@_request ||= nil
@_config ||= nil
@_default_form_builder ||= nil
buffer = @output_buffer.capture { value = yield(*args) }
def content_for(name, content = nil, options = {}, &block)
def with_output_buffer(buf = nil) # :nodoc:
def cache(name = {}, options = {}, &block)
def cache_if(condition, name = {}, options = {}, &block)
def cache_unless(condition, name = {}, options = {}, &block)
name = controller.url_for(name).split("://").last if name.is_a?(Hash)
def fragment_for(name = {}, options = nil, &block)
def atom_feed(options = {}, &block)
feed_opts.merge!(options).select! { |k, _| k.start_with?("xml") }
@xml = xml
@xml.__send__(method, *arguments) do
@xml.div(xmlns: "http://www.w3.org/1999/xhtml") do |xhtml|
@xml.__send__(method, *arguments, &block)
@xml, @view, @feed_options = xml, view, feed_options
def entry(record, options = {})
type = options.fetch(:type, "text/html")
@xml.link(rel: "alternate", type: type, href: url) if url
def asset_path(source, options = {})
source = "#{source}#{extname}"
def asset_url(source, options = {})
javascript: ".js",
def compute_asset_host(source = "", options = {})
args << request if request && (arity > 1 || arity < 0)
host = host.call(*args)
elsif host.include?("%d")
host = host % (Zlib.crc32(source) % 4)
def image_path(source, options = {})
path_to_asset(source, { type: :image }.merge!(options))
def image_url(source, options = {})
url_to_asset(source, { type: :image }.merge!(options))
def video_path(source, options = {})
path_to_asset(source, { type: :video }.merge!(options))
def video_url(source, options = {})
url_to_asset(source, { type: :video }.merge!(options))
def audio_path(source, options = {})
path_to_asset(source, { type: :audio }.merge!(options))
def audio_url(source, options = {})
url_to_asset(source, { type: :audio }.merge!(options))
def font_path(source, options = {})
path_to_asset(source, { type: :font }.merge!(options))
def font_url(source, options = {})
url_to_asset(source, { type: :font }.merge!(options))
preload_link = "<#{href}>; rel=#{rel}; as=script"
preload_link += "; nopush" if nopush
tag_options = {
content_tag("script", "", tag_options)
}.join("\n").html_safe
if preload_links_header && href.present? && !href.start_with?("data:")
preload_link = "<#{href}>; rel=preload; as=style"
def auto_discovery_link_tag(type = :rss, url_options = {}, tag_options = {})
def favicon_link_tag(source = "favicon.ico", options = {})
tag("link", {
rel: "icon",
type: "image/x-icon",
crossorigin = "anonymous" if crossorigin == true || (crossorigin.blank? && as_type == "font")
rel = mime_type == "module" ? "modulepreload" : "preload"
link_tag = tag.link(**{
rel: rel,
as: as_type,
preload_link = "<#{href}>; rel=#{rel}; as=#{as_type}"
preload_link += "; type=#{mime_type}" if mime_type
def image_tag(source, options = {})
tag("img", options)
if source.is_a?(Symbol) || source.is_a?(String)
size = size.to_s
if /\A\d+(?:\.\d+)?x\d+(?:\.\d+)?\z/.match?(size)
size.split("x")
elsif /\A\d+(?:\.\d+)?\z/.match?(size)
when "css" then "style"
when "vtt" then "track"
request.send_early_hints("Link" => preload_links.join("\n"))
header = header ? header.dup : +""
header << ","
last_line_size += 1
header << "\n"
def tag(type, options, *)
view = @view
cache_key = "#{name}.#{format}"
cache_key = "#{name}.#{format}.#{dependencies_suffix}"
def tree(name, finder, partial = false, seen = {})
logical_name = name.gsub(%r|/_|, "/")
interpolated = name.include?("#")
deps.uniq { |n| n.gsub(%r|/_|, "/") }.each do |dep_file|
end.join("-")
children.any? ? { name => children.map(&:to_dep_map) } : name
def self.debug(_); end
def self.error(_); end
next if render_call.end_with?("/_")
render_call.gsub(%r|/_|, "/")
/xm
if quote_type == '"'
name ||= :layout
_self = self
delegate :length, :empty?, :blank?, :encoding, :encode!, :force_encoding, to: :@raw_buffer
def <<(value)
alias :concat :<<
alias :append= :<<
@raw_buffer << value
@raw_buffer << val.to_s
new_buffer = +""
other.class == self.class && @raw_buffer == other.to_str
buffer = +""
old_block, @block = @block, ->(value) { buffer << value }
def xss_safe? # :nodoc:
def changed?(other) # :nodoc:
new_assigns.each { |key, value| instance_variable_set("@#{key}", value) }
gsub("unknown keyword:", "unknown local:").
gsub("missing keyword:", "missing local:").
formats << :html
I18n.load_path << File.expand_path("action_view/locale/en.yml", __dir__)
sgid: "123",
href: "http://example.com/",
node.inner_html = "How are you?"
message = Message.create!(subject: "Greetings", content: "<b>Hello!</b>")
Message.create!(subject: "Subject", content: "<h1>Content</h1>", body: "<h2>Body</h2>")
content = "<p>the space force is here, we are safe now!</p>"
html = "<div>test</div>"
html = "<div>a<br></div>"
html = '<a href="http://example.com/1">1</a><br><a href="http://example.com/1">1</a>'
html = %Q(<figure data-trix-attachment='{"sgid":"123","contentType":"text/plain","width":100,"height":100}' data-trix-attributes='{"caption":"Captioned"}'></figure>)
html = %Q(<div data-trix-attachment='{"sgid":"garbage...'></div>)
html = "<h1>Hello world</h1>"
<p>replace me</p>
<p>ignore me</p>
expected_html = <<~HTML
<p>replaced</p>
if node.text =~ /replace me/
key: "123",
byte_size: 4,
message: {
form_with url: "/messages", scope: :message do |form|
form.rich_text_area :content, { input: "trix_input_2" }
assert_select rendered, "img:match('src', ?)", %r"//foo.example.com:9001/.+/racecar"
assert_select content, "img:match('src', ?)", %r"//loocalhoost/.+/racecar"
t.text "body"
pin "trix"
File.write(file, <<~HTML)
Capybara.server = :puma, { Silent: true }
gem_root = "#{__dir__}/../../../.."
read_json_attribute(name) || {}
def _dump(*)
:"plain_text_for_#{node.name}_node"
text.chomp("")
if list_node_name_for_li_node(node) == "ol"
if depth > 1
Nokogiri::HTML::Document.new.tap { |doc| doc.encoding = "UTF-8" }
def initialize(content = nil, options = {})
rich_text_#{name} || build_rich_text_#{name}
def #{name}?
def #{name}=(body)
self.#{name}.body = body
has_one :"rich_text_#{name}", -> { where(name: name) },
scope :"with_rich_text_#{name}", -> { includes("rich_text_#{name}") }
scope :"with_rich_text_#{name}_and_embeds", -> { includes("rich_text_#{name}": { embeds_attachments: :blob }) }
reflect_on_all_associations(:has_one).collect(&:name).select { |n| n.start_with?("rich_text_") }
node.tap { |n| n.inner_html = "" }
/\A(\n|\ )*\z/.match?(child.text)
content_type.to_s.match?(/^image(\/.+|$)/)
try(:byte_size) || try(:filesize)
try(:metadata) || {}
delegate :to_s, :nil?, to: :body
delegate :blank?, :empty?, :present?, to: :to_plain_text
def rich_text_area_tag(name, value = nil, options = {})
editor_tag = content_tag("trix-editor", "", options)
def rich_text_area(method, options = {})
build_path(string, {}, "/.?", true)
x = Class.new {
def to_param; @id.to_s; end
mapper.get "/foo(/:id)", to: "foo#bar", as: "aaron"
mapper.get "/foo(/:id)", to: "foo#bar", as: "gorby"
mapper.get "/not_anchored/hello/:who-notanchored", to: "foo#bar", as: "bar", who: /\d/, anchor: false
mapper.get "/foo/:bar", to: "foo#bar", as: "aaron"
mapper.get "/hello", to: "foo#bar", as: "aaron"
mapper.get "/aaron", to: "foo#bar", as: "aaron"
get "/foo-bar-baz", to: "foo#bar"
env = rails_env "PATH_INFO" => "/foo-bar-baz"
get "/whois/:id(.:format)", to: "foo#baz"
env = rails_env "PATH_INFO" => "/whois/example.com"
list << r
get "/foo/:id", id: /\d/, anchor: false, to: "foo#bar"
@route_set.url_for({ controller: "foo", action: "bar", id: "10" }, nil)
get "/foo/:id", id: /\d+/, anchor: false, to: "foo#bar"
path, _ = _generate(nil, { controller: "foo", action: "bar", id: "10" }, {})
_generate(nil, { id: "aa" }, {})
get "/foo(/:id)", id: /\d/, to: "foo#bar"
path, _ = _generate(nil, { controller: "foo", action: "bar" }, {})
path, _ = _generate(nil, { controller: "foo", action: "bar", id: "aa" }, {})
get "/foo/:id", as: route_name, id: /\d+/, to: "foo#bar"
_generate(route_name, {}, {})
get "/messages(.:format)", to: "foo#bar"
get "/weblog", to: app
get "/foo(/:id)", to: "foo#bar", id: nil
env = rails_env "PATH_INFO" => "/foo/10"
assert_equal({ id: "10", controller: "foo", action: "bar" }, params)
assert_equal({ id: nil, controller: "foo", action: "bar" }, params)
get "/foo", anchor: false, to: "foo#bar"
env = rails_env "PATH_INFO" => "/foo/bar"
router.recognize(env) { |*_| }
get "/foo", to: "foo#bar"
get path, to: "foo#bar"
env = rails_env "PATH_INFO" => "/messages/unknown/path"
get "/messages/:a/:b", to: "foo#bar"
path, _ = _generate(nil, { controller: "foo", action: "bar", a: "a" }, { b: "b" })
get "/*path", to: "foo#bar"
path, _ = _generate(nil, { controller: "foo", action: "bar" }, { path: "b" })
assert_equal "/b", path
get "/messages/:action(/:id(.:format))", to: "foo#bar"
get "/messages/:id(.:format)", to: "bar#baz"
path, _ = _generate(nil, { controller: "foo", id: 10 }, { action: "index" })
get "/:controller(/:action(.:format))", to: "tasks#lol"
params = { controller: "tasks", format: nil }
extras = { action: "lol" }
path, _ = _generate(nil, params, extras)
assert_equal "/", path
get "/:controller(/:action)", to: "foo#bar"
nil, { id: 1, controller: "tasks", action: "show" }, {})
assert_equal({ id: "1" }, params)
path, _ = _generate(nil,
{ controller: "tasks",
action: "a/b c+d",
}, {})
path, _ = _generate(
nil, { controller: "admin/tasks",
nil, { id: 1,
action: "show",
get "/:controller/:action/:name", to: "foo#bar"
missing_key = "name"
missing_key => "task_1"
get "/:controller(/:action(/:id))", to: "foo#bar"
{ controller: "tasks", id: 10 },
{ action: "index" })
get "/:controller(/:action)", to: "foo#bar", as: "tasks"
{ controller: "tasks" },
{ controller: "tasks", action: "index" })
define_method("test_recognize_#{expected.keys.map(&:to_s).join('_')}") do
env = rails_env "PATH_INFO" => request_path
}.each do |name, (request_path, expected)|
get "/:segment/*splat", to: "foo#bar"
get "/:controller(/:action(/:id))", controller: /.+?/
env = rails_env "PATH_INFO" => "/admin/users/show/10"
id: "10"
get "/books(/:action(.:format))", controller: "books"
env = rails_env "PATH_INFO" => "/books/list.rss"
expected = { controller: "books", action: "list", format: "rss" }
match "/books(/:action(.:format))", via: "head", to: "foo#bar"
env = rails_env(
get "/books(/:action(.:format))", to: "foo#bar"
env = rails_env "PATH_INFO" => "/books/list.rss",
match "/books(/:action(.:format))", to: "foo#bar", via: :get
match "/books(/:action(.:format))", to: "foo#bar", via: :post
get "/foo-bar", to: "foo#bar"
assert_equal "a/b%20c+d%25", Utils.escape_path("a/b c+d%")
assert_equal "a%2Fb%20c+d%25", Utils.escape_segment("a/b c+d%")
assert_equal "a/b%20c+d%25?e", Utils.escape_fragment("a/b c+d%?e")
assert_equal "a/b c+d", Utils.unescape_uri("a%2Fb%20c+d")
path = "/foo%AAbar%AAbaz".b
defaults = {}
route = Route.new(name: "name", app: app, path: path)
defaults = { name: "tender" }
route = Route.new(name: "name", path: path, constraints: { ip: "192.168.1.1" },
defaults: { controller: "foo", action: "bar" })
route = Route.new(name: "name", path: path,
assert_equal(//, route.ip)
extra: "himom")
route = Route.new(name: "name", path: path, constraints: { action: "bar" },
defaults: { controller: "foo" })
action: "bar",
id: 10)
route = Route.new(name: "name", path: path, defaults: { action: "show" })
defaults = { controller: "pages", action: "show" }
path = path_from_string "/page/:id(/:action)(.:format)"
path = path_from_string "/:controller(/:action(/:id))(.:format)"
knowledge = { "id" => true, "controller" => true, "action" => true }
found = routes.sort_by { |r| r.score(knowledge) }.last
test "Scanning `#{pattern}`" do
assert_round_trip "(/:foo)"
assert_round_trip "(/:foo)(/:bar)"
assert_round_trip "(/:foo(/:bar))"
assert_round_trip("/foo.:bar")
assert_round_trip("/foo(.:bar)")
assert_round_trip("/foo(/:action)")
assert_round_trip("/foo(/:action)(/:bar)")
assert_round_trip("/foo(/:action(/:bar))")
assert_round_trip("/foo(/:action)/:bar")
assert_round_trip("/*foo")
assert_round_trip("/bar/*foo")
assert_round_trip("/bar/(*foo)")
assert_round_trip("a|b|c")
assert_round_trip("(a|b)|c")
assert_round_trip("a|(b|c)")
assert_round_trip("*a|(b|c)")
assert_round_trip("*a|:b|c")
assert_round_trip("/bar/*foo#")
assert_round_trip "/(:locale)(.:format)"
x = /.+/
}.each do |path, expected|
{ controller: /.+/ },
{ name: /
)/x },
{ name: /\d+/ },
assert_match(path, "/123")
assert_no_match(path, "/")
{ name: /(tender|love)/ },
{ name: /t(((ender|love)))()/ },
z = /\d+/
{ foo: z },
assert_equal(%r{\A/page/(#{z})\Z}, path.to_regexp)
{ name: /(tender|love)/i },
path = build_path("/:controller", {}, SEPARATORS, true)
path = path_from_string "/:controller(/:action(/:id))"
path = path_from_string "/:controller(/:action(/:id(.:format)))"
uri = "content"
uri = "/content"
match = path =~ uri
uri = "/content/list"
uri = "/content/list/10"
path = path_from_string "/books(/:action(.:format))"
uri = "/books"
uri = "/books/list"
uri = "/books/list.rss"
named_captures = { "action" => "list", "format" => "rss" }
name_regex = /test/
{ name: name_regex },
requirements = { name: /(tender|love)/, value: /./ }
path = "/page/:name/:value"
ast = Ast.new(tree, true)
tree = Journey::Parser.new.parse("/*glob")
tree = Journey::Parser.new.parse("/")
tree = Journey::Parser.new.parse("/:path/:symbol")
ast = Ast.new(tree, false)
ast = Ast.new(tree, nil)
table = tt %w{
/articles/:id(.:format)
if system("dot -V", 2 => File::NULL)
path_asts = asts %w{ /get /:method/foo }
memos = sim.memos "/get"
memos = sim.memos "/get/foo"
path_asts = asts %w{
paths.map { |x|
ast.each { |n| n.memo = ast }
new = table.move(state, sym, 0, sym.length)
/
memos = sim.memos "/test"
memos = sim.memos "/"
ast.each { |n| n.memo = memo }
@bar = bar
def me() "me too!" end
def me() "mine!" end
def foobar() "baz" end
def stratego() "Iz guuut!" end
redefine_method(:baz) { }
get "/foo", to: "my_route_generating#index", as: :foo
get "(/optional/:optional_id)/baz", to: "my_route_generating#index", as: :baz
assert_equal "/bar/foo", foo_path(script_name: "/bar")
get "/foo", headers: { "SCRIPT_NAME" => "/new", "action_dispatch.routes" => Routes }
get "/new/bar/foo", headers: { "SCRIPT_NAME" => "/new", "PATH_INFO" => "/bar/foo", "action_dispatch.routes" => Routes }
assert_equal "http://www.example.com/foo", foo_url(host: "httpz://www.example.com", protocol: "http://")
assert_equal "http://www.example.com/foo", foo_url(host: "www.example.com:80", protocol: "http://")
assert_equal "https://www.example.com/foo", foo_url(host: "www.example.com:443", protocol: "https://")
assert_equal "http://www.example.com:8080/foo", foo_url(host: "www.example.com:8080", protocol: "http://")
assert_equal "//www.example.com:8080/foo", foo_url(host: "www.example.com:8080", protocol: "//")
assert_equal "//www.example.com:80/foo", foo_url(host: "www.example.com:80", protocol: "//")
assert_equal "http://www.example.com:8080/foo", foo_url(host: "www.example.com", protocol: "http://", port: 8080)
assert_equal "//www.example.com:8080/foo", foo_url(host: "www.example.com", protocol: "//", port: 8080)
assert_equal "//www.example.com:80/foo", foo_url(host: "www.example.com", protocol: "//", port: 80)
assert_equal "http://www.example.com:8080/foo", foo_url(host: "www.example.com:8443", protocol: "http://", port: 8080)
assert_equal "//www.example.com:8080/foo", foo_url(host: "www.example.com:8443", protocol: "//", port: 8080)
assert_equal "//www.example.com:80/foo", foo_url(host: "www.example.com:443", protocol: "//", port: 80)
assert_equal "http://www.example.com/foo", foo_url(host: "www.example.com:8443", protocol: "http://", port: nil)
assert_equal "//www.example.com/foo", foo_url(host: "www.example.com:8443", protocol: "//", port: nil)
assert_equal "http://www.example.com/foo", foo_url(host: "www.example.com:8443", protocol: "http://", port: false)
assert_equal "//www.example.com/foo", foo_url(host: "www.example.com:8443", protocol: "//", port: false)
assert_equal "http://www.example.com/baz", baz_url("")
assert_equal "/bars/", bars_path(
assert_equal "/bars/?a=b", bars_path(
a: "b"
a: "b",
a: {},
file_str = "foo"
tf << "thunderhorse"
(0..599).each do |status|
response = ActionDispatch::TestResponse.create(200, { "Content-Type" => "application/json" }, '{ "foo": "fighters" }')
assert_equal({ "foo" => "fighters" }, response.parsed_body)
response = ActionDispatch::TestResponse.create(200, { "Content-Type" => "text/html" }, <<~HTML)
<html>
<head></head>
<body>
</body>
</html>
assert_equal "/", env.delete("PATH_INFO")
assert_cookies({ "user_name" => "david" }, req.cookie_jar)
assert_cookies({ "user_name" => "david", "login" => "XJ-122" }, req.cookie_jar)
assert_cookies({ "user_name" => "david", "login" => nil }, req.cookie_jar)
assert_equal Rails.root.join("tmp/screenshots/0_#{"x" * 223}.png").to_s, long_test.send(:image_path)
assert_equal Rails.root.join("tmp/screenshots/0_#{"x" * 223}.html").to_s, long_test.send(:html_path)
@new_test.stub :show, -> (img) { display_image_actual = img } do
@new_test.stub :save_html, -> { called_save_html = true } do
Rails.stub :root, Pathname.getwd.join("..") do
option.add_argument("--host=127.0.0.1")
::Selenium::WebDriver::Chrome::Service.driver_path = -> { called = true }
DummyApp = lambda { |env|
assert_equal "Hello, World!", get("/nofile").body
assert_html "/index.html", get("/index.html")
assert_html "/index.html", get("/index")
assert_html "/index.html", get("/")
assert_html "/index.html", get("")
assert_html "/foo/bar.html", get("/foo/bar.html")
assert_html "/foo/bar.html", get("/foo/bar/")
assert_html "/foo/bar.html", get("/foo/bar")
assert_html "/foo/index.html", get("/foo/index.html")
assert_html "/foo/index.html", get("/foo/index")
assert_html "/foo/index.html", get("/foo/")
assert_html "/foo/index.html", get("/foo")
assert_html "/bar.html", get("/bar")
assert_html "means hello in Japanese\n", get("/foo/%E3%81%93%E3%82%93%E3%81%AB%E3%81%A1%E3%81%AF.html")
assert_html file, get("/foo/foo(bar).html")
file_name = "/gzip/foo.zoo"
last_modified = File.mtime(File.join(@root, "#{file_name}.gz"))
File.open(path, "wb+") { |f| f.write(file) }
@app = ActionDispatch::Static.new(DummyApp, @root, headers: { "Cache-Control" => "public, max-age=60" })
assert File.exist?(File.join(@root, "..", filename))
assert_html "/other-index.html", get("/")
assert_html "/other-index.html", get("")
assert_html "/foo/other-index.html", get("/foo/")
assert_html "/foo/other-index.html", get("/foo")
def build_app(headers: {}, ssl_options: {})
def assert_redirected(redirect: {}, from: "http://a/b?c=d", to: from.sub("http", "https"))
def assert_post_redirected(redirect: {}, from: "http://a/b?c=d",
to: from.sub("http", "https"))
excluding = { exclude: -> request { request.path.match?(/healthcheck/) } }
process :not_an_http_method, "http://a/b?c=d"
get "http://a/b?c=d"
post "http://a/b?c=d"
assert_redirected redirect: { host: "ssl" }, to: "https://ssl/b?c=d"
assert_redirected redirect: { port: 8443 }, to: "https://a:8443/b?c=d"
assert_redirected redirect: { host: "ssl", port: 8443 }, to: "https://ssl:8443/b?c=d"
assert_redirected redirect: { host: "ssl:443" }, to: "https://ssl:443/b?c=d"
def assert_hsts(expected, url: "https://example.org", hsts: { subdomains: true }, headers: {})
DEFAULT = %(id=1; path=/\ntoken=abc; path=/; secure; HttpOnly)
assert_cookies "id=1; path=/; secure", "token=abc; path=/; secure; HttpOnly"
get headers: { "Set-Cookie" => "problem=def; path=/; HttpOnly; secure" }
get headers: { "Set-Cookie" => "problem=def; path=/;secure; HttpOnly" }
get headers: { "Set-Cookie" => "problem=def; path=/; secure;HttpOnly" }
get headers: { "Set-Cookie" => "problem=def; path=/; Secure; HttpOnly" }
get headers: { "Set-Cookie" => DEFAULT }, ssl_options: { secure_cookies: false }
excluding = { exclude: -> request { /example/.match?(request.domain) } }
get headers: { "Set-Cookie" => DEFAULT }, ssl_options: { redirect: excluding }
get headers: { "Connection" => "close" }
when "/bad_params", "/bad_params.json"
raise "puke!"
get "/", env: { "action_dispatch.show_exceptions" => false }
get "/", env: { "action_dispatch.show_exceptions" => true }
get "/bad_params", env: { "action_dispatch.show_exceptions" => true }
get "/not_found", env: { "action_dispatch.show_exceptions" => true }
get "/invalid_mimetype", headers: { "Accept" => "text/html,*", "action_dispatch.show_exceptions" => true }
get "/bad_params.json", env: { "action_dispatch.show_exceptions" => true }
assert_equal("{\"status\":400,\"error\":\"Bad Request\"}", body)
session.update("key" => "value")
session = ActionController::TestSession.new(one: { two: { three: "3" } })
assert_equal("3", session.dig(:one, :two, :three))
assert_nil(session.dig(:ruby, :on, :rails))
assert_equal("2", session.fetch(:two, "2"))
assert_equal("1", session.fetch("one"))
assert_equal(2, session.fetch("2") { |key| key.to_i })
session.merge!({ key: "value" })
get "/set_session_value", params: { _session_id: session_id }
SameSite = proc { :lax }
assert_session_cookie "path=/; HttpOnly", { "foo" => "bar" }
get "/set_session_value", headers: { "HTTPS" => "on" }
assert_session_cookie "path=/; secure; HttpOnly", "foo" => "bar"
assert_session_cookie "path=/; HttpOnly", "foo" => "bar"
expected_expiry = (time + 5.hours).gmtime.strftime("%a, %d %b %Y %H:%M:%S GMT")
assert_session_cookie "path=/; expires=#{expected_expiry}; HttpOnly", "foo" => "bar"
time = time + 3.hours
time = Time.local(2017, 11, 12)
time += 5.hours + 1.minute
{ "foo" => "bar" },
session = @cache.read("_session_id:#{sid.private_id}")
@cache.delete("_session_id:#{sid.private_id}")
@cache.write("_session_id:#{sid.public_id}", session)
@sessions = {}
sid ||= 1
as.call(@env)
@env = nil
lambda { |env| @env = env }
get "/id"
stub_app = -> (env) {
app.call({ "proc" => -> {
response = app.call({ "proc" => -> {
/192\.168\.1\.1\d\d/.match?(request.ip)
post "login" => :create
get "/login"
post "/login"
get "account/login", to: redirect("/login")
get "account/logout" => redirect("/logout"), :as => :logout_redirect
get "index", to: "private#index"
get "/hi"
get "hi", to: redirect("/foo"), constraints: ->(req) { true }
def call(*); true; end
def matches?(*); false; end
get "/", to: "home#show", constraints: constraint.new
get "/:controller(/:action(/:id(.:format)))"
get "account/modulo/:name", to: redirect("/%{name}s")
get "account/proc_req" => redirect { |params, req| "/#{req.method}" }
get "/mobile"
get "stores/:name", to: redirect(subdomain: "stores", path: "/%{name}")
get "stores/:name(*rest)", to: redirect(subdomain: "stores", path: "/%{name}%{rest}")
post :create, path: "create", as: ""
get "build", action: "new", as: "new"
post "create", as: ""
get "", action: :show, as: :show
constraints(ip: /192\.168\.1\.\d\d\d/) do
get "admin" => "queenbee#index"
get "/admin", headers: { "REMOTE_ADDR" => "192.168.1.100" }
get "/admin", headers: { "REMOTE_ADDR" => "10.0.0.100" }
get "/admin/accounts", headers: { "REMOTE_ADDR" => "192.168.1.100" }
get "/admin/accounts", headers: { "REMOTE_ADDR" => "10.0.0.100" }
get "/admin/passwords", headers: { "REMOTE_ADDR" => "192.168.1.100" }
get "/admin/passwords", headers: { "REMOTE_ADDR" => "10.0.0.100" }
get "profile", on: :member
original_options = { host: "test.host" }
assert_equal "/projects/1", project_path(id: "1")
assert_equal "/projects/1.xml", project_path(id: "1", format: "xml")
post "new", action: "new", on: :collection, as: :new
assert_equal "/projects/1/people/1", project_person_path(project_id: "1", id: "1")
assert_equal "/posts/1", post_path(id: 1)
post "/posts"
put "/posts/1"
get "_it", on: :member
assert_equal "/sheep/1/_it", _it_sheep_path(1)
options = { id: /.+?/, format: /json|xml/ }
assert_equal({ id: /.+?/, format: /json|xml/ }, options)
scope "pt", as: "pt" do
resources :projects, path_names: { edit: "editar", new: "novo" }, path: "projetos"
resources :projects, path_names: { new: "novo" }, path: "projetos" do
put :close, on: :member, path: "fechar"
get :open, on: :new, path: "abrir"
get "/forum"
get "articles/:year/:month/:day/:title", to: "articles#show", as: :article
assert_equal "/articles/2009/8/18/rails-3", article_path(year: 2009, month: 8, day: 18, title: "rails-3")
get "/foo/posts"
get "/foo/posts/1"
assert_equal "/foo/posts/1", foo_post_path("1")
namespace :foo, path: "bar" do
get "/bar/posts"
get "/bar/posts/1"
assert_equal "/bar/posts/1", foo_post_path("1")
namespace :foo, as: "bar" do
assert_equal "/foo/posts/1", bar_post_path("1")
scope "/articles", as: "article" do
get "/:id", action: :with_id, as: ""
scope ":access_token", constraints: { access_token: /\w{5,5}/ } do
get "/12345/rooms/1"
scope "(:locale)", locale: /en|pl/ do
assert_equal "/en", root_path(locale: "en")
get "/en"
scope "(:locale)" do
scope "(:platform)" do
scope "(:browser)" do
assert_equal "/en/osx", root_path(locale: "en", platform: "osx")
root_path(locale: "en", platform: "osx", browser: "chrome")
get "/en/osx"
get "/en/osx/chrome"
scope "(p/:platform)" do
scope "(b/:browser)" do
assert_equal "/p/osx", root_path(platform: "osx")
assert_equal "/en/p/osx", root_path(locale: "en", platform: "osx")
assert_equal "/en/b/chrome", root_path(locale: "en", browser: "chrome")
get "/p/osx"
get "/en/p/osx"
get "/b/chrome"
get "/en/b/chrome"
get "/p/osx/b/chrome"
get "/en/p/osx/b/chrome"
get "/star-trek(-tng)/:episode", to: "star_trek#show"
get "/user"
get "/user.html"
get "/info" => "projects#info", :as => "info"
get "/info"
get "get/first", "get/second", "get/third", to: "get#show"
get "/get/first"
get "/get/third"
scope "/job", controller: "job" do
get "/active"
get "/job/5/active"
get "page/:page" => "replies#index", :page => %r{\d+}
get ":page" => "replies#index", :page => %r{\d+}
get "sign_in" => "sessions#new"
get "/sign_in"
get "account/google" => redirect("http://www.google.com/", status: 302)
assert_equal "/en", root_path("en")
get "inline_pages/(:id)", to: "pages#show", id: "home"
get "default_pages/(:id)", to: "pages#show", defaults: { id: "home" }
get "scoped_pages/(:id)", to: "pages#show"
get "inline_pages/(:page)", to: "pages#show", page: 1
get "default_pages/(:page)", to: "pages#show", defaults: { page: 1 }
get "scoped_pages/(:page)", to: "pages#show"
match "/", to: "pages#show", via: :get, defaults: { id: "home" }
match "/", to: "pages#show", via: :get, id: "home"
root to: "pages#show", defaults: { id: "home" }
root to: "pages#show", id: "home"
resources :products, constraints: { id: /\d{4}/ } do
resource :dashboard, constraints: { ip: /192\.168\.1\.\d{1,3}/ }
get "/dashboard", headers: { "REMOTE_ADDR" => "10.0.0.100" }
get "/dashboard", headers: { "REMOTE_ADDR" => "192.168.1.100" }
get "/token"
scope path: "api" do
get "/" => "mes#index"
get "/api/me"
get "/api"
resource :me, as: "v2_me"
scope :v3, :admin do
resource :me, as: "v3_me"
get "/api/v2/me"
get "/api/v2"
get "/api/v3/admin/me"
get "whatever/:controller(/:action(/:id))"
url_for(controller: "foo", action: "bar", id: 1)
get "whatever/:controller(/:action(/:id))", id: /\d+/
url_for(controller: "foo/bar", action: "show")
url_for(controller: "foo/bar", action: "show", id: "1")
post :preview, on: :new
resource :admin, path_names: { new: "novo" }, path: "administrador" do
resources :products, path_names: { new: "novo" } do
get "/api/teams"
get "/api/teams/new"
get "/api/teams/1"
assert_equal "/api/teams/1", api_team_path(id: "1")
get "/api/teams/1/edit"
assert_equal "/api/teams/1/edit", edit_api_team_path(id: "1")
get "/api/players/2"
assert_equal "/api/players/2", api_player_path(id: "2")
get "/threads/1"
assert_equal "/threads/1", thread_path(id: "1")
assert_equal "/messages/2", message_path(id: "2")
assert_equal "/comments/3", comment_path(id: "3")
get "/cards/1"
assert_equal "/cards/1", card_path("1")
get "/cards/1/edit"
assert_equal "/cards/1/edit", edit_card_path("1")
put "/cards/1"
patch "/cards/1"
assert_equal "/posts/1/comments/2", post_comment_path("1", "2")
assert_equal "/posts/1/comments/2/edit", edit_post_comment_path("1", "2")
get "/tags/3"
assert_equal "/tags/3", tag_path("3")
assert_equal "/hello/notes/1/edit", edit_note_path(id: "1")
get "/hello/notes/1"
put "/hello/notes/1"
get "secret/profile" => "customers#secret", :on => :member
post "preview" => "customers#preview", :as => :another_preview, :on => :new
get "thumbnail" => "avatars#thumbnail", :as => :thumbnail, :on => :member
get "print" => "invoices#print", :as => :print, :on => :member
post "preview" => "invoices#preview", :as => :preview, :on => :new
get "preview" => "notes#preview", :as => :preview, :on => :new
get "print" => "notes#print", :as => :print, :on => :member
get "recent" => "customers#recent", :as => :recent, :on => :collection
get "profile" => "customers#profile", :as => :profile, :on => :member
post "preview" => "customers#preview", :as => :preview, :on => :new
assert_equal "/notes/1/print", print_note_path(id: "1")
get "/notices/1"
assert_equal "/notices/1", notice_path(id: "1")
scope(":version", version: /.+/) do
resources :users, id: /.+?/, format: /json|xml/
get "/api/1.0/users"
assert_equal "/api/1.0/users", api_users_path(version: "1.0")
get "/api/1.0/users.json"
assert_equal "/api/1.0/users.json", api_users_path(version: "1.0", format: :json)
assert_equal "/api/1.0/users/first.last", api_user_path(version: "1.0", id: "first.last")
assert_equal "/api/1.0/users/first.last.xml", api_user_path(version: "1.0", id: "first.last", format: :xml)
match "/foo/bar", to: "files#show"
get "/:locale/*file.:format", to: "files#show", file: /path\/to\/existing\/file/
get "(/:username)/followers" => "followers#index"
get "/groups(/user/:username)" => "groups#index"
url_for(controller: "groups", action: "index", username: "bob")
get "/groups"
get "(/user/:username)/photos" => "photos#index"
url_for(controller: "photos", action: "index", username: "bob")
get "/photos"
scope "(groups)" do
scope constraints: { id: /\d+/ } do
get "/tickets", to: "tickets#index", as: :tickets
scope constraints: { id: /\d{4}/ } do
assert_raise(NoMethodError) { edit_only_club_player_path(club_id: "1", id: "2") }
assert_raise(NoMethodError) { edit_except_club_player_path(club_id: "1", id: "2") }
resources :sections, id: /.+/ do
get "/pages"
get "secure", to: redirect("/secure/login")
get "/secure"
get "aged/:months", on: :collection, action: :aged, as: :aged
get "old", on: :collection, as: :stale
filename: /(.+)/,
resources :todos, id: /\d+/
get "/lists/2/todos/1"
get "/hello", as: :hello, to: "hello#world"
get "/c/:id", as: :collision, to: "collision#show"
get "/no_collision", to: "collision#show", as: nil
draw { get "/feeds/:service", to: "/feeds#show" }
draw { get "/feeds/:service", controller: "/feeds", action: "show" }
draw { get "/api/feeds/:service", to: "/api/feeds#show" }
draw { get "/products", to: "products#index", as: "products " }
draw { get "/products", to: "products#index", as: " products" }
draw { get "/products", to: "products#index", as: "products!" }
draw { get "/products", to: "products#index", as: "products index" }
draw { get "/products", to: "products#index", as: "1products" }
get "/collision", to: "collision#show", as: "collision"
get "/duplicate", to: "duplicate#show", as: "collision"
get "views" => "comments#views", :as => :views
get "/posts/1/admin"
get "search" => "search"
get "/search"
get "/downloads/:id/:id.tar" => "downloads#show", as: :download, format: false
assert_equal "/downloads/1/1.tar", download_path("1", "1")
get "/", to: "/bar#index", as: "root"
get "/streams/"
get "/contact-us", to: "pages#contact_us"
get "/photos/1"
assert_equal "/photos/1", photo_path("1")
get "/projects", action: "index",
scope path: "foo" do
scope as: "foo" do
scope as: "foo", shallow_prefix: "bar" do
scope path: "foo", shallow_path: "bar" do
resource :post, as: ""
scope "post", as: "post" do
resource :comment, as: ""
resources :posts, as: ""
scope "posts", as: "posts" do
scope "post", as: "" do
get "/home" => "test#index"
head "/home"
assert_equal "/?id=1", root_path(params)
get "/:controller", action: "index"
root "pages#index", constraints: { host: "www.example.com" }
get "http://www.example.com/"
def url_for(options = {})
if method.to_s.match?(/_(path|url)$/)
@path_parameters = {}
@env = env
@path_info = "/"
@script_name = ""
get "/" => TestAltApp::XHeader.new, :constraints => { x_header: /HEADER/ }
get "/" => TestAltApp::AltApp.new
s = self
get "/goodbye" => s.simple_app("goodbye")
get "/hello" => s.simple_app("hello")
get "/hello"
get "/random"
get "/foo/bar", action: :index
get "/foo/bar", to: "foo"
get "/foo/bar", to: "foo#"
match "/" => s.simple_app(method), :via => method.underscore.to_sym
get "/:segment" => lambda { |env|
}, :as => :segment
get "/*splat" => lambda { |env|
}, :as => :splat
assert_equal "/a%20b%2Fc+d", segment_path(segment: "a b/c+d")
get "/a%20b%2Fc+d"
assert_equal "/a%20b/c+d", splat_path(splat: "a b/c+d")
get "/a%20b/c+d"
}, :as => :unicode_path
get "baz" => "baz#index"
get "pooh" => "pooh#index"
render inline: "<%= url_for :controller => '/pooh', :action => 'index' %>"
get "/foo/bar/baz"
get "/~user" => ok
get "/young-and-fine" => ok
get "/~user"
get "/foo/:id" => redirect("/foo/bar/%{id}")
get "/bar/:id" => redirect(path: "/foo/bar/%{id}")
get "/baz/:id" => redirect("/baz?id=%{id}&foo=?&bar=1#id-%{id}")
get "/foo/bar/:id" => ok
get "/baz" => ok
get "/foo/1%3E"
get "/bar/1%3E"
get "/foo/1%201"
get "/baz/1%201"
get "/:bar" => ok
get "/*id" => redirect("/not_cars"), :constraints => { id: /dummy/ }
get "/cars" => ok
get "/dummy"
get "/cars"
get "/foo" => ok, as: :foo
get "/post(/:action(/:id))" => ok, as: :posts
get "/:foo/:foo_type/bars/:id" => ok, as: :bar
get "/projects/:id.:format" => ok, as: :project
get "/pages/:id" => ok, as: :page
get "/wiki/*page" => ok, as: :wiki
assert_equal "/foo/baz/bars/1", Routes.url_helpers.bar_path("foo", "baz", "1")
assert_equal "/foo/baz/bars/1", bar_path("foo", "baz", "1")
assert_equal "/wiki/foo/bar", wiki_path("foo/bar")
get "/categories/:id" => "categories#show", :as => :category
get "/products/:id" => "products#show", :as => :product
get "/" => ok, :as => :admin_root
scope constraints: { protocol: "https://" } do
get "/" => ok, :as => :secure_root
get "/" => ok, :as => :alternate_root, :constraints => { port: 8080 }
get "/search" => ok, :constraints => { subdomain: false }
get "/logs" => ok, :constraints => { subdomain: true }
get "https://www.example.com/"
get "/bar/:id", to: redirect("/foo/show/%{id}")
get "/foobar/:id", to: ok
get "/foo/show(/:id)", to: "test_invalid_urls/foo#show"
get "/bar/show(/:id)", controller: "test_invalid_urls/foo", action: "show"
get "/(page/:page)", to: "pages#index", as: :root
get "/page/1"
assert_equal "/page/1", root_path("1")
assert_equal "/page/1", root_path(page: "1")
get "/json_only", to: ok, format: true, constraints: { format: /json/ }
get "/xml_only", to: ok, format: "xml"
url_for(controller: "posts", action: "show", id: 1, only_path: true)
assert_equal "/posts/1", url_for(controller: "posts", action: "show", id: 1, bucket_type: "post", only_path: true)
assert_equal "/projects/1", url_for(controller: "projects", action: "show", id: 1, only_path: true)
mount rack_app, at: "/account", as: "account"
get "/account", to: redirect("/myaccount"), as: "account"
get "/:locale/account", to: redirect("/%{locale}/myaccount"), as: "localized_account"
get "/posts/:year/:month/:day", to: "posts#archive", as: "archived_posts"
get "/posts/foo"
get "/posts/bar"
get "/posts/baz"
get "/i_do_not_exist"
get "/songs/song-:song", to: ok
get "/songs/:song-song", to: ok
get "/:artist/song-:song", to: ok
get "/:artist/:song-song", to: ok
get "/optional/songs(/song-:song)", to: ok
get "/optional/songs(/:song-song)", to: ok
get "/optional/:artist(/song-:song)", to: ok
get "/optional/:artist(/:song-song)", to: ok
scope "(:locale)", locale: /en|es/ do
get "with_param/:foo", to: "home#with_param", as: "with_param"
render inline: "<%= with_param_path(foo: 'bar') %> | <%= without_param_path %>"
get "/home"
get "/es/home"
scope ":locale", locale: /en|ar/ do
get "/about", to: "pages#about"
get ":controller(/:action/(:id))"
render inline: "<%= root_path %>"
render inline: "<%= root_path(locale: :ar) %> | <%= url_for(locale: :ar) %>"
get "/en/about"
assert_equal "/ar | /ar/about", @response.body
{ controller: "internal", action: "internal", internal: "123" },
get "/bar", to: "flash_redirect_test/foo#bar"
get "/foo", env: { "action_dispatch.key_generator" => Generator }
get "/hash/:foo", to: "pages#show", constraints: { foo: /foo/ }
get "/hash/:bar", to: "pages#show", constraints: { bar: /bar/ }
get "/class/:foo", to: "pages#show", constraints: PageConstraint.new(:foo, /foo/)
get "/class/:bar", to: "pages#show", constraints: PageConstraint.new(:bar, /bar/)
expected_params = { controller: "pages", action: "show", bar: "bar" }
get "/", to: "posts#index", as: :posts
get "/:id", to: "posts#show", as: :post
assert_equal "/blog/", posts_path({})
assert_equal "/blog/1", post_path(id: "1")
assert_equal "/blog/1", post_path("1")
scope "secure", constraints: { protocol: "https://" } do
scope "block", constraints: lambda { |r| r.ssl? } do
mount engine => "/shelf"
mount root_engine => "/"
assert_generates("/articles/1", controller: "articles", action: "show", id: "1")
assert_generates("/articles/1/edit", { controller: "articles", action: "edit" }, { id: "1" })
assert_generates("/articles", { controller: "articles", action: "index", page: "1" }, {}, { page: "1" })
assert_recognizes({ controller: "articles", action: "show", id: "1" }, "/articles/1")
assert_recognizes({ controller: "articles", action: "index", page: "1" }, "/articles", page: "1")
assert_recognizes({ controller: "articles", action: "create" }, { path: "/articles", method: :post })
assert_recognizes({ controller: "articles", action: "update", id: "1" }, { path: "/articles/1", method: :put })
assert_recognizes({ controller: "query_articles", action: "index", use_query: "true" }, "/query/articles", use_query: "true")
assert_recognizes({ controller: "books", action: "index" }, "/shelf/books")
assert_recognizes({ controller: "books", action: "show", id: "1" }, "/shelf/books/1")
assert_recognizes({ controller: "books", action: "index" }, "/")
assert_recognizes({ controller: "books", action: "index", page: "1" }, "/shelf/books", page: "1")
assert_recognizes({ controller: "books", action: "create" }, { path: "/shelf/books", method: :post })
assert_recognizes({ controller: "books", action: "update", id: "1" }, { path: "/shelf/books/1", method: :put })
assert_recognizes({ controller: "query_books", action: "index", use_query: "false" }, "/shelf/query/books", use_query: "false")
assert_recognizes({ controller: "query_books", action: "index", use_query: "true" }, "/shelf/query/books", use_query: "true")
assert_recognizes({ controller: "secure_books", action: "index" }, "http://test.host/shelf/secure/books", {}, "This is a really bad msg")
assert_routing("/thisIsNotARoute", { controller: "articles", action: "edit", id: "1" }, { id: "1" }, {}, "This is a really bad msg")
assert_routing("/articles/1/edit", { controller: "articles", action: "edit", id: "1" }, { id: "1" })
assert_routing("/articles", { controller: "articles", action: "index", page: "1" }, {}, { page: "1" })
get "foo", to: SimpleApp.new("foo#index")
get "bar", to: SimpleApp.new("bar#index")
get "bar", to: SimpleApp.new("bar#index"), as: :bar
get "baz", to: SimpleApp.new("baz#index"), as: :bar
@set.default_url_options = { host: "example.com" }
assert_equal "/foo/1/bar/2", url_helpers.foo_bar_path(1, 2)
assert_equal "/foo/1/bar/2", url_helpers.foo_bar_path(2, foo_id: 1)
scope "(/:foo)" do
assert_equal "/a/users/1", url_helpers.user_path(1, foo: "a")
setup { @app = SimpleApp }
get "redirect", to: redirect("/login")
@logs ||= @logger.logged(:info)
get "/foo", to: "bad_route_request#foo", as: :foo
request_env = {
get "/foo", env: request_env
subscriber = -> (_event) { event = _event }
get "/cart", to: "cart#show"
mount engine => "/blog", :as => "blog"
mount engine => "/blog", as: "blog"
get "api/:action" => "api"
get ":controller(/:action(/:id))", id: /\d+/
get "photos/:id" => "photos#show", :defaults => { format: "jpg" }
get "about-us" => "pages#about_us"
mount MountedRackApp => "/foo", as: "blog"
get "/foo" => "foo#bar"
get "/foobar" => redirect { "/foo/bar" }
output = draw(grep: "posts") do
output = draw(grep: "Rails::DummyController") { }
post "/cart", to: "cart#create"
patch "/cart", to: "cart#update"
mount engine => "/blog", as: "blog", internal: true
get "/basket", to: "basket#show", as: :basket
get "/posts/:id", to: "posts#show", as: :post
get "/profile", to: "users#profile", as: :profile
get "/media/:id", to: "media#show", as: :media
get "/pages/:id", to: "pages#show", as: :page
direct(:browse, page: 1, size: 10) do |options|
@video = Video.new("4")
@article = Article.new("5")
@page = Page.new("6")
@path_params = { "controller" => "pages", "action" => "index" }
def self.call(mapper, options = {})
get "/posts/1/image/1"
assert_equal "/posts/1/reviews/1", post_review_path(post_id: 1, id: 1)
t = Thread.new {
@response.body = Object.new.tap { |o| o.singleton_class.define_method(:each) { |&block| each_counter += 1; block.call "foo" } }
@response.body = "Hello, World!"
}, headers)
body.each { |part| parts << part }
assert_headers({ "content-type" => "text/html; charset=utf-8" }, headers)
_, headers, _ = response.to_a
status, headers, _ = @response.to_a
_, headers, _ = @response.to_a
_, _, body = @response.to_a
@response.set_cookie("user_name", value: "david", path: "/")
_status, headers, _body = @response.to_a
assert_equal({ "user_name" => "david" }, @response.cookies)
@response.set_cookie("login", value: "foo&bar", path: "/", expires: Time.utc(2005, 10, 10, 5))
assert_equal({ "login" => "foo&bar", "user_name" => "david" }, @response.cookies)
assert_equal({ "user_name" => "david", "login" => nil }, @response.cookies)
assert_headers({ "content-type" => "text/plain" }, headers)
app = lambda { |env| @response.to_a }
_status, headers, _body = app.call(env)
@response.set_header "Foo", "1"
assert_equal "2", @response.set_header("Foo", "2")
assert_header_value "1,2", @response.add_header("Foo", "2")
assert_header_value "1", @response.add_header("Bar", "1")
@app = lambda { |env|
resp.etag = "123"
resp.body = "Hello"
}.to_a
resp.charset = "utf-16"
{ "Content-Type" => "application/xml; charset=utf-16" },
{ "Content-Type" => "text/csv; charset=utf-16; header=present" },
{ "Content-Type" => "text/csv; header=present; charset=utf-16" },
{ "Content-Type" => 'text/csv; header=present; charset="utf-16"' },
@env = {
options = { host: "www.example.com" }.merge!(options)
def stub_request(env = {})
env = @env.merge(env)
assert_equal "/books", url_for(only_path: true, path: "/books")
request = stub_request "REMOTE_ADDR" => "1.2.3.4,3.4.5.6"
request = stub_request "REMOTE_ADDR" => "1.2.3.4",
request = stub_request "REMOTE_ADDR" => "127.0.0.1",
request = stub_request "HTTP_X_FORWARDED_FOR" => "9.9.9.9, 3.4.5.6, 172.31.4.4, 10.0.0.1"
request.remote_ip = "2.3.4.5"
request = stub_request "HTTP_X_FORWARDED_FOR" => "fe80:0000:0000:0000:0202:b3ff:fe1e:8329, ::1, ::1"
request = stub_request "REMOTE_ADDR" => "3.4.5.6",
request = stub_request "REMOTE_ADDR" => "172.16.0.1,67.205.106.73",
request = stub_request "REMOTE_ADDR" => "67.205.106.73,3.4.5.6",
request = stub_request "HTTP_X_FORWARDED_FOR" => "9.9.9.9, 3.4.5.6, 10.0.0.1, 67.205.106.73"
@additional_trusted_proxy = /^67\.205\.106\.73$/i
request = stub_request "REMOTE_ADDR" => "67.205.106.73",
request = stub_request "HTTP_X_FORWARDED_FOR" => "10.0.0.1, 9.9.9.9, 3.4.5.6, 67.205.106.73"
request = stub_request("REMOTE_ADDR" => "127.0.0.1")
request = stub_request "HTTP_HOST" => "192.168.1.200"
request = stub_request "HTTP_HOST" => "foo.192.168.1.200"
request = stub_request "HTTP_HOST" => "192.168.1.200.com"
request = stub_request "HTTP_HOST" => "www.rubyonrails.co.uk", :tld_length => 2
request = stub_request "HTTP_HOST" => "dev.www.rubyonrails.co.uk", :tld_length => 2
request = stub_request "HTTPS" => "on"
request = stub_request "HTTP_HOST" => "www.example.org:8443", "HTTPS" => "on"
request = stub_request "SCRIPT_NAME" => "/collaboration/hieraki", "PATH_INFO" => "/books/edit/2"
request = stub_request "HTTP_HOST" => "glu.ttono.us:80"
if Rack.release < "3"
data = "rewind"
assert_predicate stub_request("HTTPS" => "on"), :ssl?
request = stub_request "rack.url_scheme" => "http"
body = "{record:{content:127.0.0.1}}"
output.rewind && (err = output.read)
request = stub_request "HTTP_ACCEPT" => "*/*;q=0.1",
assert_equal({ "charset" => "UTF-8" }, request.media_type_params)
assert_equal({ "foo" => 1, "bar" => "2" }, request.parameters)
assert_equal({ "foo" => 1 }, request.request_parameters)
assert_equal({ "bar" => "2" }, request.query_parameters)
request.path_parameters = { foo: "\xBE" }
data = "foo=%81E"
ActionDispatch::Request::Utils.stub(:set_binary_encoding, { "foo" => "\x81E".b }) do
%w(; &).each do |sep|
header = '"the-etag"'
header = 'etag1, etag2, "third etag", "etag4"'
early_hints = @request.send_early_hints("Link" => "</style.css>; rel=preload; as=style\n</script.js>; rel=preload")
expected_hints = { "Link" => "</style.css>; rel=preload; as=style\n</script.js>; rel=preload" }
assert_equal "external-uu-rid", stub_request({ "HTTP_TRACER_ID" => "external-uu-rid" }, header: "Tracer-Id").request_id
assert_equal "X" * 255, stub_request({ "HTTP_X_REQUEST_ID" => "X" * 500 }).request_id
assert_match(/\w+-\w+-\w+-\w+-\w+/, stub_request.request_id)
assert_equal "external-uu-rid", stub_request({ "HTTP_X_REQUEST_ID" => "external-uu-rid" }).uuid
def stub_request(env = {}, header: "X-Request-Id")
{ "id" => "1", "type" => "User" },
{ "type" => "Group", "id" => "2" }
expected = { "test2" => "value1" }
v.each { |el| assert_utf8 el }
s = Session.create(store, req, {})
assert_equal({ "foo" => "bar" }, s.to_hash)
assert_equal({ "foo" => "bar" }, s.to_h)
s1 = Session.create(store, req, {})
s = Session.create(store_with_data, req, {})
session = Session.create(store, req, {})
assert_equal "2", session.fetch(:two, "2")
assert_equal "three", session.fetch(:three) { |el| el.to_s }
assert_equal "3", session.dig("one", "two")
assert_equal "3", session.dig(:one, "two")
{ "action" => "create_customer", "full_name" => "David Heinemeier Hansson", "customerId" => "1" },
{ "x" => { "y" => { "z" => "10" } } },
{ "action" => "create_customer", "full_name" => "" },
{ "action" => "create_customer", "name" => "Don't & Does" },
{ "action" => "create_customer", "full_name" => "abc=def=ghi" },
assert_parses({ "action" => nil }, "action")
{ "action" => "create_customer", "full_name" => "David Heinemeier Hansson" },
FIXTURE_PATH = File.expand_path("../../fixtures/multipart", __dir__)
assert_equal({ "foo" => "bar" }, parse_multipart("single_parameter"))
assert_equal({ "foo" => { "baz" => "bar" } }, parse_multipart("bracketed_param"))
assert_equal(("a" * 20480), file.read)
post "/read", params: { uploaded_data: fixture_file_upload(FIXTURE_PATH + "/hello.txt", "text/plain") }
headers = { "CONTENT_TYPE" => "multipart/form-data; boundary=AaB03x" }
{ "rack.input" => file.read,
{ "person" => { "name" => "David" } },
{ "item" => { "enabled" => false, "count" => 10 } },
{},
post "/parse", params: json, headers: { "CONTENT_TYPE" => "application/json", "action_dispatch.show_exceptions" => false }
{ "user" => { "username" => "sikachu" }, "username" => "sikachu" },
{ "user" => { "_json" => "string content" }, "_json" => "string content" },
{ "user" => { "username" => "meinac" }, "username" => "meinac" },
reloader.to_prepare { |*args| a = b = c = 1 }
reloader.to_prepare { |*args| b = c = 2 }
reloader.to_prepare { |*args| c = 3 }
assert_nil a || b || c
i, j = 0, 0, 0, 0
reloader = reloader(lambda { i < 3 })
reloader.to_prepare { |*args| i += 1 }
reloader.to_complete { |*args| j += 1 }
resp = app.call({})
b << "hello"
b << "world"
_, _, body = app.call("rack.input" => StringIO.new(""))
@reloader ||= begin
hash = @store.read(:foo)
klass = +"Post"
get "/posts/:id", to: "inside_engine_generating#show", as: :post
get "/relative_custom_redirect", to: redirect { |params, request| "foo" }
get "/absolute_custom_redirect", to: redirect { |params, request| "/foo" }
scope "/:omg", omg: "awesome" do
mount BlogEngine => "/blog", :as => "blog_engine"
get "/posts/:id", to: "outside_engine_generating#post", as: :post
omg: "omg",
id: 1)
mount BlogEngine => "/"
@policy.usb :none, "https://example.com"
get "/", to: "policy#index"
scope "/its_a" do
mount SprocketsApp, at: "/", via: :get
assert_equal " -- /omg", response.body
get "/~omg"
assert_equal " -- /~omg", response.body
get "/star*/omg"
assert_equal "/star* -- /omg", response.body
get "/foo/sprockets/omg", headers: { "SCRIPT_NAME" => "/foo", "PATH_INFO" => "/sprockets/omg" }
unless mime_type == "image/*"
assert_equal expect.map(&:to_s), parsed.map(&:to_s)
accept = "text/*"
assert_equal expect.map(&:to_s).sort!, parsed.map(&:to_s).sort!
assert_equal expect.map(&:to_s), Mime::Type.parse(accept).map(&:to_s)
accept = "text/html;q=0.9"
type = Mime::Type.register("image/foo", :foo)
mime = Mime::Type.register("text/foo", :foo)
assert_respond_to mime, "#{type}?"
assert_equal type, mime.symbol, "#{mime.inspect} is not #{type}?"
test "match?" do
assert_equal "*/*", Mime::Type.new("*/*").to_s
assert_equal "text/*", Mime::Type.new("text/*").to_s
assert_equal "video/*", Mime::Type.new("video/*").to_s
Mime::Type.new("*/html")
Mime::Type.new("")
Mime::Type.new("text/html ;0 ;0 ;0 ;0 ;0 ;0 ;0 ;0 ;0 ;0 ;0 ;0 ;0 ;0 ;0 ;0 ;0 ;0;")
proc = Proc.new { }
routes.map(&:path).map(&:spec)
mapper.match "/", to: "posts#index", as: :main
mapper.get "/foo", to: "posts#index", as: :main, format: true
assert_equal({ controller: "posts", action: "index" },
mapper.get "/foo", to: "posts#index", as: :main
mapper.get "/", to: "posts#index", as: :main
assert_equal({ omg: :awesome, controller: "posts", action: "index" },
scope = Mapper::Scope.new({})
ast = Journey::Parser.parse "/store/:name(*rest)"
mapper.get "/one/two/", to: "posts#index", as: :main
mapper.get "/*path", to: "pages#show"
mapper.get "/*path/foo/:bar", to: "pages#show"
mapper.get "/*foo/*bar", to: "pages#show"
assert_equal "/*foo/*bar(.:format)", fakeset.asts.first.to_s
mapper.get "/*path", to: "pages#show", format: false
mapper.get "/*path", to: "pages#show", format: true
mapper.mount app => "/path", anchor: true
frozen = { foo: :bar }.freeze
headers = @response.headers.merge("Foo" => "Bar")
{ "omg" => "g" }
@response.body = "omg"
@response.each { |x| }
get "/", env: { "action_dispatch.show_detailed_exceptions" => true }
get "/", env: {
@app = ActionDispatch::HostAuthorization.new(App, "only.com", exclude: ->(req) { req.path == "/foo" })
@app = ActionDispatch::HostAuthorization.new(App, "only.com", exclude: ->(req) { req.path == "/bar" })
get "/foo", env: { "action_dispatch.show_detailed_exceptions" => true }
get "/", env: { "action_dispatch.logger" => Logger.new(output) }
@headers.each { |pair| headers << pair }
@headers.add "Foo", "1"
@headers.add "Foo", nil
@headers.add "Foo", 1
@headers.add "fOo", 2
test "key?" do
assert_equal "omg", @headers.fetch("notthere") { "omg" }
@headers.merge!("Host" => "http://example.test",
assert_equal({ "HTTP_HOST" => "http://example.test",
@headers.merge!("HTTP_HOST" => "http://first.com",
assert_equal({ "HTTP_HOST" => "http://first.com",
combined = @headers.merge("HTTP_HOST" => "http://example.com",
assert_equal({ "HTTP_HOST" => "http://example.com",
headers = make_headers({})
headers.merge! "rack.input" => "",
:Host => "test.com")
assert_equal({ "HTTP_REFERER" => "http://example.com/",
ran = 0
executor.to_run { total += 1; ran += 1 }
executor.to_complete { total += 1; completed += 1 }
stack.call({})
@cleaner.add_silencer { |line| !line.start_with?("lib") }
exc = begin ms_index; rescue TestError => ex; ex; end
code = {}
File.foreach(__FILE__).to_a.drop(lineno - 1).take(6).each_with_index do |line, i|
class_eval "def in_rack; index; end", "/gems/rack.rb", 43
id: 0,
trace: "lib/file.rb:42:in `index'"
trace: "/gems/rack.rb:43:in `in_rack'"
when "/pass"
get "/", headers: { "action_dispatch.show_exceptions" => true }
get "/", headers: { "action_dispatch.show_exceptions" => false }
get "/pass", headers: { "action_dispatch.show_exceptions" => true }
assert_match(/<body>/, body)
get "/not_found", headers: { "action_dispatch.show_exceptions" => true }
get "/", headers: xhr_request_env
assert_no_match(/<header>/, body)
assert_no_match(/<body>/, body)
Rails.stub :root, Pathname.new(".") do
assert_select "pre", { count: 0 }, body
@app = ApiApp
get "/", headers: { "action_dispatch.show_exceptions" => true }, as: :json
get "/not_found", headers: { "action_dispatch.show_exceptions" => true }, as: :json
get "/method_not_allowed", headers: { "action_dispatch.show_exceptions" => true }, as: :json
get "/unknown_http_method", headers: { "action_dispatch.show_exceptions" => true }, as: :json
get "/bad_request", headers: { "action_dispatch.show_exceptions" => true }, as: :json
get "/invalid_mimetype", headers: { "Accept" => "text/html,*", "action_dispatch.show_exceptions" => true }, as: :json
assert_select("b", /Did you mean\?/)
assert_select("li", "hello")
get "/index.html", headers: { "action_dispatch.show_exceptions" => true }
assert_match(/<header>/, body)
get "/index.xml", headers: { "action_dispatch.show_exceptions" => true }
param_encoder: -> params { params })
get "/index", headers: { "action_dispatch.show_exceptions" => true }, as: :wibble
get "/", params: { "foo" => "bar" }, headers: { "action_dispatch.show_exceptions" => true,
get("/runtime_error", headers: {
get "/", headers: { "action_dispatch.show_exceptions" => true, "action_dispatch.logger" => Logger.new(output) }
get "/", headers: { "action_dispatch.show_exceptions" => true, "action_dispatch.logger" => logger }
output = io.rewind && io.read
assert_match(/:\d+:in /, line)
assert_match(/puke/, io.rewind && io.read)
get "/", headers: env
get "/pass", headers: env
env = { "Accept" => "text/html,*",
bc.add_silencer { |line| line.match?(/method_that_raises/) }
get "/puke", headers: { "action_dispatch.show_exceptions" => true }
assert_select "#container p", /Showing #{__FILE__} where line #\d+ raised/
assert_equal({ "foo" => "bar" }, request.cookie_jar.to_hash)
assert_equal({ "foo" => "bar" }, request.cookie_jar.to_h)
value.to_s + " and loaded"
value.to_s + " was dumped"
@obj = obj
assert_equal({ "user_name" => "Jamie" }, response.cookies)
assert_equal({ "that & guy" => "foo & bar => baz" }, @response.cookies)
assert_not_equal({ "user_name" => "david" }, @response.cookies)
assert_equal({ "login" => "XJ-122", "user_name" => "david" }, @response.cookies)
assert_equal({ "user_name" => nil }, @response.cookies)
cookies.delete("user_name", path: "/path")
@request.host = "hawth.ca"
@request.host = "x.hawth.ca"
@request.host = "192.168.1.1"
@request.host = "admin.lvh.me"
@request.host = "x.y.z.t.com"
@policy.script_src -> { request.host }
@policy.script_src :self, -> { "foo.com" }, "bar.com"
get "/redirect", to: redirect("/")
render json: {}
get "/inline", to: "policy#inline"
get "/script-src", to: "policy#script_src"
get "/style-src", to: "policy#style_src"
get "/no-policy", to: "policy#no_policy"
get "/api", to: "policy#api"
get "/inline"
get "/conditional", params: { condition: "true" }
get "/conditional", params: { condition: "false" }
get "/style-src"
get "/no-policy"
p.script_src -> { :https }
p.style_src -> { :https }
assert_equal %(filename="argh+!\#$-123_|%26^`~.jpg"), disposition.ascii_filename
assert_equal "filename*=UTF-8''argh+!\#$-123_|&^`~.jpg", disposition.utf8_filename
Foo.a, Foo.b = 0, 0
ActionDispatch::Callbacks.before { |*args| Foo.a += 1; Foo.b += 1 }
Actions << "Action!"
location: "/",
error: "",
hash.keys.sort.each_with_object(+"") do |k, s|
value = "(#{dump_params_keys(value)})"
value = ""
s << ", " unless s.empty?
s << "#{k}#{value}"
post "/",
params: '{"entry":{"summary":"content..."}}',
put "/",
params: '{"request":{"summary":"content...","title":"JSON"}}',
assert_nothing_raised { post "/", headers: { "CONTENT_TYPE" => "application/json" } }
post "/?full=1",
params: '{"first-key":{"sub-key":"..."}}',
{ json: Proc.new { |data| raise Interrupt } }
end.new("rack.input" => StringIO.new('{"title":"JSON"}}'), "CONTENT_TYPE" => "application/json")
@options = {
get ":controller(/:action(/:id))"
assert_equal("http://test.host:1271/c/a/i",
@rewriter.rewrite(@routes, controller: "c", action: "a", id: "i", port: 1271)
assert_equal("https://test.host/c/a/i",
@rewriter.rewrite(@routes, protocol: "https", controller: "c", action: "a", id: "i")
@rewriter.rewrite(@routes, protocol: "https://", controller: "c", action: "a", id: "i")
@rewriter.rewrite(@routes, user: "david", password: "secret", controller: "c", action: "a", id: "i")
@rewriter.rewrite(@routes, user: "openid.aol.com/nextangler", password: "one two?", controller: "c", action: "a", id: "i")
@rewriter.rewrite(@routes, controller: "c", action: "a", id: "i", anchor: "anchor")
@rewriter.rewrite(@routes, controller: "c", action: "a", id: "i", anchor: Struct.new(:to_param).new("anchor"))
@rewriter.rewrite(@routes, controller: "c", action: "a", id: "i", anchor: Struct.new(:to_param).new("anc/hor"))
options = { controller: "foo", action: "bar", id: "3", only_path: true }
r.draw {
get ":controller(/:action(/:id(.:format)))"
get "/foo/(:bar/(:baz))/:zot", as: "fun",
baz: "baz",
zot: "zot")
def add_host!(app = W)
W.new.url_for controller: "c", action: "a", id: "i"
W.new.url_for(only_path: true, controller: "c", action: "a", anchor: "anchor")
W.new.url_for(only_path: true, controller: "c", action: "a", anchor: nil)
W.new.url_for(only_path: true, controller: "c", action: "a", anchor: false)
W.new.url_for(only_path: true, controller: "c", action: "a", anchor: Struct.new(:to_param).new("anchor"))
assert_equal("/c/a#%23anchor",
W.new.url_for(only_path: true, controller: "c", action: "a", anchor: Struct.new(:to_param).new("#anchor"))
W.new.url_for(only_path: true, controller: "c", action: "a", anchor: Struct.new(:to_param).new("name=user&email=user@domain.com"))
W.new.url_for(controller: "c", action: "a", id: "i")
W.new.url_for(host: "37signals.basecamphq.com", controller: "c", action: "a", id: "i")
W.new.url_for(subdomain: "api", controller: "c", action: "a", id: "i")
model = Class.new { def self.to_param; "api"; end }
W.new.url_for(subdomain: model, controller: "c", action: "a", id: "i")
W.new.url_for(subdomain: false, controller: "c", action: "a", id: "i")
W.new.url_for(subdomain: "", controller: "c", action: "a", id: "i")
assert_equal("http://127.0.0.1/c/a/i",
W.new.url_for(domain: "37signals.com", controller: "c", action: "a", id: "i")
W.new.url_for(subdomain: "mobile", tld_length: 2, controller: "c", action: "a", id: "i")
W.new.url_for(controller: "c", action: "a", id: "i", port: 3000)
W.new.url_for(controller: "c", action: "a", id: "i", protocol: "https")
W.new.url_for(controller: "c", action: "a", id: "i", protocol: "https:")
W.new.url_for(controller: "c", action: "a", id: "i", protocol: "https://")
W.new.url_for(controller: "c", action: "a", id: "i", protocol: "//")
W.new.url_for(controller: "c", action: "a", id: "i", protocol: false)
options = { controller: "foo", trailing_slash: true, action: "bar", id: "33" }
options = { trailing_slash: true, protocol: "https", controller: "foo", action: "bar", id: "33" }
options = { controller: "foo", trailing_slash: true }
options.update(action: "bar", id: "33")
options = { trailing_slash: true, controller: "foo", action: "bar", id: "33", only_path: true, anchor: "chapter7" }
url = W.new.url_for(trailing_slash: true, only_path: true, controller: "cont", action: "act", p1: "cafe", p2: "link")
W.new.url_for(controller: "c", action: "a", id: "i", protocol: "https", script_name: "/subdir")
w = Class.new {
r.draw { ActionDispatch.deprecator.silence { get ":controller(/:action(/:id(.:format)))" } }
add_host!(w)
w.new.url_for(controller: "c", action: "a", id: "i", protocol: "https")
get "this/is/verbose", to: "home#index", as: :no_args
get "home/sweet/home/:user", to: "home#index", as: :home
get "/home/sweet/home/:user", to: "home#index", as: :home
W.new.url_for(controller: "c", action: "a", id: "i", protocol: "https", script_name: nil, original_script_name: "/subdir")
assert_equal("/c/a?param=val",
W.new.url_for(only_path: true, controller: "c", action: "a", param: "val")
url = W.new.url_for(only_path: true, controller: "c", action: "a", p1: "X1", p2: "Y2")
url = W.new.url_for(only_path: true, controller: "c", action: "a", params: { domain: "foo", id: "1" })
assert_equal("/c/a?domain=foo&id=1", url)
request_params = ActionController::Parameters.new({ domain: "foo", id: "1", other: "BAD" })
url = W.new.url_for(only_path: true, controller: "c", action: "a", params: request_params.permit(:domain, :id))
url = W.new.url_for(only_path: true, controller: "c", action: "a", params: "p")
assert_equal("/c/a?params=p", url)
url = W.new.url_for(only_path: true, controller: "c", action: "a", query: { name: "Bob", category: "prof" })
url = W.new.url_for(only_path: true, controller: "c", action: "a", query: { person: { name: "Bob", position: "prof" }, hobby: "piercing" })
assert_match(%r(^/c/a/101), url)
get "posts.:format", to: "posts#index", as: :posts
get "/", to: "posts#index", as: :main
params = { action: :index, controller: :posts, format: :xml }
assert_equal("/c", W.new.url_for("controller" => "c", "only_path" => true))
assert_equal("/c/a", W.new.url_for("controller" => "c", "action" => "a", "only_path" => true))
assert_equal("/c/a", W.new.url_for(ActiveSupport::HashWithIndifferentAccess.new("controller" => "c", "action" => "a", "only_path" => true)))
assert_equal("/c/a", W.new.url_for(only_path: true, controller: "c", action: "a", id: Struct.new(:to_param).new(nil)))
assert_equal("/c/a?show=false", W.new.url_for(only_path: true, controller: "c", action: "a", show: false))
get "(:param1)/test(/:param2)" => "index#index",
param1: 1,
param1: /\d*/,
param2: /\d+/
url.split("?", 2).last.split("&").sort
get "/blog(/:year(/:month(/:day)))" => "posts#show_date",
:constraints => {
year: /(19|20)\d\d/,
:day => nil,
:month => nil
get "archive/:year", controller: "archive", action: "index",
defaults: { year: nil },
constraints: { year: /\d{4}/ },
as: "blog"
get "id_default(/:id)" => "foo#id_default", :id => 1
get "projects/:project_id" => "project#index", :as => "project"
get "clients" => "projects#index"
\d{5} #Prefix
(-\d{4})? #Suffix
}, :as => "geocode"
get "news(.:format)" => "news#index"
get "comment/:id(/:action)" => "comments#show"
get "ws/:controller(/:action(/:id))", ws: true
get "pages/:page_id/:controller(/:action(/:id))"
get ":controller(/:action(/:id))(.:format)"
define_method("test_#{url.gsub(/\W/, '_')}_#{i}") do
get URI("http://test.host" + route.to_s)
<a href="/"><img src="/images/button.png" /></a>
<div id="foo">
<ul>
<li class="item">hello</li>
<li class="item">goodbye</li>
</ul>
<div id="bar">
</form>
render plain: <<~XML
render html: '<div class="foo"></div>'.html_safe
render html: '<body class="foo"></body>'.html_safe
before_action { @dynamic_opt = "opt" }
controller_info = { "controller" => "test_case_test/test", "action" => "test_params" }
post :test_params, params: { foo: klass.new }
post :test_params, params: { id: 1 }
assert_equal({ "id" => "1", "controller" => "test_case_test/test", "action" => "test_params" }, ::JSON.parse(@response.body))
flash: { "test" => "value" }
flash: { "test_now" => "value_now" }
process :no_op, method: "GET", session: { "string" => "value1", symbol: "value2" }
get :no_op, session: { bar: "baz" }
get :no_op, session: { foo: "bar" }
get :no_op
get :no_op, session: { foo: "baz" }
params: { id: 7 }
process :test_uri, method: "GET", params: { id: 7 }
params: { q: "test" }
process :test_only_one_param, method: "GET", params: { left: true }
process :test_only_one_param, method: "GET", params: { right: true }
assert_select "root > map > area + p"
assert_select "root > area + p"
assert_select "root > area > p"
assert_generates "controller/action/7", { id: "7" }, { controller: "controller", action: "action" }
assert_generates "controller/action/5", { controller: "controller", action: "action", id: "5", name: "bob" }, {}, { name: "bob" }
assert_generates "controller/action/7", { id: "7", name: "bob" }, { controller: "controller", action: "action" }, { name: "bob" }
assert_generates "controller/action/7", { id: "7" }, { controller: "controller", action: "action", name: "bob" }, {}
assert_routing({ method: "post", path: "content" }, { controller: "content", action: "create" })
get "user" => "user#index"
set.draw { get("*path" => "pages#show") }
page: {
name: "Page name",
month: "4",
year: "2004",
day: "6"
assert_equal({ "action" => "foobar" }, parsed_params)
}, session: { "foo" => "bar" }, flash: { notice: "created" }
{ "controller" => "test_case_test/test", "action" => "test_params",
page: { name: "Page name", month: 4, year: 2004, day: 6 }
get :test_params, params: { format: "json", count: 999 }
get :test_params, params: { format: "json", id: 1 }
page = { name: "Page name", month: 4, year: 2004, day: 6 }
get :test_params, params: { page: page }
post :render_body, params: { bool_value: true, str_value: "string", num_value: 2 }, as: :json
post :test_params, params: { id: "12345" }, as: :json
post :render_body, params: { name: "foo.txt" }
post :render_body, params: { name: "foo.html" }
post :render_body, params: { name: "foo.fake" }
id: 20, foo: Object.new
get :test_params, params: { id: 20, foo: Object.new }
with_routing { raise "fail" }
@request.remote_addr = "192.0.0.1"
get :test_params, params: { id: 1 }, xhr: true
post :no_op, params: { foo: "bar" }
get :no_op, params: { foo: "bar" }
get :no_op, params: { foo: "baz" }
post :no_op, params: { foo: "baz" }
get :test_params, params: { id: "foo" }
get :test_format, params: { format: "html" }
get :test_format, params: { format: "json" }
get :test_format, params: { format: "xml" }
get :test_format, format: "json", params: { format: "html" }
params = { foo: "bar" }.freeze
post :test_params, params: { id: 1, foo: "an foo" }
assert_equal({ "id" => "1", "foo" => "an foo", "controller" => "test_case_test/test", "action" => "test_params" }, ::JSON.parse(@response.body))
get :test_params, params: { bar: "an bar" }
assert_equal({ "bar" => "an bar", "controller" => "test_case_test/test", "action" => "test_params" }, ::JSON.parse(@response.body))
FILES_DIR = File.expand_path("../fixtures/multipart", __dir__)
params: {
params: { q: "test1" }
params: { q: "test2" }
post :render_json, body: { foo: "heyo" }
assert_equal({ "foo" => "heyo" }, response.parsed_body)
post :render_json, body: { foo: "heyo" }.to_json, as: :json
head :ok, "C" => "3"
@defaults = { "A" => "1", "B" => "2" }
get :remove_header, params: { header: "A" }
get "/" => "bar#index"
get "/posts/:id", to: "anonymous#post", bucket_type: "post"
get "/projects/:id", to: "anonymous#project", defaults: { bucket_type: "project" }
get :post, params: { id: 1, bucket_type: "post" }
get :project, params: { id: 2 }
%w{ hello world }.each do |word|
get "/", params: { "detailed" => "0" }
get "/", params: { "detailed" => "1" }
get "/", headers: { "HTTP_ACCEPT" => "application/json" }
get "/", headers: { "HTTP_ACCEPT" => "application/xml" }
get "/", headers: { "HTTP_ACCEPT" => "text/json" }
def file_name() File.basename(__FILE__) end
def file_path() __FILE__ end
def file_data() @data ||= File.binread(file_path) end
@options ||= {}
options = { type: :png }
options = { type: nil }
response.body_parts.each { |part| output << part.to_s }
get __method__
get __method__, params: { filename: filename }
%w(file data).each do |method|
@controller.options = { type: "image/png" }
runner = MyRunner.new(Class.new { def x; end }.new)
hex = unsafe.map { |char| "%" + char.unpack1("H2").upcase }
@segment = "#{safe.join}#{unsafe.join}"
@escaped = "#{safe.join}#{hex.join}"
url_for(@set,
action: "act#{@segment}ion",
@rs = make_set
get "/:artist/:song-omg", to: lambda { |env|
assert_equal({ "artist" => "journey", "song" => "faithfully" }, hash)
get "/journey/:id", to: lambda { |env|
assert_equal({ "id" => "faithfully-omg" }, hash)
get "/:artist/:song-omg", constraints: { song: /\d+/ }, to: lambda { |env|
assert_equal({ "artist" => "journey", "song" => "123" }, hash)
get "/:artist/omg-:song", to: lambda { |env|
get "/:artist/omg-:song", constraints: { song: /\d+/ }, to: lambda { |env|
get "/*path", to: lambda { |env|
}, format: false
u = URI("http://example.org/foo/bar.html")
assert_equal u.path.delete_prefix("/"), get(u)
expected = { "path" => "foo/bar", "format" => "html" }
get "/(*filters)", to: lambda { |env|
u = URI("http://example.org/ne_27.065938,-80.6092/sw_25.489856,-82.542794")
expected = { "filters" => "ne_27.065938,-80.6092/sw_25.489856,-82",
get "/whois/:domain", constraints: {
assert_equal "id", get(URI("http://example.org/whois/123"))
get "/", constraints: { subdomain: "clients" },
assert_equal "default", get(URI("http://www.example.org/"))
get "/api", constraints: { format: :json },
get "/api", constraints: { format: :xml },
get "/", constraints: lambda { |req|
req.subdomain.present? && req.subdomain != "clients" },
req.subdomain.present? && req.subdomain == "clients" },
scope "/foo", constraints: lambda { |req| scope_called = true } do
assert_equal "default", get(URI("http://www.example.org/foo/"))
scope "/foo", constraints: lambda { |req| flunk "should not be called" } do
get "/", constraints: lambda { |req| inner_called = true },
assert_equal "Not Found", get(URI("http://example.org/"))
assert_equal "foo", get(URI("http://example.org/hello"))
get "/posts/:id(/*filters)", constraints: { filters: /.+?/ },
to: lambda { |e|
assert_equal "foo", get(URI("http://example.org/posts/1/foo.js"))
assert_equal({ id: "1", filters: "foo", format: "js" }, params)
mount lambda { } => "/foo"
url_for(rs, controller: "omg", action: "lol")
rs.draw { ActionDispatch.deprecator.silence { get "/:controller(/:action(/:id))" } }
assert_equal({ controller: "content", action: "show", id: "10" }, rs.recognize_path("/content/show/10"))
assert_equal({ controller: "admin/user", action: "show", id: "10" }, rs.recognize_path("/admin/user/show/10"))
assert_equal "/admin/user/show/10", url_for(rs, controller: "admin/user", action: "show", id: 10)
assert_equal({ controller: "admin/user", action: "list", id: "10" },
get "/:controller/:action/:id", action: "index", id: nil
get ":controller/:admintoken(/:action(/:id))", controller: /admin\/.+/
assert_equal({ controller: "admin/user", admintoken: "foo", action: "index" },
assert_equal({ controller: "content", action: "foo" },
get "/:controller(/:action(/:id))", controller: /admin\/(accounts|users)/
defaults: { file: nil },
url_for(rs, controller: "user", action: "download", file: "file")
assert_equal({ controller: "user", action: "download", file: "file" },
url_for(rs, controller: "user", action: "download", file: "file.jpg")
assert_equal({ controller: "user", action: "download", file: "file.jpg" },
root to: "content#list", as: "home"
get "page/:title" => "content#show_page", :as => "page"
get "page/:title" => "content#show_page", :title => "AboutPage", :as => "page"
scope "my" do
get "page" => "content#show_page", :as => "page"
scope "" do
get "admin/user" => "admin/user#index", :as => "users"
get "page" => "content#show_page", :as => "pages", :host => "foo.com"
get ":controller/:action/:id", as: "normal"
root "hello#index", as: :index
rs.draw { root nil }
assert_equal("http://test.host/?foo=bar", routes.root_url(foo: :bar))
get "page/:year/:month/:day/:title" => "page#show", :as => "article",
:year => /\d+/, :month => /\d+/, :day => /\d+/
routes.article_url(title: "hi", day: 10, year: 2005, month: 6)
get "file/*path" => "content#show_file", :as => "path"
get "/file/*path" => "content#index", :as => "path"
get "post/:id" => "post#show", :constraints => { id: /\d+/ }, :as => "post"
url_for(rs, controller: "post", action: "show", bad_param: "foo", use_route: "post")
get "*path" => "content#show_file"
url_for(rs, controller: "content", action: "show_file", path: %w(pages boo))
assert_equal({ controller: "content", action: "show_file", path: "pages/boo" },
get "page/:id(/:action)" => "pages#show"
assert_equal "/pages/boo", url_for(rs, controller: "pages", action: "boo")
get "page(/:id)" => "content#show_page", :id => 1
assert_equal "/page/10", url_for(rs, controller: "content", action: "show_page", id: 10)
assert_equal({ controller: "content", action: "show_page", id: 1 }, rs.recognize_path("/page"))
assert_equal({ controller: "content", action: "show_page", id: "1" }, rs.recognize_path("/page/1"))
assert_equal({ controller: "content", action: "show_page", id: "10" }, rs.recognize_path("/page/10"))
get "page/:id" => "content#show_page", :id => 1
assert_equal "/page/foo", url_for(rs, controller: "content", action: "show_page", id: "foo")
assert_equal({ controller: "content", action: "show_page", id: "foo" }, rs.recognize_path("/page/foo"))
token = +"\321\202\320\265\320\272\321\201\321\202" # 'text' in Russian
assert_equal "/page/" + escaped_token, url_for(rs, controller: "content", action: "show_page", id: token)
assert_equal({ controller: "content", action: "show_page", id: token }, rs.recognize_path("/page/#{escaped_token}"))
rs.draw { ActionDispatch.deprecator.silence { get ":controller(/:action(/:id))" } }
assert_equal "/post/10", url_for(rs, controller: "post", action: "show", id: 10)
url_for(rs, controller: "post", action: "show")
get("test(/:year)" => "post#show", :as => "blog",
:defaults => { year: nil },
:constraints => { year: /\d{4}/ }
assert_equal "/test", url_for(rs, controller: "post", action: "show")
assert_equal "/test", url_for(rs, controller: "post", action: "show", year: nil)
get "pages(/:year(/:month(/:day)))" => "content#list_pages", :month => nil, :day => nil
url_for(rs, controller: "content", action: "list_pages", year: 2005, month: 6)
url_for(rs, controller: "content", action: "list_pages", year: 2005, month: 6, day: 12)
get URI("http://test.host/pages/2005/6/12")
assert_equal({ controller: "content", action: "list_pages", year: "2005", month: "6", day: "12" },
assert_equal "/", url_for(rs, controller: "content", action: "index")
assert_equal "/", url_for(rs, controller: "content")
root to: "content#index", as: "home"
get "categories" => "content#categories", :as => "categories"
assert_equal "/content/hi", url_for(rs, controller: "content", action: "hi")
get "journal" => "content#list_journal",
:date => nil, :user_id => nil
date: nil,
user_id: nil)
match "/match" => "books##{method}", :via => method.to_sym
put "/match" => "books#not_get_or_post"
params = rs.recognize_path("/match", method: :put)
get "/items/:id/:action" => "subpath_books"
get "/posts/new/:action" => "subpath_books"
get "foos/:id" => "foos#show", :as => "foo_with_requirement", :constraints => { id: /\d+/ }
get "ca" => "ca#aa"
get "cb" => "cb#ab"
get "cc" => "cc#ac"
hash = rs.recognize_path "/cc"
get "/plain" => "c#plain"
get "/:symbol" => "c#symbol"
get "/glob/*" => "c#glob"
get "/with#anchor" => "c#with_anchor"
get "/more/plain" => "c#plain"
get "/more/:symbol" => "c#symbol"
get "/more/glob/*" => "c#glob"
get "/more/with#anchor" => "c#with_anchor"
@set = make_set
path, extras = set.generate_extras(controller: "foo", action: "bar", id: 15, this: "hello", that: "world")
extras = set.extra_keys(controller: "foo", action: "bar", id: 15, this: "hello", that: "world")
url_for(set, controller: "foo", action: "bar", id: 15, this: "hello")
get "/hello/world" => "a#b"
get "/users/index" => "users#index"
get "/hello/world" => "a#b", :as => "hello"
get "/people(/:id)" => "people#show", :as => "show"
get "/people" => "people#index", :as => "index"
get "/people/go/:foo/:bar/joe(/:id)" => "people#multi", :as => "multi"
get "/admin/users" => "admin/users#index", :as => "users"
controller.multi_url(7, "hello", 5, baz: "bar", anchor: "location")
controller.multi_url(7, "hello", 5, baz: "bar")
controller.multi_url(7, "hello", 5, {})
assert_equal "/users/index/10", url_for(set, controller: "users", id: 10)
assert_equal({ controller: "users", action: "index", id: "10" }, set.recognize_path("/users/index/10"))
assert_equal({ controller: "users", action: "index", id: "10" }, set.recognize_path("/users/index/10/"))
get "page/:id" => "pages#show", :id => /\d+/
assert_equal({ controller: "pages", action: "index" }, request_path_params("/pages"))
assert_equal({ controller: "pages", action: "list" }, request_path_params("/pages/list"))
assert_equal({ controller: "pages", action: "show", id: "10" }, request_path_params("/pages/show/10"))
assert_equal({ controller: "pages", action: "show", id: "10" }, request_path_params("/page/10"))
get "page/:id" => "pages#show", :constraints => { host: /^foo$/ }
get "page/:id" => "pages#show", :id => /^\d+/
get "page/:id" => "pages#show", :id => /\A\d+/
get "page/:id" => "pages#show", :id => /\d+$/
get "page/:id" => "pages#show", :id => /\d+\Z/
get "page/:id" => "pages#show", :id => /\d+\z/
match "valid/route" => "pages#show", :via => :options
assert_equal({ controller: "pages", action: "show", id: "hello+world" }, request_path_params("/page/hello+world"))
delete "/people/:id" => "people#destroy"
match "/people" => "people#index", :as => "people", :via => :get
params = request_path_params("/", method: :get)
:year => /\d{4}/, :day => /\d{1,2}/, :month => /\d{1,2}/
get "/profile" => "profile#index"
get "people/:id" => "people#show", :as => "person"
put "people/:id" => "people#update"
patch "people/:id" => "people#update"
get "people/:id(.:format)" => "people#show"
get "/people", controller: "people", action: "index"
get "/people/list", controller: "people", action: "list"
url = url_for(set, controller: "people", action: "list")
set.draw { root to: "people#index" }
params = request_path_params("", method: :get)
params = request_path_params("/api", method: :get)
scope module: "api", path: "prefix" do
scope module: "api", path: "" do
get "about" => "welcome#about"
get URI("http://test.host/welcom/get/7")
action: "about",
args = { controller: "foo", action: "bar", id: "7", x: "y" }
assert_equal "/my/foo/bar/7?x=y", url_for(set, args)
assert_equal "/foo/bar/7?x=y", url_for(set, args)
get "/connection" => "connection#index", :as => "family_connection"
action: "index")
action: "edit", parameter: 1, only_path: true)
get "/posts(.:format)" => "posts#index"
assert_equal({ controller: "posts", action: "index", format: "xml" },
controller: "posts", format: "xml", only_path: true)
{ controller: "weblog", action: "show", project_id: "1" },
get "milestones" => "milestones#index", :as => "milestones"
get "page/:name" => "pages#show",
:constraints => { name: /(david|jamis)/m }
:constraints => { name: /(david|jamis)/i }
( #Either
| #Or
)/x }
get "page/:name" => "pages#show", :constraints => lambda { |request|
assert_equal({ controller: "pages", action: "show", name: "mypage" },
assert_equal({ controller: "pages", action: "show", name: "jamis" }, set.recognize_path("/page/jamis"))
assert_equal({ controller: "pages", action: "show", name: "DAVID" }, set.recognize_path("/page/DAVID"))
url = url_for(set, controller: "pages", action: "show", name: "david")
url_for(set, controller: "pages", action: "show", name: "davidjamis")
url = url_for(set, controller: "pages", action: "show", name: "JAMIS")
assert_equal({ controller: "pages", action: "show", name: "david" }, set.recognize_path("/page/david"))
)/xi }
assert_equal({ controller: "pages", action: "show", name: "JAMIS" },
url_for(set, controller: "pages", action: "show", name: "JAMIS")
get "named", controller: :pages, action: :show, name: :as_symbol, as: :named
assert_equal({ controller: "pages", action: "show", name: :as_symbol }, set.recognize_path("/unnamed"))
assert_equal({ controller: "pages", action: "show", name: :as_symbol }, set.recognize_path("/named"))
get "/" => "foo#index"
get "/hello" => "bar#index"
assert_equal({ controller: "foo", action: "index" }, set.recognize_path("/"))
assert_equal({ controller: "bar", action: "index" }, set.recognize_path("/hello"))
get "/cars/:action/:person/:car/", controller: "cars"
assert_equal "/cars/buy/1/2", url_for(set, controller: "cars", action: "buy", person: "1", car: "2")
assert_equal({ controller: "cars", action: "buy", person: "1", car: "2" }, set.recognize_path("/cars/buy/1/2"))
assert_equal({ controller: "books", action: "list" }, set.recognize_path("/books/list.rss"))
assert_equal "/books/list.rss", url_for(set, controller: "books", action: "list", format: "rss")
assert_equal "/books/list.xml", url_for(set, controller: "books", action: "list", format: "xml")
assert_equal({ controller: "books", action: "list", format: "rss" }, set.recognize_path("/books/list.rss"))
assert_equal({ controller: "books", action: "list", format: "xml" }, set.recognize_path("/books/list.xml"))
assert_equal({ controller: "books", action: "index" }, set.recognize_path("/books"))
set.draw { ActionDispatch.deprecator.silence { get("/:controller(/:action(/:id))") } }
assert_equal "/content/show/1", url_for(set, controller: "content", action: "show", id: "1")
assert_equal({ controller: "content", action: "show", id: "1" }, set.recognize_path("/content/show/1"))
expected = { controller: "pages", action: "show", id: "10" }
expected = { controller: "pages", action: "show", id: "hello world" }
assert_uri_equal "/foo?x=1&y=2", url_for(default_route_set, controller: "foo", x: "1", y: "2")
assert_uri_equal "/foo?x=1&y=2", url_for(default_route_set, controller: "foo", x: 1, y: 2)
get "dummy/page/:page" => "dummy#show"
get "dummy/dots/page.:page" => "dummy#dots"
get "ibocorp(/:page)" => "ibocorp#show",
:constraints => { page: /\d+/ },
:defaults => { page: 1 }
assert_equal "/ibocorp", url_for(set, controller: "ibocorp", action: "show", page: 1)
get "blog/", controller: "blog", action: "index"
get "blog(/:year(/:month(/:day)))",
action: "show_date",
day: nil, month: nil
get "blog/show/:id", controller: "blog", action: "show", id: /\d+/
get "blog/:controller/:action(/:id)"
recognize_path = ->(path) {
get(URI("http://example.org" + path))
assert_equal({ controller: "blog", action: "index" }, recognize_path.("/blog"))
assert_equal({ controller: "blog", action: "show", id: "123" }, recognize_path.("/blog/show/123"))
assert_equal({ controller: "blog", action: "show_date", year: "2004", day: nil, month: nil }, recognize_path.("/blog/2004"))
assert_equal({ controller: "blog", action: "show_date", year: "2004", month: "12", day: nil }, recognize_path.("/blog/2004/12"))
assert_equal({ controller: "blog", action: "show_date", year: "2004", month: "12", day: "25" }, recognize_path.("/blog/2004/12/25"))
assert_equal({ controller: "articles", action: "edit", id: "123" }, recognize_path.("/blog/articles/edit/123"))
assert_equal({ controller: "blog", action: "unknown_request", anything: "junk" }, recognize_path.("/junk"))
path, qs = uri.split("?")
qs = qs.split("&").sort.join("&") if qs
qs ? "#{path}?#{qs}" : path
get "legacy/people" => "people#index", :legacy => "true"
match ":controller(/:action(/:id))(.:format)", via: :all
assert_equal({ controller: "admin/users", action: "new" }, @routes.recognize_path("/admin/users/new", method: :get))
assert_equal({ controller: "admin/users", action: "show", id: "1" }, @routes.recognize_path("/admin/users/1", method: :get))
assert_equal({ controller: "admin/users", action: "update", id: "1" }, @routes.recognize_path("/admin/users/1", method: :put))
assert_equal({ controller: "admin/users", action: "destroy", id: "1" }, @routes.recognize_path("/admin/users/1", method: :delete))
assert_equal({ controller: "admin/users", action: "edit", id: "1" }, @routes.recognize_path("/admin/users/1/edit", method: :get))
assert_equal({ controller: "admin/posts", action: "new" }, @routes.recognize_path("/admin/posts/new", method: :get))
assert_equal({ controller: "api/users", action: "index" }, @routes.recognize_path("/api", method: :get))
assert_equal({ controller: "api/users", action: "index" }, @routes.recognize_path("/api/", method: :get))
assert_equal({ controller: "posts", action: "show_date", year: "2009", month: nil, day: nil }, @routes.recognize_path("/blog/2009", method: :get))
assert_equal({ controller: "posts", action: "show_date", year: "2009", month: "01", day: nil }, @routes.recognize_path("/blog/2009/01", method: :get))
assert_equal({ controller: "posts", action: "show_date", year: "2009", month: "01", day: "01" }, @routes.recognize_path("/blog/2009/01/01", method: :get))
assert_equal({ controller: "archive", action: "index", year: "2010" }, @routes.recognize_path("/archive/2010"))
assert_equal({ controller: "people", action: "index" }, @routes.recognize_path("/people", method: :get))
assert_equal({ controller: "people", action: "index", format: "xml" }, @routes.recognize_path("/people.xml", method: :get))
assert_equal({ controller: "people", action: "create" }, @routes.recognize_path("/people", method: :post))
assert_equal({ controller: "people", action: "new" }, @routes.recognize_path("/people/new", method: :get))
assert_equal({ controller: "people", action: "show", id: "1" }, @routes.recognize_path("/people/1", method: :get))
assert_equal({ controller: "people", action: "show", id: "1", format: "xml" }, @routes.recognize_path("/people/1.xml", method: :get))
assert_equal({ controller: "people", action: "update", id: "1" }, @routes.recognize_path("/people/1", method: :put))
assert_equal({ controller: "people", action: "destroy", id: "1" }, @routes.recognize_path("/people/1", method: :delete))
assert_equal({ controller: "people", action: "edit", id: "1" }, @routes.recognize_path("/people/1/edit", method: :get))
assert_equal({ controller: "people", action: "edit", id: "1", format: "xml" }, @routes.recognize_path("/people/1/edit.xml", method: :get))
assert_equal({ controller: "symbols", action: "show", name: :as_symbol }, @routes.recognize_path("/symbols"))
assert_equal({ controller: "foo", action: "id_default", id: "1" }, @routes.recognize_path("/id_default/1"))
assert_equal({ controller: "foo", action: "id_default", id: "2" }, @routes.recognize_path("/id_default/2"))
assert_equal({ controller: "foo", action: "id_default", id: 1 }, @routes.recognize_path("/id_default"))
assert_equal({ controller: "foo", action: "get_or_post" }, @routes.recognize_path("/get_or_post", method: :get))
assert_equal({ controller: "foo", action: "get_or_post" }, @routes.recognize_path("/get_or_post", method: :post))
assert_equal({ controller: "posts", action: "index", optional: "bar" }, @routes.recognize_path("/optional/bar"))
assert_equal({ controller: "posts", action: "show", id: "1", ws: true }, @routes.recognize_path("/ws/posts/show/1", method: :get))
assert_equal({ controller: "posts", action: "list", ws: true }, @routes.recognize_path("/ws/posts/list", method: :get))
assert_equal({ controller: "posts", action: "index", ws: true }, @routes.recognize_path("/ws/posts", method: :get))
assert_equal({ page_id: "1", controller: "notes", action: "index" }, @routes.recognize_path("/pages/1/notes", method: :get))
assert_equal({ page_id: "1", controller: "notes", action: "list" }, @routes.recognize_path("/pages/1/notes/list", method: :get))
assert_equal({ page_id: "1", controller: "notes", action: "show", id: "2" }, @routes.recognize_path("/pages/1/notes/show/2", method: :get))
assert_equal({ controller: "posts", action: "ping" }, @routes.recognize_path("/posts/ping", method: :get))
assert_equal({ controller: "posts", action: "index" }, @routes.recognize_path("/posts", method: :get))
assert_equal({ controller: "posts", action: "index" }, @routes.recognize_path("/posts/index", method: :get))
assert_equal({ controller: "posts", action: "show" }, @routes.recognize_path("/posts/show", method: :get))
assert_equal({ controller: "posts", action: "show", id: "1" }, @routes.recognize_path("/posts/show/1", method: :get))
assert_equal({ controller: "news", action: "index" }, @routes.recognize_path("/", method: :get))
assert_equal({ controller: "news", action: "index", format: "rss" }, @routes.recognize_path("/news.rss", method: :get))
params = { controller: "people" }
params = { controller: "people", foo: "bar" }
assert_equal({ controller: "people", foo: "bar" }, params)
params = { controller: "people", action: "create", person: { name: "Josh" } }
assert_equal({ controller: "people", action: "create", person: { name: "Josh" } }, params)
params = { controller: "people", action: "create", domain: { foo: "Josh" } }
assert_equal({ controller: "people", action: "create", domain: { foo: "Josh" } }, params)
collection_methods = { rss: :get, reorder: :post, csv: :post }
member_methods = { rss: :get, atom: :get, upload: :post, fix: :post }
path_names = { new: "nuevo", rss: "canal", fix: "corrigir" }
expected_options = { controller: "messages", action: "show", id: "1.1.1" }
expected_options = { controller: "messages", action: "show", thread_id: "1.1.1", id: "1" }
expected_options = { controller: "messages", action: "custom", id: "1.1.1" }
actions = { "a" => :get, "b" => :put, "c" => :post, "d" => :delete, "e" => :patch }
assert_restful_routes_for :messages, path_prefix: "threads/1/", name_prefix: "thread_", options: { thread_id: "1" } do |options|
actions = { "a" => :get }
get :a, on: :collection
get :a, on: :member
mark_options = { action: "mark", id: "1" }
expected_options = { controller: "messages", action: "mark", id: "1.1.1" }
with_restful_routing :messages, member: { mark: method }, path_names: { new: "nuevo" } do
mark_options = { action: "mark", id: "1", controller: "messages" }
action_options = { action: action, id: "1" }
preview_options = { action: "preview" }
preview_options = { action: "preview", thread_id: "1" }
preview_options = { action: "preview", thread_id: "1", format: "xml" }
name_prefix: "thread_",
path_prefix: "threads/1/",
options: { thread_id: "1" }
options: { thread_id: "1", message_id: "2" }
options: { message_id: "2" }
options: { product_id: "1" }
reset_options = { action: "reset" }
scope ":site_id" do
assert_singleton_restful_for :account, path_prefix: "7/", options: { site_id: "7" }
assert_simply_restful_for :messages, name_prefix: "account_", path_prefix: "7/account/", options: { site_id: "7" }
assert_singleton_restful_for :admin, controller: "admin", name_prefix: "thread_", path_prefix: "threads/5/", options: { thread_id: "5" }
get :preview, on: :new
assert_simply_restful_for :messages, name_prefix: "thread_", path_prefix: "threads/1/", options: { thread_id: "1" }
get :login, on: :member
assert_recognizes({ controller: "messages", action: "index" }, "/messages/")
assert_recognizes({ controller: "messages", action: "index" }, "/reviews/")
assert_simply_restful_for :tutor_reviews, controller: "comments", as: "reviews", name_prefix: "tutor_", path_prefix: "tutors/1/", options: { tutor_id: "1" }
assert_recognizes({ controller: "products", action: "sale", format: "xml" }, { path: "products/sale.xml", method: :get })
match "/products", to: "products#show", via: :all
assert_routing({ method: "all", path: "/products" }, { controller: "products", action: "show" })
scope(path_prefix || "") do
set.draw { resource(*args) }
edit_action = "edit"
assert_named_route "#{full_path}/#{new_action}.xml", "new_#{name_prefix}#{singular_name}_path", route_options.merge(format: "xml")
path_options = { path: path, method: method }
post :arbitrary_action, body: "{", as: :json
post :create, params: { magazine: { name: "Mjallo!" } }
post :create, params: { book: { title: "Mjallo!" } }
post :create, params: { boko: { name: "Mjallo!" } }
post :create, params: { book: { naem: "Mjallo!" } }
post :create, params: { book: { name: "Mjallo!" } }
post :create, params: { book: { name: false } }
assert_equal({ nested: { key: "value" } }.to_param, params.to_param)
params = { root: ActionController::Parameters.new(nested: { key: "value" }).permit! }
assert_equal({ root: { nested: { key: "value" } } }.to_param, params.to_param)
assert_equal({ nested: { key: "value" } }.to_query, params.to_query)
assert_equal({ root: { nested: { key: "value" } } }.to_query, params.to_query)
render inline: "<%= form_tag('/') {} %>"
render inline: "<%= button_to('New', '/') %>"
render inline: "<%= form_for(:some_resource, :remote => true ) {} %>"
render inline: "<%= form_for(:some_resource, :remote => true, :authenticity_token => true ) {} %>"
render inline: "<%= form_for(:some_resource, :authenticity_token => true ) {} %>"
render inline: "<%= form_for(:some_resource, :remote => true, :authenticity_token => 'external_token') {} %>"
render inline: "<%= form_with(scope: :some_resource) {} %>"
render inline: "<%= form_with(scope: :some_resource, authenticity_token: true) {} %>"
render inline: "<%= form_with(scope: :some_resource, local: true, authenticity_token: true) {} %>"
render inline: "<%= form_with(scope: :some_resource, authenticity_token: 'external_token') {} %>"
render js: "foo();"
assert_blocked { post :index, format: "xml" }
patch :index, params: { custom_authenticity_token: { foo: "bar" } }
@controller.stub :form_authenticity_token, @token + "<=?" do
regexp = "#{@token}&lt;=\?"
post :index, params: { custom_token_name: "foobar" }
post :index, params: { custom_token_name: "bazqux" }
actual = @controller.send(:per_form_csrf_token, nil, "/path", "post").size
get :button_to, params: { form_method: "delete" }
get :button_to, params: { form_method: verb }
get :index, params: { form_path: "/per_form_tokens/post_one?foo=bar" }
get :index, params: { form_path: "/per_form_tokens/post_one/" }
get :index, params: { form_path: "https://example.com/per_form_tokens/post_one/" }
get :index, params: { form_method: "POST" }
@id_was = id_was
value: {
}.to_json,
same_site: :lax,
hash = { a: :b, c: :d, e: :f }
def to_json(options = {})
type.any(:js, :xml) { render body: "Either JS or XML" }
self.response_body = "Simon says: #{says}"
new_defaults = { https: true }
content = new_renderer.render(inline: "<%= request.ssl? %>")
locals: { secret: "bar" }
assigns: { secret: "foo" }
content = renderer.render inline: "<%= request.ssl? %>"
html = "Hello world!"
assert_equal "<p>1\n<br />2</p>", render(inline: '<%= simple_format "1\n2" %>')
content = renderer.new.render inline: "<%= request.ssl? %>"
def render(...)
renderer.render(...)
render inline: "<%= full_url_for(*#{args.inspect}) %>"
render xml: "<hello/>", location: "http://example.com", status: 201
assert_equal "<i-am-xml/>", @response.body
assert_equal "<i-am-THE-xml/>", @response.body
etag { "ab" }
etag { :cde }
render plain: "stale" if stale?(etag: %w(1 2 3), template: false)
fresh_when(etag: "123")
fresh_when(etag: "abc")
record = Struct.new(:updated_at, :cache_key).new(ts, "foo/123")
old_record = Struct.new(:updated_at, :cache_key).new(ts - 1.day, "bar/123")
expires_in 1.minute, :public => true, "s-maxage" => 5.hours
expires_in 1.minute, :public => true, :private => nil, "s-maxage" => 5.hours
head :ok, "Content-Type" => "application/pdf"
head :ok, location: "/foo"
head :ok, "WWW-Authenticate" => "something"
head(:ok) && return
format.any { head 200 }
key = name + ".erb"
get :dynamic_render_with_file, params: { id: '../\\../test/abstract_unit.rb' }
get :dynamic_render, params: { id: file.path }
get :dynamic_render, params: { id: '../\\../test/abstract_unit.rb' }
get :dynamic_render_permit, params: { id: { file: '../\\../test/abstract_unit.rb' } }
get :dynamic_render, params: { id: { file: '../\\../test/abstract_unit.rb' } }
time = Time.mktime(2011, 10, 30)
@request.if_none_match = '"234"'
@request.if_none_match = "*"
@request.if_none_match = '"strong"'
@request.if_none_match = %("nomatch")
get :head_with_symbolic_status, params: { status: "ok" }
assert_equal '{"hello":"world"}', @response.body
assert_equal '/**/alert({"hello":"world"})', @response.body
assert_equal '{"a":"b"}', @response.body
render js: "alert('hello')"
get :show_partial, format: "js", xhr: true
redirect_to({ action: "hello_world" }, { status: 301 })
redirect_to url_from("/")
redirect_to proc { "http://www.rubyonrails.org/" }
@url = "http://www.rubyonrails.org/"
redirect_to proc { @url }
redirect_to proc { { action: "hello_world" } }
url_for action: "dashboard", params: { "id" => id, "message" => message }
post :create, params: { person: { name: "Mjallo!" } }
post :create_with_permit, params: { person: { name: "Mjallo!" } }
post :parse, params: { "username" => "sikachu" }
assert_parameters("username" => "sikachu", "user" => { "username" => "sikachu" })
post :parse, params: { "username" => "sikachu", "color" => "blue", "size" => "large" }
assert_parameters("username" => "sikachu", "color" => "blue", "size" => "large",
assert_parameters("username" => "sikachu", "person" => { "username" => "sikachu" })
post :parse, params: { "username" => "sikachu", "title" => "Developer" }
assert_parameters("username" => "sikachu", "title" => "Developer", "user" => { "username" => "sikachu" })
assert_parameters("username" => "sikachu", "title" => "Developer", "person" => { "username" => "sikachu" })
assert_parameters("username" => "sikachu", "title" => "Developer")
assert_parameters("username" => "sikachu", "title" => "Developer", "user" => { "username" => "sikachu", "title" => "Developer" })
post :parse, params: { "authenticity_token" => "pwned", "_method" => "put", "utf8" => "&#9731;", "username" => "sikachu" }
post :parse, params: { "user" => { "username" => "sikachu" } }
assert_parameters("user" => { "username" => "sikachu" })
post :parse, params: { "user" => nil }
post :parse, params: { "person" => { "username" => "sikachu" } }
assert_parameters("person" => { "username" => "sikachu" }, "user" => { "person" => { "username" => "sikachu" } })
get :parse, params: { "user" => { "username" => "nixon" } }
assert_equal({ "controller" => "params_wrapper_test/users", "action" => "parse", "user" => { "username" => "nixon" } }, @request.filtered_parameters)
post :parse, params: {}
{ person: {} }
post :parse, params: { "username" => "sikachu", "person_attributes" => { "title" => "Developer" } }
{ "nick" => "username" }
post :parse, params: { "nick" => "sikachu", "title" => "Developer" }
assert_parameters({ "nick" => "sikachu", "title" => "Developer", "user" => { "nick" => "sikachu" } })
assert_parameters("username" => "sikachu", "title" => "Developer", "user" => { "title" => "Developer" })
assert_parameters("username" => "sikachu", "guest" => { "username" => "sikachu" })
post :parse, params: { "username" => "sikachu", "test_attr" => "test_value" }
assert_parameters("username" => "sikachu", "test_attr" => "test_value", "paramswrappernews_item" => { "test_attr" => "test_value" })
post :create, body: "{", as: :json
key1: {}
post :yaml_params, params: { person: { name: "Mjallo!" } }
key1: {
payload = <<~end_of_yaml
book: { pages: 65 },
book: { pages: 65, title: "Green Cats and where to find then." })
person: {
age: "32",
name: {
first: "David",
%w(0 1 12).each do |number|
@struct_fields << "sf(#{number}#{suffix})"
params.each do |k, v|
v.each { |x| walk_permitted v }
hash = { "foo" => { "bar" => { "0" => { "baz" => "hello", "zot" => "1" } } } }
username: "fxn",
font: {
hacked: 1 # not a hash
params.fetch :foo, {}
20.times { |i|
assert_equal "monkey", @params.fetch(:foo) { "monkey" }
assert_nil @params.fetch(:foo) { nil }
params.fetch(:missing_key) { {}.fetch(:also_missing) }
age: "32", name: { first: "David", last: "Heinemeier Hansson" }
assert_equal({ "crab" => "Senjougahara Hitagi" }, params.to_h)
assert_equal({ a: 1 }, { a: 1 }.merge!(params))
assert_equal({ "crab" => "Senjougahara Hitagi" }, params.to_hash)
def dup; @dupped = true; end
assert_equal({ "prem" => { "likes" => %i( dancing ) } }, params.permit!.to_h)
assert_equal({ "prem" => { "likes" => %i( dancing ) } }, params.to_unsafe_h)
ActionController::Parameters.new({ foo: 1 } => :bar)
book: {
born: "1564-04-26"
details: {
id: {
isbn: "x"
magazine: "Mjallo!")
{ name: "William Shakespeare", born: "1564-04-26" },
{ "authors_attributes" => { "1" => { "name" => "Unattributed Assistant" } } },
product: {
assert_predicate @params.delete_if { |k| k == "person" }, :permitted?
assert_not_predicate @params.delete_if { |k| k == "person" }, :permitted?
assert_predicate @params.keep_if { |k, v| k == "person" }, :permitted?
assert_not_predicate @params.keep_if { |k, v| k == "person" }, :permitted?
assert_predicate @params.reject! { |k| k == "person" }, :permitted?
assert_not_predicate @params.reject! { |k| k == "person" }, :permitted?
assert_predicate @params.select! { |k| k != "person" }, :permitted?
assert_not_predicate @params.select! { |k| k != "person" }, :permitted?
request_params = { book: { pages: 65 }, fishing: "Turnips" }
context = { "action" => "my_action", "controller" => "my_controller" }
request_params = { book: { pages: 65 }, fishing: "Turnips", car: "Mercedes" }
book: { pages: 65, title: "Green Cats and where to find then.", author: "G. A. Dog" })
request_params = { book: { pages: 65, title: "Green Cats and where to find then.", author: "G. A. Dog" } }
request_params = { book: { pages: 3, author: "YY" } }
request_params = { food: "tomato", fishing: "Turnips", car: "Mercedes", music: "No. 9" }
request_params = { book: { pages: 48, title: "Hope" } }
params.select { |k| k == "music" }.permit(:food)
params.reject { |k| k == "music" }.permit(:food)
request_params = { food: "tomato", fishing: "Turnips", car: nil, music: nil }
request_params = { food: "tomato" }
@hash = @params.each_pair.to_h
@params1 = ActionController::Parameters.new({ foo: {} })
assert params.has_value?("bar" => "baz")
format: "json")
assert_same @params, @params.each { |_| _ }
assert_same @params, @params.each_pair { |_| _ }
assert_same @params, @params.each_value { |_| _ }
assert_equal '{"person"=>{"age"=>"32", "name"=>{"first"=>"David", "last"=>"Heinemeier Hansson"}, ' \
@params.each { |key, value| assert(value.permitted?) if key == "person" }
@params.each { |key, value| assert_not(value.permitted?) if key == "person" }
@params.each_pair { |key, value| assert(value.permitted?) if key == "person" }
@params.each_pair { |key, value| assert_not(value.permitted?) if key == "person" }
@params.each_key { |key| assert_kind_of(String, key) if key == "person" }
assert_not_predicate @params.reject { |k| k == "person" }, :permitted?
assert_predicate @params.reject { |k| k == "person" }, :permitted?
assert_predicate @params.select { |k| k == "person" }, :permitted?
assert_not_predicate @params.select { |k| k == "person" }, :permitted?
params1 = ActionController::Parameters.new(a: 1, b: 2).permit(:a, :b)
assert(@params != "Hello")
assert(@params != 42)
assert_equal "Bill", @params.dig(:person, :name, :first)
post :test_undeclared_parameter, params: { "foo" => "foo" }
post :test_skip_parameter_encoding, params: { "bar" => "bar" }
post :test_param_encoding, params: { "baz" => "baz", "qux" => "qux" }
post :test_all_values_encoding, params: { "foo" => "foo", "bar" => "bar", "baz" => "baz" }
assert_equal "&lt;&gt;&quot;", ERB::Util.h("<>\"")
assert_equal "<", ERB::Util.h("<".html_safe)
render template: "locals", locals: { secret: "area51" }
render template: "/locals", locals: { secret: "area51" }
render "/locals", locals: { secret: "area51" }
get :builder_template, params: { "format" => "xml" }
get :with_implicit_raw, params: { format: "text" }
assert_response "{ final: json }"
assert_body "b\r\nHello world\r\nb\r\n, I'm here!\r\n0\r\n\r\n"
assert_body "b\r\nHello world\r\n0\r\n\r\n"
assert_body "d\r\n<body class=\"\r\n37\r\n\"><script>window.location = \"/500.html\"</script></html>\r\n0\r\n\r\n"
assert_body "37\r\n\"><script>window.location = \"/500.html\"</script></html>\r\n0\r\n\r\n"
get "/render_streaming/basic/hello_world", headers: { "HTTP_VERSION" => "HTTP/1.0" }
@ivar = "hello world"
get :index, params: { format: "xml" }
get :explicit, params: { format: "js" }
get :index, params: { format: "js" }
action_name = %w(.. .. fixtures shared).join(File::SEPARATOR)
action_name = %w(evil .. .. path).join(File::SEPARATOR)
render html: "<p>hello world</p>", layout: nil
render html: "<p>hello world</p>".html_safe, layout: nil
assert_body "&lt;p&gt;hello world&lt;/p&gt;"
assert_body "<p>hello world</p>"
self.view_paths = __dir__
render file: File.expand_path("../../fixtures/test/hello_world.erb", __dir__)
assert_response "The secret is <%= @secret %>\n"
assert_response "<html>\n<p>Hello</p>\n</html>\n"
result = @app.call(env)
result = @app.call(env_for("/"))
get "/content_type/implied/i_am_xml_erb", params: { "format" => "xml" }
get "/content_type/implied/i_am_xml_builder", params: { "format" => "xml" }
get "/content_negotiation/basic/hello", headers: { "HTTP_ACCEPT" => "*/*" }
assert_body "Hello world */*!"
get "/content_negotiation/basic/hello", headers: { "HTTP_ACCEPT" => "text/javascript, */*" }
get "/content_negotiation/basic/hello", headers: { "HTTP_ACCEPT" => "text/javascript, */*" }, xhr: true
ret = (self.response_body = "success")
self.response_body = "#{ret}!"
render body: "actions: #{action_methods.to_a.sort.join(', ')}"
self.response = Rack::Response.new("Hello world", 200, { "content-type" => "text/html" })
type.json { render body: "JSON" }
type.yaml { render body: "YAML" }
type.xml { render xml: "XML" }
type.html { render body: "HTML" }
type.json { }
respond_to(:html, :xml)
type.all { render body: "ALL" }
type.atom { render body: "ATOM" }
inner_type.html { render body: "HTML" }
inner_type.js { render body: "JS" }
type.any { render json: { foo: "bar" } }
type.any { render body: "Whatever you ask for, I got it" }
type.json { render json: "JS", callback: "alert" }
type.html { render body: "mobile" }
variant.any(:tablet, :phablet) { render body: "any" }
format.html.any(:tablet, :phablet) { render body: "any" }
format.html.any(:none, :phone) { render body: "none or phone" }
format.html { render body: "HTML" }
format.any(:js, :xml) do |variant|
variant.any(:tablet, :phablet) { render body: "tablet" }
@request.accept = "*/*"
get :js_or_html, xhr: true
@request.accept = "*/*, application/json"
@request.accept = "*/* , application/json"
get :json_or_yaml, format: "json"
get :json_or_yaml, format: "yaml"
{ "YAML" => %w(text/yaml),
@request.accept = "text/javascript, */*"
assert_equal "<p>Hello world!</p>\n", @response.body
@request.accept = ""
assert_equal "/**/alert(JS)", @response.body
get :html_xml_or_rss, format: "html"
get :html_xml_or_rss, format: "xml"
get :html_xml_or_rss, format: "rss"
@action ||= action_name
response.body = "#{@action} - #{formats}"
get :variant_inline_syntax, params: { v: :phone }
get :variant_any, params: { v: :phone }
get :variant_any, params: { v: :tablet }
get :variant_any, params: { v: :phablet }
get :variant_any_any, params: { v: :phone }
get :variant_any_any, params: { v: :yolo }
get :variant_inline_any, params: { v: :tablet }
get :variant_inline_any, params: { v: :phablet }
get :variant_inline_any_any, params: { v: :phone }
get :variant_inline_any_any, params: { v: :yolo }
get :variant_any_with_none, params: { v: :phone }
get :format_any_variant_any, format: :js, params: { v: :tablet }
get :index, format: "js"
self.view_paths = File.expand_path("../../fixtures/post_test", __dir__)
respond_to(:html, :iphone, :js)
get :index, format: :js
{ a: "b" }.to_json(options)
{ a: "b" }.to_xml(options)
assert_equal({ a: "b" }.to_json, @response.body)
assert_equal(" ", @response.body)
assert_no_changes -> { @logger.level } do
get :show, params: { level: "debug" }
get :show, params: { level: "warn" }
redirect_to "http://foo.bar/"
render inline: "<%= cache('foo'){ 'bar' } %>"
render inline: "<%= cache('foo%bar'){ 'Contains % sign in key' } %>"
render inline: "<%= cache_if(true, 'foo') { 'bar' } %>"
render inline: "<%= cache_if(false, 'foo') { 'bar' } %>"
render inline: "<%= cache_unless(false, 'foo') { 'bar' } %>"
render inline: "<%= cache_unless(true, 'foo') { 'bar' } %>"
get :show, format: "json"
get :show, format: "noext"
assert_nil logs.detect { |l| /Parameters/.match?(l) }
get :show, params: { id: "10" }
get :show, params: { id: "20" }
post :show, params: { id: "10", name: "jose" }
get :show, params: { password: "test" }
get :show, params: {
lifo: "Pratik", amount: "420", step: "1"
assert_match(/"step"=>"1"/, params)
I18n.locale = :"de-AT"
I18n.locale = :"de_AT"
sse.write("{\"name\":\"John\"}")
sse.write(name: "Ryan")
sse.write({ name: "Ryan" }, { retry: 1500 })
sse.write("{\"name\":\"John\"}", id: 1)
sse.write({ name: "Ryan" }, { id: 2 })
assert_match(/data: {"name":"John"}/, response.body)
assert_match(/data: {"name":"Ryan"}/, response.body)
assert_match(/data: {"name":"John"}/, first_response)
assert_match(/data: {"name":"Ryan"}/, second_response)
path = File.expand_path("../fixtures", __dir__)
("a".."z").each do |char|
assert_equal({ "hello" => "world" }, @response.cookies)
res.each { }
t = Thread.new(response) { |resp|
assert_equal ("a".."z").to_a.join, response.stream.body
_, _, body = resp.to_a
assert_match %r((window\.location = "/500\.html"</script></html>)$), response.body
@request.if_none_match = %(W/"#{ActiveSupport::Digest.hexdigest('123')}")
get "/test"
StubApp = lambda { |env|
path = "/index"; params = "blah"; headers = { location: "blah" }
path = "/index"; params = "blah"; headers = { location: "blah" }; env = { "HTTP_X_REQUESTED_WITH" => "XMLHttpRequest" }
session1 = @test.open_session { |sess| }
name.to_s == "foo" ? "pass" : super
headers = { "Origin" => "*" }
assert_nothing_raised { __send__(verb, "/", headers: headers) }
format.html { render plain: "OK", status: 200 }
format.js { render plain: "JS OK", status: 200 }
format.json { render json: "JSON OK", status: 200 }
format.xml { render xml: "<root></root>", status: 200 }
format.rss { render xml: "<root></root>", status: 200 }
format.atom { render xml: "<root></root>", status: 200 }
head :ok, "c" => "3"
get "/get"
get "/get", headers: { "HTTP_ACCEPT" => mime_string }
assert_equal "<root></root>", body
post "/post"
assert_equal({ "cookie_1" => "", "cookie_2" => "oatmeal", "cookie_3" => "chocolate" }, cookies.to_hash)
assert_equal({ "foo" => "bar" }, cookies.to_hash)
get "/moved"
follow_redirect! params: { foo: :bar }
get "/get", xhr: true
get "/get.php", xhr: true
get "/get_with_params", params: { foo: "bar" }
post "/post", params: { leaks: "does-leak?" }
head "/get"
head "/post"
with_default_headers "a" => "1", "b" => "2" do
get "/remove_header", params: { header: "a" }
get "/get", headers: { "Accept" => "application/json" }, xhr: true
get "/get", headers: { "HTTP_ACCEPT" => "application/json" }, xhr: true
get "/get", params: { format: "json" }
get "/get_with_vary_set_x_requested_with", headers: { "Accept" => "application/json" }, xhr: true
get "moved" => redirect("/method")
get "get/:action", to: controller, as: :get_action
@app = Poller
get "/success", headers: { "Referer" => "http://www.example.com/foo", "Host" => "http://nohost.com" }
get "/success", headers: { "X-Test-Header" => "value" }, env: { "HTTP_REFERER" => "http://test.com/", "HTTP_HOST" => "http://test.com" }
get "/success", env: { "HTTP_REFERER" => "http://test.com/", "HTTP_HOST" => "http://test.com" }
get "http://test.com"
get "https://test.com"
get "http://test.com:123"
get "http://test.com:443"
get "https://test.com:80"
mount MountedApp => "/mounted", :as => "mounted"
get "/fooz"
get "/metal"
env = { :SERVER_NAME => "server", "action_dispatch.custom" => "custom" }
get "/foo", env: env
post "/post", params: { username: "cjolly", password: "secret" }
{}.freeze
get "/ok"
{ host: "bar.com" }
get "/foo" => "foo#index", :as => :foos
get "/foo/:id" => "foo#show", :as => :foo
get "/foo/:id/edit" => "foo#edit", :as => :edit_foo
get "/bar" => "bar#index", :as => :bars
get "/foo/1"
assert_equal "/foo/1/edit", url_for(action: "edit", only_path: true)
resources :foo, path: "/with"
assert_equal({ "user_name" => "david" }, cookies.to_hash)
post "/foos_json.json", params: { foo: "fighters" }.to_json,
headers: { "Content-Type" => "application/json" }
post "/foos"
post "/foos_json", as: :json
get "/foos_json.json", params: { foo: "heyo" }
get "/foos_json?foo=heyo", as: :json
get "/foos_json", params: { foo: "heyo" }, as: :json
get "/foos_json", as: :json
post "/foos_#{as}", params: { foo: "fighters" }, as: as
File.expand_path("../fixtures/multipart", __dir__)
token == "lifo"
token = 'rcHu+\\\\"/896A'
token = '\"quote\" pretty'
token = +""
nonce_hash = { nonce: "123abc" }
def sample_request(token, options = { nonce: "def" })
arr << "#{k}=\"#{v}\""
USERS = { "lifo" => "world", "pretty" => "please",
username: "dhh",
method = options.delete(:method) || "GET"
username == "lifo" && password == "world"
assert_no_match(/\n/, result)
render inline: "hello: <%= stratego %>"
render inline: "test: <%= foobar %>"
render inline: "<h1><%= notice %></h1>"
render inline: "<%= useful_function %>"
File.join(File.expand_path("../fixtures", __dir__), path)
render inline: "<%= conflicting_helper %>"
self.helpers_path = File.expand_path("../fixtures/helpers_typo", __dir__)
def a() end
def b() end
def c() end
@symbol = (@@counter ||= "A0").succ.dup
{ hi: :there }
expected_backtrace_pattern = "#{__FILE__}:#{__LINE__ - 1}"
render inline: "<%= shout %>"
class B < A
helper { def shout; "B" end }
helper { def shout; "C" end }
@flash_copy = {}.update flash
flash.update("this" => "hello again")
@flash_copy = {}.update(flash)
redirect_to "/wonderland", flash: { joyride: "Horses!" }
assert_equal({ "foo" => :foo_indeed, "bar" => :bar_indeed }, flash.discard().to_hash) # nothing passed
assert_equal({ "foo" => :foo_indeed, "bar" => :bar_indeed }, flash.discard(nil).to_hash) # nothing passed
assert_equal({ "foo" => :foo_indeed, "bar" => :bar_indeed }, flash.keep().to_hash) # nothing passed
assert_equal({ "foo" => :foo_indeed, "bar" => :bar_indeed }, flash.keep(nil).to_hash) # nothing passed
if stale? etag: "abe"
get "/set_flash"
get "/use_flash"
get "/set_flash", env: env
get "/set_flash_now", env: env
get "/set_bar"
get "/set_flash_optionally", params: { flash: "hello!" }
get "/set_flash_optionally", params: { flash: "goodbye!" }
@hash.update("foo" => "baz", "hello" => "world")
assert @hash.key?("foo")
assert @hash.key?(:foo)
assert_not @hash.key?("bar")
assert_not @hash.key?("foo")
assert_equal({ "foo" => "bar" }, @hash.to_hash)
assert_not @hash.key?("zomg")
@hash.discard("foo")
assert_equal({ "greeting" => "Hello" }, hash.to_hash)
@hash.each do |k, v|
@hash.replace("omg" => "aaron")
assert_equal({ "omg" => "aaron" }, @hash.to_hash)
assert_equal({}, @hash.to_hash)
assert_equal({ "omg" => "world" }, @hash.to_hash)
assert_equal({ "hello" => "world" }, @hash.to_hash)
@hash.update("hi" => "mom")
assert_equal({ "hello" => "world", "hi" => "mom" }, @hash.to_hash)
@hash.update("hello" => "mom")
assert_equal({ "hello" => "mom" }, @hash.to_hash)
@hash.replace("hi" => "mom")
assert_equal({ "hi" => "mom" }, @hash.to_hash)
assert_equal({ "omg" => "world", "hello" => "world" }, @hash.to_hash)
filters = _process_action_callbacks.select { |c| c.kind == :before }
@ran_filter << "ensure_login"
@ran_after_action << "clean_up"
(1..3).each do |i|
define_method "fail_#{i}" do
define_method "try_#{i}" do
if action_name == "fail_#{i}"
@ran_filter << "clean_up_tmp"
before_action(only: :show) { |c| c.instance_variable_set(:"@ran_proc_action", true) }
before_action :ensure_login, if: Proc.new { |c| true }
before_action :clean_up_tmp, if: Proc.new { |c| false }
skip_before_action :ensure_login, if: -> { false }
skip_before_action :clean_up_tmp, if: -> { true }
skip_before_action :ensure_login, only: :login, if: -> { false }
skip_before_action :clean_up_tmp, only: :login, if: -> { true }
skip_before_action :ensure_login, if: -> { false }, except: :login
skip_before_action :clean_up_tmp, if: -> { true }, except: :login
@ran_filter << "find_record"
@ran_filter << "find_user"
before_action(proc { |c| c.instance_variable_set(:"@ran_proc_action", true) })
before_action { |c| c.instance_variable_set(:"@ran_proc_action", true) }
@@execution_log = ""
%w(foo bar baz).each do |action|
@ran_filter << "before_all"
@ran_filter << "after_all"
controller.__send__ :render, plain: "I rescued this: #{ex.inspect}"
@filters << "filter_one"
@filters << "action_two"
@filters << "it didn't yield"
@filters << "action_three"
@only = "Only"
@except = "Except"
around_action do |c, a|
c.values << "before"
c.values << "after"
values << "action"
wtf = 1 + 1
wtf + 1
around_action(only: :no_raise) do |c, b|
@ran_filter << "before"
@ran_filter << "around (before yield)"
@ran_filter << "around (after yield)"
@ran_filter << "after"
@ran_filter << "around_again (after yield)"
after_action { I18n.locale = "en" }
{ locale: "de" }
get :redirect, params: { locale: "de" }
format.html { render body: "hello world!" }
@params = { controller: "posts", action: "index" }
@store.write("views/name", "value")
@store.write("views/primalgrasp", "will not expire ;-)")
buffer = "generated till now -> ".html_safe
expected_body = "<body>\n<p>ERB</p>\n</body>\n"
assert_equal "<p>ERB</p>", @store.read("views/nodigest")
format = "html"
assert_equal "<p>ERB</p>",
format = "xml"
expected_body = "<body>\n<p>PHONE</p>\n</body>\n"
assert_equal "<p>PHONE</p>",
get :index, params: { id: 2 }
assert_select ":root", "david, 2"
assert_select ":root", "david, 1"
{ host: "www.override.com", action: "new", locale: "en" }
{ format: "atom", id: "default-id" }
dom_id = nil
get "home" => "pages#home"
action: "home",
params: { "token" => "secret" }
get "from_view", to: "url_options#from_view", as: :from_view
get :from_view, params: { route: "from_view_url" }
scope("/:locale") do
get :from_view, params: { route: "description_path(1)" }
get "/things/:id(.:format)" => "things#show", :as => :thing
assert_equal "/things/1.atom", thing_path("1")
assert_equal({ a: "b" }.to_xml, @response.body)
post :test, params: { "username" => "sikachu" }
expected = { "username" => "sikachu", "person" => { "username" => "sikachu" } }
send_data(file_data, {})
render plain: "Hi!"
def redirect_to_action() redirect_to action: "flash_me", id: 1, params: { "panda" => "fun" }; end
render plain: "wow!"
@howdy = "ho"
render html: "<div>#{url_for(action: 'flash_me', only_path: true)}</div>"
render file: File.expand_path("../../README.rdoc", __dir__)
get "new_route", to: "api_only#nothing"
get "route_two", to: "action_pack_assertions#nothing", id: "two", as: :route_two
get "/user/:id", to: "user#index", as: :top_level
params: { name: "David" }
self.body ||= ""
define_method("#{sym}?") do
expected = "Expected response to be a <200: OK>,"\
@response.body = "not too long" * 50
@routes.draw { get ":controller(/:action)" }
path = File.join(__dir__, "fixtures", path)
def get(thing, *args, **options)
super("#{self.class.testing}/#{thing}", *args, **options)
def assert_response(body, status = 200, headers = {})
if status == 404
def get(uri_or_host, path = nil)
def post(uri_or_host, path = nil)
def put(uri_or_host, path = nil)
tc = self
TestSet.new ->(c) { tc.controller = c }, strict
fields = fields.split(";").map(&:strip)
key, value = field.split("=", 2)
cookies = {}
fields = cookie_string.split(";").map(&:strip)
name, value = fields.shift.split("=", 2)
header = header.split("\n").sort
header.is_a?(Array) ? header.join(",") : header
two: "bar",
testing: {
index: {
nested: { html: "<a>nested</a>" }
no_action: "no_action_tr",
assert_equal "bar", @controller.t(".foo")
default = "foo"
assert_equal "bar", @controller.t(:'.foo')
time, expected = Time.gm(2000), "Sat, 01 Jan 2000 00:00:00 +0000"
def custom(mime, *args, **kwargs, &block)
collector.js(:bar) { :baz }
@text = "Hello world"
@second = "Goodbye"
@text ||= nil
self.response_body = @list.join(", ")
options = { only: :index }
before_action :callback1, :callback2, ->() { }, only: :showw
def self.create(env = {})
set_header("HTTP_ACCEPT", Array(mime_types).collect(&:to_s).join(","))
def response_parser; -> body { body }; end
@response_parser = response_parser || -> body { body }
@mime.to_s
def get(path, **args)
process(:get, path, **args)
def post(path, **args)
process(:post, path, **args)
def patch(path, **args)
process(:patch, path, **args)
def put(path, **args)
process(:put, path, **args)
process(:delete, path, **args)
def head(path, **args)
process(:head, path, **args)
def follow_redirect!(headers: {}, **args)
url_options.reverse_merge!(host: host, protocol: https? ? "https" : "http")
@controller = @request = @response = nil
@_mock_session = nil
self.remote_addr = "127.0.0.1"
def https!(flag = true)
@https = flag
def process(method, path, params: nil, headers: nil, env: nil, xhr: false, as: nil)
headers ||= {}
if method == :get && as == :json && params
if path.include?("://")
url_host += ":#{location.port}" if default != location.port
hostname, port = host.split(":")
:method => method,
@request_count += 1
alias :host! :host=
@_mock_session ||= Rack::MockSession.new(@app, host)
location.query ? "#{path}?#{location.query}" : path
super(*args, &blk)
def remove! # :nodoc:
unless method == "cookies" || method == "assigns"
result = integration_session.#{method}(...)
@@app = nil
if defined?(@@app) && @@app
@@app
def app=(app)
@@app = app
@routes ||= nil
msg = message(msg, "") {
if expected_path.include?("://")
expected_path = uri.path.to_s.empty? ? "/" : uri.path
expected_path = "/#{expected_path}" unless expected_path.start_with?("/")
found_extras = options.reject { |k, _| ! query_string_keys.include? k }
msg = message || sprintf("found extras <%s>, not <%s>", found_extras, extras)
msg = message || sprintf("The generated path <%s> did not match <%s>", generated_path,
def assert_routing(path, options, defaults = {}, extras = {}, message = nil)
generate_options = options.dup.delete_if { |k, _| defaults.key?(k) }
if path.is_a?(Hash)
method = :get
request.path = uri.path.to_s.empty? ? "/" : uri.path
path = "/#{path}" unless path.start_with?("/")
def assert_redirected_to(url_options = {}, options = {}, message = nil)
(+"Expected response to be a <#{code_with_name(expected)}>,"\
@html_document ||= if @response.media_type&.end_with?("xml")
success: "2XX",
missing: "404",
redirect: "3XX",
error: "5XX"
@name = code_or_name
@code = code_or_name
@_screenshot_counter ||= 0
failed? ? "failures" : (_screenshot_counter || 0).to_s
name = "#{unique}_#{sanitized_method_name}"
output_type ||= "simple"
!passed? && !skipped?
@name = @options.delete(:name) || driver_type
gem "selenium-webdriver", ">= 4.0.0"
@options ||=
gem "capybara", ">= 3.26"
map "/" do
@url_helpers ||=
@_routes = nil
def full_url_for(options = nil) # :nodoc:
public_send(:"#{name}_url", *args)
def _with_routes(routes) # :doc:
old_routes, @_routes = @_routes, routes
def #{method}(*args)
@helpers.#{method}(*args)
(previous_script_name.split("/").slice(0, context_parts).join("/")) + new_script_name
@routes = {}
@path_helpers.map(&:to_s) + @url_helpers.map(&:to_s)
path_name = :"#{name}_path"
url_name = :"#{name}_url"
params = {}
@arg_size.times { |i|
inner_options || {},
if args.size > 0
options = \
{ new: "new", edit: "edit" }
@default_env = {
@append << block
@append.each { |blk| eval_block(blk) }
@prepend.each { |blk| eval_block(blk) }
define_method "_#{name}" do
@_#{name} ||= _#{name}
@_proxy.route_for(name, *args)
def _routes; @_proxy._routes; end
def url_options; {}; end
define_method(:_routes) { @_routes || routes }
if !base._routes.equal?(@_proxy._routes)
raise ArgumentError, "Invalid route name, already in use: '#{name}' \n" \
def call(t, args, only_path = false)
url = t.full_url_for(eval_block(t, args, options))
if !named_route && different_controller? && !controller.start_with?("/")
size = controller.count("/") + 1
if controller.start_with?("/")
def extra_keys(options, recall = {})
options.delete(:script_name) || relative_url_root || ""
recall = options.delete(:_recall) { {} }
path += "/"
uri.path = "#{req.script_name}/#{uri.path}"
uri.path = req.script_name.empty? ? "/" : req.script_name
!params.empty? && string && string.match(/%\{\w*\}/)
url_options = {
%w(edit new).each do |action|
CACHE = { path: {}, url: {} }
prefix = action ? "#{action}_" : ""
if action.to_s == "new"
new(->(name) { name.singular_route_key }, prefix, suffix)
new(->(name) { name.route_key }, prefix, suffix)
args << model
route <<
named_route = prefix + route.join("_")
SERVE = ->(app, req) { app.serve req }
app = app.app
(constraint.respond_to?(:matches?) && constraint.matches?(req)) ||
if arity < 1
elsif arity == 1
scope_params = {
URL_OPTIONS.include?(key) && (String === default || Integer === default)
conditions.keep_if do |k, _|
@via.map { |x| Journey::Route.verb_matcher(x) }
object.is_a?(String) ? -object : object
if to.respond_to?(:action) || to.respond_to?(:call)
{ requirements: { format: /.+/ },
{ requirements: {}, defaults: {} }
part.is_a?(Regexp) ? part : part.to_s
if to&.include?("#")
to.split("#").map!(&:-@)
if controller&.start_with?("/")
if Regexp === option
path.gsub!(%r{/(\(+)/?}, '\1/')
elsif Hash === app
app, path = options.find { |k, _| k.respond_to?(:call) }
match(path, { to: app, anchor: false, format: false }.merge(options))
app.is_a?(Class) && app < Rails::Railtie
_routes = @set
script_namer = ->(options) do
_route.segment_keys.each { |k| options.delete(k) }
def get(*args, &block)
map_method(:get, args, &block)
def post(*args, &block)
def put(*args, &block)
map_method(:put, args, &block)
URL_OPTIONS.include?(k) && (v.is_a?(String) || v.is_a?(Integer))
if options.key?(:only) || options.key?(:except)
if option == :blocks
def namespace(path, options = {}, &block)
Mapper.normalize_path("#{parent}/#{child}")
parent ? "#{parent}_#{child}" : child
parent ? "#{parent}/#{child}" : child
(parent || {}).merge(child)
child ? true : false
Array(@only).map(&:to_sym)
@as || @name
@plural ||= name.to_s
singular == plural ? "#{plural}_index" : plural
:"#{singular}_#{param}"
@singular ||= name.to_s
def namespace(path, options = {})
nested { super }
path = @draw_paths.find do |_path|
File.exist? "#{_path}/#{name}.rb"
msg += @draw_paths.map { |_path| " * #{_path}" }.join("\n")
route_path = "#{path}/#{name}.rb"
def match(path, *rest, &block)
if rest.empty? && Hash === path
path, to = options.find { |name, _value| name.is_a?(String) }
if to.include?("#")
options = rest.pop || {}
def root(path, options = {})
elsif path.is_a?(Hash) && options.empty?
resources.each { |r| public_send(method, r, options, &block) }
@scope.find_all { |node|
if prefix && prefix != "/" && !prefix.empty?
Mapper.normalize_name prefix.to_s.tr("-", "_")
candidate = action_name.select(&:present?).join("_")
if as.nil?
def api_only? # :doc:
if _path && option_path
path_without_format = path.sub(/\(\.:format\)$/, "")
default_action ||= action.tr("-", "_") unless action.include?("/")
as = if !options.fetch(:as, true) # if it's set to nil or false
def direct(name, options = {}, &block)
@hash.nil? && @parent.nil?
scope = find { |node| node.frame.key? key }
NULL = Scope.new(nil, nil)
@set = set
@concerns = {}
@reqs ||= begin
@engines = {}
normalized_path = ("/" + path).squeeze("/")
{ name: route.name,
@buffer.join("\n")
@buffer <<
@buffer << "\n#{title}:"
@buffer << <<~MSG
@view = view
@buffer << %(<tr><th colspan="4">#{title}</th></tr>)
def no_routes(*)
<li>
</li>
@view.raw @buffer.join("\n")
rack_app.is_a?(Class) && rack_app < Rails::Engine
Session::Options.set(req, Session::Options.new(nil, { id: nil }))
@delegate.fetch(:id) {
@delegate = {}
@id_was = nil
options = self.options || {}
if key == "session_id"
keys = keys.map.with_index { |key, i| i.zero? ? key.to_s : key }
@delegate.dup.delete_if { |_, v| v.nil? }
@exists = @by.send(:session_exists?, @req)
load! if !loaded? && exists?
load! if enabled? && !loaded?
def initialize(app, path, index: "index", headers: {})
@root = root.chomp("/").b
@file_server = ::Rack::Files.new(@root, headers)
if status != 304
headers = { "content-type" => content_type }
if accept_encoding.any? { |enc, _| /\b#{content_encoding}\b/i.match?(enc) }
file_path = File.join(@root, path.b)
ext = ::File.extname(path)
yield "#{path}/#{@index}#{default_ext}", default_content_type
path = ::Rack::Utils.unescape_path path_info.chomp("/")
klass.new(app, *args, &block)
@payload = {
insert(index + 1, *args, &block)
middlewares.reject! { |m| m.name == target.name }
def use(klass, *args, &block)
def build(app = nil, &block)
e.build(a)
i = index.is_a?(Integer) ? index : index_of(index)
m.name == klass.name
cookies = cookies.split("\n")
if !/;\s*secure\s*(;|$)/i.match?(cookie)
}.join("\n")
{ "Content-Type" => "text/html",
location = +"https://#{host}"
location << ":#{port}" if port != 80 && port != 443
request.path_info = "/#{status}"
req.set_header("action_dispatch.request.unsigned_session_cookie", new_sid ? { "session_id" => new_sid.public_id } : {})
data || {}
data ||= {}
sid, session = generate_sid, {}
@check_ip = check_ip
@ip ||= calculate_ip
def ips_from(header) # :doc:
ips.select! do |ip|
@proxies.any? { |proxy| proxy === ip }
path = "#{public_path}/#{status}.#{I18n.locale}.html"
path = "#{public_path}/#{status}.html" unless (found = File.exist?(path))
if found || File.exist?(path)
allowed === host
if host.start_with?(".")
format = request.xhr? ? "text/plain" : "text/html"
{ "Content-Type" => "#{format}; charset=#{Response.default_charset}",
if flash_hash && (flash_hash.present? || session.key?("flash"))
k = k.to_s
@now = other.now.dup
def update(h) # :nodoc:
def replace(h) # :nodoc:
@now ||= FlashNow.new(self)
def keep(k = nil)
k = k.to_s if k
def discard(k = nil)
def sweep # :nodoc:
@discard.each { |k| @flashes.delete k }
item.kind_of?(Symbol) ? item.to_s : item
trace_with_id = {
id: idx,
built_methods = {}
File.open(full_path, "r") do |file|
PP.pp(clean_params, +"", 200)
headers.inspect.gsub(",", ",\n")
object.to_hash.sort_by { |k, _| k.to_s }.map { |k, v| "#{k}: #{v.inspect rescue $!.message}" }.join("\n")
def render(*)
path = req.path_info.chomp("/")
if path == @path
lock_state = +"Sharing"
lock_state = +"No lock"
lock_state << " (yielded share)"
end.join("\n\n---\n\n\n")
_, headers, body = response = @app.call(env)
format = "text/html"
to_format = "to_#{content_type.to_sym}"
message << "#{wrapper.exception_class_name} (#{wrapper.message}):"
@response_format == :api && !content_type.html?
jar = new(req)
@set_cookies = {}
@delete_cookies = {}
@cookies = {}
def fetch(name, *args, &block)
@cookies.fetch(name.to_s, *args, &block)
alias :has_key? :key?
alias :to_hash :to_h
set_cookies = request_jar.reject { |k, _| @delete_cookies.key?(k) || @set_cookies.key?(k) }
@cookies.map { |k, v| "#{escape(k)}=#{escape(v)}" }.join "; "
options = { value: value }
def delete(name, options = {})
def deleted?(name, options = {})
def clear(options = {})
@cookies.each_key { |k| delete(k, options) }
cookie_domain = ""
dot_splitted_host = request.host.split(".", -1)
request.host == domain || request.host.end_with?(".#{domain}")
result = parse(name, data, purpose: "cookie.#{name}")
options = { value: options }
set_callback(:call, :before, *args, &block)
set_callback(:call, :after, *args, &block)
if uri.relative? || uri.scheme == "http" || uri.scheme == "https"
message << "\n\n" if defined?(Rails.env) && Rails.env.development?
@children << i
@parameters << i
return "" if value.nil?
def visit_CAT(n); binary(n); end
node.children.each { |c| visit(c) }
def visit_OR(n); nary(n); end
def visit_GROUP(n); unary(n); end
def visit_STAR(n); unary(n); end
next unless pim =~ /^visit_(.*)$/
def visit_CAT(n, seed); binary(n, seed); end
node.children.inject(seed) { |s, c| visit(c, s) }
def visit_OR(n, seed); nary(n, seed); end
def visit_GROUP(n, seed); unary(n, seed); end
def visit_STAR(n, seed); unary(n, seed); end
node.children.inject(seed) { |s, c|
string = visit(c, s)
string << "|" unless last_child == c
visit(node.left, seed.dup << "(") << ")"
<<-eodot
size="8,5"
seed.last << "#{node.object_id} -> #{node.left.object_id};"
@ss = nil
@ss.eos?
until token = scan || @ss.eos?; end
r = @ss.scan(regex)
r ? -r : nil
when @ss.skip(/\//)
when @ss.skip(/\(/)
when @ss.skip(/\)/)
when @ss.skip(/\|/)
when @ss.skip(/\./)
when text = dedup_scan(/:\w+/)
when text = dedup_scan(/\*\w+/)
text.tr! "\\", ""
when text = dedup_scan(/./)
@ast ||= begin
@simulator ||= begin
path ||= ""
path = +"/#{path}"
path.squeeze!("/")
unless path == "/"
path.delete_suffix!("/")
before = $-w
$-w = false
$-w = before
req.script_name = (script_name.to_s + match.to_s).chomp("/")
req.path_info = "/" + req.path_info unless req.path_info.start_with? "/"
_, headers, _ = response = route.app.serve(req)
routes.select! { |r| r.matches?(req) }
routes.map! { |r|
path_parameters = {}
head_routes = routes.select { |r| r.requires_matching_verb? && r.matches?(req) }
class_eval <<-eoc, __FILE__, __LINE__ + 1
class #{v}
def self.verb; name.split("::").last; end
def self.call(req); req.#{v.downcase}?; end
@verb = verb
def self.call(_); true; end
def self.verb; ""; end
@ast = @path.ast.root
/.+?/m == v
(required_defaults.length * 2) + path.names.count { |k| supplied_keys.include?(k) }
@parts ||= segments.map(&:to_sym)
@required_defaults ||= @defaults.dup.delete_if do |k, _|
parts.include?(k) || !required_default?(k)
!@request_method_match.all? { |x| x == VerbMatchers::All }
verbs.join("|")
@request_method_match.any? { |m| m.call request }
@ast = nil
next if s.type == :DOT || s.type == :SLASH
return false if s.symbol? && s.regexp.is_a?(Array)
@optional_names ||= spec.find_all(&:group?).flat_map { |group|
}.map(&:name).uniq
%r{\A#{visit node}\Z}
re ? "(#{re})" : "(.+)"
children = node.children.map { |n| visit n }
path == "/" ? %r{\A/} : %r{\A#{path}(?:\b|\Z|/)}
alias :=~ :match
/\A#{regex}\Z/
@offsets ||= begin
spec.find_all(&:symbol?).each do |node|
offsets.push((re.match("").length - 1) + offsets.last)
0, 0, :racc_error,
2, 11, :_reduce_1,
1, 11, :_reduce_2,
1, 11, :_reduce_none,
1, 12, :_reduce_none,
3, 15, :_reduce_7,
3, 13, :_reduce_8,
3, 13, :_reduce_9,
1, 16, :_reduce_10,
1, 14, :_reduce_none,
1, 19, :_reduce_15,
1, 17, :_reduce_16,
1, 18, :_reduce_17,
racc_token_table = {
false => 0,
:error => 1,
:OR => 9 }
class Ast # :nodoc:
@tree = tree
@wildcard_options = {}
(symbols + stars).each do |node|
terminals.each { |n| n.memo = route }
stars << node
@memo = nil
-left.tr("*:", "")
def cat?; false; end
class Dot < Terminal # :nodoc:
def type; :DOT; end
@name = -left.tr("*:", "")
class Unary < Node # :nodoc:
class Group < Unary # :nodoc:
class Star < Unary # :nodoc:
@regexp = /.+?/m
def star?; true; end
def type; :STAR; end
left.name.tr "*:", ""
class Binary < Node # :nodoc:
class Cat < Binary # :nodoc:
def cat?; true; end
def type; :CAT; end
class Or < Node # :nodoc:
def type; :OR; end
module NFA # :nodoc:
module Dot # :nodoc:
edges = transitions.map { |from, sym, to|
module GTG # :nodoc:
@stdparam_states = {}
t.each { |s, previous_start|
states.each { |re, v|
hash.each do |re, to|
svg = IO.popen("dot -Tsvg", "w+") { |f|
3.times { svg.shift }
ast.filter_map { |n|
when ":id" then rand(100).to_s
when ":format" then %w{ xml json }.sample
sym = /\A#{sym}\Z/
sym = sym.to_s
(ss + ps + rs).uniq
} + @stdparam_states.flat_map { |from, hash|
} + @regexp_states.flat_map { |from, hash|
s, idx = s_d
memos.concat(tt.memo(s)) if idx.nil? && tt.accepting?(s)
s.group_by { |state| symbol(state) }.each do |sym, ps|
ps.each { |state| dtrans.add_memo(to, state.memo) }
dstates << u
node.regexp.match?("")
node.children.any? { |c| nullable?(c) }
node.children.flat_map { |c| firstpos(c) }.tap(&:uniq!)
node.children.flat_map { |c| lastpos(c) }.tap(&:uniq!)
@ast.each do |n|
def path(_)
params = options.dup.delete_if do |key, _|
if k == :controller
supplied_keys = options.each_with_object({}) do |(k, v), h|
hash = routes.group_by { |_, r| r.score(supplied_keys) }
}.flat_map { |pair|
@cache ||= build_cache
params = { params: params } unless params.is_a?(Hash)
params.reject! { |_, v| v.to_param.nil? }
path << "?#{query}" unless query.empty?
host.split(".").last(1 + tld_length).join(".")
parts = host.split(".")
result << ":#{normalized_port}"
secure_protocol ? "https://" : "http://"
when false, "//"
host = +""
host << extract_subdomains_from(_host, tld_length).join(".")
host << "." unless host.empty?
host << (domain || extract_domain_from(_host, tld_length))
when "//" then yield port
when "https://"
@protocol ||= ssl? ? "https://" : "http://"
forwarded.split(/,\s?/).last
raw_host_with_port.sub(/:\d+$/, "")
@port ||= if raw_host_with_port =~ /:(\d+)$/
$1.to_i
if "https://" == protocol
standard_port? ? "" : ":#{port}"
def read(length = nil, buffer = nil)
x = @stream.each(&block)
@str_body = nil
@str_body ||= begin
buf = +""
each { |chunk| buf << chunk }
alias_method :<<, :write
@cv.wait_until { @committed }
synchronize { @cv.wait_until { @sent } }
@sent = true
if true == v
@to_path = path
File.open(to_path, "rb") do |file|
@stream.each { |x| parts << x }
header = header.split("\n") if header.respond_to?(:to_str)
if pair = cookie.split(";").first
key, value = pair.split("=").map { |v| Rack::Utils.unescape(v) }
/x # :nodoc:
type = content_type || ""
type = "#{type}; charset=#{charset.to_s.downcase}" if charset
BODY_METHODS = { to_ary: true, each: true, call: true, to_path: true }
new({})
def self.action(_); self; end
if error.missing_name == const_name || const_name.start_with?("#{error.missing_name}::")
def routes # :nodoc:
def routes=(routes) # :nodoc:
@method ||= check_method(
@headers ||= Http::Headers.new(self)
@fullpath ||= super
@ip ||= super
@remote_ip ||= (get_header("action_dispatch.remote_ip") || ip).to_s
@remote_ip = nil
def request_id=(id) # :nodoc:
rack_query_params = super || {}
super || {}
if data = @store.read(key)
body = open(key)
key, size = slurp(body) { |part| buf << part }
_, headers, _ = response = @app.call(env)
self: "'self'",
none: "'none'",
@directives = {}
data.is_a?(Hash) ? data : { _json: data }
Mime::Type.register "text/html", :html, %w( application/xhtml+xml ), %w( xhtml )
Mime::Type.register "text/vtt", :vtt, %w(vtt)
Mime::Type.register "audio/aac", :m4a, %w( audio/mp4 ), %w(m4a mpg4 aac)
Mime::Type.register "application/x-yaml", :yaml, %w( text/yaml ), %w(yml yaml)
def <<(type)
@mimes << type
@symbols << type.to_sym
@mimes.delete_if do |x|
q ||= 0.0 if @name == "*/*" # Default wildcard match to end of list.
@q = ((q || 1.0).to_f * 100).to_i
def <=>(item)
result = item.q <=> @q
result = @index <=> item.index if result == 0
if text_xml_idx && app_xml_idx
if type.name.end_with? "+xml"
idx += 1
list.map! { |i| Mime::Type.lookup(i.name) }.uniq!
array.index { |item| item.name == name }
SET << new_mime
if !accept_header.include?(",")
list << AcceptItem.new(index, m.to_s, q)
Mime::SET.select { |m| m.match?(type) }
SET.delete_if { |v| v.eql?(mime) }
LOOKUP.delete_if { |_, v| v.eql?(mime) }
symbol || to_s
def ===(list)
if list.is_a?(Array)
def ==(mime_type)
synonym.to_s == mime_type.to_s || synonym.to_sym == mime_type.to_sym
super || (self.class == other.class &&
def =~(mime_type)
@synonyms.any? { |synonym| synonym.to_s =~ regexp } || @string =~ regexp
@synonyms.any? { |synonym| synonym.to_s.match?(regexp) } || @string.match?(regexp)
(symbol == :html) || @string.include?("html")
def all?; false; end
def to_a; end
if method.end_with?("?")
method.end_with?("?") || super
super "*/*", nil
def all?; true; end
def html?; true; end
method.end_with?("?")
false if method.end_with?("?")
v = if header.empty?
format.symbol || format.ref == "*/*"
order.include?(Mime::ALL) ? format : nil
(xhr? && (accept.present? || content_mime_type)) ||
if match = path && path.match(/\.(\w+)\z/)
def env; @req.env.dup; end
key.tr!("-", "_")
if String === filter
@filtered_path ||= query_string.empty? ? path : "#{path}?#{filtered_query_string}"
def env_filter # :doc:
query_string.gsub(PAIR_RE) do |_|
parameter_filter.filter($1 => $2).first.join("=")
status, headers, _ = response = @app.call(env)
char.bytes.map { |byte| "%%%02X" % byte }.join
def etag?; etag; end
etag? && etag.start_with?('W/"')
etag? && !weak_etag?
cache_control.delete(" ").split(",")
cache_control = {}
directive, argument = segment.split("=", 2)
directive.tr!("-", "_")
if (etag? || last_modified?) && !self._cache_control
options << "max-age=#{max_age.to_i}" if max_age
self._cache_control = options.join(", ")
value = value.map(&:to_param)
query = lambda { |value|
@data.dig(*keys)
def fetch(key, *args, &block)
@data.fetch(key.to_s, *args, &block)
@id
def get(action, **args)
res = process(action, method: "GET", **args)
process(action, method: "POST", **args)
process(action, method: "PATCH", **args)
def put(action, **args)
process(action, method: "PUT", **args)
process(action, method: "HEAD", **args)
def process(action, method: "GET", params: nil, session: nil, body: nil, flash: {}, format: nil, xhr: false, as: nil)
format ||= as
parameters = (params || {}).symbolize_keys
@request.flash.update(flash || {})
@request.query_string = ""
env.delete_if do |k, _|
method: "get",
input: ""
new_env = {}
value = value ? "on" : "off"
def new(env = nil)
if @env.key?("HTTP_HOST") || controller._routes.nil?
raise "Invalid option key: #{k}"
@_url_options = nil
@_url_options ||= {
if (same_origin = _routes.equal?(request.routes)) ||
if defined?(@_ivars)
attr_reader :param, :keys # :nodoc:
def initialize(param, keys = nil) # :nodoc:
super("found unpermitted parameter#{'s' if params.size > 1 }: #{params.map { |e| ":#{e}" }.join(", ")}")
delegate :keys, :key?, :has_key?, :member?, :empty?, :exclude?, :include?,
:as_json, :to_s, :each_key, to: :@parameters
/\A-?\d+\z/.match?(key) && (value.is_a?(Hash) || value.is_a?(Parameters))
def initialize(parameters = {}, logging_context = {})
unless key.is_a?(String) || key.is_a?(Symbol)
permitted? == other.permitted? &&
def to_h(&block)
to_h.to_query(*args)
return key.map { |k| require(k) } if key.is_a?(Array)
if value.present? || value == false
reject! { |_k, v| v.blank? }
@parameters.merge!(other_hash.to_h) { |key, left, right| left }
coder.map = { "parameters" => @parameters, "permitted" => @permitted }
@parameters.any? { |k, v| Parameters.nested_attribute?(k, v) }
converted = value.map { |_| convert_value_to_parameters(_) }
filter.keys.any? { |key| /\A-?\d+\z/.match?(key) }
if value.is_a?(Array) && value.all? { |element| permitted_scalar?(element) }
value.is_a?(Array) || value.is_a?(Parameters)
when ->(v) { permitted_scalar?(v) }
when ->(e) { permitted_scalar?(e) }
@_params ||= begin
context = {
@_params = value.is_a?(Hash) ? Parameters.new(value) : value
if request.version == "HTTP/1.0"
object.respond_to?(:fetch) && object.respond_to?(:store) && object.respond_to?(:reset)
def write(*)
%r(\A(?:text|application)/javascript).match?(media_type) && !request.xhr?
!protect_against_forgery? || request.get? || request.head? ||
def mask_token(raw_token) # :doc:
def valid_per_form_csrf_token?(token, session = nil) # :doc:
request.path.chomp("/"),
def real_csrf_token(_session = nil) # :doc:
def xor_byte_strings(s1, s2) # :doc:
s2 = s2.dup
s2.setbyte(i, s1.getbyte(i) ^ s2.getbyte(i))
i += 1
uri.path.chomp("/")
result.each { |r| string << r }
def render_to_body(options = {}) # :nodoc:
super || _render_in_priorities(options) || " "
def process_action(*) # :nodoc:
add :js do |js, options|
js.respond_to?(:to_js) ? js.to_js(options) : js
add :xml do |xml, options|
xml.respond_to?(:to_xml) ? xml.to_xml(options) : xml
def redirect_to(options = {}, response_options = {})
self.response_body = ""
end.delete("\0\r\n")
if options.is_a?(Hash) && options.key?(:status)
host = URI(url.to_s).host
!url.to_s.start_with?("//")
class Options < Struct.new(:name, :format, :include, :exclude, :klass, :model) # :nodoc:
m = model
(+key.to_s).concat("_attributes")
@name_set = true
namespaces = model_name.split("::")
model_name = namespaces.join("::")
@responses = {}
def any(*args, &block)
args.each { |type| send(type, &block) }
@variants = {}
if args.any? && args.none? { |a| a == @variant }
@variant.find { |variant| @variants.key?(variant) } || :any
around_action ->(_, action) { logger.log_at(level, &action) }, **options
def write(object, options = {})
@stream.write "#{option_name}: #{option_value}\n"
message = json.gsub("\n", "\ndata: ")
@stream.write "data: #{message}\n\n"
@queue_size = 10
@error_callback = lambda { true }
write string.end_with?("\n") ? string : "#{string}\n"
str = nil
str = @buf.pop
body.each { |part| buf.write part }
error = e
def send_file(path, options = {})
def send_data(data, options = {})
raw_payload = {
messages << ("Views: %.1fms" % view_runtime.to_f) if view_runtime
message = "#{self.class.name}\##{action_name} is missing a template " \
message = "#{self.class.name}\##{action_name} is missing a template for request formats: #{request.formats.map(&:to_s).join(',')}"
::Base64.decode64(auth_param(request) || "")
message ||= "HTTP Basic: Access denied.\n"
_uri = trailing_question_mark ? uri + "?" : uri
key, value = pair.split("=", 2)
message ||= "HTTP Digest: Access denied.\n"
t = time.to_i
::Base64.strict_encode64("#{t}:#{digest}")
t = ::Base64.decode64(value).split(":").first.to_i
nonce(secret_key, t) == value && (t - Time.now.to_i).abs <= seconds_to_timeout
raw_params.map { |param| param.split %r/=(.+)?/ }
message ||= "HTTP Token: Access denied.\n"
attrs.flatten.each { |attr| helper_method(attr, "#{attr}=") }
@helper_proxy ||= begin
status ||= :ok
@action_methods ||= super - _flash_types.map(&:to_s).to_set
def redirect_to(options = {}, response_options_and_flash = {}) # :doc:
etag { flash if request.respond_to?(:flash) && !flash.empty? }
def send_file(path, options = {}) # :doc:
def send_data(data, options = {}) # :doc:
def cookies # :doc:
last_modified: Time.new(2011, 1, 1).utc,
def build(action, app = nil, &block)
INCLUDE = ->(list, action) { list.include? action }
EXCLUDE = ->(list, action) { !list.include? action }
:status, :location, :content_type, :media_type, to: "@_response"
@_request = nil
@_response = nil
@_params = nil
@_params = val
_, _, body = @_response
def to_a # :nodoc:
display_unpermitted_keys = unpermitted_keys.map { |e| ":#{e}" }.join(", ")
def #{method}(event)
info("\#{human_name} \#{key} (\#{event.duration.round(1)}ms)")
@action_methods ||= if _routes
path = controller_path.tr("/", ".")
key = "#{path}.#{action_name}#{key}"
def _normalize_args(action = nil, options = {}) # :doc:
def _set_vary_header # :nodoc:
def _normalize_render(*args, &block) # :nodoc:
if @_helpers ||= nil
if /^#{path}(\.rb)?$/.match?(error.path)
controller.send(:'#{method}', *args, &block)
sym = mime.is_a?(Symbol) ? mime : mime.to_sym
def #{sym}(*args, &block)
ruby2_keywords(:#{sym})
@actions = Array(actions).map(&:to_s).to_set
define_method "#{callback}_action" do |*names, &blk|
def process_action(...)
tail = key.is_a?(Hash) ? url_for(key).split("://").last : key
if key.is_a?(Regexp)
def cache(key, options = {}, &block) # :doc:
methods.map!(&:to_s)
def eager_load! # :nodoc:
send_action(...)
get "/welcome" => "foo#bar", as: "welcome"
get "/dummy_model" => "foo#baz", as: "dummy_model"
get "/a/b(/:id)", to: "a#b"
c.assets_dir = "" # To get the tests to pass
@url = url_for(@options)
mail(from: "from@example.com", to: "to@example.com", subject: "subject")
def new_mail(charset = "UTF-8")
mail.mime_version = "1.0"
expected = "http://www.basecamphq.com#{expected}" if expected.start_with?("/") && !relative
assert_url_for "http://foo/", "http://foo/"
assert_url_for "/a/b/c", controller: "a", action: "b", id: "c"
assert_url_for "/a/b/c", { controller: "a", action: "b", id: "c", only_path: true }, true
expected.message_id = "<123@456>"
created.message_id = "<123@456>"
@world = "Earth"
mail body: render(inline: "Hello, <%= @world %>"),
subject: "Hi!",
to: "test@example.com",
mail body: render(inline: "Hello, #{name}"),
@test_var = "a value"
travel_to Time.new(2004, 11, 24, 1, 4, 44) do
def to_global_id(options = {})
super app: "foo"
default to: Proc.new { @invitee }, from: -> { @inviter }
format.text { render plain: "So says #{@inviter}" }
@@last_error = error
def welcome(hash = {})
mail({ subject: "The first email on new API!" }.merge!(hash))
mail({ template_name: "welcome" }.merge!(hash))
to = email_address_with_name("sunny@example.com", "")
def html_only(hash = {})
def plain_text_only(hash = {})
mime_type: "image/x-jpg",
mime_type: "image/x-jpg" }
format.any(:text, :html) { render plain: "Format with any!" }
format.text { render template: "#{mailer_name}/#{template_name}" }
format.html { render template: "#{mailer_name}/#{template_name}" }
mail()
mail(body: render(inline: "Hello, <%= @world %>", layout: "spam"))
mail(body: render(inline: "Hello, <%= @world %>", layout: false))
format.html { render(inline: "<%= block_format @text %>") }
format.html { render(inline: "<%= format_paragraph @text, 15, 1 %>") }
format.html { render(inline: "<%= format_paragraph @text, 10, 1 %>") }
format.html { render(inline: "<%= mailer.message.subject %>") }
format.html { render(inline: "<%= message.subject %>") }
format.html { render(inline: "<% cache(:foo) do %>Greetings from a cache helper block<% end %>") }
assert_equal expected.gsub("\n", "\r\n"), mail.body.encoded
c.assets_dir = ""
settings = { location: "#{Rails.root}/tmp/mails" }
default_options = { a: "b" }
overridden_options = { a: "a" }
port: 25,
expected_body = "\"Welcome\""
expected_text_body = "\"Welcome text\""
expected_html_body = "\"Welcome html\""
charset: "iso-8559-1",
mime_version: "2.0",
expected = +"\312\213\254\232)b"
with_translation "en", base_mailer: { welcome: { subject: "New Subject!" } } do
with_translation "en", base_mailer: { email_with_translations: { greet_user: "Hello %{name}!" } } do
mail body: "yay", from: "welcome@example.com", to: "to@example.com"
swap I18n, locale: "de-AT" do
assert_dom_equal(%{<img src="http://global.com/images/dummy.png" />}, mail.body.to_s.strip)
self.asset_host = "http://local.com"
assert_dom_equal(%{<img src="http://local.com/images/dummy.png" />}, mail.body.to_s.strip)
assert(mail1.to_s.to_i > mail2.to_s.to_i)
with_default BaseMailer, from: -> { flunk }, to: -> { flunk } do
headers("X-Special-Header" => "Wow, so special")
headers("X-Special-Header" => "Testing")
assert_equal '"I \"<3\" email" <test@example.org>', address
mail.to << "jane@example.com"
klass.public_send :"#{key}=", value
params = { name: "World" }
c.asset_host = "http://www.example.com"
subject: "Test e-mail", from: "test@test.host", to: "test <test@test.host>"
mail subject: "Test e-mail", from: "test@test.host", to: "test <test@test.host>" do |format|
AssertSelectMailer.test("<div><p>foo</p><p>bar</p></div>").deliver_now
AssertMultipartSelectMailer.test(html: "<div><p>foo</p><p>bar</p></div>", text: "foo bar").deliver_now
File.expand_path("..", __dir__)
def file_name # :doc:
if diff == 1
assert_enqueued_jobs(number, only: ->(job) { delivery_job_filter(job) }, &block)
args = if args.is_a?(Hash)
perform_enqueued_jobs(only: ->(job) { delivery_job_filter(job) }, queue: queue, at: at, &block)
job_class = job.is_a?(Hash) ? job.fetch(:job) : job.class
@expected.mime_version = "1.0"
def process(...)
options.each { |k, v| send("#{k}=", v) }
def call(email, params = {})
all.any? { |p| p.preview_name == preview }
all.find { |p| p.preview_name == preview }
@params ||= {}
def __getobj__ # :nodoc:
def __setobj__(mail_message) # :nodoc:
__getobj__
def deliver_later!(options = {})
formatted = text.split(/\n\r?\n/).collect { |paragraph|
}.join("\n\n")
indentation = " " * indent
}.join "\n"
message.all_parts.find { |p| p.attachment? && p.cid == cid }
location: defined?(Rails.root) ? "#{Rails.root}/tmp/mails" : "#{Dir.tmpdir}/mails"
mail.delivery_method(klass, (send(:"#{method}_settings") || {}).merge(options || {}))
args.each { |type| send(type, options.dup, &block) }
def custom(mime, options = {})
mime_version: "1.0",
@_message = Mail.new
def body; "" end
def header; {} end
def mail(headers = {}, &block)
params = m.content_type_parameters || {}
mailer_scope = self.class.mailer_name.tr("/", ".")
if p.attachment? && !p.inline?
mixed << p
mixed.each { |c| message.add_part(c) }
if responses.size == 1 && !m.has_attachments?
responses.each { |r| insert_part(m, r, m.charset) }
body "<h1>Hello, world</h1>"
\r
<h1>Hello, world</h1>
@router.add_routes("first@example.com" => :first, "second@example.com" => :second)
headers: { "Content-Type" => "message/rfc822", "User-Agent" => /\AAction Mailbox relayer v\d+\./ }
require_relative "../../test_helper"
raise "No way!"
around_processing ->(r, block) { block.call; $around_processing = "Ran that as well!" }
@mail = Mail.new \
ActiveStorage::Blob.service.stub(:upload, -> { raise "Boom!" }) do
if ARGV.include?("-v")
format.html { render plain: "Sorry!" }
destination File.expand_path("../../tmp", __dir__)
assert_match(/# test "receive mail" do/, test)
mail: {
cc: "CC <cc@example.com>",
bcc: "Bcc <bcc@example.com>",
body: "How's it going?"
from: "",
to: "",
cc: "",
bcc: "",
x_original_to: "",
subject: "",
in_reply_to: "",
body: "",
headers: { "X-Mandrill-Signature" => "forged" }, params: { mandrill_events: @events }
switch_key_to "" do
@_file_name ||= super.sub(/_mailbox\z/i, "")
status_code.start_with?("4.")
status_code.start_with?("5.")
Result.new "4.0.0", "HTTP #{response.code}"
@client ||= Net::HTTP.new(uri.host, uri.port).tap do |connection|
if uri.scheme == "https"
other_address.is_a?(Mail::Address) && to_s == other_address.to_s
delivered? || failed? || bounced?
@request, @key = request, key
signed? && recent?
@last_action = :run
ActionCable.server.config.cable = { "adapter" => "test" }
timeout -= 0.1
{ adapter: "test" }
{ adapter: "redis", driver: "ruby" }.tap do |x|
redis_conn.client("kill", "type", "pubsub")
wait -= 0.1
alt_cable_config.merge(host: url.hostname || "127.0.0.1", port: url.port || 6379, db: 12)
{ url: 1, host: 2, port: 3, db: 4, password: 5 }
database_config = { "adapter" => "postgresql", "database" => "activerecord_unittest" }
ar_tests = File.expand_path("../../../activerecord/test", __dir__)
@rx_adapter = @tx_adapter = nil
{ adapter: "postgresql" }
subscribe_as_queue("channel") { }
{ adapter: "inline" }
callback = -> data { queue << data }
2.times { received << queue.pop }
channel_1 = "a" * 100 + "1"
channel_2 = "a" * 100 + "2"
{ adapter: "async" }
GlobalID.new("User##{name}")
GlobalID.new("Room##{id}-#{name}")
delegate :to_param, :to_s, to: :uri
def initialize(gid, options = {})
@uri = gid
message = { body: "test message" }
connect params: { user_id: 323 }
connect session: { user_id: "789" }
def user; "David"; end
@exceptions << e
@lines << data
data = { "content" => "Hello World!", "action" => "speak" }
data = { "content" => "Hello World!", "action" => "throw_exception" }
rack_hijack_io = File.open(File::NULL, "w")
env = Rack::MockRequest.env_for "/test",
self.current_room = Room.new "my", "room"
io, client_io = \
break if client_io.readline == "\r\n"
assert_equal({ data: { "action" => "speak", "message" => "hello" }, context: "test" }, message)
def call(*)
raise "Do not call me!"
opts = { min_threads: 1, max_threads: 4 }
::Puma::Server.new(rack_app, nil, opts)
def initialize(port, path = "/")
@ws = WebSocket::Client::Simple.connect("ws://127.0.0.1:#{port}#{path}") do |ws|
ws.on(:error) do |event|
ws.on(:open) do |event|
ws.on(:message) do |event|
if event.type == :close
ws.on(:close) do |_|
list << msg
enum.map { |*x| Concurrent::Promises.future { yield(*x) } }.map(&:value!)
assert_equal({ "identifier" => "{\"channel\":\"ClientTest::EchoChannel\"}", "type" => "confirm_subscription" }, c.read_message)
assert_equal({ "identifier" => "{\"channel\":\"ClientTest::EchoChannel\"}", "message" => { "dong" => "hello" } }, c.read_message)
assert_equal({ "identifier" => '{"channel":"ClientTest::EchoChannel"}', "type" => "confirm_subscription" }, c.read_message)
assert_equal({ "identifier" => '{"channel":"ClientTest::EchoChannel"}', "message" => { "dong" => "hello" } }, c.read_message)
assert_equal({ "type" => "welcome" }, c.read_message)
c = websocket_client(port, "/?id=1")
assert_equal({ "type" => "disconnect", "reason" => "remote", "reconnect" => true }, c.read_message)
c = websocket_client(port, "/?id=2")
assert_equal({ "type" => "disconnect", "reason" => "remote", "reconnect" => false }, c.read_message)
transmit({ type: "pong" })
perform :echo, text: "You are man!"
assert_equal({ "text" => "You are man!" }, transmissions.last)
when nil, "json"
def encode(*) '{ "foo": "encoded" }' end
def decode(*) { foo: "decoded" } end
channel = ChatChannel.new connection, "{id: 1}", id: 1
rejection = { "identifier" => "{id: 1}", "type" => "reject_subscription" }
confirmation = { "identifier" => "{id: 1}", "type" => "confirm_subscription" }
expected = { "identifier" => "test_channel", "type" => "confirm_subscription" }
@server.broadcast "test_room_1", { foo: "bar" }, coder: DummyEncoder
expected = { "identifier" => { "channel" => MultiChatChannel.name }.to_json, "type" => "confirm_subscription" }
@user = User.new "lifo"
@channel = SecretChannel.new @connection, "{id: 1}", id: 1
expected = { "identifier" => "{id: 1}", "type" => "reject_subscription" }
periodically -> { ping }, every: 2
3.times { mock.expect(:shutdown, nil) }
times: 3,
channel = ChatChannel.new @connection, "{id: 1}", id: 1
@room = nil
transmit({ data: "latest" })
@channel = ChatChannel.new @connection, "{id: 1}", id: 1
assert_equal({ id: 1 }, @channel.params)
data = { password: "password", foo: "foo" }
data = { "action" => :speak, "content" => "Hello World" }
data = { "action" => :topic, "content" => "This is Sparta!" }
data = { "content" => "hello" }
expected = { "identifier" => "{id: 1}", "message" => { "data" => "latest" } }
expected = { "identifier" => "{id: 1}", "type" => "confirm_subscription" }
data = { "action" => :speak, "content" => "hello" }
expected_data = { data: "latest" }
@_file_name ||= super.sub(/_channel\z/i, "")
gsub_file "#{channel_js_path}.js", /\.\/consumer/, "channels/consumer" unless using_node?
using_node? ? %(import "./channels"\n) : %(import "channels"\n)
using_node? ? %(import "./#{file_name}_channel"\n) : %(import "channels/#{file_name}_channel"\n)
@using_node ||= root.join("package.json").exist?
error_message = "No messages sent with #{data} to #{stream}"
@channels_data ||= {}
gem "redis", ">= 4", "< 6"
class Redis < Base # :nodoc:
@thread = nil
@event_loop.post { super }
@thread ||= Thread.new do
sleep(sleep_t) if sleep_t > 0
class Inline < Base # :nodoc:
class Async < Inline # :nodoc:
logger.error "There was an exception - #{e.class}(#{e.message})"
adapter = (cable.fetch("adapter") { "redis" })
@pubsub = nil
ids.each { |k, v| instance_variable_set("@#{k}", v) }
identifiers.all? { |id| keys.include?(id) }
tag "meta", name: "action-cable-url", content: (
wrap = lambda do |_, inner|
def build_test_request(path, params: nil, headers: {}, session: {}, env: {})
}.merge(env)
@tags = @tags.uniq
def log(type, message) # :doc:
tag(@logger) { @logger.send type, message }
@subscriptions = {}
@nio = @executor = @thread = nil
@map = {}
def post(task = nil, &block)
task ||= block
@todo << lambda do
@nio ||= NIO::Selector.new
@thread = Thread.new { run }
spawn || @nio.wakeup
if @write_head.nil? && @write_buffer.empty?
ids.map do |o|
o.to_s
end.sort.join(":")
scheme = secure_request?(env) ? "wss:" : "ws:"
@driver.on(:message) { |e| receive_message(e.data) }
def close(code = nil, reason = nil)
reason ||= ""
unless code == 1000 || (code >= 3000 && code <= 4999)
@ready_state == OPEN
@server, @env, @coder = server, env, coder
def on_open # :nodoc:
def on_close(reason, code) # :nodoc:
def request # :doc:
@request ||= begin
proto = Rack::Request.new(env).ssl? ? "https" : "http"
tags: server.config.log_tags.map { |tag| tag.respond_to?(:call) ? tag.call(request) : tag.to_s.camelize }
def subscribe(params = {})
def perform(action, data = {})
@_streams ||= {}
-> message do
-> message { handler.(coder.decode(message)) }
-> (message) do
-> message { message }
-> { __send__ callback_or_method_name }
unless every.kind_of?(Numeric) && every > 0
@channel_name ||= name.delete_suffix("Channel").gsub("::", ":").underscore
object.map { |m| serialize_broadcasting(m) }.join(":")
def method_added(name) # :doc:
def transmit(data, via: nil) # :doc:
status += " (via #{via})" if via
payload = { channel_class: self.class.name, data: data, via: via }
def reject # :doc:
(+"#{self.class.name}##{action}").tap do |signature|
signature << "(#{arguments.inspect})"
ping: "ping",
let(:stream) { StringIO.new }
let(:app_name) { "my_app" }
time = Time.parse("2022-02-04 11:38:25.218816 +0100")
path = "/users"
ip = "127.0.0.1"
params = {"user" => {"password" => "secret"}}
expect(actual).to eql(<<~LOG)
env = Rack::MockRequest.env_for(path = "/users")
.to :info
subject(:slice_name) { described_class.new(slice, inflector: -> { inflector }) }
let(:slice) { double(name: "Main::Slice") }
let(:slice_module) { Module.new }
describe "#to_s" do
store = {}.freeze
setting :database_url, constructor: ->(_v) { raise "nope to database" }
setting :redis_url, constructor: ->(_v) { raise "nope to redis" }
store = {
store = {}
orig_env = ENV.to_h
store = described_class.new(store: {"FOO" => "bar"})
expect(store.fetch("FOO")).to eq("bar")
expect(store.fetch("foo")).to eq("bar")
expect(store.fetch(:foo)).to eq("bar")
expect(store.fetch("BAZ", "qux")).to eq("qux")
let(:value) { nil }
let(:env) { nil }
let(:value) { 18_000 }
let(:value) { 2300 }
let(:env) { 9000 }
context ".call!" do
let(:value) { 9000 }
it "set env var" do
@orig_env = ENV.to_h
let(:app_name) { "MyApp::app" }
an_object_satisfying { |path| path.dir.to_s == "templates" }
it 'is "views"' do
it 'is "app"' do
Hanami::SliceName.new(double(name: "MyApp::app"), inflector: -> { Dry::Inflector.new })
let(:env) { :development }
let(:env) { :production }
it "a value" do
expect { subject.level = :warn }
.to(:warn)
let(:env) { :test }
expected = File.join("log", "test.log")
.to(:json)
expect { subject.template = "%<message>s" }
.to("%<message>s")
expect { subject.filters << "secret" }
Hanami::SliceName.new(double(name: "SOS::app"), inflector: -> { Dry::Inflector.new })
let(:env) { :staging }
it "defaults to a URI of 'http://0.0.0.0:2300'" do
expect(config.base_url).to eq URI("http://0.0.0.0:2300")
expect { config.base_url = "http://example.com" }
.to change { config.base_url }
.to(URI("http://example.com"))
expect { config.base_url = URI("http://example.com") }
.to end_with("pub")
expect { actions.formats.add(:json, "app/json") }
.to include("app/json" => :json)
config.sessions = :cookie, {secret: "abc"}
it "is true" do
it "is false" do
expect(cookies.to_h).to eq({})
%(base-uri 'self'),
%(child-src 'self'),
%(connect-src 'self'),
%(default-src 'none'),
%(font-src 'self'),
%(form-action 'self'),
%(frame-ancestors 'self'),
%(frame-src 'self'),
%(img-src 'self' https: data:),
%(media-src 'self'),
%(object-src 'none'),
%(script-src 'self'),
%(style-src 'self' 'unsafe-inline' https:)
let(:assets_server_url) { "http://localhost:8080" }
let(:cdn_url) { "https://assets.hanamirb.test" }
run_cmd "hanami new #{input}"
expect(all_output).to match(/#{output}/)
expect("lib/#{project}.rb").to have_file_content <<~END
/db/*.sqlite
.env.*.local
expect("lib/#{project}/entities/#{model}.rb").to have_file_content <<~END
child.to_s.include?("create_#{table_name}")
expect(file).to_not be_nil, "Expected to find a migration matching: #{file}.\nFound: #{migrations.map(&:basename).join(' ')}"
root __dir__
base-uri 'self';
img-src 'self' https: data:;
font-src 'self';
require_relative '../lib/#{project}'
mount #{app_name}::Application, at: '/#{app}'
mount Web::Application, at: '/'
dir.include?("/spec/") || dir.include?(Dir.tmpdir) ||
dir.include?("/slices/") || dir.include?("/app")
write "config/app.rb", <<~RUBY
write "app/view.rb", <<~RUBY
write "app/views/users/show.rb", <<~RUBY
== yield
h1 Hello, #{name}
expect(rendered.to_s).to eq "<html><body><h1>Hello, Jennifer</h1></body></html>"
config.root = "/test_app"
let(:app_hook) {
let(:view_class) { TestApp::MyViews::Users::Show }
write "config/app.rb", <<~'RUBY'
write "app/view.rb", <<~'RUBY'
write "app/views/articles/index.rb", <<~'RUBY'
write "slices/admin/view.rb", <<~'RUBY'
write "config/slices/admin.rb", <<~'RUBY'
let(:view_class) { TestApp::View }
it "is View::Parts" do
it "is nil" do
let(:settings) { double(:settings) }
write "config/routes.rb", <<~RUBY
write "app/action.rb", <<~RUBY
let(:request) { double(:request) }
let(:session) { double(:session) }
let(:flash) { double(:flash) }
let(:assets) { double(:assets) }
write "slices/main/lib/foo.rb", <<~RUBY
let(:app) { Main::Slice.rack_app }
write "slices/main/.keep", ""
write "config/routes.rb", <<~'RUBY'
get "home", to: "home.show", as: :home
def handle(*, res)
root to: "home.show"
slice :main, at: "/main"
write "app/actions/home/show.rb", <<~'RUBY'
let(:app) { TestApp::App.app }
get "/main"
TestApp::App.register("foo") { "bar" }
expect(Hanami.app).to have_key(:foo, "bar")
Admin::Slice.register("bar") { "baz" }
Main::Slice.register("baz") { "quux" }
write "config/slices/main.rb", <<~'RUBY'
write "config/slices/search.rb", <<~'RUBY'
slice :external, at: "/" do
write "lib/external/slice.rb", <<~'RUBY'
write "lib/external/lib/test_repo.rb", <<~'RUBY'
res.body = test_repo.things.join(", ")
expect { setup }.to change { Hanami.app? }.to true
def setup(...)
Hanami.setup(...)
expect(app_path.to_s).to match(%r{^/.*/config/app.rb$})
@env = ENV.to_h
/#{numeric_error}.+#{flag_error}|#{flag_error}.+#{numeric_error}/m
write "slices/admin/.keep", ""
write "config/settings.rb", <<~'RUBY'
write ".env.development.local", <<~'TEXT'
write ".env.local", <<~'TEXT'
write ".env.development", <<~'TEXT'
write ".env", <<~'TEXT'
write ".env.test.local", <<~'TEXT'
write ".env.test", <<~'TEXT'
write "app/types.rb", <<~'RUBY'
Types = Dry.Types()
let(:app) { Hanami.app }
get "/users", to: "users.index"
post "/users", to: "users.create"
logs = -> { Pathname(dir).join("test.log").realpath.read }
post "/users", JSON.generate(name: "jane", password: "secret"), {"CONTENT_TYPE" => "application/json"}
get "/users"
raise unless e.to_s == "OH NOEZ"
err_log = logs.()
log_content = logs.()
get "/health", to: "health.show"
get "/inline" do
slice :main, at: "/" do
slice :admin, at: "/admin" do
res.body = "Health, OK"
get "/health"
slice :api, at: "/api" do
get "/people", to: "people.index"
res.body = "People"
get "/missing", to: "missing.action"
slice :foo, at: "/foo" do
get "/bar", to: "bar.index"
config.logger.stream = File.new("/dev/null", "w")
get "/admin"
slice :api_v1, at: "/v1" do
res.body = "API v1"
get "/api/v1"
expect { require "hanami/prepare" }.not_to(change { ENV.to_h })
expect(ENV.key?("FOO")).to be false
let!(:slice) {
write "app/.keep", ""
write "lib/non_app/thing.rb", <<~RUBY
write "app/some_service.rb", <<~'RUBY'
write "app/some_operation.rb", <<~'RUBY'
write "slices/main/test_class.rb", <<~'RUBY'
write "slices/main/action.rb", <<~'RUBY'
write "slices/main/lib/test_class.rb", <<~'RUBY'
write "lib/external_class.rb", <<~'RUBY'
write "lib/test_app/test_class.rb", <<~'RUBY'
expect($LOAD_PATH).to include(@dir.join("lib").to_s)
expect($LOAD_PATH).not_to include(@dir.join("lib").to_s)
config.root = Pathname(__dir__).join("..", "src").realpath
write "src/lib/external_class.rb", <<~'RUBY'
write "src/lib/test_app/test_class.rb", <<~'RUBY'
expect($LOAD_PATH).not_to include(@dir.join("src", "lib").to_s)
.to include(@dir.join("src", "lib").to_s)
expect($LOAD_PATH).to include(@dir.join("src", "lib").to_s)
config.root = Pathname(__dir__).join("..", "src").realpath and prepare_load_path
expect($LOAD_PATH).to include(@dir.join("src", "lib").to_s).exactly(1).times
write "app/test_class.rb", <<~'RUBY'
write "app/action.rb", <<~'RUBY'
write "app/lib/test_class.rb", <<~'RUBY'
expose :name, :job, :age
p = value
p = job
p = age
response = action.(name: "Jennifer", last_name: "Lopez")
expect(rendered).to eq "<html><body><h1>Hello, Jennifer</h1><p>Jennifer</p><p>Lopez</p><p>Singer</p><p>51</p></body></html>"
let(:action) { action_class.new }
let(:view) { double(:view) }
res.body = "200: Okay okay okay"
h1 Hello, #{name.to_str}!
response = action.({})
let(:action_args) { {} }
let(:action_args) { {view_context: view_context} }
proc do |app|
let(:response) { double(:response) }
is_expected.to eq({})
) { custom_view_context }
write "slices/admin/action.rb", <<~'RUBY'
subject(:app_hook) {
!value || value.to_s == "0" ? "-" : value
version =~ /alpha|beta|rc/
version.scan(/\A\d{1,2}\.\d{1,2}/).first
@slices = {}
.map { |file| File.basename(file, RB_EXT) }
.select { |path| File.directory?(path) }
.map { |path| File.basename(path) }
.then { filter_slice_names(_1) }
to_a.flat_map { |slice|
raise e unless e.name.to_s == inflector.camelize(slice_name) || e.name.to_s == :Slice
&.select { |name|
&.map { |name|
@inflector.()
require_relative "../../routes"
-> (*args) {
raise "Add \"rack\" to your `Gemfile` to run Hanami as a rack app"
@stack.each_with_object({}) do |(path, _), result|
def path(...)
router.path(...)
def url(...)
router.url(...)
def use(*args, **kwargs, &blk)
def slice(slice_name, at:, &blk)
scope(at, &blk)
@_mutex = Mutex.new
!!@booted
def register_slice(...)
slices.register(...)
def register(...)
def start(...)
container.start(...)
def stop(...)
container.stop(...)
def key?(...)
container.key?(...)
def resolve(...)
if from.is_a?(Symbol) || from.is_a?(String)
import(from: from, as: as, **kwargs)
@routes ||= load_routes
@rack_app ||= router.to_rack_app
def call(...)
rack_app.call(...)
container.use(:env, inferrer: -> { Hanami.env })
.map { |path|
errors = config._settings.map(&:name).each_with_object({}) do |name, errs|
action_file = slice.root.join("#{action_path}#{RB_EXT}")
public_send(name, *args, **kwargs, &block)
@slice || Hanami.app
:"#{setting.name}=",
path = "#{slice.slice_name.path}/#{path}"
.sub(/^#{slice.slice_name.path}\//, "")
.sub(/^#{view_class.config.template_inference_base}\//, "")
require_relative "../../errors"
@content_for = {}
super(**args)
def with(**args)
define_method(:new) do |**kwargs|
view: kwargs.fetch(:view) { resolve_view.(self) },
routes: kwargs.fetch(:routes) { resolve_routes.() },
res.render(view, **req.params) if !halted && auto_render?(res)
view && res.body.empty?
@_loaded = false
(".env.local" unless env == :test),
@_loaded = true
self.layout = "app"
@app_name = app_name
config.stream = File.join("log", "#{env}.log") if env == :test
.add_backend(log_if: -> entry { !entry.tag?(:rack) })
.add_backend(formatter: :rack, log_if: -> entry { entry.tag?(:rack) })
@policy = {
base_uri: "'self'",
child_src: "'self'",
connect_src: "'self'",
default_src: "'none'",
font_src: "'self'",
form_action: "'self'",
frame_ancestors: "'self'",
frame_src: "'self'",
img_src: "'self' https: data:",
media_src: "'self'",
object_src: "'none'",
script_src: "'self'",
style_src: "'self' 'unsafe-inline' https:"
blk&.(self)
end.join(";")
key.to_s.gsub("_", "-")
setting :root, constructor: ->(path) { Pathname(path) if path }
setting :base_url, default: "http://0.0.0.0:2300", constructor: ->(url) { URI(url) }
@_bundled = {}
lib_path = app_path&.join("..", "..", LIB_DIR)
@_app
names.map(&:to_sym).include?(env)
fab!(:topic) { Fabricate(:topic) }
url: "https://example.com/",
fab!(:category) { Fabricate(:category) }
let(:upload1) { Fabricate(:upload_s3) }
let(:upload2) { Fabricate(:upload_s3) }
let!(:post1) { Fabricate(:post) }
let!(:post2) { Fabricate(:post) }
let!(:post3) { Fabricate(:post) }
let(:post1) { Fabricate(:post) }
let(:post2) { Fabricate(:post) }
before { STDIN.stubs(:beep) }
fab!(:upload) { Fabricate(:image_upload, width: 200, height: 200) }
(active_keys | orphan_keys).each { |key| redis.set(key, 1) }
active_keys.each { |key| expect(redis.get(key)).to eq("1") }
orphan_keys.each { |key| expect(redis.get(key)).to eq(nil) }
active_keys.each { |key| redis.del(key) }
fab!(:post) { Fabricate(:post, raw: "The quick brown fox jumps over the lazy dog") }
fab!(:tricky_post) { Fabricate(:post, raw: "Today ^Today") }
post.update(cooked: "")
let(:url) do
let(:upload) { Fabricate(:upload, url: url) }
post = Fabricate(:post, raw: "A sample post <img src='#{url}'>")
fab!(:category) { Fabricate(:category, slug: "support") }
post_2 =
:post,
fab!(:admin) { Fabricate(:admin) }
fab!(:user) { Fabricate(:user) }
before { sign_in(user) }
fab!(:tag) { Fabricate(:tag) }
fab!(:tag2) { Fabricate(:tag) }
before { sign_in(admin) }
visit("/latest")
visit ("/latest")
fab!(:post) { Fabricate(:post, topic: topic) }
fab!(:current_user) { Fabricate(:admin) }
visit("/t/-/#{topic.id}")
find(".d-editor-input").fill_in(with: "Hello @dis")
find(".d-editor-input").fill_in(with: "Hello @adm")
fab!(:tag_1) { Fabricate(:tag, name: "design") }
fab!(:tag_2) { Fabricate(:tag, name: "art") }
fab!(:post) { Fabricate(:post, topic: topic, raw: "This is a test post in a test topic") }
visit("/search")
tag_selector_header.has_content?(tags.map(&:name).join(", "))
page.visit("/u/#{user.username}")
page.visit "/t/#{topic.id}"
page.visit "/"
has_css?("#post_#{number}")
find(".topic-post:not(.staged) #post_#{post_or_number}")
has_css?(".show-more-actions")
page.visit "/tag/#{tag.name}"
find("#show-tag-info")
find(".add-synonyms .ok")
find("input.full-page-search").set("")
find(".form-template-field__#{type}").present?
page.visit("/c/#{category.id}")
fill_in "link-name", with: name, match: :first
fill_in "link-url", with: url, match: :first
find(".modal-outer-container").click(x: 0, y: 0)
I18n.t("js.desktop_view"),
page.has_css?("#d-sidebar")
page.has_no_css?("#d-sidebar")
def has_link?(name, href: nil)
element.has_css?(":not(.is-expanded)")
fill_content("")
find("#{COMPOSER_ID} #reply-title").fill_in(with: title)
fill_input("")
fab!(:tag) { Fabricate(:tag, name: "cooltag", staff_topic_count: 324, public_topic_count: 324) }
fab!(:tag2) { Fabricate(:tag, name: "othertag", staff_topic_count: 66, public_topic_count: 66) }
expect(hashtag_results.map(&:text).map { |r| r.gsub("\n", " ") }).to eq(
fab!(:closed_topic) { Fabricate(:topic, closed: true) }
visit("/filter")
within("#post_1 .cooked > p") do |el|
const { deprecate } = require('@ember/debug');
deprecate("Some message", false, { id: "some.id" })
visit("/c/#{category1.id}")
visit("/c/#{category3.slug}/#{category3.id}/none")
visit("/c/#{category3.id}")
visit("/tags/c/#{category3.slug}/#{category3.id}/#{tag.name}")
sidebar_url_1 = Fabricate(:sidebar_url, name: "tags", value: "/tags")
fab!(:upload) { Fabricate(:upload) }
within(".d-editor-preview") { expect(page).to have_css(".emoji") }
within(".d-editor-preview") { expect(page).to have_css("img") }
fab!(:theme) { Fabricate(:theme) }
fab!(:post) { Fabricate(:post, topic: topic, raw: "This is some post to bookmark") }
before { sign_in user }
sample_template = "- type: input"
- "Option 1"
- "Option 2"
- "Option 3"
file_types: "jpg, png, gif"
curl -X GET "http://127.0.0.1:3000/admin/users/list/active.json" \\
curl -X POST "http://127.0.0.1:3000/categories" \\
-H "Content-Type: multipart/form-data;" \\
-H "Api-Username: system" \\
-F "color=49d9e9" \\
openapi: "3.1.0",
info: {
license: {
paths: {
url: "https://{defaultHost}",
schemas: {
type: "public-key",
fab!(:group) { Fabricate(:group) }
fab!(:category_2) { Fabricate(:category) }
fab!(:tag) { Fabricate(:tag, name: "foo") }
fab!(:pm_tag) do
fab!(:hidden_tag) { Fabricate(:tag, name: "secret") }
{ name: tag.name, pm_only: false },
{ name: pm_tag.name, pm_only: true },
{ name: hidden_tag.name, pm_only: false },
:head,
message = +"ts_vector does not match!\n\n"
message << (expected - actual).join("\n")
message << (actual - expected).join("\n")
match { |actual_time| (actual_time - expected_time).abs < 1 }
match { |actual_time| (actual_time - expected_time).abs < 60 }
match { |actual_time| (actual_time - expected_time).abs < 0.001 }
start ||= Time.zone.now
js = <<-JS
klass = job.instance_of?(Class) ? job : "::Jobs::#{job.to_s.camelcase}".constantize
at = at.to_f if at.is_a?(Time)
expected = { job: job, args: args, at: at }.compact
def expect_not_enqueued_with(job:, args: {}, at: nil)
def job_enqueued?(job:, args: {}, at: nil)
def expect_job_enqueued(job:, args: {}, at: nil)
expect(job_enqueued?(job: job, args: args, at: at)).to eq(true)
def match_jobs(jobs:, args:, at:)
args.merge!(at: at) if at
matched_job ||=
args.all? do |key, value|
if key == :at
file = File.join("spec", "fixtures", "onebox", "#{file}.response")
File.exist?(file) ? File.read(file) : ""
stub_request(:get, defined?(@uri) ? @uri : @link).to_return(
let(:html) { onebox.to_html }
let(:link) { @link }
@repos ||= {}
doc =
node.content = node.content.gsub(/\s+/, " ").strip if node.node_name&.downcase == "text"
post "/u.json",
id =
get "/session/hp.json" if id.nil?
email = +""
email += "Date: Sat, 31 Mar 2018 17:50:19 -0700\n"
email += "Mime-Version: 1.0\n"
@next_seq = (@next_seq || 0) + 1
def create_topic(args = {})
user = args.delete(:user) || Fabricate(:user)
def create_post(args = {})
def wait_for(on_fail: nil, &blk)
while !result && i < 1000
tag_group.tags << (Tag.where(name: name).first || Fabricate(:tag, name: name))
tag_group = Fabricate(:tag_group, name: "Hidden Tags", permissions: { staff: :full })
tag_records.map { |t| t.is_a?(String) ? t : t.name }.sort
previous_output = output_name == :stdout ? $stdout : $stderr
output_name == :stdout ? $stdout = io : $stderr = io
File.write("#{repo_dir}/#{name}", data)
callback = ->(*, payload) do
.with { |addr, _| addr == stub_addr }
s3 = self.new
@buckets = {}
bucket_name, _prefix = bucket_name.split("/", 2)
bucket_name, _prefix = full_bucket_name.split("/", 2)
.stubs(:new)
.with { |b| b == bucket_name || b == bucket.name }
->(context) do
{ status_code: 404, headers: {}, body: "" }
@objects = {}
.where("LOWER(name) IN (:slugs)", slugs: slugs)
.map do |bm|
item.slug = bm.name.gsub(" ", "-")
query = query.where("name ILIKE ?", "#{term}%")
query = query.where("name ILIKE ?", "%#{term}%")
params << kwargs if kwargs != {}
if @tracking && (@channel.nil? || @channel == channel)
m = MessageBus::Message.new(-1, id, channel, data)
@tracking << m
!@path.empty?
def self.run(seed, runs, &blk)
seed = seed.to_i
path = Path.new(Random.new(seed + i))
def self.run(seed: nil, runs: nil, &blk)
@blk = blk
@tasks << Fiber.new(&blk)
task = @path.choose(*@tasks)
def run(**opts)
Logic.run(**opts, &method(:run_with_path))
@redis.send(method, *args, &blk)
let(:raw) { <<~RAW.strip }
word1 => {
word2 => {
word =
).word
word => {
let!(:word3) do
let!(:word4) do
fab!(:anise) do
).to eq("Love")
).to eq("love")
word: "((move|store)(d)?)|((watch|listen)(ed|ing)?)",
word: ":woman:t5:",
word: "to replace",
fab!(:link_word) do
word: "\\Wplaceholder",
result5 = described_class.check_url("https://", "https://")
@nil_email = nil
let(:user) { Fabricate(:user) }
.last(2)
let(:wrong_username) { "" }
let!(:myself) { Fabricate(:user, username: "hansolo") }
} # make sure it does not log a dupe
@custom_min = 2
result = UsernameChanger.change(user, "a" * (@custom_min - 1))
let(:user) { Fabricate(:user, username: "foo") }
let(:topic) { Fabricate(:topic, user: user) }
expect(post.cooked).to eq(%Q(<p>Hello <a class="mention" href="/u/bar">@bar</a></p>))
post = create_post_and_change_username(raw: ".@foo -@foo %@foo _@foo ,@foo ;@foo @@foo")
expect(post.raw).to eq(".@bar -@bar %@bar _@bar ,@bar ;@bar @@bar")
<p>.<a class="mention" href="/u/bar">@bar</a>
-<a class="mention" href="/u/bar">@bar</a>
%<a class="mention" href="/u/bar">@bar</a>
_<a class="mention" href="/u/bar">@bar</a>
,<a class="mention" href="/u/bar">@bar</a>
;<a class="mention" href="/u/bar">@bar</a>
@<a class="mention" href="/u/bar">@bar</a></p>
post = create_post_and_change_username(raw: %Q("@foo" '@foo'))
expect(post.raw).to eq(%Q("@bar" '@bar'))
post = create_post_and_change_username(raw: "**@foo** *@foo* _@foo_ ~~@foo~~")
expect(post.raw).to eq("**@bar** *@bar* _@bar_ ~~@bar~~")
<p><strong><a class="mention" href="/u/bar">@bar</a></strong>
<em><a class="mention" href="/u/bar">@bar</a></em>
<s><a class="mention" href="/u/bar">@bar</a></s></p>
post = create_post_and_change_username(raw: "@foo. @foo, @foo: @foo; @foo_ @foo-")
expect(post.raw).to eq("@bar. @bar, @bar: @bar; @bar_ @bar-")
<p><a class="mention" href="/u/bar">@bar</a>.
<a class="mention" href="/u/bar">@bar</a>,
<a class="mention" href="/u/bar">@bar</a>:
<a class="mention" href="/u/bar">@bar</a>;
<a class="mention" href="/u/bar">@bar</a>_
<a class="mention" href="/u/bar">@bar</a>-</p>
post =
raw: p.raw.gsub("@foobar", "@foo_"),
cooked: p.cooked.gsub("@foobar", "@foo_"),
expect(post.raw).to eq("@bar_ @bar")
%Q(<p><span class="mention">@foo_</span> <a class="mention" href="/u/bar">@bar</a></p>),
expect(post.raw).to eq("@bar a@foo 2@foo")
%Q(<p><a class="mention" href="/u/bar">@bar</a> a@foo 2@foo</p>),
expect(post.raw).to eq("@bar mail@foo.com")
%Q(<p><a class="mention" href="/u/bar">@bar</a> <a href="mailto:mail@foo.com">mail@foo.com</a></p>),
expect(post.raw).to eq("@bar @foobar @foo-bar @foo_bar @foo1")
post.update_column(:cooked, post.cooked.gsub("/u/foo", "/users/foo"))
expect(post.raw).to eq("Hello @bar")
{ raw: "Hello Foo" },
{ title: "new topic title" },
{ raw: "Hello @foo!" },
{ raw: "Hello @foo!!" },
expect(post.raw).to eq("Hello @bar!!")
expect(post.cooked).to eq(%Q(<p>Hello <a class="mention" href="/u/bar">@bar</a>!!</p>))
%Q(<p>Hello <a class="mention" href="/u/bar">@bar</a></p>),
%Q(<p>Hello <a class="mention" href="/u/bar">@bar</a>!</p>),
%Q(<p>Hello <a class="mention" href="/u/bar">@bar</a>!!</p>),
raw: '<a class="mention">@foo</a> and <a class="mention">@someuser</a>',
expect(post.raw).to eq('<a class="mention">@bar</a> and <a class="mention">@someuser</a>')
{ raw: "Hello @#{user.username}!" },
{ raw: "Hello @#{user.username}!!" },
let(:avatar_url) { user.avatar_template_url.gsub("{size}", "40") }
expect(post.raw).to eq(<<~RAW.strip)
<p>Lorem ipsum</p>
<div class="title">
<img loading="lazy" alt='' width="20" height="20" src="#{avatar_url}" class="avatar"> bar:</div>
<p>quoted post</p>
</aside>
<img loading="lazy" alt="" width="20" height="20" src="#{avatar_url}" class="avatar"> bar:</div>
<p>dolor sit amet</p>
let(:raw) { <<~RAW }
let(:expected_raw) { <<~RAW.strip }
let(:expected_cooked) { <<~HTML.rstrip }
<p>quoted</p>
let(:avatar_url) { user_avatar_url(user) }
let(:evil_trout) { Fabricate(:evil_trout) }
url.sub(/^https?:/, "")
u.avatar_template_url.gsub("{size}", "40")
raw = "#{quoted_post.full_url}\n#{quoted_post.topic.url}"
<img loading="lazy" alt="" width="20" height="20" src="#{avatar_url}" class="avatar">
<img loading="lazy" alt="" width="20" height="20" src="#{user_avatar_url(evil_trout)}" class="avatar">
{ username: username, foo: "bar" }
n01 =
n02 =
p2,
n03 =
p1,
n05 =
n06 =
n07 =
n08 =
n09 =
n10 =
it "#{testcase_name}" do
fab!(:u1) { Fabricate(:user) }
fab!(:u2) { Fabricate(:user) }
fab!(:u3) { Fabricate(:user) }
user = Fabricate(:user, name: "Billy Bob")
tag_id: tag.id,
).exists?,
).to eq(true)
tag_id: tag2.id,
).count,
).to eq(1)
let(:staged_user) { Fabricate(:staged) }
tag: tag,
val =
bio_raw: "my new bio",
day_0_end_time: 60,
day_1_end_time: 60,
day_2_end_time: 60,
day_3_end_time: 60,
day_4_end_time: 60,
day_5_end_time: 60,
day_6_end_time: 60,
}.by(4)
let(:new_group) { Group.create(name: "new_group") }
name: "Group",
flair_bg_color: "#111111",
flair_color: "#999999",
flair_icon: "icon",
fab!(:user) { Fabricate(:user, title: "Emperor") }
fab!(:badge) { Fabricate(:badge, name: "Minion") }
user.custom_fields = { "import_username" => "my_old_username" }
}.by(1)
1,
fab!(:user_stat) { user.user_stat }
fab!(:post) { Fabricate(:post) }
fab!(:post_2) { Fabricate(:post, topic: post.topic) }
fab!(:user) { Fabricate(:user, trust_level: 0) }
fab!(:post) { Fabricate(:post, user: user) }
@override_silence_message = ->(opts) {
{ timezone: "UTC", offset: "+00:00" },
{ timezone: "America/Chicago", offset: "-06:00" },
{ timezone: "Australia/Sydney", offset: "+11:00" },
travel_to Time.new(2020, 1, 4, 12, 0, 0, "+00:00") do
6,
travel_to Time.new(2020, 1, 5, 12, 0, 0, "+00:00") do
travel_to Time.new(2020, 1, 10, 12, 0, 0, "+00:00") do
ends_at: Time.new(2020, 1, 03, 11, 0, 0, "+00:00").end_of_day,
expect(existing_timing.reload.ends_at).to eq_time(Time.new(2020, 1, 4, 7, 59, 0, "+00:00"))
day_0_start_time: -1,
day_1_start_time: -1,
day_2_start_time: -1,
day_3_start_time: -1,
day_4_start_time: -1,
day_5_start_time: -1,
day_6_start_time: -1,
Time.new(2020, 1, 4, 0, 0, 0, "+00:00"),
travel_to Time.new(2020, 12, 31, 12, 0, 0, "+00:00") do
Time.new(2020, 12, 31, 0, 0, 0, "+00:00"),
Time.new(2021, 1, 1, 7, 59, 0, "+00:00"),
Time.new(2021, 1, 1, 17, 0, 0, "+00:00"),
Time.new(2021, 1, 2, 7, 59, 0, "+00:00"),
Time.new(2021, 1, 2, 17, 0, 0, "+00:00"),
day_0_start_time: 0,
day_1_start_time: 0,
day_2_start_time: 0,
travel_to Time.new(2021, 1, 4, 12, 0, 0, "+00:00") do
travel_to Time.new(2020, 12, 31, 1, 0, 0, "+00:00") do
Time.new(2020, 12, 31, 7, 59, 0, "+00:00").httpdate,
fab!(:target_user) { Fabricate(:user, username: "alice", email: "alice@example.com") }
fab!(:source_user) { Fabricate(:user, username: "alice1", email: "alice@work.com") }
fab!(:walter) { Fabricate(:walter_white) }
fab!(:p1) { Fabricate(:post) }
fab!(:p2) { Fabricate(:post) }
fab!(:p3) { Fabricate(:post) }
fab!(:p4) { Fabricate(:post) }
fab!(:p5) { Fabricate(:post) }
fab!(:p6) { Fabricate(:post) }
pm_topic =
expect(Group.where(id: g.id).pick(:user_count)).to eq(2)
).to contain_exactly(p1.id, p2.id, p3.id)
post = p1
post1 = p1
post2 = p2
post3 = p3
post4 = p4
post2.revise(source_user, raw: "#{post2.raw} foo")
posts = {}
expect(post.public_send("#{type}_count")).to eq(1)
term: "hello",
ip_address: "192.168.0.1",
term: "world",
term: "star trek",
ip_address: "192.168.0.2",
term: "bad",
ip_address: "192.168.0.3",
fab!(:post1) { p1 }
fab!(:post2) { p2 }
target_post_id: -1,
).pluck(:id)
def create_badge(badge, user, opts = {})
expect { destroy }.to change { User.count }.by(-1)
let!(:draft) { Draft.set(user, "test", 0, "test") }
let!(:topic_starter) { Fabricate(:user) }
let!(:topic) { Fabricate(:topic, user: topic_starter) }
let!(:first_post) { Fabricate(:post, user: topic_starter, topic: topic) }
let!(:post) { Fabricate(:post, user: user, topic: topic) }
let(:destroy_opts) { { delete_posts: true } }
let!(:topic) { Fabricate(:topic, user: user) }
let!(:first_post) { Fabricate(:post, user: user, topic: topic) }
let!(:second_post) { Fabricate(:post, user: user, topic: topic) }
let!(:category) { Fabricate(:category, user: user, topic_id: topic.id) }
let(:destroy_opts) { {} }
let!(:deleted_post) { Fabricate(:post, user: user, deleted_at: 1.hour.ago) }
let!(:bookmark) { Fabricate(:bookmark, user: user) }
@post = Fabricate(:post, user: @topic.user, topic: @topic)
}.by(-1)
let(:group) { Fabricate(:group, grant_trust_level: 4) }
before { group.add(user) }
expect { d.destroy(user) }.to change { User.count }.by(-1)
ids =
let!(:email_log) { Fabricate(:email_log, user: user) }
name: "Joe Doe 546",
extra_data: {
uid: "100",
let(:admin) { Fabricate(:admin) }
let(:user) { Fabricate(:user, username: "edward") }
fab!(:another_user) { Fabricate(:evil_trout) }
expect(user.reload.username).to match(/^anon\d{3,}$/)
user.update!(name: "Bibi", date_of_birth: 19.years.ago, title: "Super Star")
website: "http://www.bim.com",
bio_raw: "I'm Bibi from Moosejaw. I sing and dance.",
post = create_post(raw: <<~RAW)
old_avatar_url = user.avatar_template.gsub("{size}", "40")
expect { make_anonymous }.to change { ApiKey.count }.by(-1)
some_field: "123",
expect(user.reload.custom_fields).to eq("some_field" => "123", "another_field" => "456")
let(:old_ip) { "1.2.3.4" }
let(:anon_ip) { "0.0.0.0" }
let(:topic) { post.topic }
term: "wat",
url: "https://discourse.org",
let!(:email_token) { Fabricate(:email_token, user: user) }
user = Fabricate(:user, email: "foo@bar.com", trust_level: 0)
let!(:p1) { Fabricate(:post, topic: topic, created_at: old_timestamp) }
let!(:p2) { Fabricate(:post, topic: topic, created_at: old_timestamp + 1.day) }
let(:new_timestamp) { old_timestamp + 2.day }
let(:new_timestamp) { old_timestamp - 2.day }
updater = ->(_) { called = true }
let(:topic) { create_topic }
let(:based_on_last_post) { false }
let(:based_on_last_post) { true }
expect(topic.public_send("#{status_name}?")).to eq(true)
let(:status_name) { "closed" }
let(:status_name) { "visible" }
let(:status_name) { "archived" }
let!(:topic1) { Fabricate(:topic) }
let!(:topic2) { Fabricate(:topic) }
let!(:post) { Fabricate(:post, topic: topic1) }
let!(:topic_user1) { Fabricate(:topic_user, user: user, topic: topic1) }
let!(:topic_user2) { Fabricate(:topic_user, user: user, topic: topic2) }
ts_query = Search.ts_query(term: "gotta", ts_config: "simple")
).map(&:id),
ts_query = Search.ts_query(term: "blah", ts_config: "simple")
describe "#can_see?" do
about_url: "https://www.site.com/about",
{ some_theme: { url: component_repo_url, add_to_all_themes: true } },
).to eq(false)
scss = "body { background-color: black; }"
fab!(:tag1) { Fabricate(:tag, name: "fact", public_topic_count: 0) }
fab!(:tag2) { Fabricate(:tag, name: "factor", public_topic_count: 5) }
fab!(:tag3) { Fabricate(:tag, name: "factory", public_topic_count: 4) }
fab!(:tag4) { Fabricate(:tag, name: "factorio", public_topic_count: 3) }
fab!(:tag5) { Fabricate(:tag, name: "factz", public_topic_count: 1) }
fab!(:deleted_user) { Fabricate(:user) }
fab!(:deleted_post) { Fabricate(:post) }
}.to change { UserHistory.count }.by(1)
expect { logger.log_site_setting_change(nil, "1", "2") }.to raise_error(
expect { logger.log_site_setting_change("title", "Discourse", "My Site") }.to change {
theme.set_field(target: :common, name: :scss, value: "body{margin: 10px;}")
expect { logger.log_site_text_change(nil, "new text", "old text") }.to raise_error(
expect { logger.log_site_text_change("created", "new text", "old text") }.to change {
expect { logger.log_user_suspend(nil, "He was bad.") }.to raise_error(
reason = "He was a big meanie."
let(:badge) { Fabricate(:badge) }
fab!(:badge) { Fabricate(:badge) }
let(:subnet) { "1.2.3.0/24" }
expect(log_record.details).to eq("#{subnet} from #{ips.join(", ")}")
let(:category) { Fabricate(:category, name: "haha") }
attributes = { name: "new_name", permissions: { category_group.group_name => 2 } }
{ category_group.group_name => 1 }.to_json,
attributes = { name: "new_name" }
old_permission = { "everyone" => 1 }
attributes.merge(permissions: { "trust_level_3" => 1 }),
attributes = { custom_fields: { "auto_populated" => "t" } }
fab!(:approved_post) { Fabricate(:post) }
logger.log_post_staff_note(post, { new_value: "my note", old_value: nil })
logger.log_post_staff_note(post, { new_value: "", old_value: "my note" })
logger.log_post_staff_note(post, { new_value: nil, old_value: "my note" })
yml = "title: Test"
yml = "fake_setting: foo"
yml = "min_password_length: 0"
fab!(:user2) { Fabricate(:user) }
fab!(:user3) { Fabricate(:user) }
fab!(:staged_user) { Fabricate(:user, staged: true) }
fab!(:tag3) { Fabricate(:tag) }
previous_value: "#{category.id}|#{category2.id}|#{category3.id}",
new_value: "#{category3.id}",
previous_value: "#{category.id}|#{category2.id}",
new_value: "#{category.id}|#{category2.id}|#{category3.id}",
:user_id,
previous_value: "",
}.by(-2).and change {
}.by(-1).and change {
}.by(3)
previous_value: "#{tag.name}|#{tag2.name}|#{tag3.name}",
new_value: "#{tag3.name}",
previous_value: "#{tag.name}|#{tag2.name}",
new_value: "#{tag.name}|#{tag2.name}|#{tag3.name}",
new_value: "#{category2.id}",
new_value: "#{category2.id}|#{category3.id}",
new_value: "#{tag2.name}",
new_value: "#{tag2.name}|#{tag3.name}",
let(:post_id) { 99 }
topic_title: "",
category_name: "",
topic_tags: "",
html =
html = "<a href='http://meta.discourse.org/'>link</a>"
expect(scrubbed).to eq(":wink:")
<p><img src="https://www.discourse.org/logo.png" alt="Discourse"></p>
<div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use href="#far-image"></use></svg>
</a>
data = "<a>This</a> is a test"
expect(raw_data).to eq("This is a test")
let(:topic) { Fabricate(:topic, title: "this is a title that I am testing") }
let(:post) { Fabricate(:post, topic: topic) }
expect { post.update!(raw: "this is new content") }.to change {
topic_tags: post.topic.tags.map(&:name).join(" "),
post.update!(raw: <<~RAW)
post.update!(raw: "123.223")
post.update!(raw: "15.2.231.423")
post = Fabricate(:post, topic: topic, raw: <<~RAW)
a https://car.com?bob=1, http://efg.com.au?bill=1 b hij.net/xyz=1
www.klm.net/?IGNORE=1 <a href="http://abc.de.nop.co.uk?IGNORE=1&ignore2=2">test</a> https://cars.com
post = Fabricate(:post, raw: <<~RAW)
<img src="#{src}" title="GOT" alt="white walkers" width="2" height="2">
let(:post) { Fabricate(:post) }
let!(:user) { Fabricate(:user) }
let!(:user2) { Fabricate(:user) }
4.times { |t| Discourse.redis.rpush key, t }
topic_id: 1,
post_url: "https://example.com/t/1/2",
user.update!(locale: "pt_BR")
response = Struct.new(:body, :inspect, :message).new("test", "test", "failed")
data: { p256dh: "public ECDH key", keys: { auth: "private ECDH key" } }.to_json,
data: { endpoint: "endpoint 1", keys: { auth: "private ECDH key" } }.to_json,
data: { endpoint: "endpoint 2", keys: { p256dh: "public ECDH key" } }.to_json,
keys: {
fab!(:editor) { Fabricate(:admin) }
fab!(:user_a) { Fabricate(:user) }
let(:p1) { create_post(post_number: 1) }
let(:topic) { p1.topic }
let(:p2) { create_post(topic: topic, post_number: 2) }
let(:p3) { create_post }
let(:p4) { create_post(post_number: 2, topic: topic) }
let(:p1user) { p1.user }
let(:p2user) { p2.user }
let(:pm_poster) { pm.user }
p4 =
p5 =
fab!(:evil_trout) { Fabricate(:evil_trout) }
email_in: "test@test.com",
op = Fabricate(:post, user: pm.user)
pm.id,
op =
Fabricate(:post, topic: pm, user: pm.user, raw: "Hello @#{user.username}, nice to meet you")
topic_id: pm.id,
fab!(:user1) { Fabricate(:user) }
fab!(:group) do
fab!(:pm) do
fab!(:op) { Fabricate(:post, user: pm.user, topic: pm) }
pm2 =
op2 = Fabricate(:post, user: pm2.user, topic: pm2)
.pluck("data::json ->> 'inbox_count'")
.to_i
raw: "this is a reply to your post...",
topic: pm,
}.to change(
).by(1)
quote_raw = <<~MD
_whisper =
raw: "this is a whisper post",
post = Fabricate(:post, raw: "I love waffles")
expect { post.revise(post.user, raw: post.raw + " ha I edited it ") }.to add_notification(
post.revise(post.user, raw: post.raw + " ha I edited it again ")
data: { topic_title: "test topic" }.to_json,
quote = <<~MD
let(:post1) { create_post }
let(:user) { post1.user }
let(:linking_post) { create_post(raw: "my magic topic\n##{Discourse.base_url}#{post1.url}") }
raw: "my magic topic\n##{Discourse.base_url}#{post1.url}",
).to eq(0)
let(:post) do
fab!(:other_post) { Fabricate(:post, topic: topic) }
3.times { Fabricate(:post, topic: topic) }
let(:post) { create_post_with_alerts(raw: "Hello @group how are you?") }
expect { post.revise(evil_trout, raw: "O hai, @eviltrout!") }.not_to change(
fab!(:alice) { Fabricate(:user, username: "alice") }
fab!(:bob) { Fabricate(:user, username: "bob") }
fab!(:carol) { Fabricate(:admin, username: "carol") }
fab!(:dave) { Fabricate(:user, username: "dave") }
fab!(:eve) { Fabricate(:user, username: "eve") }
fab!(:topic) { Fabricate(:topic, user: alice) }
args = { user: bob, topic: topic, raw: "Hello @alice" }
fab!(:pm_topic) do
args = { user: bob, topic: pm_topic, raw: "Hello @alice" }
args = { user: Discourse.system_user, topic: pm_topic, raw: "Hello @alice" }
args = { user: bob, topic: pm_topic, raw: "Hello @group" }
args = { user: bob, topic: pm_topic, raw: "Hello @carol" }
args = { user: Discourse.system_user, topic: pm_topic, raw: "Hello @carol" }
args = { user: bob, topic: pm_topic, raw: "Hello @dave" }
fab!(:some_group) do
args = { user: Discourse.system_user, topic: pm_topic, raw: "Hello @group" }
args = { user: bob, topic: pm_topic, raw: "Hello @some_group" }
args = { user: Discourse.system_user, topic: pm_topic, raw: "Hello @some_group" }
fab!(:post) { Fabricate(:post, topic: topic, created_at: 1.hour.ago) }
client_id: "xxx#{i}",
push_url: "https://site2.com/push",
body = nil
{ status: 200, body: "OK" }
new_post =
raw: "this is my first reply",
changes = {
client_id: "xxx#1",
_post = Fabricate(:post, user: user, topic: topic)
post = Fabricate(:post, raw: "hello @#{admin.username} how are you today?", topic: topic)
bob = Fabricate(:user, username: "bob", email: "bob@example.com")
user: bob,
fab!(:other_tag) { Fabricate(:tag) }
fab!(:watched_tag) { Fabricate(:tag) }
fab!(:other_tag2) { Fabricate(:tag) }
fab!(:other_tag3) { Fabricate(:tag) }
fab!(:staged) { Fabricate(:staged) }
fab!(:post2) { Fabricate(:post) }
url: "/t/#{topic.id}",
domain: "test.com",
fab!(:last_editor) { Fabricate(:user) }
raw: "one of my first posts",
expect(email.subject).to eq("Re: #{topic.title}")
args: {
}.by(2).and change { Notification.count }.by(2)
}.by(1).and change { Notification.count }.by(1)
reply_raw_mail = <<~EMAIL
}.to change {
}.by(2).and change {
}.by(1).and change {
}.by(2)
}.by(2).and not_change {
}.and change {
let(:custom_data) { "custom_string" }
).to eq(2)
let(:lurker) { Fabricate(:user) }
fab!(:first_post) { Fabricate(:post, user: user, raw: "A useless post for you.") }
let(:topic) { first_post.topic }
let(:threshold) { 1 }
let(:like_user) { "user1" }
count = 5
let(:rule) do
Proc.new { |notifications| notifications.where("(data::json ->> 'consolidated')::bool") },
data: {}.to_json,
user ||= Fabricate(:user)
data: "{\"a\": 1}",
at: no_delay ? Time.zone.now : Time.zone.now + delay,
if type == :user_linked || type == :user_quoted
let(:no_delay) { no_delay }
let(:type) { :user_mentioned }
at: Time.zone.now + delay,
let(:type) { :user_replied }
let(:type) { :user_quoted }
let(:type) { :user_linked }
let(:type) { :user_posted }
let(:type) { :user_private_message }
let(:type) { :user_invited_to_topic }
let(:type) { :user_watching_first_post }
let(:type) { :post_approved }
replace_keys = {
key = "user_notifications.#{type_key}.#{subkey}"
before { set_cdn_url "https://awesome.com" }
fab!(:upload2) { Fabricate(:upload) }
fab!(:upload3) { Fabricate(:upload) }
md = <<~MD
md = "1 > 2"
md = "<x>.<y>"
<img src="#{upload.url}">
This is an invalid `<img ...>` tag
<img src="#{upload.short_url}">
md = '<img data-id="<>">'
md = "`<a class=\"attachment\" href=\"#{upload2.url}\">In Code Block</a>`"
<img src="#{upload.url}"
<img src="#{upload2.url}">
<img src="#{upload2.short_url}">
<img src="#{upload3.url}">
<img src="#{upload3.short_url}">
<IMG src="#{upload2.url}" />
<A class="attachment" href="#{upload3.url}">Text</A>
<img src="#{upload.url}?v=1">
<img src="#{Discourse.base_url}#{upload.url}?v=2">
<img src="#{GlobalSetting.cdn_url}#{upload.url}?v=3">
<img src="/community#{upload.url}">
test<img src="#{upload.url.sub(".png", ".PNG")}">
test<img src="#{upload.short_url}">
<img src="#{Discourse.base_url}#{upload.url}" alt="some image" title="some title" />
<img src="#{Discourse.base_url}#{upload2.url}" alt="some image"><img src="#{Discourse.base_url}#{upload3.url}" alt="some image">
<img src="#{upload.url}" width="5" height="4">
<img src="#{upload.url}" width="5px" height="auto">
<img src="#{upload.url}" alt="image inside code fences">
<img src="#{upload.url}" alt="image inside code block">
<img src="#{upload.short_url}" alt="some image" title="some title">
<img src="#{upload2.short_url}" alt="some image"><img src="#{upload3.short_url}" alt="some image">
<img src="#{upload.short_url}" width="5" height="4">
<img src="#{upload.short_url}" width="5px" height="auto">
:test:
<h1></h1>
<a href="http://somelink.com">
<img src="#{upload2.url}" alt="test" width="500" height="500">
<img src="#{upload2.short_url}" alt="test" width="500" height="500">
md =
<img src="#{upload.url}" alt="test" width="500" height="500">
<img src="#{upload2.url}" alt="test">
<a href="http://somelink.com"><img src="#{upload3.url}" alt="test" width="500" height="500"></a>
<p>Test <img src="#{upload2.url}" alt="test" width="500" height="500"></p>
<hr/>
<img src="#{upload.short_url}" alt="test" width="500" height="500">
<img src="#{upload2.short_url}" alt="test">
<a href="http://somelink.com"><img src="#{upload3.short_url}" alt="test" width="500" height="500"></a>
<p>Test <img src="#{upload2.short_url}" alt="test" width="500" height="500"></p>
This is some <img src=" and <a href="
<img src="#{upload.url}" alt="test">
<img src="#{upload2.url}" alt="test" height="150<img">
<a class="attachment" href="#{upload2.url}">test2</a>
<img src="#{upload.short_url}" alt="test">
<img src="#{upload2.short_url}" alt="test" height="150<img">
<a id="test">invalid</a>
<a href="https://some.external.com/link">test</a>
<a class="attachment" href="#{upload.url}">
- <a class="attachment" href="#{upload.url}">test2</a>
- <a class="attachment" href="#{upload2.url}">test2</a>
- <a class="attachment" href="#{upload3.url}">test2</a>
<a class="test attachment" href="#{upload.url}">test3</a>
<a class="test attachment" href="#{upload2.url}">test3</a><a class="test attachment" href="#{upload3.url}">test3</a>
<a class="test attachment" href="#{upload3.url}">This is some _test_ here</a>
<a class="test attachment" href="#{upload.url}">
<a class="attachment" href="#{upload3.url}">In Code Block</a>
<a href="#{upload.url}">newtest</a>
<a href="#{Discourse.base_url_no_prefix}#{upload.url}">newtest</a>
url = "#{Discourse.base_url}#{upload.url}"
<img src="#{url}" alt="some image">
<img src="#{upload2.url}" alt="some image">
let(:upload) { Fabricate(:upload_s3) }
let(:upload3) { Fabricate(:upload) }
<img src="#{upload.url}" alt="some image">
<img src="#{upload.short_url}" alt="some image">
<img src="#{upload2.short_url}" alt="some image">
url = nil
setting_name = "#{prefix}_#{level}"
let!(:hottest_topic1) { Fabricate(:topic, views: 3000, posts_count: 10, like_count: 2) }
let!(:hottest_topic2) { Fabricate(:topic, views: 3000, posts_count: 10, like_count: 2) }
let!(:warm_topic1) { Fabricate(:topic, views: 1500, posts_count: 10, like_count: 1) }
let!(:warm_topic2) { Fabricate(:topic, views: 1500, posts_count: 10, like_count: 1) }
let!(:warm_topic3) { Fabricate(:topic, views: 1500, posts_count: 10, like_count: 1) }
let!(:lukewarm_topic1) { Fabricate(:topic, views: 800, posts_count: 10, like_count: 0) }
let!(:lukewarm_topic2) { Fabricate(:topic, views: 800, posts_count: 10, like_count: 0) }
let!(:lukewarm_topic3) { Fabricate(:topic, views: 800, posts_count: 10, like_count: 0) }
let!(:lukewarm_topic4) { Fabricate(:topic, views: 800, posts_count: 10, like_count: 0) }
let!(:cold_topic) { Fabricate(:topic, views: 100, posts_count: 10, like_count: 0) }
let!(:warm_topic1) { Fabricate(:topic, views: 2020, posts_count: 100, like_count: 99) }
let!(:warm_topic2) { Fabricate(:topic, views: 2020, posts_count: 100, like_count: 99) }
let!(:warm_topic3) { Fabricate(:topic, views: 2020, posts_count: 100, like_count: 99) }
let!(:cold_topic) { Fabricate(:topic, views: 100, posts_count: 100, like_count: 1) }
let!(:hottest_topic1) { Fabricate(:topic, views: 10_100, posts_count: 100, like_count: 230) }
let!(:hottest_topic2) { Fabricate(:topic, views: 10_012, posts_count: 100, like_count: 220) }
let!(:warm_topic1) { Fabricate(:topic, views: 4020, posts_count: 99, like_count: 126) }
let!(:warm_topic2) { Fabricate(:topic, views: 4010, posts_count: 99, like_count: 116) }
let!(:warm_topic3) { Fabricate(:topic, views: 4005, posts_count: 99, like_count: 106) }
fab!(:category1) { Fabricate(:category, name: "The Book Club", slug: "the-book-club") }
fab!(:tag1) do
fab!(:topic1) { Fabricate(:topic) }
{ type: "category", context: "awesome-composer", priority: 50 },
{ type: "tag", context: "awesome-composer", priority: 100 },
fab!(:category2) { Fabricate(:category, name: "Book Zone", slug: "book-zone") }
fab!(:category3) { Fabricate(:category, name: "Book Dome", slug: "book-dome") }
fab!(:category4) { Fabricate(:category, name: "Bookworld", slug: "book") }
fab!(:tag2) { Fabricate(:tag, name: "mid-books") }
fab!(:tag3) { Fabricate(:tag, name: "terrible-books") }
fab!(:tag4) { Fabricate(:tag, name: "book") }
fab!(:category4) { Fabricate(:category, name: "Bookworld", slug: "book", topic_count: 56) }
fab!(:category5) { Fabricate(:category, name: "Media", slug: "media", topic_count: 446) }
fab!(:tag2) do
fab!(:tag3) do
fab!(:tag4) { Fabricate(:tag, name: "book", staff_topic_count: 1, public_topic_count: 1) }
fab!(:tag2) { Fabricate(:tag, name: "fiction-books") }
let!(:admin) { Fabricate.build(:admin, id: 999) }
let!(:user) { Fabricate.build(:user, id: 111) }
.with do |from_user, opts|
it { is_expected.to eq(false) }
let(:user) { Fabricate.build(:user, id: 123_123) }
gm =
.returns("OK")
old_group_name = "team"
fab!(:group_owner) { Fabricate(:user) }
fab!(:user1) { Fabricate(:user, ip_address: "182.189.119.174") }
fab!(:post1) { Fabricate(:post, user: user1, topic: Fabricate(:topic, user: user1)) }
old_user =
ip_address: "182.189.119.174",
new_user =
fab!(:post2) do
let!(:logo_file) { file_from_fixtures("logo.png") }
let!(:pdf_file) { file_from_fixtures("large.pdf", "pdf") }
let(:object_size) { 1.megabyte }
let(:object_file) { logo_file }
let(:external_upload_stub_metadata) { {} }
let(:object_file) { file_from_fixtures("should_be_jpeg.heic", "images") }
let(:external_upload_stub_metadata) { { "sha1-checksum" => client_sha1 } }
let(:client_sha1) { "blahblah" }
).to eq("1")
let(:object_file) { pdf_file }
let(:object_file) { file_from_fixtures("backup_since_v1.6.tar.gz", "backups") }
signed_url = uri.to_s.gsub(uri.query, "")
expect(updater.update(html: "For you: %{email_content}", css: "h1 { color: blue; }")).to eq(
SiteSetting.email_custom_css = "h1 { color: blue; }"
expect(updater.update(html: "No email content", css: "")).to eq(false)
expect(updater.update(html: "For you: %{email_content}", css: "h1 { color: blue;")).to eq(
let(:username) { "kwest@gmail.com" }
let(:password) { "mbdtf" }
let(:host) { "imap.gmail.com" }
let(:port) { 993 }
obj = mock()
stub(data: stub(text: "no response")),
let(:host) { "pop.gmail.com" }
let(:port) { 995 }
let(:host) { "smtp.gmail.com" }
let(:port) { 587 }
let(:domain) { "gmail.com" }
port: 465,
port: 587,
fab!(:t) { Fabricate(:topic, category: c) }
let!(:p) { Fabricate(:post, topic: t) }
fab!(:t2) { Fabricate(:topic, category: c2) }
let!(:p2) { Fabricate(:post, topic: t2) }
fab!(:t3) { Fabricate(:topic, category: sc) }
let!(:p3) { Fabricate(:post, topic: t3) }
}.by (-1)
fab!(:t2) { Fabricate(:topic, category: c) }
let!(:pm) { Fabricate(:private_message_post) }
let!(:g) { Fabricate(:group) }
let!(:g2) { Fabricate(:group) }
let(:valid_params) { { name: color_scheme.name, colors: nil } }
cs =
fab!(:parent_category) { Fabricate(:category, slug: "fun", topic_count: 2) }
fab!(:category2) { Fabricate(:category, name: "Book Section", slug: "books", topic_count: 566) }
fab!(:category3) { Fabricate(:category, slug: "movies", topic_count: 245) }
fab!(:category5) { Fabricate(:category, slug: "casual", topic_count: 99) }
{ data: { title: "test", bookmarkable_url: "test" } },
let(:badge) { Fabricate(:badge, allow_title: true) }
user.title = "CEO"
where ue.email like \'%gmail.com\'',
query = Badge.find(1).query + "\n-- a comment"
user = Fabricate(:user, locale: "fr")
badge.query = Badge.find(1).query + "\n-- a comment"
).to eq(badge.id)
).to be_empty
locale: "en",
fab!(:liker) { Fabricate(:user) }
post2 = create_post(raw: "#{Discourse.base_url}/t/slug/#{post.topic_id}")
4,
expect(sequence).to eq((0...10).to_a)
expect(sequence).to eq((0...20).to_a)
expect(sequence.sort).to eq((0...(40 + 1)).to_a)
expect(sequence.sort).to eq((0...40).to_a)
let(:user) { Fabricate.build(:newuser) }
let(:post) { Fabricate(:post, user: user) }
let(:flagger) { Fabricate(:user) }
let!(:post) { Fabricate(:post, user: user) }
let(:user) { Fabricate(:newuser) }
let(:flagger2) { Fabricate(:user) }
let(:post2) { Fabricate(:post, user: user) }
fab!(:user) { Fabricate(:user, trust_level: 3) }
colors: {
let(:user) do
:id,
:topic_id,
:raw,
:wiki,
liked_user = Fabricate(:user, name: "John Doe", username: "john_doe")
.order(domain: :asc, url: :asc)
TopicLinkClick.create(topic_link: link, ip_address: "192.168.1.#{i + 1}")
let(:json) { serializer.as_json }
json =
let(:admin_user) { Fabricate(:admin) }
let(:scope) { Guardian.new }
let(:scope) { Guardian.new(admin_user) }
tag: tag1,
tag: tag2,
tag: tag3,
tag: tag4,
it "has a bio" do
let(:scope) { Guardian.new(user) }
fab!(:viewing_user) { Fabricate(:user) }
user_api_key_0 =
user_api_key_3 =
let(:topic) { Fabricate(:topic) }
let(:post) { Fabricate(:post, user: user, topic: topic) }
let!(:bookmark) { Fabricate(:bookmark, name: "Test", user: user, bookmarkable: post) }
let(:user) { Fabricate(:user, trust_level: 0) }
let(:user2) { Fabricate(:user, trust_level: 1) }
let(:other_user) { Fabricate(:user) }
fab!(:user_status) { Fabricate(:user_status) }
fab!(:user) { Fabricate(:user, user_status: user_status) }
fab!(:badge) { Fabricate(:badge, show_posts: true) }
fab!(:user_badge) { Fabricate(:user_badge, badge: badge, post_id: post.id) }
).as_json
fab!(:user) { Fabricate(:moderator) }
let(:token) { UserAuthToken.generate!(user_id: user.id, client_ip: "2a02:ea00::", staff: true) }
before(:each) { DiscourseIpInfo.open_db(File.join(Rails.root, "spec", "fixtures", "mmdb")) }
I18n.locale = "de"
I18n.locale = "zh_CN"
fab!(:upload) { Fabricate(:secure_upload) }
fab!(:user_2) { Fabricate(:user) }
fab!(:featured_link) { "http://meta.discourse.org" }
before { topic.update!(external_id: "42-asdf") }
json = nil
fab!(:topic2) { Fabricate(:topic) }
before { TopicUser.update_last_read(user, topic2.id, 0, 0, 0) }
fab!(:post2) { Fabricate(:post, topic: topic) }
fab!(:topic) do
fab!(:topic2) do
fab!(:hidden_tag) { Fabricate(:tag, name: "hidden") }
before { topic.tags << hidden_tag }
:tag,
name: "ctag",
name: "btag",
name: "atag",
{ btag: "b description", ctag: "c description", atag: "a description" },
payload: {
fab!(:group_user) { Fabricate(:group_user) }
let(:user) { group_user.user }
fab!(:post) { Fabricate(:post, topic: pm_topic) }
Fabricate(:topic_timer, topic: topic, execute_at: Time.utc(2022, 4, 6, 16, 23, 56))
pm =
fab!(:post) { create_post }
let(:hidden_tag) { Fabricate(:tag, name: "hidden") }
post = Fabricate(:post, raw: "https://meta.discourse.org/")
let(:featured_link) { "http://meta.discourse.org" }
fab!(:tag) { Fabricate(:tag, name: "dev") }
fab!(:tag2) { Fabricate(:tag, name: "random") }
tag_id: tag3.id,
fab!(:allowed_user) { Fabricate(:user) }
fab!(:not_allowed_user) { Fabricate(:user) }
link_url =
link = "<a href=\"#{link_url}\">#{setting_name.gsub("_", " ")}</a>"
root: nil,
fab!(:actor) { Fabricate(:user) }
let(:user) { post.user }
let(:raw) { "Raw contents of the post." }
let(:post) { Fabricate(:post, raw: raw, user: user) }
raw: raw,
fab!(:post) { Fabricate(:post, raw: "Hello world!", hidden: true) }
let(:post) { Fabricate(:post, raw: raw, user: user, wiki: true) }
fab!(:user) { Fabricate(:user, trust_level: 1) }
fab!(:user_tl1) { Fabricate(:user, trust_level: 1) }
fab!(:user_tl2) { Fabricate(:user, trust_level: 2) }
let(:current_user) { Fabricate(:user) }
fab!(:post) { Fabricate(:small_action, action_code: "public_topic") }
s.add_raw = true
fab!(:post) { Fabricate(:post, version: 2) }
fab!(:public_tag) { Fabricate(:tag, name: "public") }
fab!(:public_tag2) { Fabricate(:tag, name: "visible") }
fab!(:hidden_tag2) { Fabricate(:tag, name: "secret") }
let(:author) { post.created_by }
id: post.id,
result.message = "hello :)"
Fabricate(:theme, component: true).tap { |t| theme.add_relative_theme!(:child, t) }
fab!(:user) { Fabricate(:admin) }
fab!(:group) { Fabricate(:group, email_username: "foo@bar.com", email_password: "pa$$w0rd") }
let(:tag1) { Fabricate(:tag) }
let(:tag2) { Fabricate(:tag) }
expect(subject.as_json.keys.select { |k| k.to_s.ends_with?("_category_ids") }).to be_empty
expect(subject.as_json.keys.select { |k| k.to_s.ends_with?("_tags") }).to be_empty
expect(subject.as_json.keys.select { |k| k.to_s.ends_with?("_category_ids") }.length).to eq(
5,
fab!(:emoji) { Emoji.load_custom.first }
set_cdn_url("https://cdn.com")
let!(:tag_user) do
sequence = Draft.set(user, Draft::NEW_TOPIC, 0, "test1")
let(:user) { Fabricate(:admin) }
provider_uid: "1",
nickname: "sam",
fab!(:user_group) do
group.update!(name: "aaa")
:everyone => :readonly,
user_group.name => :full,
let(:user) { Fabricate.build(:user) }
fab!(:topic) { Fabricate(:topic, title: "safe title <a> existing topic") }
raw: "new post 123",
title: "unsafe title <a>",
reviewable.update!(payload: { raw: "new post 123" })
fab!(:topic) { Fabricate(:topic, title: "safe title <a> hello world") }
let(:post) { Fabricate.build(:post, user: user) }
let(:group) { Group.find(1) }
fab!(:group) { Fabricate(:group, bio_raw: "testing :slightly_smiling_face:") }
fab!(:group) { Fabricate(:group, has_messages: true) }
fab!(:admin) { Fabricate(:user, admin: true, email: "admin@email.com") }
fab!(:user) { Fabricate(:user, email: "user@email.com") }
let(:user_id) { lookup.add_user(user.id.to_s, user) }
VanillaBodyParser.new({ "Format" => "Html", "Body" => "Hello everyone!" }, user_id).parse
{ "Format" => "Html", "Body" => "H<br>E<br>L<br>L<br>O" },
expect(parsed).to eq "H<br>E<br>L<br>L<br>O"
parsed = VanillaBodyParser.new({ "Format" => "Html", "Body" => complex_html }, user_id).parse
expect(parsed).to eq "" \
expect(parsed).to eq "\n```\nfoobar\n```\n"
complex_html = "<code>foobar</code>"
complex_html = '<div class="Quote">foobar</div>'
parsed = VanillaBodyParser.new({ "Format" => "Rich", "Body" => body }, user_id).parse
).to eq "We can link to the <a href=\"https:\/\/www.discourse.org\/\">Discourse home page</a> and it works."
).to eq "Here's a monospaced block:\n\n```\nthis line should be monospaced\nthis one too, with extra spaces#{" " * 4}\n```\n\nbut not this one"
def convert(xml, opts = {})
xml = "<t>unformatted text</t>"
xml =
expect(convert(xml)).to eq("_this is italic **and bold** text_")
expect(convert(xml)).to eq("**this is bold text**")
<br/>
expect(convert(xml)).to eq(<<~MD.chomp)
\\
let(:opts) { { allow_inline_code: true } }
expect(convert(xml, opts)).to eq("`one line of code`")
</i> /\_/\
( o.o )
&gt; ^ &lt;
/\_/\
> ^ <
</i>foo
<r>foo
bar</r>
1. Red
or **_bar_** more text
<URL url="https://example.com/foo.png">
if url == "http://forum.example.com/viewtopic.php?f=2&t=2"
xml = '<r><EMAIL email="foo.bar@example.com">foo.bar@example.com</EMAIL></r>'
> \\
text<br/>
> **and bold
> text**
> on multiple\\
> lines_
{ username_from_user_id: lambda { |user_id| user_id == 48 ? "mr_blobby" : nil } }
expect(convert(xml, opts)).to eq(<<~MD.chomp)
expect(convert(xml, opts)).to eq("> Lorem ipsum")
{ username: "mr_blobby", post_number: 3, topic_id: 951 } if post_id == 43
<r><QUOTE author="Mr. Blobby" post_id="43" time="1534626128" user_id="48">
<r><QUOTE author="Mr. Blobby" post_id="44" time="1534626128" user_id="48">
</r>
when ":D"
when ":eek:"
xml = "<r><E>:D</E> <E>:eek:</E></r>"
<br>
expect(convert(xml)).to eq(<<~MD.rstrip)
_sit_ amet,
expect(convert(xml)).to eq("foo")
expect(convert(xml)).to eq("**bar**")
<big>large</big>
expect(User.where("id > 0").count).to eq(1)
get "/wizard"
let(:email) { "em@il.com" }
let(:message_id) { "12345@il.com" }
let(:timestamp) { Time.now.to_i }
let(:data) { "#{timestamp}#{token}" }
it "works (new)" do
it "works" do
post "/webhooks/mandrill.json", headers: { "X-Mandrill-Signature" => "foo" }, params: payload
:"bounce" => {
:"mail" => {
{ "name" => "From", "value" => "\"John Doe\" <john@example.com>" },
{ "name" => "Message-ID", "value" => message_id },
{ "name" => "Subject", "value" => "Hello" },
{ "name" => "Content-Type", "value" => "text/plain; charset=\"UTF-8\"" },
{ "name" => "Content-Transfer-Encoding", "value" => "base64" },
{ "name" => "Date", "value" => "Wed, 27 Jan 2016 14:05:45 +0000" },
post "/webhooks/aws.json", headers: { "RAW_POST_DATA" => payload }
put "/u/confirm-new-email", params: { token: "#{email_token.token}" }
put "/u/confirm-new-email", params: { token: "#{updater.change_req.new_email_token.token}" }
token: "blah",
6.times do |x|
second_factor_token: "{}",
put "/u/#{user.username}/preferences/email.json", params: { email: "sam@not-email.com'" }
email: "#{other_user.email} ",
fab!(:another_user) { Fabricate(:user) }
fab!(:invitee) { Fabricate(:user) }
fab!(:inviter) { Fabricate(:user) }
let(:user_deferred) { Fabricate(:user) }
email: "jane@jane.com",
name: "jane",
post "/u.json", params: params
let(:invite) { Fabricate(:invite) }
get "/u/password-reset/#{token}"
get "/u/password-reset/ev!l_trout@!"
put "/u/password-reset/#{email_token.token}.json", params: { password: "" }
password: ("x" * (User.max_password_length + 1)),
let!(:email_token) { Fabricate(:email_token, user: user1) }
put "/u/admin-login", params: { email: admin.email }
put "/u/admin-login", params: { email: admin.email, use_safe_mode: true }
put "/u/admin-login", params: { email: "random" }
def post_user(extra_params = {})
post_user(invite_code: " AbC deF ")
post "/u.json", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }
fab!(:api_key, refind: false) { Fabricate(:api_key, user: admin) }
post "/u.json", params: params, headers: { HTTP_API_KEY: api_key.key }
expect { post_user }.to_not change { User.count }
expect { post_user }.to change { User.count }
fab!(:api_key, refind: false) { Fabricate(:api_key, user: user1) }
fab!(:user) { admin }
fab!(:api_key, refind: false) { Fabricate(:api_key, user: user) }
uid: "123545",
name: "Osama Test",
name: "Test Osama",
expect { post "/u.json", params: create_params }.to_not change { User.count }
{ name: @user.name, username: @user.username, password: "", email: @user.email }
password: "x" * (User.max_password_length + 1),
let(:create_params) { { name: @user.name, username: @user.username, email: @user.email } }
let(:create_params) { { name: @user.name, email: @user.email, password: "x" * 20 } }
fab!(:user_field) { Fabricate(:user_field) }
let(:update_user_url) { "/u/#{user1.username}.json" }
let(:field_id) { user_field.id.to_s }
before { sign_in(user1) }
fab!(:user_field) do
put update_user_url, params: { user_fields: { field_id => "Axe" } }
put update_user_url, params: { user_fields: { field_id => valid_options } }
put update_user_url, params: { user_fields: { field_id => nil } }
put update_user_url, params: { user_fields: { field_id => "" } }
put update_user_url, params: { user_fields: { field_id => "Umbrella Corporation" } }
put update_user_url, params: { user_fields: { field_id => valid_options.first } }
put update_user_url, params: { user_fields: { field_id => valid_options.last } }
user_field.id.to_s => "value1",
another_field.id.to_s => "value2",
fab!(:staged) { Fabricate(:staged, email: "staged@account.com", active: true) }
put "/u/update-activation-email.json", params: { email: "bob@bob.com" }
let(:new_username) { "#{old_username}1234" }
fab!(:user) { Fabricate(:user, username: "OrigUsername") }
put "/u/#{user.username}/preferences/username.json", params: { new_username: "@" }
title: "This is a test topic",
raw: "This is a test this is a test",
get "/u/check_username.json", params: { email: "dood@example.com" }
before { get "/u/check_username.json", params: { username: "BruceWayne" } }
before { get "/u/check_username.json", params: { username: "bad username" } }
fab!(:user) { Fabricate(:user, username: "hansolo") }
get "/u/check_username.json", params: { username: "HanSolo" }
fab!(:someone_else) { Fabricate(:user) }
get "/u/check_username.json", params: { username: "HanSolo", for_user_id: user.id }
get "/u/check_email.json", params: { email: user1.email }
get "/u/check_email.json", params: { email: "invalid" }
get "/u/check_email.json", params: { email: "available@example.com" }
get "/u/check_email.json", params: { email: Fabricate(:staged).email }
get "/u/#{inviter.username}/invited.json", params: { filter: "pending", search: "billybob" }
get "/u/#{inviter.username}/invited.json", params: { search: "billybob" }
_user = Fabricate(:user, trust_level: 2)
put "/u/guest.json"
put "/u/#{user1.username}", params: { name: "test.test" }
fab!(:user) { Fabricate(:user, username: "test.test", name: "Test User") }
put "/u/#{user.username}", params: { name: "test.test" }
put "/u/#{user.username}.json",
name: "Jim Tom",
title: "foobar",
user_field.id.to_s => "happy",
).pluck(:tag_id),
muted_usernames: "",
put "/u/#{user.username}.json", params: { locale: :fa_IR }
put "/u/#{user.username}.json", params: { title: leader_title }
user_field.id.to_s => "",
user_field.id.to_s => ("x" * 3000),
optional_field.id.to_s => "feet",
user_field.id.to_s => "sad",
put "/u/#{user.username}.json", params: params
name: "Test User",
email: "user@mail.com",
user_field.id.to_s => "user field value",
u = User.find_by_email("user@mail.com")
put "/u/#{user.username}.json"
put "/u/#{user.username}.json", params: { sidebar_category_ids: nil }
put "/u/#{user.username}.json", params: { sidebar_tag_names: nil }
put "/u/#{user.username}.json", params: { name: "Jim Tom" }
params = { external_ids: { "pluginauth" => "pluginauth_uid" } }
put "/u/#{user.username}.json", params: params, headers: { HTTP_API_KEY: api_key.key }
params = { external_ids: { "pluginauth" => nil } }
params = { external_ids: { discourse_connect: nil } }
params = { external_ids: { "pluginauth2" => "pluginauth_uid" } }
status = { emoji: "tooth", description: "off to dentist" }
put "/u/#{user.username}.json", params: { status: status }
user.set_status!("off to dentist", "tooth")
new_status = { emoji: "surfing_man", description: "surfing" }
put "/u/#{user.username}.json", params: { status: new_status }
put "/u/#{user.username}.json", params: { status: nil }
put "/u/#{user1.username}.json",
status: {
emoji: "tooth",
old_status = { emoji: "tooth", description: "off to dentist" }
put "/u/#{user1.username}.json", params: { status: new_status }
put "/u/#{user1.username}.json", params: { status: nil }
new_status = { emoji: "tooth", description: "off to dentist" }
put "/u/#{user.username}.json", params: { bio_raw: "new bio" }
expect(user1.title).to eq("")
fab!(:badge) { Fabricate(:badge, name: "Demogorgon", allow_title: true) }
) { post "/u/action/send_activation_email.json", params: { username: user.username } }
let(:user) { post_user }
user.email_tokens.each { |t| t.destroy }
put "/u/asdf/preferences/avatar/pick.json", params: { avatar_id: 1, type: "custom" }
fab!(:upload) { Fabricate(:upload, user: user1) }
type: "custom",
type: "system",
type: "x",
fab!(:avatar1) { Fabricate(:upload) }
fab!(:avatar2) { Fabricate(:upload) }
let(:url) { "https://www.discourse.org" }
put "/u/#{user1.username}/preferences/avatar/select.json", params: { url: "" }
delete "/u/#{user1.username}/preferences/user_image.json", params: { type: "wat" }
fab!(:user) { Fabricate(:user, trust_level: 2) }
fab!(:staff_user) { admin }
).to eq(nil)
fab!(:user_with_period) { Fabricate(:user, username: "myname.test") }
get "/my/wat"
get "/my/wat/..password.txt"
let(:sign_in_admin) { sign_in(admin) }
name: "Groupie",
get "/u/confirm-admin/#{ac.token}.json"
get "/u/confirm-admin/#{ac.token}.json", params: { token: ac.token }
post "/u/confirm-admin/#{ac.token}.json"
6.times do |n|
get "/u/#{user.username}.json"
get "/u/#{user.username}.json", params: { skip_track_visit: true }
get "/u/#{user1.username}.json"
get "/u/#{user1.username}.json", params: { skip_track_visit: true }
get "/u/#{admin.username}.json", params: { include_post_count_for: topic.id }
get "/u/#{user1.username}"
get "/u/#{user.username}/card.json"
get "/u/#{user1.username}/card.json"
get "/user-cards.json?user_ids=#{user.id},#{user2.id}"
get "/u/#{user1.username}/badges"
fab!(:topic) { Fabricate :topic }
let(:post1) { Fabricate(:post, user: user, topic: topic) }
let(:staged_user) { Fabricate(:user, staged: true) }
get "/u/search/users.json", params: { term: user.name.split(" ").last }
get "/u/search/users.json", params: { topic_id: topic.id }
get "/u/search/users.json", params: { term: user.name.split(" ").last, topic_id: topic.id }
term: user.name.split(" ").last,
get "/u/search/users.json", params: { term: "", topic_id: pm_topic.id, category_id: "" }
get "/u/search/users.json", params: { limit: "-1" }
get "/u/search/users.json", params: { term: user.name }
name: "aaa1bbb",
name: "bbb1aaa",
name: "ccc1aaa",
name: "ddd1aaa",
get "/u/search/users.json", params: { include_groups: "true", term: "bbb" }
get "/u/search/users.json", params: { include_groups: "true" }
get "/u/search/users.json", params: { include_groups: "true", term: "a" }
term: "a",
get "/u/search/users.json", params: { term: staged_user.name }
get "/u/search/users.json", params: { last_seen_users: true }
limit = 3
get "/u/search/users.json", params: { last_seen_users: true, limit: limit }
get "/u/search/users.json", params: { term: user.username }
emoji = "tooth"
post "/u/email-login.json", params: { login: user1.email }
post "/u/email-login.json", params: { login: "@random" }
.returns("confirmed-password-#{user1.id}" => "false")
.returns("confirmed-password-#{user1.id}" => "true")
name: "test",
7.times do |x|
post "/users/enable_second_factor_totp.json", params: { name: "test" }
disable: "true",
name: "renamed",
id: "bad id",
rawId: "bad rawId",
clientData: Base64.encode64('{"bad": "json"}'),
name: "My Bad Key",
before { 2.times { sign_in(user1) } }
let(:user) { user1 }
let(:password) { "" }
before { post "/u/second_factors.json", params: { password: password } }
fab!(:other_topic) { Fabricate(:topic) }
put "/u/#{user1.username}/feature-topic.json", params: { topic_id: topic.id }
put "/u/#{user1.username}/feature-topic.json", params: { topic_id: other_topic.id }
get "/u/#{user1.username}/bookmarks.json", params: { q: "badsearch" }
let!(:post) { Fabricate(:post, topic: topic) }
before { sign_in(user_2) }
term: "old one",
term: "also old",
term: "new search",
fab!(:topic) { Fabricate(:post).topic }
.where("data::json ->> 'bookmark_id' = ?", bookmark_with_reminder2.id.to_s)
.update!(read: true)
.where("data::json ->> 'bookmark_id' = ?", bookmark_with_reminder.id.to_s)
ends_at = "2100-01-01T18:00:00.000Z"
put "/user-status.json", params: { description: "off to dentist" }
put "/user-status.json", params: { description: "off" }
put "/user-status.json", params: { emoji: "tooth" }
ends_at = "2100-01-01T18:00:00Z"
fab!(:badge) { Fabricate(:badge, target_posts: true, show_posts: false) }
post_id: p.id,
granted_by_id: -1,
get "/user_badges.json", params: { badge_id: badge.id }
fab!(:user_badge) { Fabricate(:user_badge, user: user, badge: badge, post: post) }
get "/user-badges/#{user.username}", xhr: true
get "/user-badges/#{user.username}.json", params: { grouped: true }
post "/user_badges.json", params: { badge_id: badge.id }
reason: "http://example.com/" + post.url,
reason: Discourse.base_url + "/random_url/" + post.url,
reason: "#{Discourse.base_url}#{post.url}",
let!(:user_badge) do
.track_events { delete "/user_badges/#{user_badge.id}.json" }
seq: 0,
seq: 1,
body: "image",
url: upload.url + ".jpg",
sha1: SecureRandom.hex << "A" * 8,
width: 98,
scopes: "read",
client_id: "x" * 32,
post "/user-api-key/revoke.json", headers: { HTTP_USER_API_KEY: key.key }
id: key2.id,
id: key.id,
post "/user-api-key/revoke.json", params: { id: key.id }
expect(key.push_url).to eq("https://push.it/here")
uri.query = ""
redis_key = "otp_#{parsed_otp}"
query_str = "/?param1=val1"
let(:params) { {} }
let(:params) { { username: username } }
let(:post) { create_post }
let(:params) { { filter: filter, username: username, offset: offset, limit: limit } }
let(:filter) { "1,2" }
let(:offset) { "0" }
let(:limit) { "10" }
let(parameter) { { bad: "data" } }
let(:logo_file) { file_from_fixtures("logo.png") }
let(:text_file) { Rack::Test::UploadedFile.new(File.new("#{Rails.root}/LICENSE.txt")) }
post "/uploads.json", params: { file: logo }
type: "avatar",
post "/uploads.json", params: { file: logo, type: "avatar" }
post "/uploads.json", params: { file: logo, type: "site_setting", for_site_setting: "true" }
post "/uploads.json", params: { file: logo, type: "composer" }
post "/uploads.json", params: { file: text_file, type: "composer" }
url = "http://example.com/image.png"
url: url,
post "/uploads.json", params: { type: "composer" }
post "/uploads.json", params: { file: text_file, type: "avatar" }
post "/uploads.json", params: { file: fake_jpg, type: "composer" }
post "/uploads.json", params: { file: fake_logo, type: "composer" }
let(:site) { "default" }
let(:sha) { Digest::SHA1.hexdigest("discourse") }
fab!(:upload) { upload_file("small.pdf", "pdf") }
before { setup_s3 }
it "returns 404 " do
get "/uploads/#{site}/#{upload.sha1}.#{upload.extension}"
get "/uploads/#{site}/#{sha}.pdf"
upload = upload_file("test.js", "themes")
get "/uploads/#{site}/#{upload.sha1}.json"
upload = upload_file("small.pdf", "pdf")
fab!(:image_upload) { upload_file("smallest.png") }
get upload.short_path, params: { dl: "1" }
let(:upload) { Fabricate(:upload_s3, secure: true) }
post "/uploads/lookup-metadata.json", params: { url: "abc" }
file_name: "test.png",
.raises(Aws::S3::Errors::ServiceError.new({}, "test"))
<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n
.with("test.png", "image/png", metadata: { "sha1-checksum" => "testing" })
.returns({ key: "test" })
<Part>
<Size>#{5.megabytes}</Size>
</Part>
</Owner>
:get,
.raises(Aws::S3::Errors::NoSuchUpload.new("test", "test"))
).with(
).to_return(status: 200, body: <<~XML)
).to_return(status: 200, body: "")
let(:upload) { Fabricate(:upload) }
.raises(Aws::S3::Errors::NotFound.new("error", "not found"))
fab!(:dest_topic) { Fabricate(:topic) }
fab!(:post_author1) { Fabricate(:user) }
fab!(:post_author2) { Fabricate(:user) }
fab!(:post_author3) { Fabricate(:user) }
fab!(:post_author4) { Fabricate(:user) }
fab!(:post_author5) { Fabricate(:user) }
fab!(:post_author6) { Fabricate(:user) }
fab!(:trust_level_0) { Fabricate(:trust_level_0) }
fab!(:trust_level_1) { Fabricate(:trust_level_1) }
fab!(:trust_level_4) { Fabricate(:trust_level_4) }
fab!(:p1) { Fabricate(:post, user: moderator) }
fab!(:p2) { Fabricate(:post, topic: p1.topic, user: moderator) }
get "/t/#{p1.topic.id}/wordpress.json", params: { best: 3 }
fab!(:p1) { Fabricate(:post, user: user, post_number: 1) }
let(:p2) { Fabricate(:post, user: user, post_number: 2, topic: p1.topic) }
post "/t/#{topic.id}/move-posts.json", params: { title: "blah" }
post "/t/#{topic.id}/move-posts.json",
title: "blah",
p2 =
end.to change { Topic.count }.by(1).and change { Tag.count }.by(2)
expect(Tag.all.pluck(:name)).to include("foo", "bar")
end.to change { Topic.count }.by(1)
fab!(:p1) { Fabricate(:post, user: group_user.user, post_number: 1, topic: topic) }
fab!(:p2) { Fabricate(:post, user: group_user.user, post_number: 2, topic: topic) }
let!(:user) { group_user.user }
fab!(:topic) { p1.topic }
fab!(:p2) { Fabricate(:post, user: moderator, topic: topic) }
fab!(:p2) { Fabricate(:post, user: moderator) }
p1.update_columns(raw: "i", cooked: "")
fab!(:message) { pm }
fab!(:p1) { Fabricate(:post, user: user, post_number: 1, topic: message) }
fab!(:p2) { Fabricate(:post, user: user, post_number: 2, topic: message) }
post "/t/#{message.id}/move-posts.json",
fab!(:p2) { Fabricate(:post, user: evil_trout, post_number: 2, topic: message) }
fab!(:p1) { Fabricate(:post, user: user) }
post "/t/#{topic.id}/merge-topic.json"
fab!(:p1) { Fabricate(:post, user: post_author1, post_number: 1, topic: topic) }
fab!(:p2) { Fabricate(:post, user: post_author2, post_number: 2, topic: topic) }
fab!(:p1) { Fabricate(:post, topic: message, user: trust_level_4) }
fab!(:p2) do
post "/t/#{message.id}/merge-topic.json", params: { archetype: "private_message" }
post "/t/#{message.id}/merge-topic.json",
before { sign_in(trust_level_4) }
username: "user_a",
fab!(:p1) { Fabricate(:post, user: post_author1, topic: topic) }
fab!(:p2) { Fabricate(:post, user: post_author2, topic: topic) }
let!(:editor) { sign_in(moderator) }
post "/t/#{topic.id}/change-owner.json",
let!(:editor) { sign_in(admin) }
context: "test",
post "/t/#{t2.id}/change-owner.json",
let!(:params) { { timestamp: Time.zone.now } }
let!(:old_timestamp) { Time.zone.now }
let!(:new_timestamp) { old_timestamp - 1.day }
let!(:p2) do
put "/t/1/clear-pin.json"
put "/t/#{pm.id}/clear-pin.json"
expect do put "/t/#{topic.id}/clear-pin.json" end.to change {
put "/t/1/status.json", params: { status: "visible", enabled: true }
put "/t/#{topic.id}/status.json", params: { status: "visible", enabled: "true" }
put "/t/#{topic.id}/status.json", params: { enabled: true }
put "/t/#{topic.id}/status.json", params: { status: "visible" }
put "/t/#{topic.id}/status.json", params: { status: "title", enabled: "true" }
put "/t/#{closed_user_topic.id}/status.json", params: { status: "closed", enabled: "false" }
put "/t/#{topic.id}/status.json", params: { status: "closed", enabled: "true" }
put "/t/#{topic.id}/status.json", params: { status: "closed", enabled: "false" }
put "/t/#{topic.id}/status.json", params: { status: "archived", enabled: "true" }
put "/t/#{topic.id}/status.json", params: { status: "archived", enabled: "false" }
put "/t/#{topic.id}/status.json",
enabled: "true",
put "/t/#{topic.id}/status.json", params: { status: "pinned", enabled: "false" }
put "/t/#{topic.id}/status.json", params: { status: "visible", enabled: "false" }
api_key_id: api_key.id,
data: "{}",
delete "/t/#{topic.id}/timings.json?last=1"
fab!(:user_topic) { Fabricate(:topic, user: user) }
fab!(:user_post) { Fabricate(:post, user: user, topic: user_topic, post_number: 2) }
put "/t/99/mute.json"
put "/t/99/unmute.json"
put "/t/1/recover.json"
let!(:post) do
put "/t/#{topic.id}/recover.json"
delete "/t/1.json"
fab!(:topic) { Fabricate(:topic, user: user, created_at: 48.hours.ago) }
fab!(:post) { Fabricate(:post, topic: topic, user: user, post_number: 1) }
delete "/t/#{topic.id}.json"
fab!(:post) { Fabricate(:post, topic: topic, post_number: 1) }
delete "/t/#{topic.id}.json", params: { force_destroy: true }
fab!(:topic) { Fabricate(:post, user: post_author1).topic }
get "/t/id_for/#{topic.slug}.json"
get "/t/id_for/#{pm.slug}.json"
put "/t/1.json", params: { slug: "xyz" }
fab!(:topic) { Fabricate(:topic, user: user) }
put "/t/#{topic.id}.json", params: { category_id: category.id }
put "/t/#{topic.slug}/#{topic.id}.json"
fab!(:post_hook) { Fabricate(:post_web_hook) }
fab!(:topic_hook) { Fabricate(:topic_web_hook) }
put "/t/#{topic.slug}/#{topic.id}.json", params: { title: "brand new title" }
put "/t/#{topic.slug}/#{topic.id}.json", params: { category_id: "" }
put "/t/#{topic.slug}/#{topic.id}.json",
put "/t/#{topic.id}.json", params: { title: "This is a new title for the topic" }
non_digit_id = "asdf"
put "/t/#{non_digit_id}.json", params: { title: "This is a new title for the topic" }
update_params = { post: { raw: "edited body", edit_reason: "typo" } }
put "/t/#{topic.slug}/#{topic.id}.json", params: { title: "asdf" }
put "/t/#{topic.slug}/#{topic.id}.json", params: { category_id: -1 }
put "/t/#{topic.slug}/#{topic.id}.json", params: { category_id: topic.category_id }
put "/t/#{topic.slug}/#{topic.id}.json", params: { category_id: category.id }
fab!(:t1) { Fabricate(:tag) }
fab!(:t2) { Fabricate(:tag) }
put "/t/#{topic.slug}/#{topic.id}.json", params: { tags: tags.map(&:name) }
put "/t/#{topic.slug}/#{topic.id}.json", params: { title: topic.title + " hello" }
it "can add a tag to topic" do
expect do put "/t/#{topic.slug}/#{topic.id}.json" end.to_not change {
fab!(:tag1) { Fabricate(:tag) }
fab!(:tag_group_2) { Fabricate(:tag_group) }
put "/t/#{topic.slug}/#{topic.id}.json", params: { category_id: restricted_category.id }
put "/t/#{tl1_topic.slug}/#{tl1_topic.id}.json",
put "/t/#{tl0_topic.slug}/#{tl0_topic.id}.json",
put "/t/#{tl1_topic_in_category.slug}/#{tl1_topic_in_category.id}.json",
fab!(:topic) { Fabricate(:topic, external_id: "asdf") }
get "/t/external_id/asdf.json", params: { not_valid: true }
fab!(:private_topic) { pm }
fab!(:p1) { Fabricate(:post, user: topic.user) }
fab!(:p2) { Fabricate(:post, user: topic.user) }
get "/t/#{private_topic.id}.json"
get "/t/#{topic.id}.json"
get "/t/#{topic.id}", params: { slug: topic.slug }
get "/t/#{invisible_topic.id}.json", params: { slug: invisible_topic.slug }
get "/t/#{topic.id}.json", params: { slug: "just-guessing" }
get "/t/#{topic.slug}.json"
get "/t/#{topic.slug}/#{topic.id}.json"
get "/t/#{topic.slug}/#{topic.id}.json", params: { page: 2 }
get "/t/#{topic.slug}"
get "/t/#{topic.slug}", params: { post_number: 42 }
get "/t/#{topic.slug}", params: { post_number: 42, page: 123 }
get "/t/nope-nope.json"
get "/t/#{topic.slug}/#{topic.id}.json?print=false"
fab!(:allowed_group) { Fabricate(:group) }
fab!(:normal_topic) { Fabricate(:topic) }
let!(:nonexistent_topic_id) { Topic.last.id + 10_000 }
it "returns #{value} for #{key}" do
slug = key == :nonexistent ? "garbage-slug" : send(key.to_s).slug
topic_id = key == :nonexistent ? nonexistent_topic_id : send(key.to_s).id
format = request_json ? ".json" : ""
get "/t/#{slug}/#{topic_id}#{format}"
get "/t/#{secure_topic.slug}#{format}"
expect do get "/t/#{topic.slug}/#{topic.id}.json" end.to change(TopicViewItem, :count).by(1)
get "/t/#{topic.slug}/#{topic.id}/#{256**4}", params: { u: user.username }
expect do get "/t/#{topic.slug}/#{topic.id}", params: { u: user.username } end.to change {
get "/t/#{topic.slug}/#{topic.id}/print"
get "/t/#{topic.slug}/#{topic.id}/print", headers: { HTTP_USER_AGENT: "Rails Testing" }
expect(body).to_not have_tag(:meta, with: { name: "fragment" })
get "/t/#{topic.slug}/#{topic.id}", headers: { HTTP_USER_AGENT: "Rails Testing" }
expect(body).to have_tag(:meta, with: { name: "fragment" })
let(:restricted_tag) { Fabricate(:tag) }
let(:public_tag) { Fabricate(:tag) }
get "/t/#{topic.id}", headers: { HTTP_REFERER: "http://twitter.com" }
get "/t/#{topic.slug}/#{topic.id}", headers: { HTTP_REFERER: nil }
get "/t/#{topic.slug}/#{topic.id}"
3.times { @post_ids << Fabricate(:post, user: post_author1, topic: topic).id }
get "/t/#{topic.slug}/#{topic.id}.json", params: { page: 1 }
get "/t/#{topic.slug}/#{topic.id}/#{post_number}.json"
get "/t/#{topic.slug}/#{topic.id}.json", params: { page: 3 }
fab!(:post) { Fabricate(:post, user: post_author1) }
fab!(:topic) { post.topic }
fab!(:post2) { Fabricate(:post, user: post_author2, topic: topic) }
fab!(:post3) do
fab!(:post4) do
fab!(:post5) { Fabricate(:post, user: post_author5, topic: topic) }
fab!(:quote_reply) { Fabricate(:basic_reply, user: user, topic: topic) }
get "/t/#{topic.id}.json", params: { replies_to_post_number: post2.post_number }
fab!(:post6) do
get "/t/#{topic.id}.json", params: { filter_top_level_replies: true }
fab!(:post3) { Fabricate(:post, user: post_author3, topic: topic) }
fab!(:post5) do
fab!(:post6) { Fabricate(:post, user: post_author6, topic: topic) }
get "/t/#{topic.id}.json", params: { filter_upwards_post_id: post5.id }
let(:api_key) { Fabricate(:api_key, user: topic.user) }
get "/t/#{topic.slug}/#{topic.id}.json", headers: { "HTTP_API_KEY" => api_key.key }
get "/t/#{topic.slug}/#{topic.id}.#{format}", headers: { "HTTP_API_KEY" => "bad" }
expect { get "/t/#{topic.id}.json" }.not_to change(IncomingLink, :count)
get "/t/#{topic.id}.json", headers: { HTTP_REFERER: "http://#{"a" * 2000}.com" }
raw: "I am mentioning @#{post_author1.username}.",
get "/t/#{topic.slug}/#{topic.id}", params: { _escaped_fragment_: "true" }
expect(body).to have_tag(:script, with: { src: "/assets/discourse.js" })
get "/t/#{topic.slug}/#{topic.id}",
expect(body).to have_tag(:body, with: { class: "crawler" })
get "/t/#{topic.id}.json",
:meta,
with: {
expect(body).to have_tag(:link, with: { itemprop: "image", href: post.image_url })
get "/t/#{topic.id}/post_ids.json", params: { post_number: post.post_number }
fab!(:post2) { Fabricate(:post, topic: topic, user: user) }
get "/t/#{topic.id}/post_ids.json",
fab!(:post2) { Fabricate(:post, user: post_author2, topic: topic, percent_rank: 0.2) }
fab!(:post3) { Fabricate(:post, user: post_author3, topic: topic, percent_rank: 0.5) }
get "/t/#{topic.id}.json", params: { post_number: post.post_number, filter: "percent" }
get "/t/#{topic.id}/posts.json"
get "/t/#{topic.id}/posts.json",
asc: true,
get "/t/foo/#{topic.id}.rss"
post "/t/#{topic.id}/invite-group.json", params: { group: "admins" }
post "/t/#{pm.id}/invite-group.json", params: { group: "admins" }
put "/t/#{tl4_topic.id}/make-banner.json"
put "/t/#{admin_topic.id}/make-banner.json"
put "/t/#{tl4_topic.id}/remove-banner.json"
let!(:operation) { { type: "change_category", category_id: "1" } }
put "/topics/bulk.json", params: { topic_ids: topic_ids }
put "/topics/bulk.json", params: { topic_ids: topic_ids, operation: {} }
g.add(user_2)
.tap { |tu| tu.update!(last_read_post_number: 1) }
put "/topics/bulk.json", params: { topic_ids: "1", operation: operation }
put "/t/#{pm.topic_id}/bookmark.json"
put "/t/#{post.topic_id}/bookmark.json"
@old_date = 2.years.ago
let!(:old_date) { @old_date }
}.by(5)
7,
fab!(:tag_topic) { Fabricate(:topic) }
fab!(:topic_tag) { Fabricate(:topic_tag, topic: tag_topic, tag: tag) }
fab!(:topic3) { Fabricate(:topic) }
put "/topics/reset-new.json", params: { topic_ids: topic2.id }
get "/topics/feature_stats.json", params: { category_id: 1 }
create_post(raw: "This is the first post :)", title: "This is a test title I am making yay")
get "/t/#{first_post.topic_id}/excerpts.json",
fab!(:post) { Fabricate(:post, user: user, topic: topic) }
fab!(:post) { Fabricate(:post, user: post_author1, topic: topic) }
fab!(:post_1) { Fabricate(:post, user: post_author1, topic: topic) }
timings: {
post_1.post_number => 2,
it "caps post read time at the max integer value (2^31 - 1)" do
msecs: 2**31 - 10,
post_1.post_number => 100,
expect(post_timing.msecs).to eq(2**31 - 1)
post "/t/#{topic.id}/timer.json",
time: 24,
post "/t/#{topic.id}/timer.json", params: { time: 10, status_type: "something" }
post "/t/#{pm_topic.id}/timer.json",
time: "24",
post "/t/#{topic.id}/timer.json", params: { time: 10, status_type: "delete" }
post "/t/#{topic.id}/timer.json", params: { time: 10, status_type: "delete_replies" }
put "/t/#{topic.id}/slow_mode.json", params: { seconds: "3600" }
put "/t/#{topic.id}/slow_mode.json", params: { seconds: "3600", enabled_until: timestamp }
put "/t/#{topic.id}/slow_mode.json", params: { seconds: "0", enabled_until: timestamp }
put "/t/#{topic.id}/slow_mode.json",
seconds: "3600",
post "/t/#{topic.id}/invite.json", params: { email: "jake@adventuretime.ooo" }
post "/t/#{user_topic.id}/invite.json", params: { email: "someguy@email.com" }
post "/t/#{id}/invite.json", params: { email: user.email }
post "/t/#{topic.id}/invite.json"
fab!(:pm) { Fabricate(:private_message_topic, user: user) }
post "/t/#{pm.id}/invite.json", params: { user: user_2.username }
post "/t/#{moderator_pm.id}/invite.json", params: { user: user_2.username }
fab!(:topic) { pm }
post "/t/#{topic.id}/invite.json", params: { user: user.username }
post "/t/#{topic.id}/invite-group.json", params: { group: admins.name }
before { pm.allowed_users << user }
post "/t/#{pm.id}/invite-group.json", params: { group: group.name }
post "/t/#{moderator_pm.id}/invite-group.json", params: { group: group.name }
).to eq(3)
fab!(:other_cat) { Fabricate(:category) }
put "/t/#{topic.id}/shared-draft.json", params: { category_id: other_cat.id }
put "/t/#{topic.id}/publish.json",
expect(body).to include('<link rel="next" href="' + topic.relative_url + "?page=2")
expect(body).to include("id='post_1'")
expect(body).to include("id='post_2'")
get topic.url + "?page=2", env: { "HTTP_USER_AGENT" => user_agent }
expect(body).to include("id='post_3'")
expect(body).to include("id='post_4'")
expect(body).to include('<link rel="next" href="' + topic.relative_url + "?page=3")
get topic.url + "?page=3", env: { "HTTP_USER_AGENT" => user_agent }
expect(body).to include('<link rel="prev" href="' + topic.relative_url + "?page=2")
fab!(:topic_embed) { Fabricate(:topic_embed, embed_url: "https://markvanlan.com") }
let!(:user_agent) do
get topic_embed.topic.url, env: { "HTTP_USER_AGENT" => user_agent }
put "/t/#{topic.id}/reset-bump-date.json"
it "denies access for #{user}" do
put "/t/#{max_id + 1}/reset-bump-date.json"
put "/topics/pm-reset-new.json", params: { inbox: "group", group_name: "randomgroup" }
put "/topics/pm-reset-new.json", params: { inbox: "group", group_name: group.name }
put "/topics/pm-reset-new.json", params: { inbox: "user" }
put "/topics/pm-reset-new.json", params: { inbox: "all" }
user: user_2,
put "/topics/pm-reset-new.json", params: { topic_ids: "1" }
let!(:theme) { Fabricate(:theme) }
ThemeField.create!(theme: theme, target_id: 0, name: "header", value: "<a>html</a>")
update_digest_and_get("../../Gemfile")
get js_cache_url, headers: { "Accept" => "text/html" }
get js_cache_url, headers: { "Accept" => "invalidcontenttype" }
type: :js,
value: "assert.ok(true);",
name: "yaml",
value: "num_setting: 5",
js_file.write("console.log(123);\n")
digest = Rack::Utils.escape("../../../../../../../../../../etc/passwd").gsub(".", "%2E")
get "/theme-javascripts/tests/#{Theme.maximum(:id) + 1}-#{SecureRandom.hex(20)}.js"
fab!(:regular_user) { Fabricate(:trust_level_4) }
fab!(:test_tag) { Fabricate(:tag, name: "test", description: "some description") }
fab!(:topic_tag) do
name: "topic-test",
fab!(:pm_only_tag) do
fab!(:synonym) { Fabricate(:tag, name: "synonym", target_tag: topic_tag) }
get "/tags.json"
fab!(:tag) { Fabricate(:tag, name: "test") }
get "/tag/test.json"
get "/tag/%2ftest%2f"
get "/tag/#{synonym.name}"
get "/tag/test"
get "/tag/none.json"
get "/tags/c/#{category.slug}/#{tag.name}.json"
get "/tags/c/#{category.slug_path.join("/")}/#{category.id}/#{tag.name}.json?per_page=1"
get "/tags/c/#{category.slug_path.join("/")}/#{category.id}/somerandomstring/#{tag.name}.json?per_page=1"
get "/tags/c/#{c.slug_path.join("/")}/#{c.id}/#{tag.name}.json"
get "/tags/c/#{category.slug}/#{subcategory.slug}/#{tag.name}.json"
let(:synonym) { Fabricate(:tag, name: "synonym", target_tag: tag) }
get "/tag/#{tag.name}/info.json"
get "/tag/#{synonym.name}/info.json"
.track_events { put "/tag/#{tag.name}.json", params: { tag: { id: "hello" } } }
it "can't see pm tags" do
fab!(:third_tag) { Fabricate(:tag) }
get "/tag/#{tag.name}/l/latest.json"
get "/tag/#{tag.name}/l/latest"
get "/tag/#{tag.name}/l/latest.json", params: { additional_tag_ids: other_tag.name }
get "/tag/#{tag.name}/l/latest.json",
additional_tag_ids: "#{other_tag.name}/#{third_tag.name}",
get "/tag/#{tag.name}/l/latest.json", params: { additional_tag_ids: "notatag" }
get "/tags/c/#{category.slug}/#{tag.name}/l/latest.json"
get "/tags/c/#{category.slug}/#{subcategory.slug}/#{tag.name}/l/latest.json"
get "/tags/c/#{category.slug}/none/#{tag.name}/l/latest.json"
get "/tag/#{tag.name}/l/bookmarks.json"
get "/tag/#{tag.name}/l/top.json"
get "/tag/#{tag.name}/l/top.json?period=daily"
get "/tags/c/#{category.slug}/#{category.id}/#{tag.name}/l/top.json"
get "/tag/test/l/top.json"
get "/tags/filter/search.json", params: { q: "stuff" }
tag_names.each { |name| Fabricate(:tag, name: name) }
get "/tags/filter/search.json", params: { q: "stu" }
get "/tags/filter/search.json", params: { q: "tag", limit: 2 }
fab!(:yup) { Fabricate(:tag, name: "yup") }
nope = Fabricate(:tag, name: "nope")
q: yup.name,
count: 1,
fab!(:tag) { Fabricate(:tag, name: "plant") }
fab!(:synonym) { Fabricate(:tag, name: "plants", target_tag: tag) }
get "/tags/filter/search.json", params: { q: "plant" }
get "/tags/filter/search.json", params: { q: "plant", excludeSynonyms: "true" }
get "/tags/filter/search.json", params: { q: "plants", excludeSynonyms: "true" }
yup, nope = Fabricate(:tag, name: "yup"), Fabricate(:tag, name: "nope")
get "/tags/filter/search.json", params: { q: "N/ope" }
get "/tags/filter/search.json", params: { q: "cool" }
q: "",
limit: 5,
get "/tags/filter/search.json", params: { q: "", limit: -1 }
I18n.t("invalid_params", message: "limit"),
{ "name" => tag_group.name, "min_count" => crtg.min_count },
delete "/tag/#{tag.name}.json"
let!(:tags) do
name: "unused1",
name: "unused2",
expect { delete "/tags/unused.json" }.to change { Tag.count }.by(-2) &
let(:csv_file) { File.new("#{Rails.root}/spec/fixtures/csv/tags.csv") }
let(:filename) { "tags.csv" }
post "/tags/upload.json", params: { file: file, name: filename }
}.to_not change { Tag.count }
}.to change { Tag.count }.by(1)
fab!(:synonym) { Fabricate(:tag, target_tag: tag, name: "synonym") }
subject { delete("/tag/#{tag.name}/synonyms/#{synonym.name}.json") }
expect { subject }.to_not change { Tag.count }
fab!(:tag_group) { Fabricate(:tag_group) }
get "/tag_groups/filter/search.json", params: { q: "oop" }
options.merge!({ name: name }) if name
set_cdn_url "//some-cdn.com/site"
get "/svg-sprite/picker-search", params: { filter: "500px" }
get "/stylesheets/#{builder.stylesheet_filename.sub(".css", "")}.css"
get "/stylesheets/desktop_#{digest}.css", headers: { "Accept" => "text/html" }
put "/wizard/steps/made-up-id.json", params: { fields: { forum_title: "updated title" } }
fields: {
title: "FooBar",
put "/wizard/steps/introduction.json", params: { fields: { title: "" } }
let(:filename) { "smallest.png" }
after { Discourse.redis.scan_each(match: "memoize_*").each { |key| Discourse.redis.del(key) } }
stub_request(:get, "https:/#{upload.url}").to_return(status: 200, body: file)
let (:site) {
get "/cdn_asset/#{site}/test.js.br"
get "/faq"
context "with #{id}" do
it "renders the #{id} page" do
get "/#{id}"
get "/signup"
get "/#{page_name}"
routes = Proc.new { get "contact" => "static#show", :id => "contact" }
current_user&.locale == "pl" ? "test_polish_faq_topic_id" : "test_faq_topic_id"
sign_in(Fabricate(:user, locale: "pl"))
post "/login.json", params: { redirect: "/foo" }
post "/login.json", params: { redirect: "#{Discourse.base_url}/foo" }
post "/login.json", params: { redirect: "/foo?bar=1" }
post "/login.json", params: { redirect: ".org/foo" }
post "/login.json", params: { redirect: "http://eviltrout.com/foo" }
post "/login.json", params: { redirect: "javascript:alert('trout')" }
post "/login.json", params: { redirect: login_path }
let(:name) { "Arts & Media" }
post "/slugs.json", params: { name: name }
post "/slugs.json?name=#{name}"
get "/news"
get "/sitemap_1.xml"
loc = url.at_css("loc").text
expect(loc).to eq("#{Discourse.base_url}/t/#{topic.slug}/#{topic.id}")
loc = urls.first.at_css("loc").text
all_urls = urls.map { |u| u.at_css("loc").text }
expect(all_urls).not_to include("#{Discourse.base_url}/t/#{old_topic.slug}/#{old_topic.id}")
two_page_size = page_size + 1
expect(url).to include("?page=2")
get "/news.xml"
let(:raw) { "this body is long enough to search for" }
let(:topic) { Fabricate(:topic, title: title) }
let(:post) { Fabricate(:post, topic: topic, raw: raw, post_number: 1) }
title: "#{title} 02",
get "/topics/similar_to.json", params: { raw: raw }
get "/topics/similar_to.json", params: { title: title, raw: raw }
fab!(:sidebar_url_1) { Fabricate(:sidebar_url, name: "tags", value: "/tags") }
{ icon: "link", name: "categories", value: "/categories" },
{ icon: "link", name: "tags", value: "/tags" },
icon: "link",
{ icon: "address-book", name: "tags", value: "/tags" },
{ icon: "external-link-alt", name: "Discourse", value: "https://discourse.org" },
fab!(:sidebar_url_2) { Fabricate(:sidebar_url, name: "categories", value: "/categories") }
{ icon: "link", id: sidebar_url_1.id, name: "latest", value: "/latest" },
{ icon: "link", id: sidebar_url_2.id, name: "tags", value: "/tags", _destroy: "1" },
sidebar_url_3 = Fabricate(:sidebar_url, name: "other_tags", value: "/tags")
ip_address: "111.111.11.11",
let(:permitted_ip_address) { "111.234.23.11" }
post "/drafts.json", params: {}
sso = get_sso("/a/")
sso.external_id = "666"
sso.email = "bob@bob.com"
sso.name = "Bob Bobson"
sso.username = "bob"
sso = get_sso("/")
sso.external_id = "abc"
sso.username = "sam"
sso = get_sso("/session/sso?bla=1")
sso.external_id = "123"
sso.external_id = "nil"
sso = get_sso("#{Discourse.base_url}//site.com/xyz")
sso = get_sso("#{Discourse.base_url}/b/")
sso = get_sso("https://gusundtrout.com")
sso = get_sso("//eviltrout.com")
sso = get_sso("http://eviltrout.com")
end.to change { User.count }.by(1)
let(:invite_email) { nil }
user = User.find_by_email("bob@bob.com")
sso = get_sso("/hello/world")
sso.external_id = "997"
@sso = get_sso("/hello/world")
@sso.external_id = "997"
@sso.name = @user.name
body: lambda { |request| file_from_fixtures("logo.png") },
@sso.nonce = "mynonce"
@user = user
xhr: true,
expect(sso2.groups).to eq(@user.groups.pluck(:name).join(","))
before { @sso.require_2fa = true }
post "/session.json", params: { login: user.username, password: "sssss" }
password: ("s" * (User.max_password_length + 1)),
it "doesn't log in" do
login: "@" + user.username,
let(:username) { " #{user.username} " }
let(:email) { " #{user.email} " }
ip_address: "111.234.23.11",
login: "#{user.username}#{x}",
user.username + " ",
callback_params = {}
callback = ->(data) { callback_params = data }
get "/session/otp/#{token}"
post "/session/otp/#{token}"
ip_address: "100.0.0.1",
login: "made_up",
post "/session/forgot_password.json", params: { login: "made_up" }
let!(:staged) { Fabricate(:staged) }
let!(:user) { sign_in(Fabricate(:user)) }
get "/session/2fa.json", params: { nonce: "asdasdsadsad" }
get "/session/2fa.json", params: { nonce: "wrongnonce" }
get "/session/2fa.json", params: { nonce: nonce }
post "/session/2fa/test-action", params: { redirect_url: "/ggg" }, xhr: true
token += token == 999_999 ? -1 : 1
fab!(:user_post) do
term: "hi there",
get "/search.json",
q: "awesome",
get "/search/query.json", params: { term: term }
get "/search/query.json", params: { term: "awesome" }
get "/search/query.json", params: { term: "order:views elephant" }
get "/search/query.json", params: { term: user.username, type_filter: "topic" }
get "/search/query.json", params: { term: user.username, type_filter: "user" }
get "/search/query.json", params: { term: "wookie" }
get "/search/query.json", params: { term: "boop", type_filter: "exclude_topics" }
term: "in:first",
get "/search/query.json", params: { term: "wookie" }, env: { REMOTE_ADDR: ip_address }
def limited_request(ip_address = "1.2.3.4")
t = Time.now
limited_request("1.2.3.6")
limited_request("1.2.3.8")
get "/search.json", params: { q: "ba" }
get "/search.json", params: { q: term }
get "/search.json", params: { q: "kittens", page: "3" }
get "/search.json", params: { q: "kittens", page: 3 }
get "/search.json?page=xawesome%27\"</a\&"
get "/search.json", params: { q: "bantha" }
get "/search.json", params: { q: "wookie" }, env: { REMOTE_ADDR: ip_address }
freeze_time(t + 2)
limited_request("3.3.3.3")
limited_request("5.5.5.5")
get "/search.json", params: { q: "status:open" }
get "/search.json", params: { q: "status:open Priority Post" }
term: "test",
id: "hole",
get "/search/query.json", params: { term: "test", search_context: { type: "user" } }
type: "user",
type: "tag",
id: "important-tag",
_, search_log_id =
user_id: -10,
ip_address: "127.0.0.1",
tag = Fabricate(:tag, name: "test")
expect(response.body).to include("data-theme-id=\"#{theme.id}\"")
get "/safe-mode"
expect(response.body).not_to include("data-theme-id=\"#{theme.id}\"")
i = response.body.index("User-agent: *")
before { sign_in(Fabricate(:user)) }
let(:from) { 3.days.ago.strftime("%F") }
let(:to) { 1.day.ago.strftime("%F") }
get "/review.json?from_date=#{from}&to_date=#{to}"
raw: "this is the third post",
{ args: { :version => reviewable_phony.version, "fake_id" => "2" } },
fake_id: 2,
fab!(:post0) { Fabricate(:post) }
fab!(:post1) { Fabricate(:post, topic: post0.topic) }
fab!(:user0) { Fabricate(:user) }
field: "value",
raw: "new raw content",
raw: "new topic op",
let(:params) { { reviewable_claimed_topic: { topic_id: topic.id } } }
.size,
let(:theme) { Fabricate(:theme, name: "main-theme") }
let(:theme_without_tests) { Fabricate(:theme, name: "no-tests-guy") }
value: "console.log(#{t.id});",
name: "acceptance/some-test-#{t.id}.js",
value: "assert.ok(#{t.id});",
get "/theme-qunit?id=#{theme.id}"
p256dh: "256dh",
auth: "auth",
subscription = { endpoint: "endpoint", keys: { p256dh: "256dh", auth: "auth" } }
sub = { endpoint: "endpoint", keys: { p256dh: "256dh", auth: "auth" } }
get "/pub/check-slug.json", params: { slug: "check-slug" }
put "/pub/by-topic/#{topic.id}.json", params: { published_page: { slug: "cant-do-this" } }
put "/pub/by-topic/#{topic.id}.json", params: { published_page: { slug: "i-hate-salt" } }
).to be(true)
put "/pub/by-topic/#{topic.id}.json",
slug: "i-hate-salt",
delete "/pub/by-topic/#{topic_id}.json"
fab!(:group) { Fabricate(:group).tap { |g| g.add(user) } }
let(:ch1) { PresenceChannel.new("/test/public1") }
let(:ch2) { PresenceChannel.new("/test/public2") }
when %r{\A/test/public\d*\z}
ch1.name => true,
let(:user2) { Fabricate(:user) }
let(:user3) { Fabricate(:user) }
ch1.name => {
get "/presence/get",
ch1.name => be_truthy,
let!(:post) { post_by_user }
before { post.trash!(user) }
let(:user_gm) { group_user.user }
let(:group) { group_user.group }
fab!(:user_trust_level_0) { Fabricate(:trust_level_0) }
fab!(:user_trust_level_1) { Fabricate(:trust_level_1) }
fab!(:post_by_user) { Fabricate(:post, user: user) }
let(:public_post) { Fabricate(:post, user: user, topic: topic) }
let(:topicless_post) { Fabricate(:post, user: user, raw: "<p>Car 54, where are you?</p>") }
let(:url) { "/posts/#{post.id}.json" }
get "/posts/#{new_post.id}.json"
let(:url) { "/posts/by_number/#{post.topic_id}/#{post.post_number}.json" }
let(:url) { "/posts/by-date/#{post.topic_id}/#{post.created_at.strftime("%Y-%m-%d")}.json" }
get "/posts/by-date/#{second_post.topic_id}/#{(second_post.created_at - 2.days).strftime("%Y-%m-%d")}.json"
get "/posts/by-date/#{post.topic_id}/2245-11-11.json"
let(:url) { "/posts/#{post.id}/reply-history.json" }
let(:url) { "/posts/#{post.id}/reply-ids.json" }
get "/posts/#{post.id}/reply-ids.json"
let(:url) { "/posts/#{post.id}/replies.json" }
post = Fabricate(:post, topic: pm, post_number: 3)
delete "/posts/#{post.id}.json"
let!(:post) { Fabricate(:post, topic_id: topic.id, post_number: 3) }
delete "/posts/#{post.id}.json", params: { force_destroy: true }
fab!(:poster) { Fabricate(:moderator) }
fab!(:post1) { Fabricate(:post, user: poster, post_number: 2) }
put "/posts/#{post.id}/recover.json"
raw: "edited body",
edit_reason: "typo",
put "/posts/#{post.id}.json", params: param
put "/posts/#{post.id}.json",
raw: "this is a test edit to post",
raw: "this is a random post",
put "/posts/#{post.id}/wiki.json", params: {}
put "/posts/#{post.id}/wiki.json", params: { wiki: "true" }
put "/posts/#{another_post.id}/wiki.json", params: { wiki: "true" }
put "/posts/#{another_post.id}/wiki.json", params: { wiki: "false" }
it "can wiki a post" do
put "/posts/#{wikied_post.id}/wiki.json", params: { wiki: "false" }
put "/posts/#{post.id}/post_type.json", params: { post_type: 2 }
put "/posts/#{post.id}/post_type.json", params: {}
put "/posts/#{post.id}/post_type.json", params: { post_type: -1 }
put "/posts/#{post.id}/rebake.json"
post "/posts.json",
wpid: 1,
wpid: 2,
raw: "this is test reply 1",
raw: "this is test reply 2",
raw: "this is test reply 3",
title: "this is a test topic",
expect(Draft.get(user, Draft::NEW_TOPIC, 0)).to eq("test")
title: "this is a test title",
raw: "this is test body",
embed_url: "/test.txt",
raw: "this is a test title",
Draft.set(user, "should_clear", 0, "{'a' : 'b'}")
raw = "A post <!-- " + ("a" * 3000) + "-->"
post "/posts.json", params: { raw: raw, title: "this is the test title for the topic" }
raw: "I can haz a test",
title: "I loves my test",
expect do post "/posts.json", params: { raw: raw, title: title, wpid: 1 } end.to change {
post "/posts.json", params: { raw: raw, title: title, wpid: 2 }
meta_data: {
xyz: "abc",
expect(topic.meta_data).to eq("xyz" => "abc")
category: "",
width: "100",
height: "200",
user_3 = Fabricate(:user, username: "foo_bar")
user_4 = Fabricate(:user, username: "Iyi_Iyi")
post "/posts.json", params: { raw: "test" }
fab!(:user_to_mention) { Fabricate(:user) }
post "/posts.json", params: { raw: "No mentions here", topic_id: topic.id }
post "/posts.json", params: { raw: "Mentioning a @stranger", topic_id: topic.id }
post "/posts.json", params: { raw: "this is the test content", topic_id: topic.id }
it "will raise an error for #{user}" do
get "/posts/#{post.id}/revisions/1.json"
get "/posts/#{pr.post_id}/revisions/#{pr.number}.json"
fab!(:deleted_post) { Fabricate(:post, user: admin, version: 3) }
fab!(:deleted_topic) { Fabricate(:topic, user: admin) }
fab!(:post) { Fabricate(:post, user: admin, topic: deleted_topic, version: 3) }
let(:tag) { Fabricate(:tag) }
fab!(:post) do
let(:post_id) { post.id }
logs =
put "/posts/#{post_id}/revisions/#{revision_id + 1}/revert.json"
put "/posts/#{post_id + 1}/revisions/#{revision_id}/revert.json"
it "works!" do
pm_post =
get "/posts/#{post.id}/raw.json"
get "/posts/0/raw"
get "/raw/#{topic.id}/1.json"
get "/raw/#{topic.id}"
get "/p/#{post.id}.json"
get "/p/#{post.id}"
get "/p/0"
expect(response.body).to have_tag("input", with: { value: "private_posts" })
get "/posts.rss"
post = Fabricate(:post, cooked: "WAt")
get "/posts/#{post.id}/cooked.json"
get "/posts/#{post.id}/raw-email.json"
put "/posts/#{public_post.id}/locked.json", params: { locked: "true" }
put "/posts/#{public_post.id}/locked.json", params: { locked: "false" }
put "/posts/#{public_post.id}/notice.json", params: { notice: raw_notice }
put "/posts/#{public_post.id}/notice.json", params: { notice: nil }
put "/posts/#{public_post.id}/notice.json", params: { notice: "Hello" }
let(:current_user) { user }
string_arg: "123",
hash_arg: {
key1: "val",
fab!(:reader) { Fabricate(:user) }
get "/post_readers.json", params: { id: @post.id }
fab!(:post) { Fabricate(:post, user: coding_horror) }
delete "/post_actions/#{post.id}.json",
id: pm.id,
fab!(:post_1) { Fabricate(:post, user: coding_horror) }
id: -1,
post "/post_actions.json", params: { id: post_1.id }
id: post_1.id,
post_id: post_1.id,
take_action: "true",
let(:post) { Fabricate(:post, user: sign_in(user)) }
get "/post_action_users.json", params: { id: post.id }
page: 1,
limit: 2,
get "/#{permalink.url}"
SiteSetting.permalink_normalizations = "/(.*)\\?.*/\\1"
get "/#{permalink.url}", params: { test: "hello" }
SiteSetting.permalink_normalizations = "/(.*)\\?.*/\\1X"
get "/not/a/valid/url"
let(:url) { "http://google.com" }
get "/onebox.json", params: { url: url }
let(:html) do
<head>
</head>
<p>body</p>
get "/onebox.json", params: { url: url, refresh: "true" }
url = "http://noodle.com/"
stub_request_to_onebox_url(" \t ")
get "/onebox.json", params: { url: category.url }
get "/onebox.json", params: { url: subcategory.url }
get "/onebox.json", params: { url: staff_category.url }
mock().tap do |m|
let(:email) { "somename@gmail.com" }
let(:username) { "somename" }
let(:name) { "Some Name" }
events.any? do |e|
username = ""
name = "John Smith"
let(:uid) { 12_345 }
before { mock_auth(user.email, "Somenickname", "Some name", uid) }
).not_to eq(nil)
name: "My new name",
uid = "12345"
username = "strange_name*&^"
let(:group1) { { id: "12345", name: "group1" } }
let(:group2) { { id: "67890", name: "group2" } }
let(:uid) { "12345" }
let(:token) { "1245678" }
let(:domain) { "mydomain.com" }
body: { "access_token" => token, "type" => "bearer" }.to_json,
.with(headers: { "Authorization" => "Bearer #{token}" })
body: { groups: groups }.to_json,
get "/auth/google_oauth2/callback.json", params: { code: "abcde", hd: domain }
let(:user1_provider_id) { "12345" }
let(:user2_provider_id) { "123456" }
old_identity = { name: "Bob", username: "bob", email: old_email }
new_identity = { name: "Bob", username: "boguslaw", email: new_email }
def mock_auth(email, nickname = nil, name = nil, uid = "12345")
uid: uid,
extra: {
data: { message: "tada" }.to_json,
fab!(:user) { sign_in(Fabricate(:user)) }
get "/notifications", params: { recent: true }
get "/notifications.json", params: { filter: "read" }
get "/notifications.json", params: { filter: "unread" }
fab!(:liked1) do
fab!(:liked2) do
get "/notifications.json", params: { recent: true, filter_by_types: "liked", limit: 1 }
fab!(:allowed_pm) do
fab!(:admin) { sign_in(Fabricate(:admin)) }
title = "MyApp"
fab!(:group) { Fabricate(:group, name: "AwesomeGroup") }
get "/latest?page=-1"
get "/latest?page=0"
get "/latest?page=1"
get "/#{filter}"
get "/latest.json", params: { topic_ids: "#{p.topic_id}" }
get "/latest"
get "/#{filter}", params: { _escaped_fragment_: "true" }
get "/u/#{user.username}/messages/tags/#{tag.name}"
let!(:topic2) { Fabricate(:topic, user: user2) }
let!(:another_topic) { Fabricate(:topic) }
_post = Fabricate(:post, topic: topic, user: user)
get "/top.rss"
it "renders #{period} top RSS" do
get "/top.rss?period=#{period}"
get "/top"
let(:group) { Fabricate(:group) }
get "/c/#{category.slug}/#{category.id}/l/latest"
name: "#{category.id} name",
).tap { |category| category.update_column(:slug, "#{category.id}-name") }
get "/c/#{category.slug}/#{sub_category.slug}/#{sub_category.id}/l/latest"
get "/c/#{category.slug}/#{category.id}.rss"
get "/c/#{category.slug}/#{category.id}.json"
it "has a default view of ''" do
get "/c/#{category.slug}/#{category.id}"
fab!(:topic2) { Fabricate(:topic, user: user) }
before { sign_in(user2) }
fab!(:pm_user) { Fabricate(:user) }
fab!(:target_user) { Fabricate(:user) }
get "/read"
get "/c/Hello/#{category.id}"
get "/c/hello/#{category.id}"
get "/c/syst%C3%A8mes/#{category.id}"
get "/c/#{category.slug}"
get "/c/#{category1.slug}/#{category1.id}.json"
get "/c/#{category2.slug}/#{category2.id}.json"
get "/c/#{c.slug}/#{sub_c.slug}/#{sub_c.id}"
fab!(:welcome_topic) { Fabricate(:topic) }
fab!(:post) { Fabricate(:post, topic: welcome_topic) }
post.revise(post.user, { raw: "#{post.raw}2" }, revised_at: post.updated_at + 2.minutes)
fab!(:invite) { Fabricate(:invite) }
expect(response.body).not_to include("i*****g@a***********e.ooo")
post "/invites.json", params: { email: "test@example.com" }
post "/invites.json", params: { email: "test@example.com", topic_id: -9999 }
category.permissions = { group.name => :full }
post "/invites.json", params: { email: "test@example.com", topic_id: topic.id }
group_names: "#{group.name},#{group2.name}",
let(:params) { { email: email } }
let(:email) { "test@example.com" }
let(:invite) { Invite.last }
let(:email) { "test@mailinator.com" }
let(:email) { user.email }
fab!(:invite) { Fabricate(:invite, invited_by: user, email: "test@example.com") }
fab!(:invite) { Fabricate(:invite, invited_by: admin, email: "test@example.com") }
put "/invites/#{invite.id}", params: { email: "test2@example.com" }
put "/invites/#{invite.id}", params: { email: "test2@example.com", skip_email: true }
put "/invites/#{invite.id}", params: { custom_message: "new message" }
expect { put "/invites/#{invite.id}", params: { send_email: true } }.to change {
put "/invites/#{invite.id}.json", params: { email: "test2@example.com" }
subject(:update_invite) { put "/invites/#{invite.id}.json", params: { email: admin.email } }
delete "/invites.json", params: { email: "test@example.com" }
fab!(:invite) { Fabricate(:invite, invited_by: user) }
delete "/invites.json", params: { id: 848 }
delete "/invites.json", params: { id: invite.id }
fab!(:invite) { Fabricate(:invite, expires_at: 1.day.ago) }
put "/invites/show/#{invite.invite_key}.json", params: { password: "password" }
uid: "12345",
family_name: "Last",
given_name: "First",
gender: "male",
name: "First Last",
put "/invites/show/#{invite.invite_key}.json", params: { name: "somename" }
fab!(:invite) do
}.to change { User.count }
}.not_to change { User.count }
fab!(:invite) { Fabricate(:invite, email: "test@example.com") }
fab!(:user) { Fabricate(:user, email: "test@example.com") }
put "/invites/show/#{invite.invite_key}.json", params: { id: invite.invite_key }
fab!(:invite) { Fabricate(:invite, email: nil) }
let(:csv_file) { File.new("#{Rails.root}/spec/fixtures/csv/discourse.csv") }
post "/invites/upload_csv.json", params: { file: file, name: "discourse.csv" }
fab!(:category) { Fabricate(:category, name: "Random", slug: "random") }
fab!(:tag) { Fabricate(:tag, name: "bug") }
tag.name => tag.full_url,
expect(response.parsed_body).to eq("categories" => {}, "tags" => {})
fab!(:tag_2) { Fabricate(:tag, name: "random") }
fab!(:other_user) { Fabricate(:user) }
50.times { Fabricate(:group) }
get "/groups.json", params: { page: 1 }
get "/groups.json", params: { filter: "test" }
get "/groups.json", params: { order: "name" }
get "/groups.json", params: { order: "user_count" }
get "/groups.json", params: { order: "name", asc: true }
get "/groups.json", params: { order: "user_count", asc: "true" }
get "/groups.json", params: { username: "asdasd" }
u = Fabricate(:user)
m = Fabricate(:user)
o = Fabricate(:user)
g =
name: "#{group_level}_#{members_level}",
g.add(m)
get "/groups.json", params: { username: u.username }
expect(group_names).to contain_exactly("0_0", "0_1", "1_0", "1_1")
sign_in(m)
sign_in(o)
all_group_names = levels.product(levels).map { |a, b| "#{a}_#{b}" }
get "/groups.json", params: { type: type }
get "/groups/#{group.name}.json"
group.update!(bio_raw: "testing **group** bio")
get "/groups/#{group.name}.html"
get "/groups/#{group.name}/members.json", params: { limit: 1 }
4.times { group.add(Fabricate(:user)) }
get "/groups/#{group.name}/members.json", params: { limit: 3, asc: true }
get "/groups/#{group.name}/members.json", params: { limit: 3, offset: 3, asc: true }
get "/groups/#{group.name}/members.json", params: { order: "added_at" }
let!(:group) do
put "/groups/#{@group.id}.json",
group: {
put "/groups/#{group.id}.json",
title: "haha",
flair_bg_color: "FFF",
flair_color: "BBB",
bio_raw: "testing",
name: "testing",
put "/groups/#{group.id}.json", params: { group: { messageable_level: 1 } }
put "/groups/#{group.id}.json", params: { group: { flair_color: "BBB" } }
put "/groups/#{group.id}.json", params: { group: { name: "testing" } }
email: "b@test.org",
last_seen_at: Time.zone.now - 1.day,
email: "a@test.org",
fab!(:user3) { Fabricate(:user, last_seen_at: nil, last_posted_at: nil, email: "c@test.org") }
fab!(:bot) { Fabricate(:bot) }
get "/groups/#{group.name}/members.json", params: { order: "last_seen_at" }
get "/groups/#{group.name}/members.json", params: { order: "last_seen_at", asc: true }
get "/groups/#{group.name}/members.json", params: { order: "last_posted_at" }
get "/groups/#{group.name}/members.json", params: { order: "email" }
get "/groups/#{group.name}/members.json", params: { requesters: true }
get "/groups/#{group.name}/members.json", params: { filter: email }
}.each do |filter, ids|
get "/groups/#{group.name}/members.json", params: { filter: filter }
put "/groups/#{group.id}/members.json", params: { usernames: "bob" }
delete "/groups/#{group.id}/members.json", params: { username: "bob" }
put "/groups/#{group.id}/members.json", params: { usernames: "l77t" }
put "/groups/#{group.id}/members.json",
put "/groups/#{group.id}/members.json", params: { emails: "test@example.com" }
fab!(:user2) { Fabricate(:user, username: "UsEr2") }
it "adds by id" do
emails: emails.join(","),
{ usernames: "some thing" },
{ user_ids: "-5,-6" },
{ user_emails: "some@test.org" },
{ usernames: "", emails: "" },
put "/groups/#{group.id}/members.json", params: { emails: emails.join(",") }
put "/groups/#{group.id}/members.json", params: { emails: other_user.email }
put "/groups/#{group.id}/members.json", params: { emails: new_user.email }
put "/groups/#{group.id}/owners.json",
delete "/groups/#{group.id}/members.json", params: { user_id: 42 }
delete "/groups/#{group.id}/members.json", params: { user_id: -10 }
delete "/groups/#{group.id}/members.json", params: { user_id: -1 }
delete "/groups/#{group.id}/members.json", params: { user_id: user.id }
end.to change { group.users.count }.by(-1)
params: "{\"user_id\":#{user.id}}",
end.to change { group1.users.count }.by(-2)
params: "{\"user_ids\":#{user1.id}}",
end.to change { group1.users.count }.by(-1)
}.to change { Topic.count }.by(1).and change { Post.count }.by(1)
get "/groups/#{group.name}/logs.json",
filters: {
fab!(:new_user) { Fabricate(:user) }
expected_ids = Group::AUTO_GROUPS.map { |name, id| id }
get "/groups/check-name.json", params: { group_name: "test" }
before { sign_in(other_user) }
ssl: ssl,
let(:protocol) { "smtp" }
let(:username) { "test@gmail.com" }
let(:ssl) { true }
let(:host) { "smtp.somemailsite.com" }
let(:protocol) { "imap" }
let(:host) { "imap.somemailsite.com" }
let(:protocol) { "sigma" }
username: "",
get "/extra-locales/overrides", params: { v: "a" }
get "/extra-locales/admin", params: { v: "a" * 32 }
.with(any_of("en", "en_GB"))
after { I18n.reload! }
ctx.eval("I18n = {};")
:en,
:fr,
user = Fabricate(:user, locale: :fr)
{ "js.some_key" => "some key (fr)", "js.only_fr" => "only French" },
post "/export_csv/export_entity.json", params: { entity: "user_list" }
get "/404"
text: "#{I18n.t("page_not_found.page_title")} - #{SiteSetting.title}",
let(:api_key) { Fabricate(:api_key) }
get "/embed/info.json",
embed_url: "http://nope.com",
expect(response.body).to match("data-topic-id=\"#{topic.id}\"")
expect(response.body).to match("data-topic-id=\"#{good_topic.id}\"")
expect(response.body).not_to match("data-topic-id=\"#{topic.id}\"")
expect(response.body).to match("data-referer=\"\\*\"")
get "/embed/comments", params: { embed_url: embed_url }
target_id: 0,
type_id: 1,
value: ".test-osama-15 { color: red }",
get "/embed/comments", params: { embed_url: embed_url }, headers: { "REFERER" => embed_url }
type_id: 0,
value: "<strong class='custom-text'>hey there!</strong>\n",
post "/email/unsubscribe/#{key}.json", params: { unsubscribe_all: "1" }
post "/email/unsubscribe/#{key}.json", params: { disable_mailing_list: "1" }
post "/email/unsubscribe/#{key}.json", params: { digest_after_minutes: "0" }
fab!(:a_post) { Fabricate(:post) }
post "/email/unsubscribe/#{key}.json", params: { unwatch_topic: "1" }
post "/email/unsubscribe/#{key}.json", params: { mute_topic: "1" }
cu =
post "/email/unsubscribe/#{key}.json", params: { unwatch_category: "1" }
get "/email/unsubscribed", params: { key: key, topic_id: topic.id }
let(:post) { nil }
Draft.set(user, "xxx", 0, "{}")
Draft.clear(user, "xxx", 0)
Draft.set(topic_user, "topic_#{topic.id}", 0, "{}")
Draft.set(other_user, "topic_#{topic.id}", 0, "{}")
Draft.set(user, "hello", 0, "test")
post "/drafts.json", params: { draft_key: "xyz", data: { my: "data" }.to_json, sequence: 0 }
expect(Draft.get(user, "xyz", 0)).to eq(%q({"my":"data"}))
post "/drafts.json", params: { data: { my: "data" }.to_json, sequence: 0 }
post "/drafts.json",
draft_key: "topic",
data: { postId: post.id, originalText: post.raw, action: "edit" }.to_json,
data: { postId: post.id, originalText: "something else", action: "edit" }.to_json,
draft_key: "abc",
data: { a: "test" }.to_json,
data: { b: "test" }.to_json,
data: { c: "test" }.to_json,
owner: "abc",
Draft.set(user, "abc", seq, { b: "test" }.to_json)
sequence: seq - 1,
sequence: seq + 1,
let(:data) { "a" * (SiteSetting.max_draft_length + 1) }
draft_key: "xyz",
data: { reply: data }.to_json,
let(:data) { "not-proper-json" }
post "/drafts.json", params: { draft_key: "xyz", data: data, sequence: 0 }
Draft.set(user, "xxx", 0, "hi")
delete "/drafts/xxx.json", params: { sequence: 0 }
expect(Draft.get(user, "xxx", 0)).to eq(nil)
post "/do-not-disturb.json", params: { duration: 30 }
post "/do-not-disturb.json", params: { duration: -30 }
travel_to Time.new(2020, 11, 24, 01, 04, 44) do
post "/do-not-disturb.json", params: { duration: "tomorrow" }
Time.new(2020, 11, 24, 23, 59, 59).utc.to_i,
topic_id: 2,
fab!(:stage_user) { Fabricate(:staged, username: "stage_user") }
get "/directory_items.json", params: { period: "eviltrout" }
get "/directory_items.json", params: { period: "all" }
period: "all",
user_field_ids: "1|2",
get "/directory_items.json", params: { asc: true, order: "username", period: "all" }
get "/directory_items.json", params: { order: "username", period: "all" }
get "/directory_items.json", params: { period: "all", name: "eviltrout" }
get "/directory_items.json", params: { period: "all", name: "stage_user" }
get "/directory_items.json", params: { period: "all", group: group.name }
{ user: walter_white, field: field1, value: "Yellow", order: 1 },
{ user: stage_user, field: field1, value: "Apple", order: 0 },
{ user: evil_trout, field: field2, value: "Moon", order: 2 },
user_field_ids: "#{field1.id}|#{field2.id}",
get "/directory_items.json", params: { period: "all", group: "not a group" }
}.from(true).to(false)
post "/csp_reports",
referrer: "",
fab!(:post) { Fabricate(:post, topic: topic, post_number: 1, created_at: 10.years.ago) }
let(:args) do
{ "topic_id" => post.topic.id, "post_id" => "333", "composer_action" => "reply" }
fab!(:user_1) { Fabricate(:user, last_seen_at: 3.years.ago) }
fab!(:user_2) { Fabricate(:user, last_seen_at: 2.years.ago) }
fab!(:user_3) { Fabricate(:user, last_seen_at: 6.months.ago) }
fab!(:current_user) { Fabricate(:user) }
group.name => {
group.name => "not_allowed",
other_group.name => {
topic_id: -1,
let(:url) { "https://discourse.org/" }
let(:post_with_url) { create_post(raw: "this is a post with a link #{url}") }
let!(:category) { Fabricate(:category, user: admin) }
fab!(:tag) { Fabricate(:tag, name: "test-tag") }
fab!(:tag_2) { Fabricate(:tag, name: "second-test-tag") }
fab!(:topic1) do
fab!(:topic3) do
name: "hello",
color: "ff0",
text_color: "fff",
post "/categories.json", params: { name: "hello", color: "ff0", text_color: "fff" }
post "/categories.json", params: { color: "ff0", text_color: "fff" }
post "/categories.json", params: { name: category.name, color: "ff0", text_color: "fff" }
slug: "hello-cat",
get "/c/#{category.id}/show.json"
if c3.id < c2.id
tmp = c3
c2 = c3
c3 = tmp
payload = {}
name: "Email",
name: "new name",
field_1: "hello",
field_2: "hello",
expect(category.custom_fields).to eq({ "field_1" => "hello", "field_2" => "hello" })
field_1: nil,
expect(category.custom_fields).to eq({ "field_2" => "hello" })
field_1: "hi",
field_2: nil,
expect(category.custom_fields).to eq({ "field_1" => "hi" })
put "/category/#{category.id}/slug.json", params: { slug: "valid-slug" }
put "/category/#{category.id}/slug.json", params: { slug: " valid slug" }
put "/category/#{category.id}/slug.json", params: { slug: " another !_ slug @" }
put "/category/#{category.id}/slug.json", params: { slug: "." }
before { 10.times.each { Fabricate(:topic) } }
.dig("topic_list", "topics")
.detect { |t| t.dig("id") == private_topic.id }
user_only_group.name => :full,
let(:theme) { Fabricate(:theme, enabled: true) }
let(:bookmark_post) { Fabricate(:post) }
bm2 =
let(:bookmark_user) { Fabricate(:user) }
get "/badges/#{badge.id}.json"
get "/badges/#{badge.id}.rss"
let!(:grant) do
raw_info: {
get "#{uri.path}.json"
after { Rails.logger = @old_logger }
bad_str = (+"d\xDE").force_encoding("utf-8")
get "/latest.json", params: { test: bad_str }
puts ">> exception class: #{ex.class} : #{ex}"
expect(response.parsed_body).to eq("status" => 400, "error" => "Bad Request")
get "/search/query.json", params: { trem: "misspelled term" }
get "/t/#{topic.id}.json", xhr: true
get "/t/#{trashed_topic.slug}/#{trashed_topic.id}"
expect(response_body).to have_tag("input", with: { value: "nope nope" })
get "/", params: { preview_theme_id: theme2.id }
get "/", params: { preview_theme_id: non_selectable_theme.id }
get("/latest", headers: { "X-Forwarded-Host" => "test123.com" })
get("/latest")
before { admin }
{ auth_redirect: "http://no-good.com", user_api_public_key: "not-a-valid-public-key" }
.split(";")
.map do |policy|
.to_h
href: "http://test.localhost/",
get "/?query_param=true", headers: { HTTP_ACCEPT: "*/*" }
get "/latest?page=2&additional_param=true", headers: { HTTP_ACCEPT: "*/*" }
href: "http://test.localhost/t/#{topic.slug}/#{topic.id}",
get "/t/#{topic.slug}/#{topic.id}/2"
get "/t/#{topic.slug}/#{topic.id}/21"
get "/t/#{topic.slug}/#{topic.id}?page=2"
locale: "fr",
id: post1.id,
id: post2.id,
get "/search.json", params: { q: "hello\0hello" }
let(:user) { Fabricate(:user, locale: :fr) }
expect(response.body).to have_tag("script", with: { src: "/assets/locales/fr.js" })
get "/bootstrap.json", headers: headers("")
get "/bootstrap.json", headers: { Cookie: "locale=es" }
get "/bootstrap.json", headers: { Cookie: "locale=zh-CN" }
get "/bootstrap.json", headers: { Cookie: "" }
get "/latest", headers: { "Accept" => "application/json" }
get "/latest.json", headers: { "Api-Key": api_key, "Api-Username": admin.username }
get "/session/current.json", headers: { "User-Api-Key": user_api_key.key }
get "/", headers: { "HTTP_USER_AGENT" => "iam problematiccrawler" }
fab!(:p1) { Fabricate(:post, topic: banner_topic, raw: "A banner topic") }
get("/latest.json")
let(:"Api-Key") { Fabricate(:api_key).key }
let(:"Api-Username") { "system" }
path "/u/{username}.json" do
let(:params) { { "name" => "user" } }
let(:external_id) { "1" }
in: :path,
let(:provider) { "google_oauth2" }
let(:external_id) { "myuid" }
let(:upload) { Fabricate(:upload, user: user) }
let(:params) { { "upload_id" => upload.id, "type" => "uploaded" } }
let(:params) { { "email" => "test@example.com" } }
let(:params) { { "new_username" => "#{user.username}1" } }
in: :query,
schema: {
let(:period) { "weekly" }
let(:order) { "likes_received" }
let(:asc) { "true" }
let(:page) { 0 }
path "/admin/users/{id}.json" do
get "Get a user by id" do
tags "Users", "Admin"
let(:id) { Fabricate(:user).id }
let(:params) { { "suspend_until" => "2121-02-22", "reason" => "inactivity" } }
let(:params) {}
path "/admin/users/{id}/log_out.json" do
%r{https://www.gravatar.com/avatar/\w+.png\?d=404&reset_cache=\S+&s=360},
).to_return(status: 200, body: "", headers: {})
let(:flag) { "active" }
let(:order) { "created" }
let(:show_emails) { false }
let(:offset) { 0 }
let(:filter) { "4,5" }
let(:params) { { "login" => user.username } }
let(:params) { { "username" => user.username, "password" => "NH8QYbxYS5Zv5qEFzA4jULvM" } }
tags "Badges", "Users"
parameter name: :username, in: :path, schema: { type: :string }
{ "type" => "avatar", "user_id" => admin.id, "synchronous" => true, "file" => logo }
let!(:upload) { Fabricate(:upload) }
let(:params) { { "unique_identifier" => unique_identifier } }
2MB chunk, for part numbers 1, 2, and 3.
path "/t/{id}/posts.json" do
parameter name: :id, in: :path, schema: { type: :string }
in: :body,
type: :array,
items: {
created_at: {
cooked: {
post_type: {
updated_at: {
reads: {
score: {
yours: {
topic_id: {
topic_slug: {
flair_name: {
flair_url: {
can_edit: {
can_delete: {
can_wiki: {
read: {
user_title: {
can_act: {
admin: {
staff: {
user_id: {
hidden: {
deleted_at: {
wiki: {
let(:id) { Fabricate(:topic).id }
path "/t/{id}.json" do
let!(:post) { Fabricate(:post) }
let(:id) { post.topic.id }
path "/t/-/{id}.json" do
topic: {
title: {
slug: {
let(:post_body) { { title: "New topic title" } }
path "/t/{id}/invite.json" do
user: {
let(:request_body) { { user: username } }
path "/t/{id}/bookmark.json" do
path "/t/{id}/status.json" do
enabled: {
until: {
example: "2030-12-31",
success: {
example: "OK",
let(:request_body) { { status: "closed", enabled: "true" } }
name: :order,
users: {
topic_list: {
draft: {
draft_key: {
per_page: {
topics: {
image_url: {
bumped: {
bumped_at: {
unseen: {
pinned: {
visible: {
closed: {
liked: {
views: {
like_count: {
op_like_count: {
posters: {
extras: {
let(:order) { "default" }
let(:ascending) { "false" }
path "/top.json" do
description: "Enum: `all`, `yearly`, `quarterly`, `monthly`, `weekly`, `daily`",
for_period: {
let(:period) { "all" }
schema type: :object, properties: { success: { type: :string, example: "OK" } }
let(:request_body) { { notification_level: "3" } }
let(:request_body) { { timestamp: "1594291380" } }
path "/t/{id}/timer.json" do
time: {
example: "",
execute_at: {
let(:request_body) { { time: Time.current + 1.day, status_type: "close" } }
let!(:topic_post) { Fabricate(:post) }
let(:id) { topic_post.topic.id }
response "301", "redirects to /t/{topic_id}.json" do
let(:topic) { Fabricate(:topic, external_id: "external_id_1") }
let!(:tag) { Fabricate(:tag, name: "foo") }
response "200", "tags" do
tag_groups: {
tag_names: {
one_per_topic: {
let(:params) { { "name" => "todo" } }
path "/tag_groups/{id}.json" do
tag_group: {
let(:id) { tag_group.id }
let(:put_body) { { name: "todo2" } }
path "/tags.json" do
tags: {
text: {
count: {
pm_count: {
target_tag: {
path "/tag/{name}.json" do
parameter name: :name, in: :path, schema: { type: :string }
let(:name) { tag.name }
path "/site.json" do
name: :q,
description: <<~MD,
- `before:`: `yyyy-mm-dd`
- `after:`: `yyyy-mm-dd`
- `order:`: `latest`, `likes`, `views`, `latest_topic`
- `assigned:`: username (without `@`)
- `with:`: `images`
- `status:`: `open`, `closed`, `public`, `archived`, `noreplies`, `single_user`, `solved`, `unsolved`
- `group:`: group_name or group_id
- `min_posts:`: 1
- `max_posts:`: 10
- `min_views:`: 1
- `max_views:`: 10
curl -i -sS -X GET -G "http://localhost:4200/search.json" \\
let(:q) { "awesome post" }
let(:page) { 1 }
JSON.parse(File.read(File.join(__dir__, "json", "#{@filename}.json")))
raw: {
let(:params) { Fabricate(:post) }
path "/posts/{id}.json" do
let(:id) { Fabricate(:post).id }
let(:post_body) { { post: { raw: "Updated content!", edit_reason: "fixed typo" } } }
parameter name: :id, in: :path, schema: { type: :integer }
let(:post) { Fabricate(:post, topic_id: topic.id, post_number: 3) }
let(:id) { post.id }
let(:params) { { "force_destroy" => false } }
fab!(:post) { Fabricate(:post, topic: topic, user: user) }
let!(:reply) do
let!(:id) { post.id }
path "/posts/{id}/locked.json" do
locked: {
schema type: :object, properties: { locked: { type: :boolean } }
let(:post_body) { { locked: "true" } }
flag_topic: {
acted: {
can_undo: {
notice: {
let(:post_body) { { id: id, post_action_type_id: 2 } }
badge_id: {
badge_name: {
badge_slug: {
schema type: :object, properties: { success: { type: :string } }
skip_email: {
group_id: {
expires_at: {
link: {
emailed: {
groups: {
expired: {
let(:request_body) { { email: "not-a-user-yet@example.com" } }
let(:params) { { "group" => { "name" => "awesome" } } }
path "/admin/groups/{id}.json" do
parameter name: :id, in: :path, type: :integer
let(:id) { Fabricate(:group).id }
path "/groups/{id}.json" do
get "Get a group" do
example: "name",
let(:id) { Fabricate(:group).name }
let(:usernames) { "#{user.username},#{user2.username}" }
let(:params) { { "usernames" => usernames } }
let(:id) { category.id }
path "/c/{slug}/{id}.json" do
parameter name: :slug, in: :path, schema: { type: :string }
let(:slug) { category.slug_path.join("/") }
path "/c/{id}/show.json" do
let(:params) { { "name" => "badge1", "badge_type_id" => 2 } }
path "/admin/badges/{id}.json" do
let(:id) { badge.id }
let(:backup_filename) { "2021-02-10-065935.tar.gz" }
let(:backup_filename2) { "2021-02-11-065935.tar.gz" }
@paths =
File.open(path, "w") { |f| f.write("test backup") }
@paths&.each { |path| File.delete(path) if File.exist?(path) }
@paths = nil
let(:params) { { "with_uploads" => false } }
fab!(:web_hook) { Fabricate(:web_hook) }
web_hook: {
put "/admin/api/web_hooks/#{web_hook.id}.json",
payload_url: "https://test.com",
delete "/admin/api/web_hooks/#{web_hook.id}.json",
WebHookEvent.create!(web_hook: web_hook, payload: "abc", headers: JSON.dump(aa: "1", bb: "2"))
body: "abc",
body: "efg",
{ "content-type" => "application/json", "yoo" => "man" },
post "/admin/customize/watched_words.json", params: { action_key: "flag", word: "Fr33" }
post "/admin/customize/watched_words.json", params: { action_key: "flag", word: "Deals" }
action_key: "flag",
Fabricate(:tag, name: "tag1")
Fabricate(:tag, name: "tag2")
Fabricate(:tag, name: "tag3")
action_key: "tag",
tag_words = response.body.split("\n").map(&:parse_csv)
get "/admin/users/list.json", params: { show_emails: "true" }
expect do get "/admin/users/list.json", params: { show_emails: "true" } end.to change {
get "/admin/users/list.json", params: { show_emails: "true", order: "email" }
get "/admin/users/#{user.id}.json"
Fabricate(:user, ip_address: "88.88.88.88")
fab!(:created_post) { Fabricate(:post) }
put "/admin/users/#{user.id}/suspend.json",
put "/admin/users/#{user.id}/suspend.json", params: {}
raw: "this is the reply text",
fab!(:another_admin) { Fabricate(:admin) }
token = (token == 999_999 ? token - 1 : token + 1).to_s
post "/admin/users/#{user.id}/groups.json", params: { group_id: group.id }
put "/admin/users/#{user.id}/groups.json", params: { group_id: group.id }
delete "/admin/users/#{user.id}/groups/#{group.id}.json"
put "/admin/users/#{another_user.id}/trust_level.json", params: { level: 2 }
let(:acting_user) { admin }
) { put "/admin/users/#{another_user.id}/grant_moderation.json" }
fab!(:another_group) { Fabricate(:group, title: "New") }
put "/admin/users/#{another_user.id}/primary_group.json", params: { primary_group_id: "" }
fab!(:delete_me) { Fabricate(:user) }
let(:topic) { Fabricate(:topic, user: delete_me) }
let!(:post) { Fabricate(:post, topic: topic, user: delete_me) }
delete "/admin/users/#{delete_me.id}.json", params: { delete_posts: true }
status: 4,
delete "/admin/users/#{delete_me.id}.json",
delete "/admin/users/#{delete_me.id}.json", params: { block_email: true }
delete "/admin/users/#{delete_me.id}.json", params: { block_email: false }
delete "/admin/users/#{delete_me.id}.json", params: { block_ip: true }
delete "/admin/users/#{delete_me.id}.json", params: { block_ip: false }
@urls =
.pluck(:url)
fab!(:reg_user) { Fabricate(:inactive_user) }
fab!(:reg_user) { Fabricate(:active_user) }
fab!(:reg_user) { Fabricate(:user) }
post_action: "edit",
log =
put "/admin/users/#{user.id}/silence.json",
fab!(:reg_user) { Fabricate(:user, silenced_till: 10.years.from_now) }
ip = "81.2.69.142"
get "/admin/users/ip-info.json", params: { ip: ip }
country_code: "GB",
user_a = Fabricate(:user, ip_address: "42.42.42.42")
user_b = Fabricate(:user, ip_address: "42.42.42.42")
ip: "42.42.42.42",
exclude: -1,
let(:sso_secret) { "sso secret" }
sso.name = "Bob The Bob"
sso.external_id = "1"
user =
sso.name = "Bill"
sso.username = "Hokli$$!!"
sso.email = "bob2@bob.com"
sso.name = "Dr. Claw"
sso.email = "dr@claw.com"
sso.external_id = "2"
user = User.find_by_email("dr@claw.com")
sso.email = ""
sso.name = ""
sso.external_id = ""
fab!(:first_post) { Fabricate(:post, topic: topic, user: user) }
fab!(:sso_record) do
last_payload: "",
user_field: {
field_type: "text",
}.to change(UserField, :count).by(1)
}.to change(UserField, :count).by(-1)
name: "fraggle",
let! :repo do
setup_git_repo("about.json" => { name: "discourse-branch-header" }.to_json)
let(:file) { file_from_fixtures("fake.woff2", "woff2") }
theme.set_field(target: :common, name: :scss, value: ".body{color: black;}")
theme.set_field(target: :desktop, name: :after_header, value: "<b>test</b>")
value: 'console.log("test");',
end.to change { Theme.count }.by (1)
let(:image) { file_from_fixtures("logo.png") }
}.by (0)
}.by (1)
end.to change { Theme.count }.by (0)
remote_version: "7",
local_version: "8",
theme: {
name: "my test name",
put "/admin/themes/#{theme.id}.json", params: { id: theme.id, theme: { default: true } }
put "/admin/themes/#{theme.id}.json", params: { theme: { default: false } }
put "/admin/themes/#{theme.id}.json",
{ name: "scss", target: "common", value: "" },
{ name: "scss", target: "desktop", value: "body{color: blue;}" },
{ name: "bob", target: "common", value: "", type_id: 2, upload_id: upload.id },
{ name: "scss", target: "desktop", value: ".ember-view{color: blue;}" },
{ name: "scss", target: "desktop", value: "#ember392{color: blue;}" },
{ name: "header", target: "common", value: "filename.jpg", upload_id: 4 },
r = RemoteTheme.create!(remote_url: "")
put "/admin/themes/#{child_theme.id}.json",
name: :en,
value: { en: { somegroup: { somestring: "defaultstring" } } }.deep_stringify_keys.to_yaml,
remote_version: "a",
local_version: "a",
put "/admin/themes/#{theme.id}.json", params: { theme: { remote_check: true } }
put "/admin/themes/#{child.id}.json", params: { theme: { enabled: false } }
).size,
put "/admin/themes/#{child.id}.json", params: { theme: { enabled: true } }
put "/admin/themes/#{theme.id}.json", params: { theme: { remote_update: true } }
put "/admin/themes/#{theme.id}.json", params: { theme: { default: true } }
put "/admin/themes/#{theme.id}.json", params: { theme: { component: true } }
value: '<script>console.log("test")</script>',
let(:theme) { Fabricate(:theme) }
theme.set_field(target: :settings, name: :yaml, value: "bg: red")
put "/admin/themes/#{theme.id}/setting.json", params: { name: "bg", value: "green" }
put "/admin/themes/#{theme.id}/setting.json", params: { name: "bg" }
.upto(4)
.each do |idx|
get "/admin/logs/staff_action_logs.json", params: { limit: 3 }
get "/admin/logs/staff_action_logs.json", params: { limit: 3, page: 1 }
theme.set_field(target: :mobile, name: :scss, value: "body {.up}")
theme.set_field(target: :mobile, name: :scss, value: "body {.down}")
get "/admin/customize/site_texts.json", params: { q: "e", locale: default_locale }
get "/admin/customize/site_texts.json", params: { q: "e", page: 1, locale: default_locale }
get "/admin/customize/site_texts.json", params: { q: "yes_value", locale: "de" }
expect(value).to eq(I18n.t("js.yes_value", locale: :de))
get "/admin/customize/site_texts.json", params: { locale: "?" }
site_text: {
%q|"That's a 'magic' sock."|,
include("id" => "title", "value" => value),
include("id" => "embed.loading", "value" => value),
locale: :ru,
value: "foo",
locale: "en_GB",
colour: {
one: "%{count} colour",
other: "%{count} colours",
get "/admin/customize/site_texts.json", params: { q: "colour", locale: locale }
id: "colour.#{key}",
let(:locale) { :en }
let(:expected_translations) { { one: "%{count} colour", other: "%{count} colours" } }
let(:locale) { :ru }
few: "%{count} colours",
many: "%{count} colours",
:ru,
let(:expected_overridden) { { one: true, few: true } }
key = "js.topic.list"
id = "colour.#{key}"
get "/admin/customize/site_texts/#{id}.json", params: { locale: locale }
{ one: "%{count} colour", few: "%{count} colours", other: "%{count} colours" }
value: "hello %{key} %{omg}",
keys: "key, omg",
count: 2,
value: "yay",
value: "hello",
locale = :ru
ru_title = "title ru"
ru_mf_text = "ru {NUM_RESULTS, plural, one {1 result} other {many} }"
en_locale = :en
let(:badge) { Badge.find(Badge::Regular) }
{ id: "staff_category_id", name: "Staff EN", selected: true },
I18n.t("staff_category_name", locale: :de),
fab!(:staged_user) { Fabricate(:staged) }
default_sidebar_tags: "#{tag.name}",
let!(:user1) { Fabricate(:user) }
new_value: "tag1|tag2",
new_value: "1|2",
previous_value: "3|4",
let(:category_ids) { 3.times.collect { Fabricate(:category).id } }
).to eq(User.real.where(staged: false).count - 1)
}.not_to change {
let(:tags) { 3.times.collect { Fabricate(:tag) } }
default_tags_watching: tags.last(2).pluck(:name).join("|"),
before { SearchLog.log(term: "ruby", search_type: :header, ip_address: "127.0.0.1") }
get "/admin/logs/search_logs/term.json", params: { term: "ruby" }
get "/admin/logs/screened_ip_addresses.json", params: { filter: "1.2.*" }
get "/admin/logs/screened_ip_addresses.json", params: { filter: "4.5.6.7" }
get "/admin/logs/screened_ip_addresses.json", params: { filter: "5.0.0.1" }
get "/admin/logs/screened_ip_addresses.json", params: { filter: "6.0.0.1" }
put "/admin/customize/robots.json", params: { robots_txt: "" }
reports: {
limit: 10,
likes: {
not_found: {
start_date: "2015-0-1",
end_date: "2015-0-1",
let(:invalid_id) { "!!&asdfasdf" }
get "/admin/permalinks.json", params: { filter: "topic" }
url: "/topics/771",
url: "topics/771",
post_id: nil,
tag_id: nil,
url: "/topics/771/8291",
url: "topics/771/8291",
url: "/forums/11",
url: "forums/11",
url: "/forums/12",
url: "forums/12",
delete "/admin/groups/#{group.id}/owners.json", params: { user_id: user.id }
primary: "true",
max_id = Group.maximum(:id).to_i
delete "/admin/groups/#{max_id + 1}.json"
id: group.id,
name: "Bug Reports",
template: "- type: checkbox",
}.to change(FormTemplate, :count).by(-1)
group: "Foo",
name: "test.png",
name: "st&#* onk$",
post "/admin/embeddable_hosts.json", params: { embeddable_host: { host: "test.com" } }
host: "test.com",
new_value: "category_id: #{category.id}, host: test.com",
).exists?
let(:headers) { { ACCEPT: "application/json" } }
subject: "Foo",
body: "Bar",
let(:email_subject) { "%{email_wrongfix} Foo" }
}",
keys: "invalid",
let(:email_subject) { "%{email_prefix} Foo" }
body: "Lorem ipsum",
body: "Body",
let(:default_css) { "" }
{ html: "For you: %{email_content}", css: ".user-name { color: purple; }" }
fab!(:email_log) { Fabricate(:email_log) }
fab!(:email_log) { Fabricate(:email_log, post: post) }
get "/admin/email/sent.json", params: { reply_key: reply_key }
fab!(:eviltrout) { Fabricate(:evil_trout) }
mail: email("cc"),
) { post "/admin/email/handle_mail.json", params: { email: email("cc") } }
Date: Mon, 3 Dec 2018 00:00:00 -0000
it "should ..." do
name: "Such Design",
updated_colors = existing.colors.map { |color| { name: color.name, hex: color.hex } }
fab!(:user) { Fabricate(:user, email: "user1@test.com", username: "username1") }
names = groupings.map { |g| g.name }
ids = groupings.map { |g| g.id.to_s }
expect(groupings2.map { |g| g.name }).to eq(names)
expect((groupings.map(&:id) - groupings2.map { |g| g.id }).compact).to be_blank
put "/admin/badges/#{editor_badge.id}.json", params: { name: "123456" }
put "/admin/badges/#{badge.id}.json",
name: "123456",
icon: "fa-rocket",
fab!(:badge) { Fabricate(:badge, name: "Oathbreaker", allow_title: true) }
) { put "/admin/badges/#{badge.id}.json", params: { name: "Shieldbearer" } }
post "/admin/badges/award/#{badge.id}.json", params: { file: "" }
csv.write("#{user.username}\n" * 11)
csv.write(content.join("\n"))
csv.write(csv_content.join("\n"))
let(:backup_filename) { "2014-02-10-065935.tar.gz" }
let(:backup_filename2) { "2014-02-11-065935.tar.gz" }
{ publish_to_message_bus: true, with_uploads: false, client_id: "foo" },
post "/admin/backups.json", params: { with_uploads: false, client_id: "foo" }
get "/admin/backups/#{backup_filename}.json", params: { token: token }
get "/admin/backups/#{backup_filename}.json", params: { token: "bad_value" }
post "/admin/backups/#{backup_filename}/restore.json", params: { client_id: "foo" }
expect { put "/admin/backups/readonly.json", params: { enable: true } }.to change {
new_value: "t",
expect { put "/admin/backups/readonly.json", params: { enable: false } }.to change {
new_value: "f",
chunks: 1,
chunks: 2,
chunks: 3,
let(:upload_type) { "backup" }
let(:backup_file_exists_response) { { status: 404 } }
file_name: "test.tar.gz",
let(:backup_file_exists_response) { { status: 200, body: "" } }
file_name: "blah $$##.tar.gz",
fab!(:key1, refind: false) { Fabricate(:api_key, description: "my key") }
fab!(:key2, refind: false) { Fabricate(:api_key, user: admin) }
fab!(:key3, refind: false) { Fabricate(:api_key, user: admin) }
get "/admin/api/keys/#{key1.id}.json"
put "/admin/api/keys/#{key1.id}.json",
key: {
put "/admin/api/keys/#{key1.id}.json", params: { key: "string not a hash" }
put "/admin/api/keys/#{key1.id}.json", params: {}
delete "/admin/api/keys/#{key1.id}.json"
post "/admin/api/keys.json", params: { key: { description: "master key description" } }
scope = ApiKeyScope.find_by(api_key_id: data.dig("key", "id"))
get "/admin.json",
get "/about"
add_group "Libraries", %r{^/lib/(?!tasks).*$}
add_group "Tasks", "lib/tasks"
@ex
def initialize(app, config = {})
require File.expand_path("../../config/environment", __FILE__)
def fab!(name, &blk)
let!(name, &blk)
.new(logging_prefs: { "browser" => browser_log_level, "driver" => "ALL" })
.new(logging_prefs: { "browser" => "INFO", "driver" => "ALL" })
driven_by driver.join("_").to_sym
lines << "~~~~~~~ JS LOGS ~~~~~~~"
lines << "(no logs)"
logs.each { |log| lines << log.message }
def log_on_user(user, session, cookies, opts = {})
time = now
if Time === now
swap1 = 0
data = { token: token, user_id: user_id, trust_level: trust_level, issued_at: issued_at.to_i }
{ _t: cookie },
:_t
before(:each) { setup_s3 }
let(:s3_client) { Aws::S3::Client.new(stub_responses: true) }
acl: "public-read",
let(:original_filename) { "small.pdf" }
let(:uploaded_file) { file_from_fixtures("small.pdf", "pdf") }
disp_opts = {
let(:original_filename) { "small.mp4" }
let(:uploaded_file) { file_from_fixtures("small.mp4", "media") }
let(:original_filename) { "small.mp3" }
let(:uploaded_file) { file_from_fixtures("small.mp3", "media") }
let(:upload) { build_upload }
let(:upload_key) { "#{upload_path}/original/1X/#{upload.sha1}.png" }
let(:client) { Aws::S3::Client.new(stub_responses: true) }
let(:resource) { Aws::S3::Resource.new(client: client) }
let(:s3_helper) { store.s3_helper }
let(:s3_object) { stub }
.with("#{upload_path}/original/1X/#{upload.sha1}.pdf")
link = "mailto: roman;@test.com"
called = { default: 0, second: 0 }
status, =
let(:upload3) { Fabricate(:upload_s3) }
post.each_upload_url { |src, _, _| urls << src.sub("http:", "") }
describe "#pause!, #unpause! and #paused?" do
) { yield }
let(:cache1) { cache("test", namespace: false) }
expect(cache1.hash).to eq("default" => true, "second" => true)
fab!(:post_hook) { Fabricate(:web_hook, payload_url: " https://example.com ") }
payload = { test: "some payload" }.to_json
let(:post) { Fabricate(:post, topic: topic, user: user) }
{ category_id: category.id },
{ category_id: Category.last.id, raw: "#{post.raw} new" },
raw: "post",
fab!(:another_user) { Fabricate(:user, trust_level: 2) }
fab!(:like_web_hook) { Fabricate(:like_web_hook) }
like =
fab!(:post_hook) { Fabricate(:web_hook, payload_url: "https://example.com") }
.with { |h| h == "badhostname.com" }
.with { |h| h == "goodhostname.com" }
expect(described_class.create(word: "a**les").word).to eq("a*les")
let(:w) { WatchedWord.new(word: "troll") }
w.action_key = k
w.action_key = k.to_s
w.action_key = "shame"
}.to change { described_class.count }.by(1)
w =
word: "meta2",
word: "meta3",
word: "joker",
let(:word) { existing_word.word }
let(:word) { "metA" }
expect_invalid("a", "ab", "abc", error_message: I18n.t(:"user.username.short", min: 4))
expect_invalid("abc|", "a#bc", "abc xyz", error_message: I18n.t(:"user.username.characters"))
expect_valid("abcd", "1abc", "_abc")
expect_valid("abcd", "abc9")
error_message: I18n.t(:"user.username.long", max: 8),
expect_valid("a-z_A-Z.0-9")
{ 1.day.ago.to_date => 2, 2.days.ago.to_date => 1, Time.zone.now.to_date => 1 }
t = Fabricate(:topic, category: c, user: u)
Fabricate(:post, user: u, topic: t)
let(:stat) { user.user_stat }
let!(:view) { TopicViewItem.add(topic.id, "127.0.0.1", user.id) }
user_2.id,
user_3.id,
user_5.id,
user_6.id,
expect(ttl).to be > 0
fab!(:badge1) { Fabricate(:badge) }
fab!(:badge2) { Fabricate(:badge) }
Draft.create!(user: user, draft_key: "topic_1", data: {})
Draft.create!(user: user, draft_key: "new_topic", data: {})
Draft.create!(user: user, draft_key: "topic_2", data: {})
{ pending_posts_count: 1 },
subject(:user) { Fabricate(:user, last_seen_at: 1.day.ago) }
category.permissions = { "staff" => :full }
fab!(:hidden_tag) { Fabricate(:tag) }
user = Fabricate(:user, id: -Time.now.to_i)
user.name = "x" * (User.max_password_length + 1)
fab!(:watched_word) { Fabricate(:watched_word, word: "bad") }
let(:value) { "bad user field value" }
it { is_expected.to be_valid }
let(:value) { "censored word" }
let(:value) { "word to replace" }
let(:value) { "don't replace me" }
word: "replace",
let(:value) { "good user field value" }
let(:value) { "https://discourse.org" }
{ 1.day.ago.to_date => 2, 2.days.ago.to_date => 1, Time.now.utc.to_date => 1 }
4.days.ago.to_date => 1,
fab!(:first_admin) { Fabricate(:admin) }
let(:user) { Fabricate(:user, active: false) }
fab!(:post1) { Fabricate(:post) }
fab!(:user) { post1.user }
fab!(:post2) { Fabricate(:post, topic: post1.topic, user: user) }
fab!(:post3) { Fabricate(:post, user: user) }
posts.each { |p| expect(Topic.find_by(id: p.topic_id)).to be_nil if p.is_first_post? }
.with(u, :ip_address, u.ip_address)
u.ip_address = "87.123.23.11"
subject { user.staff? }
it { is_expected.to eq(true) }
before { user.admin = true }
before_all { @user = Fabricate(:user) }
email: "sam@sam.com",
it "allows #{username}" do
user = Fabricate(:user, email: "bar@foo.com")
Fabricate(:group, name: "foo")
u = Fabricate(:user, email: "good@gmail.com")
let!(:first_visit_date) { Time.zone.now }
let!(:second_visit_date) { 2.hours.from_now }
let!(:third_visit_date) { 5.hours.from_now }
let(:timezone) { "Jupiter" }
raw: "this post has a link: http://discourse.org",
raw: "this post has no links in it.",
expect(Fabricate(:user, username: "foo", name: "foo").readable_name).to eq("foo")
def test_user?(opts = {})
{ created_at: Time.zone.now }.merge(opts),
let!(:topic) { Fabricate(:post).topic }
let!(:post) { Fabricate(:post, topic: topic, user: user) }
fab!(:user) { Fabricate(:user, email: "bob@example.com") }
let(:user) { build(:user, username: "Sam") }
let(:user) { build(:user, uploaded_avatar_id: 99, username: "Sam") }
let!(:now) { Time.zone.now }
}.to change { UserVisit.count }.by(1)
group.usernames = ""
u = User.create!(username: "bob", email: "bob@bob.com")
expect(user.custom_fields).to eq("jack" => "jill")
let(:too_long) { "x" * (User.max_password_length + 1) }
expect(hash("poutine", "gravy")).to eq(hash("poutine", "gravy"))
expect(hash("poutine", "gravy")).not_to eq(hash("fries", "gravy"))
expect(hash("poutine", "gravy")).not_to eq(hash("poutine", "cheese"))
title: "bars and wats",
user = Fabricate(:user, active: true, email: "foo@bar.com")
user = Fabricate(:user, active: true, email: "sso@bar.com")
email: "foo@bar.com",
let!(:user0) { Fabricate(:user, staged: true) }
let!(:user0) { Fabricate(:user, silenced_till: 1.month.ago) }
let!(:user1) { Fabricate(:user, silenced_till: 1.month.from_now) }
let!(:user) do
name: "Stage Name",
let!(:inactive) { Fabricate(:user, active: false) }
expect { user.update(primary_group: group_b) }.to change { user.reload.title }.from("A").to(
).to(group_a)
).to(group_b)
fab!(:badge) { Fabricate(:badge, name: "Badge", allow_title: false) }
fab!(:group_a) { Fabricate(:group, title: "Group A") }
fab!(:group_b) { Fabricate(:group, title: "Group B") }
fab!(:group_c) { Fabricate(:group, title: "Group C") }
fab!(:badge) { Fabricate(:badge, name: "Badge", allow_title: true) }
let(:contact_user) { Fabricate(:admin) }
let(:user) { Fabricate(:user, username: "Lo\u0308we") } # NFD
let(:sec_ident) { SecureRandom.hex(20) }
fab!(:user) { Fabricate(:reviewable_user) }
let(:user) { Fabricate(:user, approved: false) }
) # Old, should be ignored
Discourse.redis.del("user:#{user.id}:#{Time.zone.now.to_date}")
}.to("127.0.0.1")
expect do user.update_ip_address!("0.0.0.0") end.to change {
starts_at: Time.zone.now - 2.day,
).tap { |n| n.topic.trash!(Fabricate(:admin)) }
expect(user.grouped_unread_notifications).to eq({ 1 => 2, 2 => 1 })
).id
fab!(:topic2) { Fabricate :topic }
fab!(:topic3) { Fabricate :topic }
fab!(:topic4) { Fabricate :topic }
fab!(:mr_b) do
fab!(:mr_blue) do
fab!(:mr_orange) do
fab!(:mr_pink) do
fab!(:mr_brown) do
fab!(:mr_white) do
fab!(:inactive) { Fabricate :user, username: "Ghost", active: false }
fab!(:admin) { Fabricate :admin, username: "theadmin" }
fab!(:staged) { Fabricate :staged }
fab!(:searching_user) { Fabricate(:user) }
sam = Fabricate(:user, username: "sam")
fab!(:post1) { Fabricate :post, user: mr_b, topic: topic }
fab!(:post2) { Fabricate :post, user: mr_blue, topic: topic2 }
fab!(:post3) { Fabricate :post, user: mr_orange, topic: topic }
fab!(:post4) { Fabricate :post, user: mr_pink, topic: topic }
fab!(:post5) { Fabricate :post, user: mr_brown, topic: topic3 }
fab!(:post6) { Fabricate :post, user: mr_white, topic: topic }
fab!(:post7) { Fabricate :post, user: staged, topic: topic4 }
results = search_for("mr")
results = search_for("", topic_id: topic2.id)
results = search_for("", topic_id: topic.id)
results = search_for("", topic_id: pm_topic.id, searching_user: mr_b)
results = search_for("z")
abc = Fabricate(:user, username: "abc", last_seen_at: 2.years.ago)
results = search_for("", topic_id: topic.id, searching_user: mr_b)
def add(user_profile_id, ip, user_id = nil, at = nil)
expect { add(user_profile_id, "1.1.1.1") }.to change { described_class.count }.by(1)
expect { add(user_profile_id, "1.1.1.1", other_user.id) }.to change {
add(user_profile_id, "1.1.1.1", nil, time)
let(:location) { "bad location" }
let(:location) { "word to replace" }
before { profile.location = "a" * 3500 }
before { profile.bio_raw = "bad bio" }
before { profile.bio_raw = "a" * 3500 }
expect(user_profile.bio_cooked).to eq("<p>test</p>")
let(:user_profile) { UserProfile.new(bio_raw: "test") }
user_profile.website = "a" * 3500
user.user_profile.bio_raw = "**turtle power!**"
fab!(:forum_user) { Fabricate(:user) }
fab!(:mailing_list_user) { Fabricate(:user) }
let(:custom_type) { "confirmed_ham" }
new_value: "New",
xss = "<b onmouseover=alert('Wufff!')>click me!</b><script>alert('TEST');</script>"
expect(user_field.description).to eq("<b>click me!</b>alert('TEST');")
link = "<a target=\"_blank\" href=\"/elsewhere\">elsewhere</a>"
file_name: "test",
file_name: "test2",
let(:params) { { per_page: 1000 } }
ub1 =
ub2 =
let(:temp) { Tempfile.new("test") }
fab!(:upload) { Fabricate(:upload, user: user) }
).to_return(status: 404, body: "", headers: {})
client_ip: "1.1.2.3",
expect(user_token.client_ip.to_s).to eq("1.1.2.3")
rotated = user_token.rotate!(user_agent: "a new user agent", client_ip: "1.1.2.4")
expect(user_token.client_ip).to eq("1.1.2.4")
token.rotate!(user_agent: "firefox", client_ip: "1.1.1.1")
client_ip: "1.2.3.3",
user_agent: "bob",
client_ip: "127.0.0.1",
path: "/path",
client_ip: "1.1.1.1",
let(:group2) { Fabricate(:group) }
expect(key.allow?(request_env("GET", "/random"))).to eq(false)
key.allow?(request_env("PUT", "/xyz", controller: "notifications", action: "mark_read")),
key.allow?(request_env("POST", "/xyz", controller: "user_api_keys", action: "revoke")),
expect(key.allow?(request_env("GET", "/random"))).to eq(true)
expect(key.allow?(request_env("PUT", "/random"))).to eq(true)
expect(key.allow?(request_env("PATCH", "/random"))).to eq(true)
expect(key.allow?(request_env("DELETE", "/random"))).to eq(true)
expect(key.allow?(request_env("POST", "/random"))).to eq(true)
expect(key.allow?(request_env("PUT", "/random"))).to eq(false)
fab!(:public_post) { Fabricate(:post) }
fab!(:private_post) { Fabricate(:post) }
def log_test_action(opts = {})
}.merge(opts),
m =
private_post.custom_fields ||= {}
let(:likee) { post.user }
fab!(:liker) { coding_horror }
target_topic_id: -1,
target_topic_id: -2,
let(:upload) { build(:upload) }
let(:user_id) { 1 }
let(:image_filename) { "logo.png" }
let(:image_svg_filename) { "image.svg" }
let(:huge_image_filename) { "huge.jpg" }
let(:attachment_path) { __FILE__ }
post = Fabricate(:post, raw: "<img src='#{post_upload.url}'>")
name: "logo",
expect(File.read(path)).to match(/<style>/)
let(:upload) { Fabricate(:upload, sha1: sha1) }
upload.update!(url: upload.url.sub(".png", ""))
).to eq(upload)
let(:path) { upload.url.sub(SiteSetting.Upload.s3_base_url, "") }
stub_request(:get, upload.url).to_return(status: 200, body: "hello", headers: {})
let(:s3_cdn_url) { "https://mycdn.slowly.net" }
cdn_url = "http://my.cdn.com"
url = upload.url.sub(".png", "")
expect(Upload.sha1_from_short_path(path.sub(".png", ""))).to eq(sha1)
upl =
url = "http://URL:%20https://google.com"
let(:white_image) { Fabricate(:image_upload, color: "white") }
let(:red_image) { Fabricate(:image_upload, color: "red") }
file << "Not really an image"
u.update!(dominant_color: "")
fab!(:upload1) { Fabricate(:upload) }
name: "field",
value: "",
user = nil
file_name: "export",
I18n.t("js.trust_levels.detailed_name", level: 0, name: "New Member"),
fab!(:topic4) { Fabricate(:topic) }
TopicViewItem.add(topic.id, "11.22.33.44", user_id, at, _skip_redis = true)
:flag,
let(:old_post) { create_post(created_at: 102.days.ago) }
let(:topic) { Fabricate(:topic, user: user, created_at: 102.days.ago) }
let(:old_post) { create_post(topic: topic, user: user, created_at: 102.days.ago) }
let(:liker) { Fabricate(:user) }
let(:liker2) { Fabricate(:user) }
one: "%{key1} %{key2}",
other: "%{key3} %{key4}",
TranslationOverride.upsert!(I18n.locale, "some_key", "%{key} %{omg}")
interpolation_key_names.map { |x| "%{#{x}}" }.join(" ")
keys: "key3, key4",
xss = "<a target='blank' href='%{path}'>Click here</a> <script>alert('TEST');</script>"
ovr =
expect(ovr.value).to eq("<a href=\"%{path}\">Click here</a> alert('TEST');")
original_en_topics = I18n.t("topics", locale: :en)
original_de_likes = I18n.t("likes", locale: :de)
locale: "de",
expect(I18n.t("topics", locale: :en)).to eq("Threads")
expect(I18n.t("js.composer.emoji", locale: :en)).to eq("Smilies")
def add(topic_id, ip, user_id = nil)
add(2, "1.1.1.1")
add(2, "1.1.1.1", 1)
TopicViewItem.create!(topic_id: 1, ip_address: "1.1.1.1", viewed_at: 1.day.ago)
add(1, "1.1.1.1")
add(1, "1.1.1.1", user.id)
add(topic.id, "1.1.1.1", user.id)
add(topic.id, "1.2.3.4", nil)
blk = Proc.new { called = true }
before { TopicUser.update_last_read(new_user, topic.id, 2, 2, 0) }
WHERE topic_id = :topic_id AND user_id = :user_id",
}.to change(TopicUser, :count).by(1)
it "has a lookup" do
user_id: 1,
user_id: 2,
user_id: 3,
p2 = Fabricate(:post, user: p1.user, topic: p1.topic, post_number: 2)
user_id: p1.user_id,
user_id: p.user_id,
called = 0
user_first_visit = ->(topic_id, user_id) {
visits << "#{topic_id}-#{user_id}"
called += 1
raw: "this is a test post",
let(:user) { Fabricate(:user, last_seen_at: Date.today) }
let(:post) { create_post(user: user) }
let(:third_user) { Fabricate(:user, last_seen_at: Date.today) }
let(:read_post_key) { "/topic/#{group_message.id}" }
let!(:post) { Fabricate(:post, topic: group_message) }
let!(:post_2) { Fabricate(:post, topic: group_message) }
tag_id: tag1.id,
tracking = {
fab!(:topic_timer) { Fabricate(:topic_timer) }
fab!(:topic) { Fabricate(:topic, closed: false) }
fab!(:topic) { Fabricate(:topic, closed: true) }
it "is true for #{public_type}" do
it "is false for #{private_type}" do
let(:upload1) { Fabricate(:image_upload, width: 50, height: 50) }
let(:upload2) { Fabricate(:image_upload, width: 50, height: 50) }
let(:topic_tag) { Fabricate(:topic_tag, topic: topic, tag: tag) }
expect { topic_tag }.to change { tag.reload.pm_topic_count }.by(1)
expect { topic_tag.destroy! }.to change { tag.reload.pm_topic_count }.by(-1)
let(:now) { Time.zone.local(2013, 11, 20, 8, 0) }
fab!(:trust_level_2) do
let(:topic) { Fabricate.build(:topic) }
topic.external_id = "a*&^!@()#"
topic.external_id = ""
topic.title = "The cake is a lie"
topic.title = "I have a co(onut a**le"
let(:types) { Post.types }
let!(:title) { "hello world topic" }
let!(:slug) { "hello-world-topic" }
let!(:topic) { Fabricate.build(:topic, title: title) }
expect(topic.slug).to eq("%E7%86%B1%E5%B8%B6%E9%A2%A8%E6%9A%B4%E7%95%AB%E7%9C%89")
let!(:title) { "123456789" }
let!(:slug) { "topic" }
invert_slug = ->(topic, slug, title) { slug.reverse }
let!(:title) { "hello test topic" }
let!(:slug) { "hello-test-topic".reverse }
let!(:other_title) { "other title" }
let!(:other_slug) { "other-title".reverse }
let!(:topic) { Fabricate(:topic) }
build(:topic, title: title).tap { |t| t.valid? }
let(:topic_bold) { build_topic_with_title("Topic with <b>bold</b> text in its title") }
let(:topic_shortcut_emoji) { build_topic_with_title("I love candy :)") }
let(:topic) { Fabricate.build(:topic, title: %{"this topic" -- has ``fancy stuff''}) }
expect(topic.fancy_title).to eq("&quot;this topic&quot; -- has ``fancy stuff&#39;&#39;")
topic.title = "this is my test hello world... yay"
).to be_blank
let!(:p1) { Fabricate(:post, topic: topic, user: topic.user) }
let!(:p2) { Fabricate(:post, topic: topic, user: topic.user) }
let!(:p3) { Fabricate(:post, topic: topic, user: topic.user) }
fab!(:user) { trust_level_2 }
fab!(:inviter) { Fabricate(:user).tap { |user| group.add_owner(user) } }
.new(
raw: "This is my message to you-ou-ou",
.find_by(user_id: user.id)
let!(:topic) { Fabricate(:topic, bumped_at: 1.year.ago) }
}.to change(topic, :bumped_at)
{ raw: @last_post.raw + "a" },
mod_post =
fab!(:post) { Fabricate(:post).tap { |p| p.topic.update!(bumped_at: 1.hour.ago) } }
}.from(1).to(0)
}.from(0).to(1)
let(:status) { "closed" }
let(:status) { "autoclosed" }
freeze_time(Time.new(2000, 1, 1))
fab!(:user) { topic.user }
let(:banner) { { html: "<p>BANNER</p>", url: topic.url, key: topic.id } }
@user = @post.user
@topic = @post.topic
}.to change(@category, :topic_count).by(1)
fab!(:topic) { Fabricate(:topic, meta_data: { "hello" => "world" }) }
before { topic.update_meta_data("hello" => "bane") }
before { topic.update_meta_data("city" => "gotham") }
topic.update_meta_data("other" => "key")
let(:post) { Fabricate(:post, topic: topic, user: topic.user) }
a = Fabricate(:topic, user: user, created_at: now - 2.minutes)
b = Fabricate(:topic, user: user, created_at: now)
c = Fabricate(:topic, user: user, created_at: now)
d = Fabricate(:topic, user: user, created_at: now - 2.minutes)
b = Fabricate(:topic, user: user, created_at: now - 1.minute)
d = Fabricate(:topic, user: user, created_at: now + 1.minute)
e = Fabricate(:topic, user: user, created_at: now + 2.minutes)
3.times { |i| topics << Fabricate(:topic, created_at: 1.minute.ago) }
fab!(:allowed_group_user) { Fabricate(:user) }
fab!(:rando) { Fabricate(:user) }
expect(topic.custom_fields).to eq("bob" => "marley", "jack" => "black")
t =
_post1 =
fab!(:robot) { Fabricate(:bot) }
let!(:topic) { post.topic }
fab!(:topic) { Fabricate(:topic, user: user1) }
fab!(:post1) { Fabricate(:post, topic: topic, user: user1) }
fab!(:post2) { Fabricate(:post, topic: topic, user: user2) }
fab!(:like1) { Fabricate(:like, post: post1, user: user2) }
it { is_expected.not_to be_a_group_pm }
it { is_expected.to be_a_group_pm }
let!(:topic_creator) { Fabricate(:user) }
let!(:topic) { Fabricate(:topic, user: topic_creator) }
fab!(:featured_user1) { Fabricate(:user) }
let!(:topic) do
let!(:last_poster) { Fabricate(:user) }
fab!(:featured_user2) { Fabricate(:user) }
fab!(:featured_user3) { Fabricate(:user) }
fab!(:featured_user4) { Fabricate(:user) }
fab!(:topic_creator) { Fabricate(:user) }
fab!(:user4) { Fabricate(:user) }
fab!(:user5) { Fabricate(:user) }
fab!(:user6) { Fabricate(:user) }
let(:user) { topic.user }
list =
fab!(:topic) { Fabricate(:topic, title: "unique topic name") }
ftl = TopicLink.new(url: "/t/#{topic.id}", topic_id: topic.id, link_topic_id: topic.id)
non_png = "https://b.com/#{SecureRandom.hex}"
body: "<html><head><title>amazing</title></head></html>",
png = "https://awesome.com/#{png_title}"
post = Fabricate(:post, raw: <<~RAW, user: user, topic: topic)
http://a.com/
http://#{"a" * 200}.com/invalid
//b.com/#{"a" * 500}
raw: "Link to another topic:\n\n#{url}\n\n#{invalid_url}",
fab!(:other_topic) { Fabricate(:topic, user: user) }
let(:post) { Fabricate(:post, topic: other_topic, user: user, raw: "some content") }
url = "http://#{test_uri.host}/t/#{other_topic.slug}/#{other_topic.id}"
Fabricate(:post, topic: topic, user: user, raw: "Link to another topic: #{url}")
url = "http://#{test_uri.host}/t/#{other_topic.slug}"
other_topic_url = "http://#{test_uri.host}/t/#{other_topic.slug}/#{other_topic.id}"
raw: "Link to another topic: #{other_topic_url}",
topic_url = "http://#{test_uri.host}/t/#{topic.slug}/#{topic.id}"
raw: "<a href='/u/#{user.username_lower}'>user</a>",
Fabricate(:post, topic: topic, user: user, raw: "<a href='/faq'>faq link here</a>")
let(:post) { Fabricate(:post, topic: topic, user: user, raw: "Hey #{user.username_lower}") }
Fabricate(:post, topic: pm, user: user, raw: "some content")
url = "http://#{test_uri.host}/t/topic-slug/#{topic.id}"
Fabricate(:post, topic: pm, user: user, raw: "initial post")
linked_post = Fabricate(:post, topic: pm, user: user, raw: "Link to another topic: #{url}")
url = "http://#{alternate_uri.host}:5678/t/topic-slug/#{other_topic.id}"
post = Fabricate(:post, topic: topic, user: user, raw: "Link to another topic: #{url}")
url = "http://#{test_uri.host}/t/topic-slug/#{secret_topic.id}"
post = Fabricate(:post, raw: "hello test topic #{url}")
url = "http://#{test_uri.host}/t/topic-slug/#{other_topic.id}"
fab!(:user) { Fabricate(:user, username: "junkrat") }
expect(result).to eq({})
raw: '<a href="http:geturl">http:geturl</a>',
URI.parse("http://test.host")
url: "http://url-that-doesnt-exist.com",
post_id: @post.id,
ip: "127.0.0.1",
ip: "127.0.0.0",
user_id: @post.user_id,
url: "http://discourse.org#a#b",
@url =
url = TopicLinkClick.create_from(url: "/relative-url", post_id: @post.id, ip: "127.0.0.1")
url = "//#{host}/relative-url"
url = "http://#{host}/relative-url"
topic_id: @topic.id,
ip: "127.0.0.3",
url: "https://cdn.discourse.org/stuff#{path}",
url: "https://twitter.com",
expect(@url).to eq("https://twitter.com")
@post =
url: "http://example.com/a",
url: "http://example.com/a?b=c",
ip: "127.0.0.2",
url: "http://example.com/a?b=c&d=e",
ip: "127.0.0.4",
TopicLink.where("url LIKE '%example.com%'").pluck(:url, :clicks),
Fabricate(:post, topic: t, user: t.user)
p2 = Fabricate(:post, topic: t)
p3 = Fabricate(:post, topic: t, user: p2.user)
p4 = Fabricate(:post, topic: t)
p5 = Fabricate(:post, topic: t)
let(:title) { "How to turn a fish from good to evil in 30 seconds" }
let(:url) { "http://eviltrout.com/123" }
expect(post.cooked).to have_tag("a", with: { href: "http://eviltrout.com/hello" })
expect(post.cooked).to have_tag("img", with: { src: "http://eviltrout.com/images/wat.jpg" })
pc =
no_para = "<div><h>testing it</h></div>"
expect(@response.body).to have_tag("img", with: { class: "emoji" })
expect(@response.body).to have_tag("img", with: { class: "foo" })
expect(@response.body).to have_tag("p", with: { class: "foo" })
expect(@response.body).to have_tag("img", without: { class: "other" })
fab!(:user) { Fabricate(:user, username: "eviltrout") }
let(:url) { "http://eviltrout.com/321" }
before(:each) { stub_request(:get, url).to_return(status: 200, body: contents) }
expect(@response.body).to have_tag("img", without: { class: "emoji" })
expect(@response.body).to have_tag("img", without: { class: "foo" })
it 'p node doesn\'t foo class' do
expect(@response.body).to have_tag("p", without: { class: "foo" })
let(:url) { "http://example.com/hello%20world" }
let(:contents) { "<title>Hello World!</title><body></body>" }
url = "/test.txt"
let(:url) { "http://example.com/foo" }
expect(response.body).to have_tag("a", with: { href: "mailto:foo@example.com" })
expect(response.body).to have_tag("a", with: { href: "mailto:bar@example.com" })
let(:contents) { '<p><a href="(http://foo.bar)">Baz</a></p>' }
let(:url) { "http://eviltrout.com/123?asd" }
let(:canonical_url) { "http://eviltrout.com/123" }
let(:content) { "<head><link rel=\"canonical\" href=\"#{canonical_url}\"></head>" }
let(:canonical_content) { "<title>Canonical</title><body></body>" }
it "a" do
contents = "hello world new post <a href='/hello'>hello</a>"
expect(raw).to eq("hello world new post <a href=\"http://source.com/hello\">hello</a>")
url = "https://somesource.com"
fab!(:author) { Fabricate(:user) }
fab!(:category) { Fabricate(:category, topic_count: 1) }
let(:other_user) { private_message.topic_allowed_users.find { |u| u.user != author }.user }
}.from(0).to(1).and change { author.reload.post_count }.from(0).to(2)
.order("id asc")
fab!(:post) { Fabricate(:post, topic: topic, user: topic.user) }
}.from(2).to(0).and change { author.reload.topic_count }.from(1).to(0)
fab!(:t1) { Fabricate(:topic) }
fab!(:t2) { Fabricate(:topic) }
fab!(:topic_1) { Fabricate(:topic, posts_count: 10, like_count: 28) }
fab!(:t1_post_1) { Fabricate(:post, topic: topic_1, like_count: 28, post_number: 1) }
fab!(:topic_2) { Fabricate(:topic, posts_count: 10, like_count: 20) }
fab!(:t2_post_1) { Fabricate(:post, topic: topic_2, like_count: 10, post_number: 1) }
fab!(:t2_post_2) { Fabricate(:post, topic: topic_2, like_count: 10) }
fab!(:topic_3) { Fabricate(:topic, posts_count: 10) }
fab!(:t3_post_1) { Fabricate(:post, topic_id: topic_3.id) }
let!(:t3_view_1) { TopicViewItem.add(topic_3.id, "127.0.0.1", user) }
let!(:t3_view_2) { TopicViewItem.add(topic_3.id, "127.0.0.2", coding_horror) }
it "has name" do
fab! :user do
let(:theme) { Fabricate(:theme, user: user) }
let(:child) { Fabricate(:theme, user: user, component: true) }
theme.set_field(target: :common, name: "head_tag", value: "<b>I am bold")
expect(Theme.lookup_field(theme.id, :desktop, "head_tag")).to eq("<b>I am bold</b>")
{{hello}}
theme.set_field(target: :common, name: :body_tag, value: "<b>test")
expect(Theme.lookup_field(theme.id, :desktop, :body_tag)).to match(%r{<b>test</b>})
let!(:orphan1) { Fabricate(:theme, component: true) }
let!(:child) { Fabricate(:theme, component: true) }
let!(:child2) { Fabricate(:theme, component: true) }
let!(:orphan2) { Fabricate(:theme, component: true) }
let!(:orphan3) { Fabricate(:theme, component: true) }
let!(:orphan4) { Fabricate(:theme, component: true) }
f =
theme_id: 1,
const x = 1;
scss, _map =
name: :yaml,
name: :scss,
setting = theme.settings.find { |s| s.name == :font_size }
setting.value = <<~CSS
theme.set_field(target: :common, name: :scss, value: "body {font-size: quote($font-size)}")
expect(theme_field.javascript_cache.content).to include("let a = () => {}")
setting = theme.settings.find { |s| s.name == :name }
theme.name = "sam"
name: "Fancy",
messages = MessageBus.track_publish { theme.save! }.filter { |m| m.channel == "/file-change" }
.filter { |m| m.channel == "/file-change" }
theme.set_field(target: :settings, name: "yaml", value: <<~YAML)
name: "my_upload",
name: "en",
name: "fr",
child.set_field(target: :extra_js, name: "test.js.es6", value: "const hello = 'world';")
value: '<script>console.log("hello world");</script>',
let(:scss) { "body { background: red}" }
let(:second_file_scss) { "p { color: blue};" }
let(:child_scss) { "body { background: green}" }
theme.set_field(target: :common, name: :scss, value: '@import "my_files/magic";')
css, _map = compiler
value: '@import "my_files/magic"; @import "my_files/magic2"',
value: "some_number: 1",
.filter { |m| m.channel == "/global/asset-version" }
(0..1).each do |num|
ThemeField.create!(theme: theme, target_id: num, name: "header", value: "<a>html</a>")
ThemeField.create!(theme: theme2, target_id: num, name: "header", value: "<a>html</a>")
ThemeField.create!(theme: theme3, target_id: num, name: "header", value: "<a>html</a>")
ThemeField.create!(theme_id: 1, target_id: 0, name: "body_tag", value: "<div>new div</div>")
theme_field = ThemeField.create!(theme_id: 1, target_id: 0, name: "body_tag", value: <<~HTML)
theme_field = ThemeField.create!(theme_id: 1, target_id: 0, name: "scss", value: <<~SCSS)
body {
var b = "inline raw script";
var c = "text/javascript";
<script>var a = 10</script>
<script>var b = 10</script>
extracted = <<~JS
var a = 10
var b = 10
field = ThemeField.create!(theme_id: 1, target_id: 0, name: "header", value: html)
field.update!(value: "")
target_id: 3,
value: "string_setting: \"test text \\\" 123!\"",
css = "body {"
field = ThemeField.create!(theme_id: 1, target_id: 0, name: "scss", value: css)
field.value = "body {color: blue};"
value: ".class1{color: red}\n@import 'rootfile1';\n@import 'rootfile3';",
value: ".class5{color:yellow}\n@import '../rootfile2';",
js_field =
value: "import 'discourse/lib/ajax'; console.log('hello from .js.es6');",
_js_2_field =
value: "import 'discourse/lib/ajax'; console.log('hello from .js');",
value: "{{hello-world}}",
.create!(
.tap { |tf| tf.ensure_baked! }
let(:key) { "themes.settings_errors" }
value: "setting: 5",
name: "header",
expect(field.error).to eq(I18n.t("#{key}.invalid_yaml"))
I18n.t("#{key}.default_not_match_type", name: "no_match_setting"),
I18n.t("#{key}.data_type_not_a_number", name: "invalid_type_setting"),
I18n.t("#{key}.default_out_range", name: "string_default_out_of_range"),
let!(:theme2) { Fabricate(:theme) }
let!(:theme3) { Fabricate(:theme) }
let!(:en1) do
key1: "enval1",
let!(:fr1) do
fr: {
key2: "frval2",
let!(:fr2) do
let!(:en2) do
let!(:ca3) do
name: "ca",
let!(:en3) do
fr1.update(value: "fr:")
name: "test_js",
name: "head_tag",
value: "<script>let c = 'd';</script>",
type: :html,
theme.set_field(target: :settings, type: :yaml, name: "yaml", value: "hello: world")
js_to_eval = <<~JS
var window = {};
settings = s;
});
val = ctx.eval(js_to_eval)
expect(theme.scss_variables).to include("$test_js: unquote(\"#{upload.url}\");")
let!(:tag1) { Fabricate(:tag) }
let!(:tag2) { Fabricate(:tag) }
let!(:tag3) { Fabricate(:tag) }
let!(:tag4) { Fabricate(:tag) }
let!(:tag_user1) do
let!(:tag_user2) do
let!(:tag_user3) do
let!(:tag_user4) do
).to be(1)
).length,
).to be(2)
let(:muted_tag) { Fabricate(:tag) }
fab!(:tracked_tag) { Fabricate(:tag) }
count.times { |i| @tags << Fabricate(:tag) }
}.from(3).to(1)
expect { Fabricate.build(:tag, name: "hElLo").save! }.to raise_error(
expect { Fabricate.build(:tag, name: "None").save! }.to raise_error(
expect { tag.destroy }.to change { Tag.count }.by(-1)
tag = Fabricate(:tag, name: "tag1")
tag2 = Fabricate(:tag, name: "tag2")
tag3 = Fabricate(:tag, name: "tag3")
let(:synonym) { Fabricate(:tag, target_tag: tag) }
expect { tag.destroy }.to change { Tag.count }.by(-2)
fab!(:beta_group) { Fabricate(:group) }
fab!(:staff_category) { Fabricate(:category, name: "Secret") }
let(:tag_group) { Fabricate(:tag_group) }
fab!(:synonym) { Fabricate(:tag, name: "synonym", target_tag: tag) }
StylesheetCache.add("a", "d" + i.to_s, "c" + i.to_s, "map")
expect(StylesheetCache.add("a", "b", "c", "map")).to be_present
expect(StylesheetCache.add("a", "b", "cc", "map")).to eq(false)
StylesheetCache.add("desktop", SecureRandom.hex, "body { }", "map", max_to_keep: 2)
StylesheetCache.add("mobile", SecureRandom.hex, "body { }", "map", max_to_keep: 2)
StylesheetCache.add("a", "b", "c", "map")
StylesheetCache.add("d", "e", "f", "map")
news =
first_page = Sitemap.find_by(name: "1")
let(:sitemap) { described_class.new(enabled: true, last_posted_at: 1.minute.ago, name: "1") }
sitemap.name = "2"
.order(:name)
.pluck(:id, :name, :color_scheme_id)
.map do |id, n, cs|
2.times { TopTopic.create!(daily_score: 2.5) }
expect(SiteSetting.global_notice).to eq("<b>click me!</b>alert('TEST');")
value = 'OX5y3Oljb+Qt9Bu809vsBQ==<>!%{}*&!@#$%..._-A'
).valid?,
).to be false
).to be true
status, _ =
action, log_id =
action, _ = SearchLog.log(term: "darth", search_type: :header, ip_address: "127.0.0.1")
action, _ = SearchLog.log(term: "anakin", search_type: :header, ip_address: "127.0.0.1")
action, _ = SearchLog.log(term: "darth", search_type: :header, ip_address: "127.0.0.2")
term: "hello dolly",
ip_address: "192.168.0.33",
action, _ =
time = Time.utc(2019, 5, 23, 18, 15, 30)
Fabricate(:search_log, term: "ruby core", ip_address: "127.0.0.3")
term: "ruBy",
ip_address: "127.0.0.2",
.where("lower(term) = ?", "ruby")
.where(ip_address: "127.0.0.2")
SearchLog.log(term: "ruby", search_type: :header, ip_address: "127.0.0.1")
SearchLog.log(term: "php", search_type: :header, ip_address: "127.0.0.1")
SearchLog.log(term: "java", search_type: :header, ip_address: "127.0.0.1")
SearchLog.log(term: "ruby", search_type: :header, ip_address: "127.0.0.1", user_id: user.id)
SearchLog.log(term: "swift", search_type: :header, ip_address: "127.0.0.1")
SearchLog.log(term: "ruby", search_type: :header, ip_address: "127.0.0.2")
SearchLog.log(term: "jawa", search_type: :header, ip_address: "127.0.0.1")
SearchLog.log(term: "jedi", search_type: :header, ip_address: "127.0.0.1")
SearchLog.log(term: "rey", search_type: :header, ip_address: "127.0.0.1")
SearchLog.log(term: "finn", search_type: :header, ip_address: "127.0.0.1")
let(:url) { "http://shopppping.com/bad/drugz" }
let(:domain) { "shopppping.com" }
let(:valid_params) { { url: url, domain: domain } }
it "strips #{prefix}" do
@params = valid_params.merge(url: url.gsub("http://", prefix))
expect(subject.url).to eq(url.gsub("http://", ""))
let!(:existing) { Fabricate(:screened_url, url: url, domain: domain) }
let(:ip_address) { "99.232.23.124" }
let(:valid_params) { { ip_address: ip_address } }
test_good_value("210.56.12.12", "210.56.12.12")
test_good_value("210.56.0.0/16", "210.56.0.0/16")
test_good_value("fc00::/7", "fc00::/7")
test_good_value(IPAddr.new("94.99.101.228"), "94.99.101.228")
test_good_value(IPAddr.new("94.99.0.0/16"), "94.99.0.0/16")
test_good_value(IPAddr.new("fc00::/7"), "fc00::/7")
test_good_value("123.*.*.*", "123.0.0.0/8")
test_good_value("123.12.*.*", "123.12.0.0/16")
test_good_value("123.12.1.*", "123.12.1.0/24")
test_good_value("123.12.*.*/16", "123.12.0.0/16")
test_good_value("123.12.*", "123.12.0.0/16")
test_good_value("123.*", "123.0.0.0/8")
test_bad_value("123.*.1.12")
test_bad_value("*.123.*.12")
test_bad_value("*.*.*.12")
test_bad_value("123.*.1.12/8")
fab!(:existing) { Fabricate(:screened_ip_address, ip_address: "99.232.23.124/24") }
let(:ip_address_arg) { "99.232.23.124" }
let(:ip_address_arg) { "99.232.23.135" }
it "doesn't block 10.0.0.0/8" do
it "doesn't block 192.168.0.0/16" do
it "doesn't block 127.0.0.0/8" do
ip_address: "111.234.23.0/24",
ip_address: "222.234.23.0/24",
ip_address: "222.234.23.11",
expect(ScreenedIpAddress.pluck(:ip_address)).not_to include("1.1.1.1", "1.1.1.2", "1.1.1.3")
let(:email) { "block@spamfromhome.org" }
expect(actions.to_a.find { |a| a.id == id }.require_reject_reason).to eq(expected)
expect(r1.id).to eq(r0.id)
r0 =
raw: "hello world I am a post",
r1 =
expect(r1.id).not_to eq(r0.id)
.where("tcf.name = ?", "troublemaker_user_id")
.where("u.username = ?", value)
fab!(:user0) { Fabricate(:user, trust_level: 1) }
fab!(:user1) { Fabricate(:user, trust_level: 2) }
fab!(:user2) { Fabricate(:user, trust_level: 3) }
let(:user_stat) { user.user_stat }
it "returns 1.0 + trust_level" do
6.0,
flag_score = -21.88
let(:user_stats) { user.user_stat }
let(:post) { Fabricate.build(:post) }
:size,
let(:expected_score) { 8 }
let(:c0) { Fabricate(:category, user: user) }
let(:c1) { Fabricate(:category, parent_category: c0, user: user) } # id: 2
let(:c2) { Fabricate(:category, user: user) }
date: (i + 1).days.ago.to_time,
count: 10,
date: (31 + i).days.ago.to_time,
title: "topic #{i}",
let(:report) { Report.find("visits") }
let(:report) { Report.find("mobile_visits") }
if arg == :flag
builder = ->(dt) {
:spam,
elsif arg == :signup
builder = ->(dt) { Fabricate(:user, created_at: dt) }
factories = { email: :email_log }
1.day.ago,
count: 35,
count: 8,
count: 3,
let(:topic) { Fabricate(:topic, created_at: 1.hour.ago, user: user) }
let(:report) { Report.find("users_by_trust_level") }
let(:report) { Report.find("users_by_type") }
3.times { Fabricate(:user, admin: true) }
label = Proc.new { |key| I18n.t("reports.users_by_type.xaxis_labels.#{key}") }
term: "ruby",
let(:report) { Report.find("dau_by_mau") }
r = Report.find("posts")
let(:report) { Report.find("flags_status") }
let(:post) { Fabricate(:post, user: flagger) }
let(:report) { Report.find("post_edits") }
let(:editor) { Fabricate(:user) }
{ raw: "updated body by author", edit_reason: "not cool" },
fab!(:posts) { Fabricate.times(3, :post) }
Fabricate(:user).tap { |user| posts.last.revise(user, { raw: "edit 3" }) }
Report.find("post_edits", { filters: { "editor" => editor_with_one_edit.username } })
Report.find("post_edits", { filters: { "editor" => editor_with_two_edits.username } })
let(:sam) { Fabricate(:user, moderator: true, username: "sam") }
let(:jeff) { Fabricate(:user, moderator: true, username: "jeff") }
before { Fabricate(:topic, user: sam, created_at: 1.year.ago) }
let(:report) { Report.find("flags") }
let(:report) { Report.find("flags", filters: { category: c1.id }) }
let(:report) { Report.find("topics") }
let(:report) { Report.find("topics", filters: { category: c1.id }) }
let(:report) { Report.find("posts") }
let(:report) { Report.find("posts", filters: { category: c1.id }) }
let(:report) { Report.find("topics_with_no_response", filters: { category: c1.id }) }
let(:report) { Report.find("likes") }
.tap { |pa| pa.created_at = 45.days.ago }
.save!
let(:report) { Report.find("likes", filters: { category: c1.id }) }
let(:joffrey) { Fabricate(:user, username: "joffrey") }
let(:robin) { Fabricate(:user, username: "robin") }
it "it works" do
let(:joffrey) { Fabricate(:admin, username: "joffrey") }
let(:robin) { Fabricate(:admin, username: "robin") }
let(:james) { Fabricate(:user, username: "james") }
.with(ip.join("."))
.returns("ip-#{ip.join("-")}.example.com")
client_ip: ip.join("."),
let(:report) { Report.find("top_uploads") }
let(:tarek) { Fabricate(:admin, username: "tarek") }
let(:khalil) { Fabricate(:admin, username: "khalil") }
let(:report) { Report.find("top_ignored_users") }
let(:tarek) { Fabricate(:user, username: "tarek") }
let(:john) { Fabricate(:user, username: "john") }
let(:matt) { Fabricate(:user, username: "matt") }
fab!(:gwen) { Fabricate(:user) }
fab!(:martin) { Fabricate(:user) }
fab!(:jpg_upload) { Fabricate(:upload, extension: :jpg) }
fab!(:png_upload) { Fabricate(:upload, extension: :png) }
report = Report.find("top_uploads", filters: { file_extension: "jpg" })
user_2 = Fabricate(:user, username: "jake")
user_3 = Fabricate(:user, username: "john")
post_1 = Fabricate(:post, topic: topic_1, user: user_1)
post_2 = Fabricate(:post, topic: topic_2, user: user_2)
post_3 = Fabricate(:post, topic: topic_3, user: user_3)
user_id: user_4.id,
user_id: user_5.id,
user_id: user_6.id,
user_1 = Fabricate(:user, username: "jonah", trust_level: 2)
user_2 = Fabricate(:user, username: "jake", trust_level: 2)
user_3 = Fabricate(:user, username: "john", trust_level: 2)
after { `rm -fr #{initial_repo}` }
time = Time.new("2000")
time = Time.new("2001")
old_version = `cd #{initial_repo} && git rev-parse HEAD`.strip
new_version = `cd #{initial_repo} && git rev-parse HEAD`.strip
let!(:theme) { Fabricate(:theme, remote_theme: remote) }
last_error_text: "can't contact this repo :(",
post1 = create_post(topic: topic, post_number: 1, raw: "foo bar")
post5 = create_post(topic: topic, post_number: 5, raw: "post 5")
post = create_post(topic: topic, post_number: 1, raw: "foo bar")
post.cooked = <<-HTML
<aside class="quote" data-post="#{post.post_number}" data-topic="#{post.topic_id}">
post2.cooked = <<-HTML
<aside class="quote" data-post="#{post1.post_number}" data-topic="#{post1.topic_id}">
fab!(:p2) { Fabricate(:post, topic: p1.topic, user: p1.user) }
fab!(:p3) { Fabricate(:post, topic: p1.topic, user: p1.user) }
timing(1, 1)
timing(2, 1)
timing(2, 2)
timing(3, 1)
timing(3, 2)
timing(3, 3)
_tu_one = topic_user(1, 1)
_tu_two = topic_user(2, 2)
_tu_three = topic_user(3, 3)
(2..5).each { |i| Fabricate(:post, topic: post.topic, post_number: i) }
(1..3).each { |i| Fabricate(:post, topic: pm, user: user1) }
@timing_attrs = {
}.to change(post, :reads).by(1)
let(:initial_read_count) { 0 }
before { @types = Post.types }
it { is_expected.not_to allow_value("x").for(:raw) }
it { is_expected.not_to allow_value("x" * (SiteSetting.max_post_length + 1)).for(:raw) }
it { is_expected.not_to allow_value((" " * SiteSetting.min_post_length) + "x").for(:raw) }
let(:post_args) { { user: topic.user, topic: topic } }
2.times { |t| Fabricate(:post, created_at: t.seconds.from_now) }
let(:post) { Fabricate(:post, post_args) }
expect { post.trash! }.to change { post.custom_fields }.to({})
fab!(:user) { coding_horror }
post_with_body('<code><img src="coolimage.png"></code>', newuser)
let(:post_image_within_pre) { post_with_body('<pre><img src="coolimage.png"></pre>', newuser) }
expect(two_links.linked_hosts).to eq("disneyland.disney.go.com" => 1, "reddit.com" => 1)
expect(three_links.linked_hosts).to eq("discourse.org" => 1, "www.imdb.com" => 1)
let(:post_onebox) { post_with_body("http://www.google.com", newuser) }
let(:post_code_link) { post_with_body("<code>http://www.google.com</code>", newuser) }
post = Fabricate.build(:post, post_args.merge(raw: "@Jake @Finn @Jake"))
post = Fabricate.build(:post, post_args.merge(raw: "p <pre>@Jake</pre> @Finn"))
post = Fabricate.build(:post, post_args.merge(raw: "a <pre>hello</pre> @Finn <pre></pre>"))
post = Fabricate.build(:post, post_args.merge(raw: "@Jake `@Finn`"))
post = Fabricate.build(:post, post_args.merge(raw: "@Jake @Finn @Jake_Old"))
let(:raw) { "this is our test post body" }
let(:post) { post_with_body(raw) }
{ raw: "yet another updated body" },
{ raw: "yet another, another updated body" },
let!(:result) { post.revise(changed_by, raw: "updated body") }
let!(:post) { Fabricate(:post, post_args) }
let(:reply) { Fabricate.build(:post, post_args) }
it "has a quote" do
raw =
let!(:p1) { Fabricate(:post, post_args.merge(score: 4, percent_rank: 0.33)) }
let!(:p2) { Fabricate(:post, post_args.merge(score: 10, percent_rank: 0.66)) }
let!(:p3) { Fabricate(:post, post_args.merge(score: 5, percent_rank: 0.99)) }
fab!(:p4) { Fabricate(:post, percent_rank: 0.99) }
let!(:p1) { Fabricate(:post, post_args) }
let!(:p2) { Fabricate(:post, post_args) }
let!(:p3) { Fabricate(:post, post_args) }
let!(:p1) { Fabricate(:post, topic: topic, post_number: 1) }
let!(:p2) { Fabricate(:post, topic: topic, post_number: 2, reply_to_post_number: 1) }
let!(:p3) { Fabricate(:post, topic: topic, post_number: 3) }
let!(:p4) { Fabricate(:post, topic: topic, post_number: 4, reply_to_post_number: 2) }
let!(:p5) { Fabricate(:post, topic: topic, post_number: 5, reply_to_post_number: 4) }
let!(:p6) { Fabricate(:post, topic: topic, post_number: 6) }
{ id: p2.id, level: 1 },
{ id: p4.id, level: 2 },
{ id: p5.id, level: 3 },
{ id: p6.id, level: 2 },
post.add_detail("key", "value")
post = Fabricate(:post, raw: "hello @#{group.name}")
%Q|<p>hello <a class="mention-group" href="/groups/#{group.name}">@#{group.name}</a></p>|,
post.update!(raw: "hello @#{group.name}")
%Q|<p>hello <a class="mention-group notify" href="/groups/#{group.name}">@#{group.name}</a></p>|,
let(:raw) do
post = Fabricate(:post, raw: raw)
post = Fabricate(:post, raw: raw, user: user)
expect(post.custom_fields).to eq("Tommy" => "Hanks", "Vincent" => "Vega")
stub_request(:get, "http://testonebox.com/vvf").to_return(status: 200, body: <<~HTML)
<html><head>
</head></html>
post = create_post(raw: <<~POST).reload
describe "#hide!" do
fab!(:video_upload) { Fabricate(:upload, extension: "mp4") }
fab!(:image_upload) { Fabricate(:upload) }
fab!(:image_upload_2) { Fabricate(:upload) }
let(:base_url) { "#{Discourse.base_url_no_prefix}#{Discourse.base_path}" }
let(:video_url) { "#{base_url}#{video_upload.url}" }
let(:raw_video) { <<~RAW }
<video width="100%" height="100%" controls>
<source src="#{video_url}">
<a href="#{video_url}">#{video_url}</a>
</video>
let(:post) { Fabricate(:post, raw: raw_video) }
fab!(:audio_upload) { Fabricate(:upload, extension: "ogg") }
let(:audio_url) { "#{base_url}#{audio_upload.url}" }
let(:raw_multiple) { <<~RAW }
<a href="#{attachment_upload.url}">Link</a>
<img src="#{image_upload.url}">
<source src="#{audio_url}">
<a href="#{audio_url}">#{audio_url}</a>
</audio>
let(:post) { Fabricate(:post, raw: raw_multiple) }
post = Fabricate(:post, raw: raw, user: user, topic: Fabricate(:topic, user: user))
cooked: "A post with upload <img src='/#{upload_path}/1/defghijklmno.png'>",
<a href='#{Discourse.base_url}#{upload2.url}'>Link to upload</a>
<source src="#{Discourse.base_url}#{upload6.url}" type="video/mp4" />
post.each_upload_url do |src, path, _|
urls << src
<img src="#{upload1_url}"/>
<img src="#{upload2_path}"/>
post.each_upload_url { |src, path, sha| sha1s << sha }
sha1s << sha
post.each_upload_url { |src, _, _| urls << src }
fab!(:group_user) { Fabricate(:group_user, user: user3) }
expect(raw_key.delete("-")).to eq(hex)
fab!(:user) { Fabricate(:user, admin: true) }
fab!(:another_user) { evil_trout }
fab!(:category) { Fabricate(:category, user: user) }
fab!(:topic) { Fabricate(:topic, user: user, created_at: 4.hours.ago) }
fab!(:p1) do
fab!(:p3) do
fab!(:p4) do
fab!(:p5) { Fabricate(:post, created_at: 30.minutes.ago) }
let(:p6) { Fabricate(:post, topic: topic, created_at: 15.minutes.ago) }
p3.update!(raw: raw)
}.and change { p2.post_number }.and change { p3.reload.raw }.and change {
}.to(nil).and change { p3.baked_version }.to(nil)
expect(p3.raw).to include("post:#{p2.post_number}, topic:#{p2.topic_id}")
non_existent_post_id = Post.maximum(:id)&.next || 1
p2.replies << p5
).to eq(p3.post_number)
raw: "A small action",
tu1 =
tu2 =
def create_topic_user(user, opts = {})
fab!(:admin1) { Fabricate(:admin) }
fab!(:admin2) { Fabricate(:admin) }
moved_to =
fab!(:some_user) { Fabricate(:user) }
post: p3,
def create_topic_user(user, topic, opts = {})
custom_fields = { "some_field" => "payload" }
let!(:old_post) { p1 }
let!(:old_post) { p3 }
end.to change { PostReply.count }.by(-1)
end.to change { PostReply.count }.by(-2)
fab!(:p1) { Fabricate(:post, topic: personal_message, user: user, created_at: 4.hours.ago) }
fab!(:p5) do
p1.replies << p3
p2.replies << p4
locale: :en,
fab!(:p1) { Fabricate(:post, topic: banner_topic, user: evil_trout) }
let(:default_topic_id) { 12 }
let(:raw) { "Here's a tweet:\n#{url}" }
let(:options) { {} }
let(:options) { { invalidate_oneboxes: true } }
expect(cooked).to eq("Hello <div/> world")
expect(cooked).to eq("<p><em>this is italic</em></p>")
<p>something</p>
<p><a href="#{url}" class="onebox" target="_blank" rel="noopener nofollow ugc">#{url}</a></p>
let(:raw_no_links) { "hello world my name is evil trout" }
expect(post_analyzer.linked_hosts).to eq("discourse.org" => 1, "www.imdb.com" => 1)
let(:raw_post_with_anchors) { "# hello world" }
post_analyzer = PostAnalyzer.new('<a href="">Hello world</a>', nil)
post_analyzer = PostAnalyzer.new(". <pre>hello</pre> @Finn <pre></pre>", default_topic_id)
fab!(:second_post) { Fabricate(:post, topic: post.topic) }
pa =
topic_user_ids = topic.reload.topic_users.map { |x| x.user_id }
fab!(:liker2) { Fabricate(:user) }
fab!(:likee) { Fabricate(:user) }
expected_count = type_name == :like ? 2 : 1
post.revise(post.user, raw: post.raw + " ha I edited it ")
let(:post1) { create_post(topic: topic) }
let(:post2) { create_post(topic: topic) }
let(:post3) { create_post(topic: topic) }
fab!(:flagger1) { Fabricate(:user) }
fab!(:flagger2) { Fabricate(:user) }
fab!(:staff_user) { Fabricate(:user, moderator: true) }
fab!(:topic) { Fabricate(:topic, user: staff_user) }
message: "WAT",
post.topic.title = "This is a test topic " * 2
expect(limiter(2, :like).max).to eq (
).to_i
expect(limiter(3, :like).max).to eq (
expect(limiter(4, :like).max).to eq (
expect(limiter(2, type).max).to eq (
expect(limiter(3, type).max).to eq (
expect(limiter(4, type).max).to eq (
describe "#is_flag?" do
let(:store) { PluginStore.new("my_plugin_2") }
def set(k, v)
store.set(k, v)
def get(k)
value == store.get(k) ? value : "values mismatch"
value == store.get_all(k) ? value : "values mismatch"
set("hello", "world")
expect(get("hello")).to eq("world")
set("hello", "world1")
expect(get("hello")).to eq("world1")
set("hello", 1)
expect(get("hello")).to eq(1)
set("hello", true)
expect(get("hello")).to eq(true)
set("hello", false)
expect(get("hello")).to eq(false)
set("hello", nil)
expect(get("hello")).to eq(nil)
set("hello_str", "world")
set("hello_int", 1)
set("hello_bool", true)
{ hello_str: "world", hello_int: 1, hello_bool: true }.stringify_keys,
val = { "hi" => "there", "1" => 1 }
set("hello", val)
result = get("hello")
normalizer = Permalink::Normalizer.new("/(\\/hello.*)\\?.*/\\1|/(\\/bye.*)\\?.*/\\1")
expect(normalizer.normalize("/bla?a=1")).to eq("/bla?a=1")
expect(target_url).to eq("#{category.url}")
before { upload.id = 42 }
tmp_path = "/tmp/cropped.png"
let(:image) { "#{Rails.root}/spec/fixtures/images/logo.png" }
tmp_path = "/tmp/resized.png"
expect { OptimizedImage.ensure_safe_paths!("/a.png", "/b.png") }.not_to raise_error
expect { OptimizedImage.ensure_safe_paths!("/a.png", "/b.png", "c.png") }.to raise_error(
expect(local("//hello")).to eq(false)
expect(local("http://hello")).to eq(false)
expect(local("https://hello")).to eq(false)
expect(local("/hello")).to eq(true)
let(:filename) { "logo.png" }
it "is able to 'optimize' an svg" do
stub_request(:head, "http://#{s3_upload.url}").to_return(status: 200)
stub_request(:get, "http://#{s3_upload.url}").to_return(status: 200)
let(:s3_upload) { Fabricate(:upload_s3) }
let(:optimized_path) { %r{/optimized/\d+X.*/#{s3_upload.sha1}_2_100x200\.png} }
stub_request(:get, "http://#{s3_upload.url}").to_return(
:put,
).to_return(status: 200, headers: { "ETag" => "someetag" })
Fabricate(:post, user: user2, topic: post.topic, raw: "hello @" + user.username)
fab!(:user) { Fabricate(:user, last_seen_at: 1.day.ago) }
@post = Fabricate(:post, topic: @topic, user: @topic.user)
@topic.id,
topic_id: t.id,
(1..3).map do |i|
p = Fabricate(:post)
user_id: p2.user_id,
@i ||= 0
@i += 1
a = unread_pm
c = pm
fab!(:group) { Fabricate(:group, name: "XXsssssddd") }
pattern = File.join(Rails.root, "config", "locales", "client.*.yml")
name: "German (Austria)",
expect(native_locale_name("tlh")).to eq("tlh")
fab!(:invite) { Invite.generate(user, email: "test@example.com") }
fab!(:another_topic) { Fabricate(:topic, user: topic.user) }
expect(user.is_a?(User)).to eq(true)
fab!(:user) { Fabricate(:user, email: invite.email) }
fab!(:redeeming_user) { Fabricate(:user, email: "redeemer@test.com") }
email: "blah@test.com",
fab!(:invite) { Fabricate(:invite, email: "foobar@example.com") }
ip_address = "192.168.1.1"
password: "aaa",
let(:name) { "john snow" }
let(:password) { "know5nOthiNG" }
user_fields = { required_field.id.to_s => "value1", optional_field.id.to_s => "value2" }
fab!(:invite) { Fabricate(:invite, email: nil, domain: "test.com") }
fab!(:redeeming_user) { Fabricate(:user, email: "foo@test.com") }
fab!(:redeeming_user) { Fabricate(:user, email: "foo@example.com") }
7.times do |n|
referer: "http://test.com",
ip_address: "10.0.0.#{n}",
3.times do |n|
referer: "http://foo.com",
ip_address: "10.0.0.#{n + 7}",
2.times do |n|
ip_address: "10.0.0.#{n + 7 + 3}",
user_id: p1.user.id,
num_clicks: 7 + 2,
user_id: p2.user.id,
{ domain: "test.com", num_clicks: 7, num_topics: 1 },
{ domain: "foo.com", num_clicks: 3 + 2, num_topics: 1 },
num_clicks: 2 + 3,
id_address: "1.2.3.4",
id_address: "5.6.7.8",
fab!(:amy) { Fabricate(:user, username: "amy") }
let(:topic1) { post1.topic }
let(:topic2) { post2.topic }
username: "amy",
user_id: amy.id,
username: "bob",
user_id: bob.id,
fab!(:sharing_user) { Fabricate(:user, name: "Alice") }
fab!(:current_user) { Fabricate(:user, name: "Bob") }
host: "a.com",
referer: "http://twitter.com",
ip_address: "1.1.1.1",
post_id: 1,
add(post_id: 1)
add(post_id: 1, host: "example.com", referer: "http://example.com")
add(post_id: 1, referer: "bang bang bang")
add(host: "test.com", referer: "http://some.other.site.com", post_id: 1)
ip_address: "100.64.1.1",
expect(il.ip_address).to eq "100.64.1.1"
ip_address: "100.64.1.2",
ip_address: "100.64.1.3",
group = Group.create!(name: "bob")
fab!(:tag4) { Fabricate(:tag) }
fab!(:tag5) { Fabricate(:tag) }
fab!(:synonym1) { Fabricate(:tag, target_tag: tag1) }
expect { group.add(user) }.to change { TagUser.count }.by(5)
fab!(:group_2) { Fabricate(:group) }
fab!(:pm_topic) { pm_post.topic.tap { |t| t.allowed_groups << group } }
fab!(:user) do
u.id,
fab!(:user_2) do
fab!(:user_3) do
let(:group) { build(:group) }
group.name = ""
group.name = "this_is_a_name"
group.name = "this is_a_name"
build(:group, name: "this_is_a_name").save
group.name = "This_Is_A_Name"
).to(group)
).to(nil)
expect { group.update(title: "Super") }.to change { user.reload.title }.from("Awesome").to(
I18n.locale = "en"
.where("length(username) < 6")
.each do |u|
g.add(u1)
usernames = "#{u2.username},#{u3.username}"
expect(group.custom_fields).to eq("hugh" => "jackman", "jack" => "black")
block = Proc.new { |user, group| called = { user_id: user.id, group_id: group.id } }
fab!(:user) { Fabricate(:user, trust_level: 1, created_at: Time.zone.now - 10.years) }
fab!(:group) { Fabricate(:group, grant_trust_level: 3) }
fab!(:group2) { Fabricate(:group, grant_trust_level: 2) }
group.update!(bio_raw: "")
expect { group.remove(user) }.to change { user.reload.title }.from("Awesome").to("Super")
expect { group.add(user) }.to change { user.reload.title }.from(nil).to("Awesome")
Proc.new do |_u, _g, options|
Fabricate(:group, name: "pears_11", full_name: "fred apple")
}.to change { group.user_count }.by(2)
let(:tag3) { Fabricate(:tag) }
let(:tag4) { Fabricate(:tag) }
let(:synonym1) { Fabricate(:tag, target_tag: tag1) }
let(:synonym2) { Fabricate(:tag, target_tag: tag2) }
subject: "test",
).sort,
f = Tempfile.new("foo")
f.write("\n")
f.write("c = \'10 # = 00\' # this is a # comment\n")
f.write("d =\n")
f.write("#f = 1\n")
f.write("a1 = 1\n")
expect(provider.lookup(:a, "")).to eq 1000
expect(provider.lookup(:b, "")).to eq "10 # = 00"
expect(provider.lookup(:c, "")).to eq "10 # = 00"
expect(provider.lookup(:e, "bob")).to eq "bob"
expect(provider.lookup(:f, "bob")).to eq "bob"
expect(provider.lookup(:a1, "")).to eq 1
it "uses ERB" do
expect(provider.lookup(:a, "")).to eq 500
expect(value_for(user.id, dt)).to eq(0)
expect(value_for(user.id, dt)).to eq(1)
expect(value_for(user.id, dt)).to eq(2)
t = Fabricate.build(:form_template, name: "Bug Report", template: "- type: input")
template = "- type: fancy"
template = "- hello: world"
expect(Emoji.exists?(":test:")).to be(true)
expect(Emoji.exists?(":foo-bar:")).to be(false)
str = "This is a good day :xxxxxx: :woman: :man:t4:"
str = "This is a good day :woman: :foo: :bar:t4: :man:t8:"
emoji = Emoji.create_from_db_item("name" => "scotland")
emoji = Emoji.create_from_db_item("name" => "white_hair")
expect(eh.host).to eq("192.168.0.1")
expect(eh.host).to eq("192.168.0.1:3000")
fab!(:host) { Fabricate(:embeddable_host) }
Fabricate(:embeddable_host, allowed_paths: '^/fp/\d{4}/\d{2}/\d{2}/.*$')
expect(EmbeddableHost.record_for_url("@@@@@")).to eq(false)
fab!(:user) { Fabricate(:user, active: false) }
it "has a token" do
fab!(:invite) { Fabricate(:invite, email: "test@example.com", expires_at: 1.day.ago) }
email_type: "blah",
cc_user = Fabricate(:user, email: "test@test.com")
let(:user) { Fabricate(:user, email: "test@test.com") }
seq = Draft.set(Discourse.system_user, "abc", 0, { reply: "hi" }.to_json)
expect(seq).to eq(0)
draft = { reply: "this is a reply", random_key: "random" }
seq = Draft.set(user, "xyz", 0, draft.to_json)
seq = Draft.set(user, "xyz", seq, draft.to_json)
Draft.set(user, "xyz", seq, draft.to_json)
Draft.set(user, "test", 0, "data")
expect(Draft.get(user, "test", 0)).to eq "data"
seq = Draft.set(user, "test", 0, "data")
seq = Draft.set(user, "test", seq, "new data")
expect(Draft.get(user, "test", seq)).to eq "new data"
expect(seq).to eq(1)
Draft.clear(user, "test", 0)
expect(Draft.get(user, "test", 0)).to eq nil
Draft.set(user, "test", 0, "old")
expect(Draft.get(user, "test", 0)).to eq "old"
expect(seq).to eq(2)
Draft.set(user, "test", seq, "data")
expect(Draft.get(user, "test", seq)).to eq "data"
expect do expect(Draft.get(user, "test", seq - 1)).to eq "data" end.to raise_error(
expect do expect(Draft.get(user, "test", seq + 1)).to eq "data" end.to raise_error(
Draft.set(user, "test", 1, "hello")
expect(Draft.get(user, "test", 1)).to eq "hello"
seq = Draft.set(user, "test", 0, "foo", nil, force_save: true)
Draft.set(user, key, 0, "draft")
Draft.set(user, key, seq, "draft")
Draft.set(Fabricate(:user), Draft::NEW_TOPIC, 0, "data")
let(:stream) { Draft.stream(user: user) }
Draft.set(user, "test", 0, '{"reply":"hey.","action":"createTopic","title":"Hey"}')
Draft.set(user, "test2", 0, '{"reply":"howdy"}')
Draft.set(user, "topic_#{public_topic.id}", 0, '{"reply":"hi"}')
Draft.set(user, "topic_#{public_topic.id}", 0, '{"reply":"hey"}')
p =
).to eq nil
Draft.set(user, "new_topic", 0, "hello")
Draft.set(user, "new_topic", 0, "goodbye")
draft_seq = Draft.set(user, "new_topic", 0, "hello", _owner = "ABCDEF")
draft_seq = Draft.set(user, "new_topic", 0, "hello world", _owner = "HIJKL")
draft_seq = Draft.set(user, "new_topic", 1, "hello world", _owner = "HIJKL")
{ raw: "hello", postId: post.id }.to_json,
user.id = -99_999
2.times { expect(DraftSequence.next!(user, "test")).to eq(0) }
Draft.create!(user: user, draft_key: "test", data: {})
sso.external_id = "100"
sso.bio = "about"
sso.sso_secret = "test"
sso.email = "sam@sam.com"
let(:ip_address) { "127.0.0.1" }
sso.external_id = "A"
sso.name = "Bob O'Bob"
sso.external_id = "B"
expect(user.name).to eq("Bob O'Bob")
let(:sso) do
sso.email = "bob@obob.com"
sso.name = "Bob Admin"
sso.external_id = "id"
expect(mod_group.users.where("users.id = ?", user.id).exists?).to eq(true)
expect(staff_group.users.where("users.id = ?", user.id).exists?).to eq(true)
expect(admin_group.users.where("users.id = ?", user.id).exists?).to eq(true)
sso.name = "Bob"
sso.add_groups = "#{group.name},badname"
sso.groups = "#{group.name},badname"
sso.name = "test user"
sso.bio = "This **is** the bio"
sso.username = ""
sso.email = "TEST@bob.com"
sso.name = "Louis C.K."
name = "John"
sso.name = "John Smith"
sso.name = "Plato"
expect(user.name).to eq ""
url, payload = sso.to_url.split("?")
expect(sso.to_url.split("?").size).to eq 2
sso.name = "test"
sso.locale = "es"
sso.locale = "fake"
sso.title = "The User's Title"
sso.title = "farmer"
sso.bio = "new profile"
sso.bio = "new profile 2"
sso.name = "sam"
let!(:sso) do
let(:logo) { file_from_fixtures("logo.png") }
time_read: 1,
let(:valid_params) { { name: "Best Colors Evar", colors: valid_colors } }
{ name: "$primary_background_color", hex: "FFBB00" },
{ name: "$secondary_background_color", hex: "888888" },
theme.set_field(name: :scss, target: :desktop, value: ".bob {color: $primary;}")
let(:base_colors) { { first_one: "AAAAAA", second_one: "333333", third_one: "BEEBEE" } }
let!(:base) do
name: "Base",
c =
name: "Yellow",
first_one: "FFFF00",
third_one: "F00D33",
first = c.colors.find { |x| x.name == "first_one" }
second = c.colors.find { |x| x.name == "second_one" }
third = c.colors.find { |x| x.name == "third_one" }
).to eq 1
raw: "test raw",
expect(category.custom_fields).to eq("bob" => "marley", "jack" => "black")
expect(@category.slug).to eq("%E6%B5%8B%E8%AF%95")
expect(@category.slug_for_url).to eq("%E6%B5%8B%E8%AF%95")
let(:category) { Fabricate.build(:category, name: "2") }
c = Fabricate.build(:category, name: "More Fun Cats", slug: "love-cats")
@cat.slug = "#{@c.id}-category"
@cat.slug = "#{@cat.id}-category"
c.description = "&lt;hello <a>foo/bar</a>."
name: "little-test",
permalink = Permalink.create!(url: "c/#{@category.slug}/#{@category.id}", category_id: 42)
c2.slug = "the-slug"
fab!(:category) { Fabricate(:category, name: "root") }
it "builds a url" do
expect(category.url).to eq("/c/root/#{category.id}")
category = Category.new(name: "test", user: user, email_in: "<sup>test</sup>")
fab!(:group) { Fabricate(:group, name: "testgroup", incoming_email: "test@example.com") }
name: "<b>cool</b>",
user_id: -1,
fab!(:group2) { Fabricate(:group) }
fab!(:category) { Category.create!(user: user, name: "foo") }
before_all { DB.exec(<<-SQL, id: category.id) }
title: "</a><script>alert(document.cookie);</script><a>",
.find { |x| x.name == public_cat.name }
.find { |x| x.name == private_cat.name }
.find { |x| x.name == private_cat.name },
.find { |x| x.name == cat.name }
.find { |c| c.id == category.id }
let(:category) { category_list.categories.find { |c| c.id == topic_category.id } }
let!(:pinned) do
size = Category.order(:id).where("id < ?", category.id).count + 1
{ 1.day.ago.to_date => 1, 2.days.ago.to_date => 1, 3.days.ago.to_date => 2 },
{ 1.day.ago.to_date => 1 },
expect(Bookmark.count_per_day(since_days_ago: 2)).to eq({ 1.day.ago.to_date => 1 })
{ 2.days.ago.to_date => 1, 3.days.ago.to_date => 2 },
UserBadge.create!(user_id: -100, badge_id: b.id, granted_at: 1.minute.ago, granted_by_id: -1)
badge_id: b.id,
expect(badge.description).to eq("<b>click me!</b>alert('TEST');")
fab!(:badge) { Fabricate(:badge, name: "Test Badge") }
before { badge.system = true }
it { is_expected.to be false }
it "has CDN url" do
revisor.revise!(post.user, { raw: "I am editing a wiki" }, force_new_version: true)
post = create_post(raw: "https://www.discourse.org/")
url: "https://www.discourse.org/",
ip: "192.168.0.100",
ip: "192.168.0.101",
let(:badge_id) { Badge.maximum(:id) + 1 }
b.id = badge_id
b.name = "Foo"
4.times { inc("http_2xx") }
inc("http_2xx")
controller, method = m.split("#")
request.path_parameters = { controller: "topics", action: "show", topic_id: "3" }
let(:env) { request.env }
request.path_parameters = { controller: "topics", action: "show", topic_id: "4" }
request.path_parameters = { controller: "topics", action: "show", id: "3" }
request.path_parameters = { controller: "topics", action: "show", topic_id: "3", id: "3" }
let(:scope) { ApiKeyScope.new(resource: "global", action: "read") }
let(:key) { :facebook_app_id }
let(:key) { :twitter_consumer_key }
let(:key) { :github_client_id }
let!(:theme) { Fabricate(:theme, remote_theme: remote, name: "Test< Theme") }
last_error_text: "can't reach repo :'(",
{ name: name, show_in_ui: show_in_ui, block: stats_block },
stats = { :last_day => 1, "7_days" => 10, "30_days" => 100, :count => 1000 }
stats = { "7_days" => 10, "30_days" => 100, :count => 1000 }
let(:token) { "test123" }
let(:requested_by_admin) { true }
after { Discourse.redis.keys("summary-new-users:*").each { |key| Discourse.redis.del(key) } }
let!(:new_today) do
score: 100.0,
topic: t,
raw: "Try to find this post",
raw: "I regret this post",
too_new =
_too_new_post =
/http:\/\/test.localhost\/forum\/email\/unsubscribe\/\h{64}/,
expect(html).to match(' lang="pl-PL"')
expect(html).to match(' xml:lang="pl-PL"')
let(:response_by_user) { Fabricate(:user, name: "John Doe") }
let(:category) { Fabricate(:category, name: "India") }
let(:tag1) { Fabricate(:tag, name: "Taggo") }
let(:tag2) { Fabricate(:tag, name: "Taggie") }
let(:post) { Fabricate(:post, topic: topic, raw: "This is My super duper cool topic") }
mail =
expect(mail.subject.scan(/#{tag1.name}/).count).to eq(1)
let(:response_by_user) { Fabricate(:user, name: "John Doe", username: "john") }
let(:topic) { Fabricate(:topic, title: "Super cool topic") }
let(:response_by_user) { Fabricate(:user, name: "", username: "john") }
let(:group) { Fabricate(:group, name: "my_group") }
let(:mail) do
data: { original_username: "bob" }.to_json,
let(:mail_type) { "user_#{notification_type}" }
let(:username) { "walterwhite" }
it "has a url" do
it "has an post_id" do
it "has an topic_id" do
body << "%{context}" if notification_type != :invited_to_topic
let(:mail_type) { "group_mentioned" }
let(:inviter) { Fabricate(:user) }
let(:invitee) { Fabricate(:user) }
let(:user) { Fabricate(:user, locale: locale) }
let(:mail_type) { mail_type }
let(:locale) { "fr" }
fab!(:group1) { Fabricate(:group, name: "group1") }
fab!(:group2) { Fabricate(:group, name: "group2") }
fab!(:group3) { Fabricate(:group, name: "group3") }
fab!(:admin) { Fabricate(:admin, username: "admin", name: nil) }
fab!(:posts) do
date = "May 25, 2020, 12:00pm"
fab! (:user) {
let (:template_args) {
let (:reject_mail) {
let(:trust_level_2) { build(:user, trust_level: 2) }
name: "Testers",
title: "Tester",
let(:raw) { "hello, how are you doing?" }
let(:step) { wizard.create_step("test-step") }
text = step.add_field(id: "test", type: "text")
dropdown.add_choice("nachos", data: { color: "yellow" })
let(:wizard) { Wizard.new(user) }
let(:step1) { wizard.create_step("first-step") }
let(:step2) { wizard.create_step("second-step") }
wizard.append_step("wat") { |step| expect(step).to be_present }
field = step1.add_field(id: "test", type: "text")
wizard.append_step("first") { |step| step.add_field(id: "another_element", type: "text") }
wizard.append_step("second") { |step| step.add_field(id: "another_element", type: "text") }
wizard.append_step("last", after: "second") do |step|
wizard.append_step("first") { |step| step.add_field(id: "element", type: "text") }
wizard.append_step("simple") { |step| step.add_field(id: "name", type: "text") }
let(:introduction_step) { wizard.steps.find { |s| s.id == "introduction" } }
let(:privacy_step) { wizard.steps.find { |s| s.id == "privacy" } }
count = defined?(::Chat) ? 5 : 4
if defined?(::Chat)
let(:styling_step) { wizard.steps.find { |s| s.id == "styling" } }
let(:branding_step) { wizard.steps.find { |s| s.id == "branding" } }
body_font: "open_sans",
body_font: "arial",
-1,
company_name: "ACME, Inc.",
let(:client_data_origin) { "http://localhost:3000" }
name: "My Yubikey",
let(:rp_id) { "localhost" }
let(:challenge_params) { { challenge: challenge, rp_id: rp_id, origin: "http://localhost:3000" } }
let(:rp_id) { "bad_rp_id" }
let(:params) { nil }
let(:params) { "test" }
let(:client_data_origin) { "http://localhost:4200" }
secure_session = {}
expect(Discourse.has_needed_version?("1.0.0", "1.0.0")).to eq(true)
expect(Discourse.has_needed_version?("2.0.0", "1.0.0")).to eq(true)
expect(Discourse.has_needed_version?("0.0.1", "1.0.0")).to eq(false)
expect(Discourse.has_needed_version?("1.1.0", "1.1.0")).to eq(true)
expect(Discourse.has_needed_version?("1.2.0", "1.1.0")).to eq(true)
expect(Discourse.has_needed_version?("2.0.0", "1.1.0")).to eq(true)
expect(Discourse.has_needed_version?("0.1.0", "0.1.0")).to eq(true)
expect(Discourse.has_needed_version?("1.0.0", "1.1.0")).to eq(false)
expect(Discourse.has_needed_version?("0.0.1", "0.1.0")).to eq(false)
expect(Discourse.has_needed_version?("2.0.0", "2.0.0")).to eq(true)
expect(Discourse.has_needed_version?("2.0.1", "2.0.0")).to eq(true)
expect(Discourse.has_needed_version?("1.12.0", "2.0.0")).to eq(false)
expect(Discourse.has_needed_version?("1.12.0", "2.12.5")).to eq(false)
expect(Discourse.has_needed_version?("1.3.0.beta3", "1.2.9")).to eq(true)
expect(Discourse.has_needed_version?("1.3.0.beta3", "1.3.0.beta1")).to eq(true)
expect(Discourse.has_needed_version?("1.3.0.beta3", "1.3.0.beta4")).to eq(false)
expect(Discourse.has_needed_version?("1.3.0.beta3", "1.3.0")).to eq(false)
expect(Discourse.has_needed_version?("1.2.0", "1.3.0.beta3")).to eq(false)
expect(Discourse.has_needed_version?("1.2.9", "1.3.0.beta3")).to eq(false)
expect(Discourse.has_needed_version?("1.3.0.beta1", "1.3.0.beta3")).to eq(false)
expect(Discourse.has_needed_version?("1.3.0.beta4", "1.3.0.beta3")).to eq(true)
expect(Discourse.has_needed_version?("1.3.0", "1.3.0.beta3")).to eq(true)
let(:version_list) { <<~YML }
fab!(:luke) { Fabricate(:user, username: "luke") }
expect(v.valid_value?("luke")).to eq(false)
let(:record) { Fabricate.build(:user, name: @name) }
@name = "Bigfoot"
http://xn--nw2a.xn--j6w193g/
it "#{valid_url} should be valid" do
let(:filename) { "discourse.csv" }
let(:csv_file) { file_from_fixtures(filename, "csv") }
).to be_valid
expect(subject.valid_value?("/foo/")).to eq(false)
expect(subject.valid_value?("f/o/o")).to eq(true)
expect(subject.valid_value?("\\p{Foo}")).to eq(false)
let(:record) { Fabricate.build(:topic) }
it "is up to date" do
record.title = "aaa"
expect(v.valid_value?("the_file")).to eq(true)
expect(v.valid_value?("hi")).to eq(false)
expect(v.valid_value?("a_b_c")).to eq(true)
expect(v.valid_value?("a b c")).to eq(false)
it "min and max" do
v = described_class.new(min: 3, max: 5)
expect(v.valid_value?("a")).to eq(false)
expect(v.valid_value?("a b c")).to eq(true)
expect(v.valid_value?("a b")).to eq(true)
it "min, max, and regex" do
v = described_class.new(min: 3, max: 12, regex: "bacon")
expect(v.valid_value?("go bacon!")).to eq(true)
expect(v.valid_value?("ba")).to eq(false)
expect { SiteSetting.search_ranking_weights = "{1.1,0.1,0.2,0.3}" }.to raise_error(
expect(validator.valid_value?("(()")).to eq(false)
expect(validator.valid_value?("(.)*")).to eq(false)
expect(validator.valid_value?('\d{3}-\d{4}')).to eq(true)
let(:valid_title) { "hello this is my cool topic! welcome: all;" }
let(:xxxxx_title) { valid_title.gsub(/./, "x") }
let(:post) { build(:post, topic: topic) }
let(:validator) { PostValidator.new({}) }
post.raw = ""
post.raw = "abc"
post = build(:post, topic: topic)
post.raw = "<!-- #{"very long comment" * SiteSetting.min_post_length} -->"
post.raw = "<!-- an html comment -->abc"
post.raw = "<!-- an html comment -->\n abc \n<!-- a comment -->"
post.raw = "<!-- <!-- an html comment --> -->"
fab!(:post) { Fabricate(:post, raw: "Non PM topic body", user: user, topic: topic) }
fab!(:pm_post) do
let(:new_post) { Fabricate.build(:post, user: user, raw: "unique content", topic: topic) }
def build_post(is_pm:, raw:)
new_post = build_post(is_pm: false, raw: post.raw)
new_post = build_post(is_pm: true, raw: pm_post.raw)
new_post = build_post(is_pm: true, raw: post.raw)
new_post = build_post(is_pm: false, raw: pm_post.raw)
post = Post.new(user: u, topic: topic, raw: "post number #{i}")
Post.create!(user: user, topic: topic, raw: "post number 2", post_number: 2)
Post.create!(user: user, topic: topic, raw: "post number 3", post_number: 3)
post = Post.new(user: user, topic: topic, raw: "post number 4", post_number: 4)
before { post.acting_user = build(:user, staged: true) }
@password = "p"
@password = ""
record.title = ":joy: :blush: :smile: is not only about emojis: Happiness::start()"
it "should not add an error for #{arg}" do
record.ip_address = "99.99.99"
subject(:validator) { described_class.new(min: -1, max: 3) }
it { expect(validator.valid_value?("*")).to eq false }
it { expect(validator.valid_value?("**")).to eq false }
it { expect(validator.valid_value?(".*")).to eq false }
it { expect(validator.valid_value?("a")).to eq true }
it { expect(validator.valid_value?("?")).to eq false }
it { expect(validator.valid_value?("??")).to eq false }
it { expect(validator.valid_value?(".?")).to eq false }
expect(blocks?("sam@sam.com")).to eq(false)
expect(blocks?("sam@sam.com")).to eq(true)
expect(blocks?("SAM@sam.com")).to eq(true)
expect(blocks?("sam@e-mail.com")).to eq(true)
let(:value) { "some new bad text" }
let(:record) { Fabricate(:post, raw: "this is a test") }
let(:attribute) { :raw }
let(:value) { "some new good text" }
fab!(:user) { Fabricate(:user, username: "john_doe", name: "John Doe") }
fab!(:group) { Fabricate(:group, name: "testgroup") }
fab!(:user2) { Fabricate(:user, username: "jane_doe", name: "Jane Doe", primary_group: group) }
fab!(:target_user1) { Fabricate(:user, username: "bobscreen") }
fab!(:acting_user) { Fabricate(:user) }
fab!(:acting_user) { Fabricate(:admin) }
it "does not double escape %3A (:)" do
url = "http://discourse.org/%3A/test"
it "does not double escape %2F (/)" do
url = "http://discourse.org/%2F/test"
expect(url).to eq("http://example.com/?a=%09%0D")
expect(url).to eq("http://example.com/%D9%85%D8%A7%D9%87%DB%8C")
url = "https://example.com/ article/id%3A1.2%2F1/bar"
expected = "https://xn--3s8h.example/%F0%9F%92%BB?computer=%F0%9F%92%BB"
let(:asset_host) { "//my.awesome.cdn" }
expect(cdn_url).to eq("#{asset_host}#{url}")
let(:secure) { true }
let(:secure) { false }
{ controller: "users", action: "index" },
let(:type) { nil }
let(:opts) { { type: type, creating: creating } }
let(:creating) { true }
let(:type) { "badge_image" }
let(:type) { "group_flair" }
let(:type) { "avatar" }
let(:type) { "custom_emoji" }
let(:type) { "profile_background" }
let(:type) { "category_logo" }
let(:type) { "category_background" }
let(:type) { "my_custom_type" }
let(:type) { "composer" }
let(:creating) { false }
public_path = "#{Discourse.store.public_dir}#{u.url}"
raw: "<a href=#{"/uploads/test/original/3X/a/6%0A/#{upload.sha1}.png"}>test</a>",
let(:post) { Fabricate(:post, raw: <<~SQL, user: user).tap(&:link_post_uploads) }
<a class="attachment" href="#{upload2.url}">some.pdf</a>
<a>blank</a>
File.read(file_from_fixtures("small.pdf", "pdf")),
<img src='#{upload.url}'>
let(:filename) { "utf-8.txt" }
end.to change { Upload.count }.by(1)
let(:filename) { "png_as.bin" }
let(:filename) { "tiff_as.bin" }
let(:filename) { "pngquant.png" }
let(:filename) { "should_be_jpeg.png" }
let(:small_filename) { "logo.png" }
let(:filename) { "should_be_jpeg.heic" }
let(:file) { file_from_fixtures(filename, "images") }
let(:filename) { "small.pdf" }
let(:file) { file_from_fixtures(filename, "pdf") }
let(:opts) { { type: "composer" } }
let(:pdf_filename) { "small.pdf" }
let(:pdf_file) { file_from_fixtures(pdf_filename, "pdf") }
before { existing_upload.update(url: "") }
let(:filename) { "logo.jpg" }
let(:opts) { {} }
let(:opts) { { for_private_message: true } }
let(:opts) { { for_group_message: true } }
let(:filename) { "smallest.ico" }
let(:b64) { Base64.encode64('<svg onmouseover="alert(alert)" />') }
file.write(<<~XML)
<defs>
<path id="pathdef" d="m0 0h100v100h-77z" stroke="#000" />
</defs>
<g>
<use id="valid-use" x="123" href="#pathdef" />
</g>
<use id="invalid-use1" href="https://svg.example.com/evil.svg" />
<use id="invalid-use2" href="data:image/svg+xml;base64,#{b64}" />
</svg>
let(:tiny_svg_filename) { "tiny.svg" }
let(:zero_sized_svg_filename) { "zero_sized.svg" }
let(:gif_file) { file_from_fixtures("animated.gif") }
event = Proc.new { |file, is_image, upload| upload.errors.add(:base, error) }
<a href='https://twitter.com/foo' target='_blank'>@foo</a> <a href='https://twitter.com/foobar' target='_blank'>@foobar</a>
<a href='https://twitter.com/search?q=%23foo' target='_blank'>#foo</a> <a href='https://twitter.com/search?q=%23foobar' target='_blank'>#foobar</a>
expect { p1.trash! }.to change { Post.count }.by(-1)
expect { p1.recover! }.to change { Post.count }.by(1)
fab!(:user) { Fabricate(:user, created_at: 1.days.ago) }
fab!(:fist_post) { Fabricate(:post, topic: topic) }
tba =
expect { topic_ids = tba.perform! }.to change { PostTiming.count }.by(-1)
type: "change_tags",
type: "append_tags",
fab!(:first_poster) { topic.user }
fab!(:p0) { Fabricate(:post, topic: topic) }
fab!(:p1) { Fabricate(:post, topic: topic, wiki: true) }
tv = TopicView.new(topic.id, evil_trout, { filter: "wiki" })
tv = TopicView.new(topic.id, evil_trout, { filter: "whatever" })
let!(:post) { Fabricate(:post, topic: topic, user: first_poster) }
let!(:post2) { Fabricate(:post, topic: topic, user: evil_trout) }
let!(:post3) { Fabricate(:post, topic: topic, user: user) }
let!(:post4) { Fabricate(:post, topic: topic, user: anonymous) }
let!(:admin) { Fabricate(:user, admin: true) }
let!(:post4) { Fabricate(:post, topic: topic, user: admin) }
fab!(:p1) { Fabricate(:post, topic: topic, user: first_poster, percent_rank: 1) }
fab!(:p2) { Fabricate(:post, topic: topic, user: evil_trout, percent_rank: 0.5) }
fab!(:p3) { Fabricate(:post, topic: topic, user: first_poster, percent_rank: 0) }
best = TopicView.new(topic.id, nil, best: 99, min_score: 99)
best =
best: 99,
let(:path) { "/1234" }
5.times { |i| Fabricate(:post, post_number: i + 1, topic: topic) }
2.times { |i| Fabricate(:post, post_number: i + 1, topic: topic) }
2.times { |i| Fabricate(:whisper, post_number: i + 3, topic: topic) }
).to eql("/1234?page=3")
let!(:post2) { Fabricate(:post, topic: topic, user: user) }
let!(:post4) { Fabricate(:post, topic: topic, user: user) }
let!(:post5) { Fabricate(:post, topic: topic, user: user) }
p2.user_id = nil
describe ".read?" do
let!(:p5) { Fabricate(:post, topic: topic, user: evil_trout) }
let!(:p2) { Fabricate(:post, topic: topic, user: evil_trout) }
let!(:p6) { Fabricate(:post, topic: topic, user: user, deleted_at: Time.now) }
let!(:p4) { Fabricate(:post, topic: topic, user: evil_trout, deleted_at: Time.now) }
let!(:p1) { Fabricate(:post, topic: topic, user: first_poster) }
let!(:p7) { Fabricate(:post, topic: topic, user: evil_trout, deleted_at: Time.now) }
let!(:p3) { Fabricate(:post, topic: topic, user: first_poster) }
p.sort_order = idx + 1
p6.user_id = nil # user got nuked
let(:asc) { true }
let(:asc) { false }
fab!(:tag1) { Fabricate(:tag, staff_topic_count: 0, public_topic_count: 0) }
fab!(:tag2) { Fabricate(:tag, staff_topic_count: 2, public_topic_count: 2) }
fab!(:op_post) { Fabricate(:post, topic: topic) }
fab!(:post1) { Fabricate(:post, topic: topic) }
expect(title).to eq("#{topic.title} - #2 by #{post1.user.username}")
expect(title).to eq("#{topic.title} - #3 by #{whisper.user.username}")
expect(title).to eq("#{topic.title} - #3")
expect(title).to eq("#{topic.title} - #4 by #{post2.user.username}")
let!(:post) { Fabricate(:post, topic: topic, user: first_poster, created_at: 18.hours.ago) }
let!(:post2) { Fabricate(:post, topic: topic, user: evil_trout, created_at: 6.hours.ago) }
let!(:post3) { Fabricate(:post, topic: topic, user: first_poster) }
let!(:p3) { Fabricate(:post, topic: topic) }
let!(:p2) { Fabricate(:post, topic: topic) }
let!(:p1) { Fabricate(:post, topic: topic) }
fab!(:op_upload) { Fabricate(:image_upload) }
.tap { |p| p.update_column(:image_upload_id, post3_upload.id) }
raw: "to the handler I say enqueue me!",
fab!(:post) { Fabricate(:post, topic: topic, created_at: 2.hours.ago) }
fab!(:post_2) { Fabricate(:post, topic: topic, created_at: 1.hour.ago) }
let(:queue_enabled) { true }
let(:queue_enabled) { false }
let!(:topic) { Fabricate(:topic, user: user, category: category) }
let!(:post1) { Fabricate(:post, topic: topic) }
let!(:post2) { Fabricate(:post, topic: topic) }
let!(:post3) { Fabricate(:post, topic: topic) }
let!(:post4) { Fabricate(:post, topic: topic) }
let!(:upload) { Fabricate(:secure_upload) }
let!(:upload3) { Fabricate(:upload) }
fab!(:creator) { Fabricate(:user) }
fab!(:tl4_user) { Fabricate(:trust_level_4) }
per_page = 3
(num_topics - 1)
.downto(0)
per_page: 10,
page: 0,
).pluck(:id),
fab!(:uppercase_tag) { Fabricate(:tag, name: "HeLlO") }
fab!(:no_tags_topic) { Fabricate(:topic) }
fab!(:tag_group) do
let(:synonym) { Fabricate(:tag, target_tag: tag, name: "synonym") }
expect(topics.any? { |t| t.tags.include?(tag) }).to eq(false)
.map(&:id),
.map(&:id)
.sort,
views: 10,
views: 50,
views: 1,
views: 2,
views: 30,
expect(topics.map(&:id)).to eq(
.new(admin, order: order, ascending: descending ? "false" : "true")
expect(ids_in_order("posts")).to eq(
expect(ids_in_order("posts", false)).to eq(
expect(ids_in_order("likes")).to eq(
expect(ids_in_order("likes", false)).to eq(
expect(ids_in_order("views")).to eq(
expect(ids_in_order("views", false)).to eq(
expect(ids_in_order("sheep")).to eq(
expect(ids_in_order("sheep", false)).to eq(
fab!(:topic_no_cat) { Fabricate(:topic) }
fab!(:topic_in_cat1) do
fab!(:fully_read) { Fabricate(:post, user: creator).topic }
let!(:new_topic) { Fabricate(:topic, user: creator, bumped_at: 10.minutes.ago) }
let!(:your_post) { create_post(user: user, topic: other_users_topic) }
let(:sender) { Fabricate(:user) }
before { clear_cache! }
let!(:new_topic) { Fabricate(:post, user: creator).topic }
let!(:closed_topic) { Fabricate(:topic, user: creator, closed: true) }
let!(:topic3) { Fabricate(:topic) }
let!(:topic4) { Fabricate(:topic) }
let!(:topic5) { Fabricate(:topic) }
let!(:topic6) { Fabricate(:topic) }
let!(:topic7) { Fabricate(:topic) }
{ result: Topic.order("id desc").limit(1), params: {} }
let(:plugin) { plugin_class.new }
topic_query.list_suggested_for(topic)&.topics&.map { |t| t.id }
tt = topic
let!(:new_topic) { Fabricate(:topic, created_at: 2.days.ago) }
let!(:old_topic) { Fabricate(:topic, created_at: 3.years.ago) }
let(:group_user) { Fabricate(:user) }
let!(:user) { group_user }
let!(:fully_read) { Fabricate(:post, user: creator).topic }
let!(:topic1) { Fabricate(:topic, user: user) }
let!(:topic5) { Fabricate(:topic, user: user, visible: false) }
let!(:topic6) { Fabricate(:topic, user: user2) }
fab!(:unread_topic) { Fabricate(:post).topic }
fab!(:new_topic) { Fabricate(:post).topic }
fab!(:read_topic) { Fabricate(:post).topic }
fab!(:user_3) { Fabricate(:user) }
fab!(:user_4) { Fabricate(:user) }
fab!(:group_2) do
user: user_3,
fab!(:pm_2) do
fab!(:pm_3) do
pm,
pm_2,
pm.tags << tag
.new(user_2)
fab!(:op) { Fabricate(:post, topic: topic) }
}.to change { Notification.count }.by(1)
raw: "this is a new post",
title: "this is a new title",
raw: "this is a new email",
opts =
import_topic_id: "foo",
import_id: "bar",
fab!(:tag1) { Fabricate(:tag, name: "fun") }
fab!(:tag2) { Fabricate(:tag, name: "fun2") }
fab!(:tag3) { Fabricate(:tag, name: "fun3") }
fab!(:tag4) { Fabricate(:tag, name: "fun4") }
fab!(:tag5) { Fabricate(:tag, name: "fun5") }
fab!(:word1) do
fab!(:word2) do
fab!(:word3) do
title: "This is a #{word1.word} title",
raw: "#{word2.word.upcase} is not the same as #{word3.word.upcase}",
fab!(:category) { Fabricate(:category, name: "beta", minimum_required_tags: 2) }
).to be_falsy
name: "beta",
tc =
time2 = Time.zone.parse("2020-03-10 15:17")
valid_attrs.merge(created_at: "2019-09-02", pinned_at: "2020-03-10 15:17"),
file_name = "test.zip"
Dir.chdir(@temp_folder) { `tar -cvzf test.tar.gz test/* 2> /dev/null` }
file_name = "test.tar.gz"
let(:rand_hex) { +"X" << SecureRandom.hex }
let!(:theme) do
theme.set_field(target: :common, name: :body_tag, value: "<b>testtheme1</b>")
value: { en: { key: "value" } }.deep_stringify_keys.to_yaml,
name: "other_logo",
remote_url: "",
theme_version: "1.0",
cs1 =
cs2 =
let(:dir) do
dir = "#{tmpdir}/#{SecureRandom.hex}"
after { FileUtils.rm_rf(dir) }
folders = Dir.glob("**/*").reject { |f| File.file?(f) }
files = Dir.glob("**/*").reject { |f| File.directory?(f) }
assets: {
expect(File.read("common/body_tag.html")).to eq("<b>testtheme1</b>")
{ en: { key: "value" } }.deep_stringify_keys.to_yaml,
let(:url) { "https://github.com/example/example.git" }
let(:branch) { "dev" }
hex = "xxx"
.with("github.com")
field = ThemeField.create!(theme_id: 1, target_id: 3, name: "yaml", value: yaml)
.load { |name, default, type, opts| @settings << setting(name, default, type, opts) }
def setting(name, default, type, opts = {})
{ name: name, default: default, type: type, opts: opts }
let(:loader) { Loader.new }
int_setting.value = "4.3"
string_setting.value = "ab" * 10
template = "<h1>hello</h1>"
{ "discourse/components/mycomponent.hbs" => '{{theme-i18n "my_translation_key"}}' },
sources = {
fab!(:theme) do
expect(TextSentinel.new((" " * 10) + "x").entropy).to eq(1)
expect(TextSentinel.new("{{$!")).not_to be_valid
let(:duplicated_string) { "my precious!!!!" }
let(:duplicated_string) { "please help me????" }
let(:regular_case) { "entire text is all caps" }
let(:lowercased) { "this is awesome" }
let(:capitalized) { "This is awesome" }
let(:iletter) { "iLetter" }
let(:with_one_period) { "oops." }
let(:with_several_periods) { "oops..." }
let(:without_period) { "oops" }
).to eq(without_period + " ")
let(:with_space_exclamation) { "oops !" }
let(:without_space_exclamation) { "oops!" }
let(:with_space_question) { "oops ?" }
let(:without_space_question) { "oops?" }
without_space_question + " ",
let(:unspacey_string) { "test" }
let(:with_invalid_bytes) { "abc\u3042\x81" }
let(:without_invalid_bytes) { "abc\u3042" }
user_de = Fabricate(:user, locale: "de")
expect(SvgSprite.raw_svg("this-is-not-an-icon")).to eq("")
let(:upload_s3) { Fabricate(:upload_s3) }
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
</symbol>
expect(link).to eq("")
expect(link).not_to eq("")
c.set_field(target: :common, name: "scss", value: ".child_common{.scss{color: red;}}")
c.set_field(target: :desktop, name: "scss", value: ".child_desktop{.scss{color: red;}}")
c.set_field(target: :mobile, name: "scss", value: ".child_mobile{.scss{color: red;}}")
value: ".child_embedded{.scss{color: red;}}",
t.set_field(target: :common, name: "scss", value: ".common{.scss{color: red;}}")
t.set_field(target: :desktop, name: "scss", value: ".desktop{.scss{color: red;}}")
t.set_field(target: :mobile, name: "scss", value: ".mobile{.scss{color: red;}}")
t.set_field(target: :common, name: "embedded_scss", value: ".embedded{.scss{color: red;}}")
expect(css).to match(/\.common/)
expect(css).to match(/\.desktop/)
expect(tag).to have_tag("link", with: { "data-theme-name" => theme.name.downcase })
expect(tag).to have_tag("link", with: { "data-theme-name" => child_theme.name.downcase })
z.set_field(target: :desktop, name: "scss", value: ".child_desktop{.scss{color: red;}}")
t.set_field(target: :desktop, name: "scss", value: ".child_desktop{.scss{color: red;}}")
t.set_field(target: :desktop, name: "scss", value: ".el{color: red;}")
value: ".scss{color: red;}",
child_with_mobile_scss.set_field(target: :mobile, name: :scss, value: "body { color: red; }")
let(:image2) { file_from_fixtures("logo-dev.png") }
name: "icon",
value: "body {color: fuchsia}",
cs = Fabricate(:color_scheme, name: 'Funky Bunch -_ @#$*(')
}.to change(preload_list, :size).by(1)
value: ":root {--special: rebeccapurple;}",
let(:scss_child) { ':root {--child-definition: #{dark-light-choose(#c00, #fff)};}' }
scss = "$test: $missing-var;"
scss = "body{ border: 2px solid $primary;}"
t.set_field(target: :common, name: :scss, value: "body { background: green }")
expect(results.size).to eq(22) # (3 themes * 2 targets) + 16 color schemes (2 themes * 8 color schemes (7 defaults + 1 theme scheme))
results.count { |target| target =~ /^#{tar}_(#{user_theme.id}|#{default_theme.id})$/ },
theme_id: t.id,
value: "body { background: url($logo); border: 3px solid green; }",
default_font = ":root{--font-family: Arial, sans-serif}"
let(:scss) { ":root{--custom-color: green}" }
expect(styles).to include("--custom-color-rgb: 0, 0, 128")
next if path =~ /ember_cli/
path = File.basename(path, ".scss")
it "can compile '#{path}' css" do
let!(:upload) do
name: "primary",
name: "scss",
value: "body { background: $primary }",
css, _map =
scss +=
expect(css).to include("--primary:")
name: "Stylish",
.glob(Rails.root.join("app/assets/stylesheets/**/*/"))
.each do |dir|
.glob("#{dir}_index.scss")
if !contents.match(/@import "#{filename}";/)
refs << "#{filename} import missing in #{indexfile}"
css, _ = Stylesheet::Compiler.compile("a{right:1px}", "test.scss", rtl: true)
expect(css).to eq("a{left:1px}")
let(:default_slug) { "topic" }
expect(Slug.for("=213=-!(@#+@)(!*_(@#&(!)#")).to eq default_slug
expect(Slug.for("", "king")).to eq "king"
expect(Slug.for("o_o_o")).to eq("o-o-o")
expect(Slug.for("")).to eq(default_slug)
expect(Slug.for("Jeff hate's !~-_|,=#this")).to eq("jeff-hates-this")
).to eq(
expect(Slug.for("2- -this!~-_|,we-#-=^-")).to eq("2-this-we")
expect { URI.parse("http://example.com/#{slug}") }.not_to raise_error
expect(Slug.ascii_generator("a.b.c")).to eq("a-b-c")
expect(Slug.ascii_generator("a....b.....c")).to eq("a-b-c")
expect(Slug.ascii_generator("hello...")).to eq("hello")
expect(Slug.ascii_generator("...hello")).to eq("hello")
expect(Slug.ascii_generator("")).to eq("")
expect(Slug.encoded_generator("")).to eq("")
expect(Slug.none_generator("")).to eq("")
expect(Slug.none_generator("31")).to eq("")
def setting(category, name, default = nil, opts = {})
let!(:receiver) { Receiver.new }
receiver.expects(:setting).with("category1", "title", "My Site", {}).once
receiver.expects(:setting).with("category3", "reply_by_email_address", "", {}).once
receiver.expects(:setting).with("category2", "tos_url", "", { client: true })
category == ("basics") && name == ("default_locale") && default == ("en") &&
{ min: 2, client: true, locale_default: { zh_CN: 2, zh_TW: 2 } },
validate("")
it "should be ok" do
it "is ok" do
it "is not ok" do
v < 10
{ type: "array", items: { type: "object", properties: { name: { type: "string" } } } }
settings.setting(:type_upload, "", type: "upload")
let(:true_val) { "t" }
let(:false_val) { "f" }
it "writes `f` if given not `true` value" do
1.2,
1.0,
it "returns true when it is true or `t` or `true`" do
described_class::Setting.new(name, data_type).tap { |s| s.value = value }
provider.save("test", "bla", 2)
provider.save("test", "bla1", 2)
provider.save("one", "two", 3)
expect_same_setting(provider.find("one"), setting("one", "two", 3))
provider.save("one", "three", 4)
expect_same_setting(provider.find("one"), setting("one", "three", 4))
settings.setting(:test_override, "default", locale_default: { zh_CN: "cn" })
settings.setting(:test_default, "test", regex: '^\S+$')
test_override: "cn",
let(:val) { "env_overridden" }
provider.save("test", "one", 1)
provider.save("test", "two", 2)
provider.save("test2", "three", 3)
all = provider.all.sort { |a, b| a.name <=> b.name }
t1 =
t2 =
settings.foo = "baz"
%Q|{"default_locale":"#{SiteSetting.default_locale}","upload_type":"#{upload.url}","string_type":"haha"}|,
upload.update!(url: "a_new_url")
%Q|{"default_locale":"#{SiteSetting.default_locale}","upload_type":"a_new_url","string_type":"changed"}|,
test_setting: "test description <a href='%{base_path}/admin'>/admin</a>",
settings.set("test_str", "hi")
settings.setting(:test_str, "bob", regex: "hi", regex_error: "oops")
settings.test_str = "a"
settings.setting(:"trout_api_key_#{index}", "evil")
it "refresh!" do
let(:upload) { Fabricate(:image_upload, width: 200, height: 200) }
post = Fabricate(:post, raw: "<img src='#{upload.url}'>")
let(:upload) { Fabricate(:s3_image_upload, width: 200, height: 200) }
expect { create_topic }.to change { Topic.count }.by(1).and change { Post.count }.by(1)
expect { create_topic("privacy_topic_id") }.to change { Topic.count }.by(1).and change {
SiteSetting.welcome_topic_id = (Topic.maximum(:id) || 0) + 1
{ id: "guidelines_topic_id", name: I18n.t("guidelines_topic.title"), selected: true },
{ id: "welcome_topic_id", name: "Changed Topic Title", selected: false },
}.and not_change { Topic.count }
Category.last.update!(name: "Foo", slug: "foo")
{ id: "meta_category_id", name: I18n.t("meta_category_name"), selected: true },
{ id: "general_category_id", name: I18n.t("general_category_name"), selected: false },
s.set(key, "test2", expires: 5.minutes)
s.set(key, "test2")
def create_request(request_method: "GET", path: "/")
.with({ random_param: "hello" })
.returns({ callback_params: { call_me_back: 4314 } })
) do |ex|
describe "#run!" do
manager.run!(create_request, { hello_world: 331 }, {})
.with({ expect_me: 131 })
redirect_url: "/gg",
.with({})
params = { a: 1 }
results = manager.run!(action.request, {}, {})
.with({ call_me_back: 4314 })
.returns({ eviltrout: "goodbye :(" })
expect(results.data).to eq({ eviltrout: "goodbye :(" })
}.from(false).to(true)
{ logout: true, return_sso_url: "http://hobbit.shire.com/sso" },
expect(Search.ts_config("en_GB")).to eq("english")
expect(Search.ts_config("xx")).to eq("simple")
cooked = <<~RAW
fab!(:post_2) { Fabricate(:post, raw: "Cette oeuvre d'art n'est pas une *****") }
fab!(:topic2) { Fabricate(:topic, title: "Some random topic title") }
fab!(:post1) { Fabricate(:post, raw: "start", topic: topic) }
fab!(:post2) { Fabricate(:post, raw: "#{"start " * 100}", topic: topic2) }
fab!(:post_1) { Fabricate(:post, raw: "searching for: John's") }
fab!(:post_2) { Fabricate(:post, raw: "searching for: Johns") }
fab!(:user) { Fabricate(:user, username: "DonaldDuck") }
name: "user_field_#{user_field2.id}",
expect(result.users.find { |u| u.id == user.id }.custom_data).to eq(
{ name: "custom field", value: "test" },
{ name: "another custom field", value: "longer test" },
expect(result.users.find { |u| u.id == user2.id }.custom_data).to eq(
Fabricate(:post, topic: topic, raw: 'this <b>fun test</b> <img src="bla" title="my image">')
@user = Fabricate(:user, username: "fred", name: "bob jones")
term =
expect(term == "capybara").to eq(false)
expect(term == '"discourse"').to eq(false)
expect(search.term).to eq("")
search = Search.new("a b c d", min_search_term_length: 5)
search = Search.new('"a b c d"', min_search_term_length: 5)
expect(search.term).to eq('"a b c d"')
let!(:post) { Fabricate(:post, raw: "hello world") }
let(:result) { Search.execute("bruce", type_filter: "user") }
let(:result) { Search.execute("bruce") }
let(:staged) { Fabricate(:staged) }
let!(:current) { Fabricate(:user, admin: true, username: "current_user") }
Fabricate(:post, user: u, topic: pm)
group.users.each { |u| Fabricate(:post, user: u, topic: pm) }
let!(:u1) { Fabricate(:user, username: "fred", name: "bob jones", email: "foo+1@bar.baz") }
let!(:u2) { Fabricate(:user, username: "bob", name: "fred jones", email: "foo+2@bar.baz") }
let!(:u3) { Fabricate(:user, username: "jones", name: "bob fred", email: "foo+3@bar.baz") }
let!(:u4) do
Fabricate(:user, username: "alice", name: "bob fred", email: "foo+4@bar.baz", admin: true)
let!(:public_topic) { Fabricate(:topic, user: u1) }
user: u1,
let!(:public_post2) { Fabricate(:post, topic: public_topic, raw: "ham and spam", user: u2) }
post.update!(raw: "#{post.raw} elephant")
post = Fabricate(:post, topic: topic, raw: "this is a play post")
post3 = Fabricate(:post, raw: "this is a play post")
5.times { Fabricate(:post, topic: topic, raw: "play playing played") }
post_1 = Fabricate(:post, raw: "this is a play post")
let(:result) { Search.execute("hundred", type_filter: "topic") }
create_post(raw: "this is the raw body", title: "I am a title yeah")
let!(:p1) { Fabricate(:post, topic: personal_message, post_number: 1) }
let!(:post) { Fabricate(:post, topic: topic, raw: "snow monkey") }
slug: "test",
let!(:post2) do
&:id
let!(:group) { Fabricate(:group) }
let!(:group) { Fabricate(:group, name: "plugin-special") }
let!(:tag) { Fabricate(:tag) }
let!(:uppercase_tag) { Fabricate(:tag, name: "HeLlO") }
let(:post) { Fabricate(:post, raw: "I am special post") }
category_tag = Fabricate(:tag, name: "#{tag.name}9")
let!(:user) { Fabricate(:user, username: "amazing", email: "amazing@amazing.com") }
let(:results) { Search.execute("amazing", type_filter: "user") }
sub_post =
post = Fabricate(:post, topic: topic, user: topic.user, raw: "This is my hello")
let!(:post_2) { Fabricate(:post, topic: topic_2) }
let!(:bookmark_post2) { Fabricate(:post, raw: "wow some other cool thing") }
post = Fabricate(:post, raw: "this is a test 248", wiki: true, topic: topic)
Fabricate(:post, raw: "this is a test 248", wiki: false, topic: topic_2)
post_2 = Fabricate(:post, raw: "longan is logan", topic: topic_2)
time = Time.zone.parse("2001-05-20 2:55")
post_1 = Fabricate(:post, raw: "hi this is a test 123 123", created_at: time.months_ago(2))
post_1 = Fabricate(:post, raw: "hi this is a test 123 123", topic: topic)
fab!(:topic) { Fabricate(:topic, created_at: 3.months.ago) }
fab!(:group) { Fabricate(:group, name: "Like_a_Boss").tap { |g| g.add(user) } }
fab!(:group_2) { Fabricate(:group).tap { |g| g.add(user_2) } }
let!(:post) { Fabricate(:post, raw: "hi this is a test 123 123", topic: topic, user: user) }
let!(:post_2) { Fabricate(:post, user: user_2) }
Proc.new { |query, term, guardian| query.where.not(name: "Like_a_Boss") },
post = Fabricate(:post, raw: "hi this is a test 123 123", topic: topic)
badge = Badge.create!(name: "Like a Boss", badge_type_id: 1)
post = Fabricate(:post, raw: "3.0 eta is in 2 days horrah")
post2 = Fabricate(:post, raw: "3.0 is eta in 2 days horrah")
post = Fabricate(:post, raw: "hi this is a test 123 123")
post2 = Fabricate(:post, raw: "that Sam I am, that Sam I am", created_at: 5.minutes.ago)
post = Fabricate(:post, raw: "Topic", topic: topic)
post2 = Fabricate(:post, raw: "Topic", topic: topic2)
post = Fabricate(:post, raw: "Will.2000 Will.Bob.Bill...")
post = Fabricate(:post, raw: "i like http://wb.camra.org.uk/latest#test so yay")
Fabricate(:tag, name: "alpha"),
Fabricate(:tag, name: "HeLlO"),
category = Fabricate(:category, name: "top", slug: "top")
leaf = Fabricate(:category, name: "leaf", slug: "leaf", parent_category_id: sub.id)
_post = Fabricate(:post, raw: "Sams first post", topic: topic)
Fabricate(:post, raw: "testing #1 #9998")
results = Search.new("xxx #:").execute
fab!(:tag1) { Fabricate(:tag, name: "lunch") }
fab!(:tag2) { Fabricate(:tag, name: "eggs") }
fab!(:tag3) { Fabricate(:tag, name: "sandwiches") }
fab!(:post1) { indexed_post(topic: topic1) }
fab!(:post2) { indexed_post(topic: topic2) }
fab!(:post3) { indexed_post(topic: topic3) }
fab!(:post4) { indexed_post(topic: topic4) }
fab!(:post5) { indexed_post(topic: topic5) }
raw: "Wakey, wakey, eggs and bakey.",
raw: "Bakey, bakey, eggs to makey.",
str = +" grigio:babel deprecated? "
expect { DB.exec(+"SELECT to_tsvector('bbb') @@ " << ts_query) }.to_not raise_error
ts_query = Search.ts_query(term: "foo.bar/'&baz", ts_config: "simple")
time = Time.zone.parse("2001-02-20 2:55")
s = Search.new("indiana jones", search_type: :header, ip_address: "127.0.0.1")
s = Search.new("foo bar", ip_address: "127.0.0.1")
let(:number_of_results) { 2 }
let!(:post1) { Fabricate(:post, raw: "hello hello hello hello hello") }
let!(:post2) { Fabricate(:post, raw: "hello hello hello hello") }
let!(:post3) { Fabricate(:post, raw: "hello hello hello") }
let!(:post4) { Fabricate(:post, raw: "hello hello") }
let!(:post5) { Fabricate(:post, raw: "hello") }
search = Search.new("hello", search_type: :full_page, type_filter: "topic", page: 3)
_post6 = Fabricate(:post, raw: "hello post #6")
let!(:topic) { Fabricate(:topic, title: "This is a topic with a bunch of posts") }
let!(:post1) { Fabricate(:post, topic: topic, raw: "hola amiga") }
let!(:post2) { Fabricate(:post, topic: topic, raw: "hola amigo") }
let!(:post3) { Fabricate(:post, topic: topic, raw: "hola chica") }
let!(:post4) { Fabricate(:post, topic: topic, raw: "hola chico") }
let!(:post5) { Fabricate(:post, topic: topic, raw: "hola hermana") }
let!(:post6) { Fabricate(:post, topic: topic, raw: "hola hermano") }
let!(:post7) { Fabricate(:post, topic: topic, raw: "hola chiquito") }
_post = Fabricate(:post, topic: topic, raw: "this is the first post")
let!(:post0) do
Search.advanced_filter(/^min_chars:(\d+)$/) do |posts, match|
fab!(:group) { Fabricate(:group, name: "bruce-world-fans") }
fab!(:topic) { Fabricate(:topic, title: "Bruce topic not a result") }
raw: "this topic is a story about some person #{"sam " * 100}",
scss_theme.set_field(target: :common, name: "scss", value: ".scss{color: red;}")
fab!(:post) { Fabricate(:post, reads: 111) }
fab!(:another_post) { Fabricate(:post, topic: post.topic, reads: 222) }
till = Time.now + (timeout.to_f / 1000)
sleep 0.001 while Time.now < till && !blk.call
@defer.later("first") {}
@defer.later("second") {}
@defer.later("bad") { raise "boom" }
wait_for(200) { @defer.length == 0 }
10.times { @defer.later("fast job") {} }
wait_for(200) { l.errors.length == 1 }
@defer.later { x = 2 }
@defer.later { x = 3 }
wait_for(1000) { x == 3 }
expect(x).to eq(3)
s = nil
wait_for(1000) { @defer.stopped? }
@defer.later { s = "good" }
wait_for(1000) { s == "good" }
expect(s).to eq("good")
->(context) {
key: "example1.csv.gz",
owner: {
size: 11,
key: "example2.csv.gz",
expect(output).to eq("#{@upload1.url}\n#{@no_etag.url}\n2 of 5 uploads are missing\n")
expect(output).to eq(<<~TEXT)
).to eq(12)
).to eq(7)
}.by(-2)
expect(output).to eq("#{upload.url}\n#{no_etag.url}\n2 of 5 uploads are missing\n")
let(:bucket_name) { "s3-upload-bucket" }
let(:subfolder_path) { "subfolder" }
@lifecycle = <<~XML
<Rule>
</Rule>
).to_return(status: 200, body: @lifecycle, headers: {})
.with do |req|
helper = S3Helper.new("bob", "tomb")
{ "some/bucket" => "bucket/testing", "some" => "testing" }.each do |bucket_name, prefix|
let(:s3_helper) { S3Helper.new("test-bucket", "", client: client) }
.with(source_stub, {})
.returns(stub(copy_object_result: stub(etag: '"etag"')))
.returns(stub(data: stub(etag: '"etag"')))
Aws::S3::Errors::NoSuchCORSConfiguration.new("", {}),
.raises(Aws::S3::Errors::AccessDenied.new("test", "test", {}))
let(:use_db_s3_config) { false }
let(:use_db_s3_config) { true }
before { user.locale = "he" }
expect(Rtl.new(user).css_class).to eq("")
before { user.stubs(:locale).returns("he") }
attributes = (1..1000).map { |x| " attr#{x}='1' " }.join
<body #{attributes}>
body: "<html><title>very amazing</title>",
stub_request(:get, "https://cat.com/meow").to_return(
stub_request(:get, "https://example.com").to_return(status: 404, body: "")
body: "<html><head><title>Internet - Wikipedia</ti",
body: "<html><head><title>Internet - Wikipedia</title>",
RateLimiter.new(user, "peppermind-servant", 5, 40, staff_limit: { max: 10, secs: 80 })
RateLimiter.new(admin, "peppermind-servant", 5, 40, staff_limit: { max: 10, secs: 80 })
limiter = RateLimiter.new(nil, "test", 2, 30, global: true)
fab!(:post) { Fabricate(:post, raw: "This has **text** we _are_ matching") }
expect(qc("")).to be_modified
) { @result = promotion.review }
<p>ddd</p>
).to eq(n(expected))
let(:md) { <<~MD }
<p>This is a quote with an emoji shortcut :)</p>
:smile_cat: :smile_cat:
:smile_cat: :smile_cat: :smile_cat: :smile_cat:
baz? :smile_cat:
<img src="/images/emoji/twitter/smile_cat.png?v=#{Emoji::EMOJI_VERSION}" title=":smile_cat:" class="emoji only-emoji" alt=":smile_cat:" loading="lazy" width="20" height="20"><br>
baz? <img src="/images/emoji/twitter/smile_cat.png?v=#{Emoji::EMOJI_VERSION}" title=":smile_cat:" class="emoji" alt=":smile_cat:" loading="lazy" width="20" height="20"><br>
<img src="/images/emoji/twitter/wink.png?v=#{Emoji::EMOJI_VERSION}" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"> foo<br>
<a href="http://test.localhost/t/#{topic.id}/3">#{I18n.t("on_another_topic")}</a>
<p>I have nothing to say.</p>
<a href="http://test.localhost/t/this-is-an-off-topic-topic/#{topic.id}/3">#{topic.title}</a>
fab!(:user) { Fabricate(:user, primary_group: group) }
<aside class="quote group-#{group.name}" data-username="#{user.username}" data-post="2" data-topic="#{topic.id}">
<p>te <strong>s</strong> t</p>
nested = <<~MD
).to match_html "<p><span class=\"mention\">@hello</span> <span class=\"mention\">@hello</span> <span class=\"mention\">@hello</span></p>"
expect(PrettyText.cook("hi\n@s")).to eq("<p>hi<br>\n<span class=\"mention\">@s</span></p>")
expect(PrettyText.cook("hi\n@ss")).to eq("<p>hi<br>\n<span class=\"mention\">@ss</span></p>")
expect(PrettyText.cook("hi\n@s.")).to eq("<p>hi<br>\n<span class=\"mention\">@s</span>.</p>")
expect(PrettyText.cook("hi\n@s.s")).to eq(
expect(PrettyText.cook("hi\n@.s.s")).to eq("<p>hi<br>\n@.s.s</p>")
name: "Group2",
%Q|<p>test <a class="mention-group" href="/groups/#{group.name}">@#{group.name}</a> test</p>|,
%Q|<p>test <a class="mention-group notify" href="/groups/#{group.name}">@#{group.name}</a> test</p>|,
%Q|<p>something <span class="mention">@#{user.username}</span> something</p>|,
expect(PrettyText.cook("hi @user")).to eq("<p>hi @user</p>")
expect(PrettyText.cook("<a> @inner</a> ")).to match_html "<p><a> @inner</a></p>"
).to match_html '<p><a href="http://site.com" rel="noopener nofollow ugc">link @inner</a></p>'
).to match_html "<p><span class=\"mention\">@hello</span> <span class=\"mention\">@hello-hello</span></p>"
expect(PrettyText.cook("hello @bob's @bob,@bob; @bob\"")).to match_html(
code = <<~MD
<p>X</p>
</code></pre>
expect(PrettyText.cook("```cpp\ncpp\n```")).to match_html(
expect(PrettyText.cook("```\ncpp\n```")).to match_html(
expect(PrettyText.cook("```text\ncpp\n```")).to match_html(
expect(PrettyText.cook("```INVALID a=1\n```")).to match_html(
expect(PrettyText.cook("```INVALID a=1, foo=bar , baz=2\n```")).to match_html(
expect(PrettyText.cook("```text\n```")).to match_html(
expect(PrettyText.cook("```auto\n```")).to match_html(
expect(PrettyText.cook("```ruby startline=3 $%@#\n```")).to match_html(
).to match_html(
expect(PrettyText.cook("```c++\nc++\n```")).to match_html(
expect(PrettyText.cook("```p21\np21\n```")).to match_html(
PrettyText.cook("<pre data-code='3' data-code-foo='1' data-malicous-code='2'></pre>"),
).to match_html("<pre data-code-foo='1'></pre>")
console.log("You are an admin.");
/* end admins only <span class="bidi-warning" title="#{hidden_bidi_title}">&lt;U+202E&gt;</span>*/<span class="bidi-warning" title="#{hidden_bidi_title}">&lt;U+2066&gt;</span> }
formatted_bidi = format("&lt;U+%04X&gt;", bidi.ord)
<code>#{bidi}</code>
<p><code><span class="bidi-warning" title="#{I18n.t("post.hidden_bidi_character")}">#{formatted_bidi}</span></code></p>
<pre>#{bidi}</pre>
<pre><span class="bidi-warning" title="#{I18n.t("post.hidden_bidi_character")}">#{formatted_bidi}</span></pre>
expect(PrettyText.cook('<a href="http://cnn.com">cnn</a>')).to match(/noopener nofollow ugc/)
PrettyText.cook("<a href='#{Discourse.base_url}/test.html'>cnn</a>") !~ /nofollow ugc/,
) !~ /nofollow ugc/,
).to match(/nofollow ugc/)
expect(PrettyText.cook("<a href='http://foo.com/test.html'>cnn</a>") !~ /nofollow ugc/).to eq(
expect(PrettyText.cook("<a href='http://afoo.com/test.html'>cnn</a>")).to match(
PrettyText.cook("<a href='http://bar.foo.com/test.html'>cnn</a>") !~ /nofollow ugc/,
PrettyText.cook('<a href="http://cnn.com">cnn</a>', omit_nofollow: true) !~ /nofollow ugc/,
raw_html = '<a href="https://www.mysite.com/" target="_blank">Check out my site!</a>'
spinner = "<a href=\"http://thedailywtf.com/\" data-bbcode=\"' class='fa fa-spin\">WTF</a>"
expect(PrettyText.excerpt("<img src='http://cnn.com/a.gif' alt>", 100)).to eq(
expect(PrettyText.excerpt("<img src='http://cnn.com/a.gif' title='car'>", 100)).to eq(
expect(PrettyText.excerpt("<img src='http://cnn.com/a.gif' title>", 100)).to eq(
PrettyText.excerpt("<img src='http://cnn.com/a.gif'>", 100, strip_images: true),
).to eq("Hello world!")
html = "<img src='http://cnn.com/a.gif'> Hello world #{emoji_image}"
).to match_html("Hello world #{emoji_image}")
expect(PrettyText.excerpt(html, 7)).to eq(":bike: &hellip;")
expect(PrettyText.excerpt(html, 8)).to eq(":bike: &hellip;")
expect(PrettyText.excerpt(html, 9)).to eq(":bike: &hellip;")
expect(PrettyText.excerpt(html, 12)).to eq(":bike: :cat: &hellip;")
expect(PrettyText.excerpt(html, 13)).to eq(":bike: :cat: &hellip;")
expect(PrettyText.excerpt(html, 14)).to eq(":bike: :cat: &hellip;")
expect(PrettyText.excerpt("<a href='http://cnn.com'>cnn</a>", 100, strip_links: true)).to eq(
PrettyText.excerpt("<a href='http://cnn.com'>cnn</a>", 100),
).to match_html "<a href='http://cnn.com'>cnn</a>"
expect(PrettyText.excerpt("<pre><b></pre>", 100)).to eq("")
expect(PrettyText.excerpt("<p>hello</p><p>world</p>", 6)).to eq("hello w&hellip;")
expect(PrettyText.excerpt("<p>a</p><p>b</p>", 5)).to eq("a b")
expect(PrettyText.excerpt("<aside class='quote'><p>a</p><p>b</p></aside>boom", 5)).to eq(
PrettyText.excerpt("<a href='http://cnn.com'>cnn</a>", 3),
PrettyText.excerpt("<a href='http://cnn.com'>cnn</a>", 2, text_entities: true),
).to match_html "<a href='http://cnn.com'>cn...</a>"
PrettyText.excerpt("<a href='http://cnn.com'>cnn</a>", 2),
).to match_html "<a href='http://cnn.com'>cn&hellip;</a>"
).to_a,
expect(extract_urls("<aside class=\"quote\" data-topic=\"321\">aside</aside>")).to eq(
<a href="https://example.com">example</a>
extract_urls("<aside class=\"quote\" data-topic=\"1234\" data-post=\"4567\">aside</aside>"),
<a href='http://body_only.com'>http://useless1.com</a>
<aside class=\"quote\" data-topic=\"1234\">
<a href='http://body_and_quote.com'>http://useless3.com</a>
<a href='http://quote_only.com'>http://useless4.com</a>
<a href='http://body_and_quote.com'>http://useless2.com</a>
</header>
<div class="tweet">Example URL: <a target="_blank" href="https://example.com" rel="noopener">example.com</a></div>
</article>
).to eq("&lt;h3&gt;Hours&lt;/h3&gt;")
raw = <<~MD
expect(PrettyText.excerpt("<div class='excerpt'>hi</div> test", 100)).to eq("hi")
expect(PrettyText.excerpt("<span class='excerpt'>hi</span> test", 100)).to eq("hi")
two_hundred = "123456789 " * 20 + "."
text = two_hundred + "<div class='excerpt'>#{two_hundred}</div>" + two_hundred
text = two_hundred + "<span class='excerpt'>#{two_hundred}</span>" + two_hundred
expect(PrettyText.excerpt("&#39;", 500, text_entities: true)).to eq("'")
).to eq("#{expected}\n\n#{expected}")
).to eq("boom")
<p>Listen to this!</p>
ellipsis = "&hellip;"
expect(PrettyText.strip_links("I'm the <b>batman</b>")).to eq("I'm the <b>batman</b>")
).to eq("I'm the linked batman")
).to eq("I'm the linked &lt;batman&gt;")
html = "<img src=\"wat.png\">"
let(:base_url) { "http://baseurl.net" }
html = "<p>Check out <a href=\"http://mywebsite.com/users/boss\">this guy</a>.</p>"
html = "<p>Check out <a href=\"#{base_url}/users/boss\">this guy</a>.</p>"
html = "<p>Check out <a href=\"not a real url\">this guy</a>.</p>"
html = "<p>Contact me at <a href=\"mailto:username@me.com\">this address</a>.</p>"
it "converts <iframe> to <a>" do
<p>This is a Vimeo link:</p>
expect(md).to match_html(<<~HTML)
<p><a href="https://vimeo.com/1">https://vimeo.com/1</a></p>
<video width="100%" height="100%" controls="">
</source>
<a href=\"#{url}\"><img src=\"/secure-uploads/original/1X/testimage.png\"></a>
expect(md).not_to include("<img")
expect(md).to include("data-stripped-secure-upload=\"#{url}\"")
<img src=\"#{url}\" width=\"20\" height=\"20\">
expect(md).to include("data-width=\"20\"")
expect(md).to include("data-height=\"20\"")
a <img>
<img>
- li
<p>a <img><br>
<img></p>
<p><img><br>
<p><img></p>
<p>a</p>
<li>li</li>
expect(PrettyText.cook(":bomb:")).to eq("<p>:bomb:</p>")
expect(PrettyText.cook(":)")).to eq("<p>:)</p>")
expect(PrettyText.cook(":)")).to match("smile")
expected = "<p><a>Steam URL Scheme</a></p>"
cooked = cook <<~MD
<source src="steam://store/452530"><source src=""><track src="steam://store/452530"><track src="">
expected = '<p><a href="tel://+452530579785" rel="noopener nofollow ugc">Tel URL Scheme</a></p>'
expected2 = "<p><a>Steam URL Scheme</a></p>"
<p><a href="http://example.com" rel="noopener nofollow ugc"><code>a</code> #known::tag here</a></p>
cooked = PrettyText.cook("<a href='http://example.com'>`a` #known::tag here</a>")
cooked = PrettyText.cook("<A href='/a'>test</A> #known::tag")
<p><a href="/a">test</a> <a class="hashtag" href="/tag/known">#<span>known</span></a></p>
PrettyText.cook("<a href='http://example.com'>`a` #known::tag here</a>", user_id: user.id)
cooked = PrettyText.cook("<A href='/a'>test</A> #known::tag", user_id: user.id)
cooked = PrettyText.cook("* a\n\n1. b")
expect(cooked).to match_html("<ul>\n<li>a</li>\n</ul>\n<ol>\n<li>b</li>\n</ol>")
expect(PrettyText.cook("1\n2")).to match_html "<p>1 2</p>"
expect(PrettyText.cook("1\n2")).to match_html "<p>1<br>\n2</p>"
cooked = PrettyText.cook("a,:man:t2:,b")
cooked = PrettyText.cook(":) ;) :)")
expect(cooked.split("img").length - 1).to eq(3)
expect(PrettyText.cook(",:)")).to include("emoji")
expect(PrettyText.cook(":-)\n")).to include("emoji")
expect(PrettyText.cook("a :)")).to include("emoji")
expect(PrettyText.cook(":),")).not_to include("emoji")
expect(PrettyText.cook("abcde ^:;-P")).to include("emoji")
word: "dolor sit*",
word: "meta",
<a href=\"https://meta.discourse.org\" rel=\"noopener nofollow ugc\">Meta</a>
word: "f.o",
expect(PrettyText.cook("foo")).to match_html("<p>foo</p>")
expect(PrettyText.cook("f.o")).to match_html("<p>test</p>")
expect(PrettyText.cook("foo")).to match_html("<p>test</p>")
word: "test",
<a class="mention" href="/u/test">@test</a>
<a class="hashtag" href="/c/test/#{category.id}">#<span>test</span></a>
category = Fabricate(:category, slug: "test", name: "test")
word: "es",
expect(PrettyText.cook("->")).to eq("<p>-&gt;</p>")
expect(PrettyText.cook(%q|"Do you know," he said, "what 'Discourse' is?"|)).to eq(
expect(PrettyText.cook("http://a.com\nhttp://b.com").split("onebox").length).to eq(3)
expect(PrettyText.cook("http://a.com\n\nhttp://b.com").split("onebox").length).to eq(3)
expect(PrettyText.cook("> http://a.com")).not_to include("onebox")
expect(PrettyText.cook("- http://a.com")).not_to include("onebox")
expect(PrettyText.cook("<http://a.com>")).not_to include("onebox")
expect(PrettyText.cook("<img src='a'>\nhttp://a.com")).to include("onebox")
op = post
quote = create_post(topic_id: op.topic.id, raw: "This is a sample reply with a quote\n\n#{url}")
markdown = <<~MD
| ------------- |:-------------:| -----:|
<div class="md-table">
<tr>
<th>Tables</th>
</tr>
</thead>
<td>col 3 is</td>
<td style="text-align:right">$1600</td>
</tbody>
</table>
html = "<p><img src=\"http://www.image/test.png\" alt=\"\" role=\"presentation\"></p>"
html = '<p><a href="mailto:sam@sam.com" data-bbcode="true">sam@sam.com</a></p>'
html = "<p>Testing <code>codified **stuff** and `more` stuff</code></p>"
expect(PrettyText.cook("<test>alert(42)</test>")).to eq "<p>alert(42)</p>"
expect(PrettyText.cook("<p class='hi'>hi</p>")).to eq "<p>hi</p>"
expect(PrettyText.cook("<script>alert(42)</script>")).to eq ""
).to eq "<p><test>alert(42)</test></p>"
<p><img src="http://png.com/my.png" alt="title with | title" width="220" height="100"><br>
<img src="http://png.com/my.png" alt="" role="presentation"><br>
<img src="http://png.com/my.png" alt="" width="220" height="100" role="presentation"><br>
<img src="http://png.com/my.png" alt="stuff"><br>
<img src="http://png.com/my.png" alt="" title="some title" width="110" height="50" role="presentation"></p>
<p><img src="http://png.com/my.png" alt="" width="110" height="50" role="presentation"><br>
<img src="http://png.com/my.png" alt="" width="110" height="50" role="presentation"><br>
<img src="http://png.com/my.png" alt="" width="150" height="68" role="presentation"><br>
<img src="http://png.com/my.png" alt="" width="110" height="50" role="presentation"></p>
- test
Inline img <img src="#{upload.short_url}">
Block img <img src="#{upload.short_url}">
<p><img src="#{cdn_url}" alt="upload" data-base62-sha1="#{upload.base62_sha1}"></p>
<p><img src="#{cdn_url}" alt="upload" title="some title to test" data-base62-sha1="#{upload.base62_sha1}"></p>
<p>test</p>
<li><img src="#{cdn_url}" alt="upload" data-base62-sha1="#{upload.base62_sha1}"></li>
<p>Inline img <img src="#{cdn_url}" data-base62-sha1="#{upload.base62_sha1}"></p>
Block img <img src="#{cdn_url}" data-base62-sha1="#{upload.base62_sha1}">
<p><a href="#{upload.short_path}">some attachment</a></p>
<p><a class="attachment" href="#{upload.short_path}">some attachment</a></p>
<p><a href="#{upload.short_path}">some attachment|random</a></p>
<p><img src="/images/transparent.png" alt="upload" data-orig-src="upload://abcABC.png"></p>
<p><a class="attachment" href="/404" data-orig-href="upload://abcdefg.png">some attachment</a></p>
<iframe src='https://bob.com/a?testing'></iframe>
<iframe src="https://bob.com/a?testing"></iframe>
md = "www.cnn.com test.it http://test.com https://test.ab https://a"
<p>www.cnn.com test.it http://test.com https://test.ab https://a</p>
cooked = PrettyText.cook("<div data-theme-a='a'>test</div>")
html = (<<~MD).strip
<ruby lang="je">
<rb lang="je">X</rb>
</ruby>
<div class="d-wrap" data-wrap="toc">
<p>taco</p>
<p>Hello <span class="d-wrap" data-wrap="toc" data-id="1">taco</span> world</p>
<div class="d-wrap" data-wrap="toc" data-id="a" data-aa="b&amp;quot;" data-bb="f'">
<p>taco1</p>
<div class="d-wrap" data-wrap="toc"></div>
<div class="d-wrap" data-wrap="toc" data-name="single quote's" data-id="1&amp;quot;2">
<div class="d-wrap" data-wrap="toc" data-foo="&amp;lt;script&amp;gt;console.log(1)&amp;lt;/script&amp;gt;">
<div class=\"d-wrap\" data-wrap=\"toc\" data-io=\"bar\">
<h1>
<a name="hello-world-1" class="anchor" href="#hello-world-1"></a>
</h1>
expect(cooked).to eq("<p>This is some text **bold**</p>")
expect(cooked).to eq("<p>This is some text <strong>bold</strong></p>")
expect(cooked).to eq("<p>:grin: @mention</p>")
expect(cooked).to eq("<p>:grin: <span class=\"mention\">@mention</span></p>")
fab!(:tag) { Fabricate(:tag, name: "somecooltag") }
icon: "tag",
icon: "folder",
let(:post_args) { { user: newuser, topic: topic } }
let(:tc) do
expect(tc.diff).to eq({})
tc.record_change("height", "180cm", "170cm")
tc.record_change("wat", "js", "js")
{ raw: "updated body" },
post = Fabricate(:post, raw: "hello world")
{ raw: "hello world123456789" },
{ raw: "Hello world" },
}.to change { post.topic.bumped_at }
{ raw: "hello world123456789", edit_reason: "this is my reason" },
{ raw: "hello world4321" },
{ raw: "hello some other thing" },
let!(:revised_at) { post.updated_at + 2.minutes }
let!(:new_revised_at) { revised_at + 2.minutes }
subject.revise!(post.user, raw: "# This is a title")
fab!(:changed_by) { coding_horror }
subject.revise!(user, raw: "body (edited)")
expect { subject.revise!(user, raw: "body (edited)") }.to_not raise_error
fab!(:changed_by) { Fabricate(:admin) }
url = "http://i.imgur.com/wfn7rgU.jpg"
Oneboxer.stubs(:onebox).with(url, anything).returns("<img src='#{url}'>")
subject.revise!(changed_by, raw: "So, post them here!\n#{url}")
url = "http://i.imgur.com/FGg7Vzu.gif"
Oneboxer.stubs(:cached_onebox).with(url, anything).returns("<img src='#{url}'>")
subject.revise!(post.user, raw: "So, post them here!\n#{url}")
params = { raw: "body (edited)" }
{ raw: "Edit the first post" },
}.to change { topic.excerpt }
}.to_not change { topic.excerpt }
.track_publish("/topic/#{topic.id}") do
fab!(:mentioned_user) { Fabricate(:user) }
@result =
}.to change { Tag.count }.by(2)
Fabricate(:tag, name: "super"),
Fabricate(:tag, name: "stuff"),
let(:bumped_at) { 1.day.ago }
let(:image1) { Fabricate(:upload) }
let(:image2) { Fabricate(:upload) }
let(:image3) { Fabricate(:upload) }
let(:image4) { Fabricate(:upload) }
let(:post_args) { { user: user, topic: topic, raw: <<~RAW } }
subject.revise!(user, raw: <<~RAW)
let!(:image5) { Fabricate(:secure_upload) }
draft_key = "topic_#{topic.id}"
data = { reply: "test 12222" }.to_json
{ title: "updated title for my topic" },
}.to not_change {
}.and not_change {
}.to change { Draft.where(user: user, draft_key: draft_key).count }.from(1).to(
).and change {
fab!(:post) { Fabricate(:post, raw: "aaa", skip_validation: true) }
subject.revise!(admin, { raw: "bbb" }, skip_validations: true)
subject.revise!(admin, { raw: "aaa" }, skip_validations: true)
expect { revisor.revise!(admin, { raw: "updated body" }) }.not_to change(
merged_raw = reply1.raw + "\n\n" + reply2.raw
let(:new_topic) { false }
let(:opts) { { post_alert_options: {} } }
) { subject.enqueue_jobs }
let(:new_topic) { true }
@user,
{ edit_reason: "made a change" },
{ raw: "this is a change to the post" },
fab!(:review_user) { Fabricate(:user) }
before { @reply.topic.trash! }
topic_destroyed = ->(topic, user) {
topic_recovered = ->(topic, user) {
}.to change { author.topic_count }.by(-1)
}.to change { author.post_count }.by(-1)
let!(:post) { create_post(user: user) }
fab!(:second_user) { coding_horror }
let(:author) { post.user }
let!(:reply) { create_post(topic_id: topic.id, user: post.user) }
let(:author) { reply.user }
fab!(:post) { Fabricate(:post, raw: "Hello @CodingHorror") }
}.to change(post.topic, :posts_count).by(-1)
).by(-1)
let(:second_post) { Fabricate(:post, topic_id: post.topic_id) }
let!(:flag) { flag_result.post_action }
).strip,
fab!(:first_post) { Fabricate(:post) }
let!(:topic) { first_post.topic }
let!(:second_post) { Fabricate(:post, topic: topic) }
let!(:other_post) { Fabricate(:post, topic: other_topic) }
let!(:base_url) { URI.parse(Discourse.base_url) }
let!(:guardian) { Guardian.new }
let!(:url) do
new_post = Post.create!(user: user, topic: topic, raw: "Link to other topic:\n\n#{url}\n")
new_post = create_post(user: user, topic: topic, raw: "Link to other topic:\n\n#{url}\n")
let(:reply) { Fabricate(:post, topic: post.topic) }
let(:defer_reply_flags) { true }
let(:defer_reply_flags) { false }
fab!(:upload1) { Fabricate(:upload_s3, created_at: 5.hours.ago) }
fab!(:first_post) { Fabricate(:post, created_at: 10.days.ago.round) }
fab!(:post_1) { Fabricate(:post, topic: topic) }
fab!(:post_2) { Fabricate(:post, topic: topic) }
{ title: "hello world topic", raw: "my name is fred", archetype_id: 1, advance_draft: true }
{ "http://an.image.host/image.jpg" => { "width" => 111, "height" => 222 } }
raw: "http://www.discourse.org",
basic_topic_params.merge(topic_opts: { custom_fields: { hello: "world" } }),
expect(channels.find { |s| s =~ /unread/ }).to eq(nil)
expect(channels.find { |s| s =~ /new/ }).to eq(nil)
job_enqueued?(job: :post_update_topic_tracking_state, args: { post_id: p.id }),
_reply =
messages.filter! { |m| m.channel != "/distributed_hash" }
channels = messages.map { |m| m.channel }.sort
messages.any? do |m|
m.group_ids != admin_ids &&
(!m.user_ids.include?(other_admin.id) && !m.user_ids.include?(admin.id))
p = nil
latest = messages.find { |m| m.channel == "/latest" }
latest = messages.find { |m| m.channel == "/new" }
read = messages.find { |m| m.channel == "/unread/#{p.user_id}" }
user_action = messages.find { |m| m.channel == "/u/#{p.user.username}" }
draft_count = messages.find { |m| m.channel == "/user-drafts/#{p.user_id}" }
expect(messages.filter { |m| m.channel != "/distributed_hash" }.length).to eq(7)
image_sizes = { "http://an.image.host/image.jpg" => { "width" => 17, "height" => 31 } }
expect { creator.create }.to change { Draft.count }.by(-1)
let(:topic) { topic_timer.topic }
fab!(:post) { Fabricate(:post, topic: topic_timer.topic) }
raw: "this is a second post",
job_enqueued?(job: :create_linked_topic, args: { post_id: post_2.id }),
expect { @post = creator_with_tags.create }.to change { Tag.count }.by(
tag_names.size - 2,
Fabricate(:tag, name: "hey")
word: "art",
word: "artist*",
word: "he(llo|y)",
let(:basic_topic_params) { { raw: "test reply", topic_id: topic.id, reply_to_post_number: 4 } }
fab!(:topic) { Fabricate(:topic, user: user, title: "topic title with 25 chars") }
one_day = 86_400
fab!(:topic) { Fabricate(:topic, user: user, closed: true) }
let(:topic) { Fabricate(:topic, user: user, deleted_at: 5.minutes.ago) }
fab!(:unrelated_user) { Fabricate(:user) }
1.upto(3) do |i|
fab!(:unrelated) { Fabricate(:user) }
time = Time.zone.parse("2019-09-02")
created_at: "2019-09-02",
created_at: "2019-09-02 00:00:00 UTC",
it "can save a post" do
let(:embed_url) { "http://eviltrout.com/stupid-url" }
).msecs,
).to be > 0
@increase_posts = ->(post, opts, user) { @posts_created += 1 }
@increase_topics = ->(topic, opts, user) { @topics_created += 1 }
post_creator = PostCreator.new(user, title: "", raw: "")
fab!(:muted_me) { evil_trout }
fab!(:staff_user) { Fabricate(:admin) }
fab!(:ignorer) { evil_trout }
fab!(:sender) { evil_trout }
fab!(:target_user2) { evil_trout }
title: "#{user.username}'s first topic",
raw: "#{user.name}'s first post",
fab!(:image_upload) { Fabricate(:upload, secure: true) }
fab!(:public_topic) { Fabricate(:topic) }
@plugin.add_to_class(:trout, :status?) { "evil" }
@hello_count = 0
@increase_count = -> { @hello_count += 1 }
@set = @plugin.on(:hello, &@increase_count)
expect(@trout.status?).to eq("evil")
ctx.data = "hello"
@plugin.register_html_builder("test:html") { |c| "<div>#{c.data}</div>" }
File.open("#{plugin.auto_generated_path}/junk", "w") { |f| f.write("junk") }
plugin.assets.each { |a, opts| expect(File.exist?(a)).to eq(true) }
}.to change { ColorScheme.count }.by(1)
plugin = Plugin::Instance.new(nil, "/tmp/test.rb")
let!(:plugin) { Plugin::Instance.new(nil, "#{plugin_path}/plugin.rb") }
lambda do |n|
return :one if n == 1
return :few if n < 10
path = "#{plugin_path}/#{path}"
Plugin::Instance.new.register_emoji("bar", "/baz/bar.png", "baz")
it "adds a new flag" do
) { |settings, next_flag_id| settings.add(next_flag_id, :new_flag) }
let!(:plugin) { Plugin::Instance.new }
let(:column_name) { "random_c" }
icon: "recycle",
plan =
cb = Proc.new { callback_called = true }
def to_markdown(text, opts = {})
let(:nbsp) { "&nbsp;" }
expect(to_markdown("> foo")).to eq("> foo")
expect(to_markdown(">>> foo")).to eq(">>> foo")
expect(to_markdown(">>>>>>> foo")).to eq(">>>>>>> foo")
expect(to_markdown(">foo")).to eq("> foo")
expect(to_markdown(">\tfoo")).to eq("> foo")
expect(to_markdown("> foo\nbar")).to eq("> foo\n\nbar")
expect(to_markdown(">> foo\nbar")).to eq(">> foo\n\nbar")
expect(to_markdown("> foo\n\nbar")).to eq("> foo\n\nbar")
expect(to_markdown("> foo\n\n\nbar")).to eq("> foo\n\nbar")
expect(to_markdown("> foo\n> \n>\n>\n> bar")).to eq("> foo\n>\n> bar")
expect(to_markdown(">> foo\n>bar")).to eq(">> foo\n>\n> bar")
expect(to_markdown(">>>> foo\n>bar")).to eq(">>>> foo\n>\n> bar")
expect(to_markdown(">> foo\nno quote\n>bar")).to eq(">> foo\n\nno quote\n> bar")
expect(to_markdown(">>> foo\n>>\n>> bar")).to eq(">>> foo\n>>\n>> bar")
expect(to_markdown('\ backslash')).to eq('\\\\ backslash')
expect(to_markdown("` backtick")).to eq('\` backtick')
expect(to_markdown("* asterisk")).to eq('\* asterisk')
expect(to_markdown("_ underscore")).to eq('\_ underscore')
expect(to_markdown("{} curly braces")).to eq('\{\} curly braces')
expect(to_markdown("() parentheses")).to eq('\(\) parentheses')
expect(to_markdown("# hash mark")).to eq('\# hash mark')
expect(to_markdown("+ plus sign")).to eq('\+ plus sign')
expect(to_markdown("- minus sign")).to eq('\- minus sign')
expect(to_markdown(". dot")).to eq('\. dot')
expect(to_markdown("~ tilde")).to eq('\~ tilde')
expect(to_markdown("' single quote")).to eq("&#39; single quote")
expect(to_markdown("\" double quote")).to eq("&quot; double quote")
expect(to_markdown("& ampersand")).to eq("&amp; ampersand")
expect(to_markdown(" foo")).to eq(" foo")
expect(to_markdown("\tfoo")).to eq("#{nbsp}#{nbsp}foo")
expect(to_markdown(" \tfoo")).to eq("#{nbsp}#{nbsp}#{nbsp}foo")
expect(to_markdown("\t foo")).to eq("#{nbsp}#{nbsp}#{nbsp}foo")
expect(to_markdown(" \t foo")).to eq("#{nbsp}#{nbsp}#{nbsp}#{nbsp}foo")
expect(to_markdown("\t\tfoo")).to eq("#{nbsp}#{nbsp}#{nbsp}#{nbsp}foo")
expect(to_markdown("foo\t\tbar")).to eq("foo\t\tbar")
text =
markdown = "\\-\\- \nsignature line 1\nsignature line 2"
).to eq("foo https://www.example.com/foo.html?a=1 bar")
).to eq("foo https://www.example.com/foo.html bar")
Timeout.timeout(0.25) { to_markdown("https://www.discourse.org/?boom=#{"." * 20}") }
expect(to_markdown("foo\n```\n<this is code>\n```")).to eq("foo\n```\n<this is code>\n```")
expect(to_markdown("foo\n```\n<this is code> ```")).to eq(
let(:pinned_at) { 12.hours.ago }
expect(Pbkdf2.hash_password("test", "abcd", 100)).to eq(
expect(Pbkdf2.hash_password("test", "abcd", 101)).to eq(
expect(ONPDiff.new("abcd", "abef").diff).to eq(
expect(ONPDiff.new("abc", "acd").short_diff).to eq(
expect(ONPDiff.new("abcd", "abef").short_diff).to eq(
stub_request(:head, "http://boom.com")
stub_request(:get, "http://boom.com").to_return(body: "")
expect(Oneboxer.onebox("http://boom.com")).to eq("")
let(:url) { "http://test.com" }
url = "#{Discourse.base_url}#{url}"
%{<a href="#{url}">#{url}</a>}
def preview(url, user = nil, category = nil, topic = nil)
user_id: user&.id,
topic_id: topic&.id,
public_post = Fabricate(:post, raw: "This post has an emoji :+1:")
expect(onebox).to include(%{data-post="2"})
short_url = "#{Discourse.base_path}/t/#{public_topic.id}"
expect(onebox).to include(%{data-post="4"})
expect(preview("#{path}.pdf")).to match_html(link("#{path}.pdf"))
expect(preview("#{path}.MP3")).to include("<audio ")
expect(preview("#{path}.mov")).to include("<video ")
expect(preview("/u/#{user.username}")).not_to include("<span class=\"location\">")
expect(preview("/u/#{user.username}")).to include("<span class=\"location\">")
expect(preview("/u/#{user.username}")).not_to include("<img src=x")
Fabricate(:tag, name: "bug")
post = Fabricate(:post, raw: Discourse.base_url + "/new?'class=black")
stub_request(:get, "http://cat.com/meow").to_return(
stub_request(:head, "http://cat.com/meow").to_return(
stub_request(:get, "https://kitten.com").to_return(status: 200, body: html, headers: {})
stub_request(:head, "https://kitten.com").to_return(status: 200, body: "", headers: {})
body: "a",
body: "b",
stub_request(:get, "https://cat.com/end").to_return(status: 200, body: html)
stub_request(:head, "https://cat.com/end").to_return(status: 200, body: "", headers: {})
url = "https://example.com/"
stub_request(:any, url).to_return(status: 200, body: <<~HTML, headers: {})
stub_request(:get, "https://its.me").to_return(status: 200, body: html)
stub_request(:head, "https://its.me").to_return(status: 200, body: "", headers: {})
stub_request(:head, url).to_return(status: 403, body: "", headers: {})
stub_request(:get, url).to_return(status: 403, body: "", headers: {})
let(:html) { <<~HTML }
body: nil,
type: "rich",
height: "100",
html: "<iframe src='https://ifram.es/foo/bar'></iframe>",
html: "<iframe src='https://malicious/discourse.org/'></iframe>",
before { stub_request(:head, url) }
let(:url) { "https://example.com/fake-url/" }
).to_return(status: 429, body: "{}", headers: {})
body: "{\"access_token\":\"token\"}",
cooked = Oneboxer.apply(PrettyText.cook(raw)) { "<div>onebox</div>" }
<p>Before Onebox</p>
<p>After Onebox</p>
cooked = Oneboxer.apply(Loofah.fragment(cooked)) { "<div><svg><path></path></svg></div>" }
<p>Onebox</p>
<div><svg><path></path></svg></div>
let(:hostname) { "my.interesting.site" }
let(:url) { "https://#{hostname}/cool/content" }
<p>cache me if you can</p>
let(:url) { "https://www.example.com/my/great/content" }
let(:url2) { "https://www.example2.com/my/great/content" }
url = "#{Discourse.base_url}/wizard"
Net::HTTPError.new("error", nil),
describe "#ok?" do
let(:preview_url) { "http://www.amazon.com/product" }
expect(described_class.new("not a url").to_s).to eq("")
expect(result).to include("width=\"1280\"")
expect(result).to include("height=\"720\"")
expect(result).to include("width=\"900\"")
expect(result).to include("height=\"506\"")
let(:xss) { "wat' onerror='alert(/XSS/)" }
let(:img_html) { "<img src='#{xss}'>" }
let(:iframe_html) { "<iframe src='https://thirdparty.example.com'>" }
<meta property="og:article:tag" content="&lt;b&gt;tag1&lt;/b&gt;" />
json = '{"text": "<iframe src=\'https://ifram.es/foo/bar\'></iframe>"}'
json = '{"html": "<iframe src=\'https://ifram.es/foo/bar\'></iframe>"}'
expect(oembed.html).to eq("<iframe src='https://ifram.es/foo/bar'></iframe>")
name: "Rudy",
rating: 7.5,
duration: "01:54",
def self.===(uri)
let(:url) { "http://party.time.made.up-url.com/beep/boop" }
let(:matcher) { Onebox::Matcher.new(url, opts) }
let(:url) { "http://party.time.made.up-url.com/" }
let(:url) { "http://party.time.made.up-url.com/?article_id=1234" }
let(:url) { "http://party.time.made.up-url.com/#article_id=1234" }
it "finds an engine for '#{url}'" do
it "doesn't find an engine for '#{url}'" do
let(:record) { {} }
let(:html) { layout.to_html }
record = { link: "foo" }
expect(html).to include(%|"foo"|)
record = { image: "/image.png", link: "https://discourse.org" }
invalid_json = "{\"@type\":invalid-json}"
expect(json_ld.data).to eq({})
doc = Nokogiri.HTML("<script type=\"something else\"></script>")
doc = Nokogiri.HTML("<script type=\"application/ld+json\"></script>")
it { expect(described_class.blank?("")).to be(true) }
it { expect(described_class.blank?(" ")).to be(true) }
it { expect(described_class.blank?("test")).to be(false) }
it { expect(described_class.blank?({})).to be(true) }
it { expect(described_class.blank?(a: "test")).to be(false) }
let(:test_string) { "Chops off on spaces" }
it { expect(described_class.truncate(test_string, 5)).to eq("Chops...") }
it { expect(described_class.truncate(test_string, 7)).to eq("Chops...") }
it { expect(described_class.truncate(test_string, 9)).to eq("Chops off...") }
it { expect(described_class.truncate(test_string, 10)).to eq("Chops off...") }
it { expect(described_class.truncate(" #{test_string} ", 6)).to eq(" Chops...") }
Onebox.options = { max_download_kb: 1 }
stub_request(:get, uri).to_return(status: 200, body: "<!DOCTYPE html><p>success</p>")
uri = "https://www.example.com"
body: "<!DOCTYPE html><link rel='canonical' href='http://foobar.com/'/><p>invalid</p>",
stub_request(:get, "http://foobar.com").to_return(
body: "<!DOCTYPE html><p>success</p>",
stub_request(:head, "http://foobar.com").to_return(status: 200, body: "")
.with { |h| h == "localhost" }
body: "<!DOCTYPE html><link rel='canonical' href='http://localhost/test'/><p>success</p>",
(1..6).each do |i|
code = codes.pop || 302
stub_request(:get, "https://httpbin.org/redirect/#{i}").to_return(
location: "https://httpbin.org/redirect/#{i - 1}",
cookie: "a=b; Path=/",
).to_return(status: 200, body: "test")
).to eq("")
expect(described_class.uri_encode("http://example.com/f.o~o;?<ba'r>")).to eq(
expect(described_class.uri_encode("http://example.com/<pa'th>(foo)?b+a+r")).to eq(
expect(described_class.uri_encode("http://example.com/p,a:t!h-f$o@o*?b!a#r@")).to eq(
).to eq("http://example.com/index&%3Cscript%3Ealert('XSS');%3C/script%3E")
{ key: "value" }
it "escapes `link`" do
expect(html).not_to match(/'/)
describe ".===" do
@@matcher = /example/
it "treats '*' as a catch-all" do
@@matcher_content_type = %r{^image/png$}
expect(result).to_not match(/http(?!s)/)
).to match(/iframe/)
).to match(/embed/)
/<img/,
).to_s,
.stubs(:to_html)
/start=3782/,
).to match(/start=3782/)
let(:link) { "https://xkcd.com/327/" }
let(:api_link) { "https://xkcd.com/327/info.0.json" }
body =
).to_return(status: 200, body: body, headers: {})
it "has the link" do
).to match(/<video/)
/<video/,
CGI.parse(URI.parse(form_url).query || "")
let(:full_name) { "Vyki Englert" }
let(:screen_name) { "vyki_e" }
let(:timestamp) { "6:59 PM - 1 Aug 2013" }
let(:favorite_count) { "0" }
let(:retweets_count) { "0" }
let(:full_name) { "Metallica" }
let(:screen_name) { "Metallica" }
let(:timestamp) { "10:45 PM - 13 May 2019" }
let(:favorite_count) { "1.7K" }
let(:retweets_count) { "201" }
let(:full_name) { "Jeff Atwood" }
let(:screen_name) { "codinghorror" }
let(:avatar) { "" }
let(:timestamp) { "3:02 PM - 27 Jun 2021" }
let(:favorite_count) { "90" }
expect(html).to eq("")
created_at: "Fri Aug 02 01:59:30 +0000 2013",
name: "Peers",
url: "http://t.co/T4Sc47KAzh",
screen_name: "vyki_e",
url: "http://t.co/YCAP3asRG1",
url: {
created_at: "Sun Jan 13 19:53:00 +0000 2013",
utc_offset: -25_200,
time_zone: "Pacific Time (US & Canada)",
lang: "en",
geo: nil,
created_at: "Mon May 13 22:45:04 +0000 2019",
url: "https://t.co/gLtZSdDFmN",
source: "<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>",
id_str: "238475531",
url: "http://t.co/kVxaQpmqSI",
url: "http://t.co/EAkqroM0OA",
created_at: "Sat Jan 15 07:34:59 +0000 2011",
lang: nil,
created_at: "Sun May 12 18:45:35 +0000 2019",
url: "https://t.co/wlUtDQbQEK",
type: "photo",
sizes: {
large: {
w: 2048,
h: 1498,
resize: "fit",
thumb: {
w: 150,
h: 150,
resize: "crop",
medium: {
w: 1200,
h: 877,
small: {
w: 680,
h: 497,
h: 922,
h: 522,
h: 1574,
location: "",
url: "https://t.co/KgwIPrVVhg",
created_at: "Mon Jul 17 14:45:13 +0000 2017",
let(:hostname) { "www.example.com" }
let(:options) { { hostname: hostname } }
let(:instance) { host_class.new }
.stubs(:data)
html_doc = mocked_html_doc(twitter_data: { "name" => "twitter:url", "content" => "cool.url" })
expect(instance.raw).to eq({ url: "cool.url" })
html_doc =
expect(instance.raw).to eq({ title: "do not override me" })
html_doc.stubs(at_css: nil, at: nil)
.stubs(:css)
expect(described_class === URI("http://#{domain}/q/55495")).to eq(true)
expect(described_class === URI("http://#{domain}/a/55503")).to eq(true)
expect(described_class === URI("http://example.com/q/4711")).to eq(false)
expect(described_class === URI("http://example.com/a/4711")).to eq(false)
}.each do |name, url|
@link = url
stub_request(:get, "#{link}/").to_return(status: 200, body: onebox_response("reddit_image"))
let(:link) { "http://www.ncbi.nlm.nih.gov/pubmed/7288891" }
let(:link) { "http://www.ncbi.nlm.nih.gov/pubmed/24737116" }
let(:link) do
stub_request(:head, link).to_return(status: 200, headers: { "Content-Length" => "335562" })
let(:link) { "https://videos.kaltura.com/id/0_e2ea6ygt" }
og_video_width = "534"
og_video_height = "300"
let(:tag_name) { "iframe" }
let(:tag_name) { "img" }
@url = link
let(:access_token) { "abc123" }
let(:link) { "https://www.instagram.com/p/CARbvuYDm3Q" }
let(:api_link) { "https://api.instagram.com/oembed/?url=#{link}" }
Onebox.options = {}
let(:link) { "https://imgur.com/gallery/Sdc0Klc" }
let(:html) { imgur.to_html }
).to match(/<img/)
@link = "http://amazon.com"
short: {
test: "https://goo.gl/maps/rEG3D",
long: {
custom: {
.tap do |obj|
URLS.each do |kind, t|
it "has icon" do
@link =
expect(html).to include("02:05AM - 26 Jul 13")
@uri =
expect(html).to include("3.times { puts &quot;Gist API test.&quot; }")
expect(html).to include("console.log(&quot;Hey! ;)&quot;)")
expect(html).to include("#### Hey, this is a test!")
@uri = "https://github.com/ruby/rdoc"
expect(html).to include("02:16AM - 02 Aug 13 UTC")
@uri = URI.parse(@link)
uri = mock("object")
expect(html).to include("<a href='https://gfycat.com/gifs/search/lego'>#lego</a>")
subject(:data) { onebox.data }
card: "summary",
label2: "Likes",
).to match(/<audio/)
/<audio/,
/<a.*mp3/,
let(:giphy) { "http://gph.is/15bRbWf" }
let(:tenor) { "https://tenor.com/bb3fQ.gif" }
expect(html).to include("src='#{direct_gif}'")
expect(html).to include("$21.11")
let(:link) { "https://www.amazon.com/dp/B01MFXN4Y2" }
let(:link) { "https://www.amazon.com/dp/B00AYQNR46" }
let(:link) { "https://www.amazon.com/dp/193435659X" }
let(:link) { "https://www.amazon.com/dp/B0123ABCD3210" }
expect(onebox.to_html).to eq("")
let(:link) { "https://www.amazon.com/dp/B07FQ7M16H" }
expect(html).to include("$37.99")
expect(described_class === URI("http://foo.bar/resource")).to be(true)
expect(described_class === URI("http://1.2.3.4/resource")).to be(false)
expect(described_class === URI("http://1.2.3.4:1234/resource")).to be(false)
{ html: "cool html", height: 123, provider_name: "CoolSite" }
).to eq "<iframe src='http://youtube.com/asdf'></iframe>"
).to eq "<iframe src='https://youtube.com/asdf'></iframe>"
stub_request(:get, "http://api.meetup.com/oembed?url=#{url}").to_return(
stub_request(:get, url).with(headers: { cookie: "evil=trout" }).to_return(
onebox.options = { cookie: "evil=trout" }
it { expect(described_class.is_blocked?("api.cat.org")).to be(true) }
it { expect(described_class.is_blocked?("api.dog.org")).to be(false) }
it { expect(described_class.is_blocked?("dev.api.cat.org")).to be(true) }
it { expect(described_class.is_blocked?(".api.cat.org")).to be(true) }
title: "this is a new post",
raw: "this is a new topic",
title: "Let's start a new topic!",
npm =
before { user.update!(trust_level: 0) }
handler = -> { nil }
a = -> { nil }
b = -> { nil }
c = -> { nil }
@queue_handler = ->(manager) {
u = user
let!(:review_group) { Fabricate(:group) }
(<<~STR).split("\n")
eq(true),
eq(false),
outputString += "2"
outputString += "3"
DB.after_commit { outputString += "6" }
outputString += "4"
DB.after_commit { outputString += "7" }
outputString += "5"
DB.after_commit { outputString += "4" }
DB.after_commit { outputString += "2" }
table_name = '#{table_name}'
let(:table_name) { "table_with_old_name" }
:up,
).run
DB.exec(<<~SQL, table: table, column: column) == 1
columns.each { |column| expect(has_column?("topics", column)).to eq(false) }
SET topic_id = 2
def env(opts = {})
path = opts.delete(:path) || "/path?bla=1"
).merge(opts)
0.2,
0.1,
).to eq(warn_count)
warn_count += 1
Middleware::RequestTracker.register_ip_skipper { |ip| ip == "1.1.1.2" }
app =
lambda do |_|
envs =
3.times.map do |n|
sql_calls.times { User.where(id: -100).pluck(:id) }
->(env, data) {
uri = "/path?#{SecureRandom.hex}"
request_params = { "a" => "b", "action" => "bob", "controller" => "jane" }
User.where(id: -100).pluck(:id)
tracker.call(env("HTTP_DONT_CHUNK" => "True", :path => "/message-bus/abcde/poll"))
}.merge(opts)
def new_helper(opts = {})
expect(new_helper("HTTP_COOKIE" => "jack=1; _t=#{cookie}; jill=2").cacheable?).to eq(false)
expect(new_helper("HTTP_COOKIE" => "jack=1; _t=#{cookie}; jill=2").cacheable?).to eq(true)
expect(new_helper("PATH_INFO" => "/srv/status").cacheable?).to eq(false)
expect(new_helper("HTTP_API_KEY" => "abcde").cacheable?).to eq(false)
with_good_theme_key = new_helper("HTTP_COOKIE" => "theme_ids=#{theme.id}").cache_key
expect(new_helper("HTTP_COOKIE" => "locale=es;").cache_key).to include("l=es")
key1 = new_helper("HTTP_USER_AGENT" => "my_old_browser").cache_key
key2 = new_helper("HTTP_USER_AGENT" => "my_new_browser").cache_key
payload = "x" * 1000
env =
status, _ = app.call(env.dup)
_status, headers, _body = app.call(env.dup)
status, headers, _ =
@env =
get "/", headers: { "HTTP_USER_AGENT" => "Googlebot/2.1 (+http://www.google.com/bot.html)" }
get "/",
get "/", headers: non_crawler
get "/robots.txt",
get "/srv/status",
get "/srv/status.json",
recurse(count - 1) if count > 0
fab!(:second_post) { Fabricate(:post, topic: topic) }
let(:post_format_message_id) { "<topic/#{topic.id}/#{post.id}.test123@test.localhost>" }
message_id = "<" + "@" * 50
let(:obj) { Fabricate.build(:user) }
let(:invalid_user) { User.new }
@ctx.eval("MessageFormat = {locale: {}};")
@ctx.eval("var test = #{compiled}")
@ctx.eval("test(#{opts.to_json})")
one {1 apple}
other {# apples}
expect(localize(GENDER: "male")).to eq("He read a book")
hash = { "a" => "b", "c" => { "d" => { "f_MF" => "bob" } } }
ctx.eval("I18n = { pluralizationRules: {} };")
expect(ctx.eval('I18n.messageFormat("test_MF", { HELLO: "hi", COUNT: 3 })')).to eq(
expect(ctx.eval('I18n.messageFormat("error_MF", { HELLO: "hi", COUNT: 3 })')).to match(
expect(ctx.eval('I18n.messageFormat("missing", {})')).to match(/missing/)
expect(ctx.eval('I18n.messageFormat("simple_MF", {})')).to match(/COUNT/) # error
expect(ctx.eval('I18n.messageFormat("foo_MF", { HELLO: "hi", COUNT: 4 })')).to eq(
ctx.eval("var window = this;")
ctx.eval('I18n.defaultLocale = "ru";')
expected.each { |key, expect| expect(ctx.eval("I18n.t(#{"js.#{key}".inspect})")).to eq(expect) }
JsLocaleHelper.set_translations("en", "en" => { "js" => { "something_MF" => "en mf" } })
JsLocaleHelper.set_translations("de", "de" => { "js" => { "something_MF" => "de mf" } })
=0 {are no}
other {are # unread}
ctx.eval(<<~JS)
expect(ctx.eval("I18n.messageFormat('something_MF', { UNREAD: 1 })")).to eq(
expect(content).to eq("")
expect(content).to_not eq("")
expect(locale).to eq("de")
expect(locale).to eq("en")
url = "https://example.com/good-url"
body: "<html><head><title>a blog</title></head></html>",
lookup = ->(number) {
expect(lookup.call(3)).to eq("Inline oneboxer - #3")
body: "<html><head><title>a</title></head></html>",
body: "<html><head><title>hello world</title></head></html>",
body: "<html><head><title>The Redirects Website</title></head></html>",
body: "<html><head><title>welcome to my blog</title></head></html>",
stub_request(:get, "https://eviltrout.com/some-path").to_return(status: 404, body: "")
{ url: url, title: "Custom Onebox for Wizard" }
markdown = <<MD
&nbsp;
<pre>
<code>
I am a te&nbsp;&quot;
<pre><code>this is a &quot;&quot;</code></pre>
let(:sync_handler) { Imap::Sync.new(group) }
let(:from) { "john@free.fr" }
let(:subject) { "Testing email post" }
let(:message_id) { "#{SecureRandom.hex}@example.com" }
}.by(1).and change { IncomingEmail.count }.by(1)
expect(post.raw).to eq("This is an email *body*. :smile:")
let(:first_from) { "john@free.fr" }
let(:second_from) { "sam@free.fr" }
let(:second_body) { "<p>This is an <b>answer</b> to this message.</p>" }
subject: "Re: #{subject}",
}.by(2).and change { IncomingEmail.count }.by(2)
fab!(:username) { "test@generic.com" }
fab!(:password) { "test1!" }
let(:imap_stub) { stub }
let(:x_gm_thrid) { Imap::Providers::Gmail::X_GM_THRID }
main_uid = 78
before { imap_stub.expects(:list).with("", "*").returns(dummy_mailboxes) }
imap_stub.expects(:list).with("", "*").returns(dummy_mailboxes)
{ "ENVELOPE" => stub(message_id: "<h4786x34@test.com>"), "UID" => 4 },
{ "ENVELOPE" => stub(message_id: "<f349xj84@test.com>"), "UID" => 6 },
provider.uids(from: 5, to: 9)
port: 993,
server: "imap.yo.com",
before { @w, @h = ImageSizer.resize(600, 123) }
expect(@w).to eq(500)
expect(@h).to eq(102)
before { @w, @h = ImageSizer.resize(123, 600) }
expect(@h).to eq(500)
expect(@w).to eq(102)
before { @w, @h = ImageSizer.resize(533, 800) }
expect(@w).to eq(333)
backend.store_translations(:en, foo: "Foo in :en", bar: "Bar in :en", wat: "Hello %{count}")
backend.store_translations(:en, items: { one: "one item", other: "%{count} items" })
expect(backend.translate(:en, "foo")).to eq("Foo in :en")
expect(backend.translate(:en, "items", count: 1)).to eq("one item")
expect(backend.translate(:en, "items", count: 3)).to eq("3 items")
expect(backend.translate(:en, "wat", count: 3)).to eq("Hello 3")
expect(backend.search(:en, "fo")).to eq("foo" => "Foo in :en")
expect(backend.search(:en, "foo")).to eq("foo" => "Foo in :en")
expect(backend.search(:en, "Foo")).to eq("foo" => "Foo in :en")
expect(backend.search(:en, "hello")).to eq("wat" => "Hello %{count}")
expect(backend.search(:en, "items.one")).to eq("items.one" => "one item")
expect(backend.translate(:de, "bar")).to eq("Bar in :de")
expect(backend.translate(:de, "foo")).to eq("Foo in :en")
expect(backend.exists?(:de, :bar)).to eq(true)
expect(backend.exists?(:de, :foo)).to eq(true)
expect(backend.exists?(:en, :foo)).to eq(true)
expect(backend.exists?(:ru, :foo)).to eq(true)
one: "%{count} Russian item",
many: "%{count} Russian items are many",
other: "%{count} Russian items",
expect(backend.translate(:ru, :items, count: 2)).to eq("2 items")
few: "%{count} Russian items are a few",
def html_to_markdown(html, opts = {})
<div dir="auto">Hello,
<div dir="auto"><br></div>
<div dir="auto">&nbsp; &nbsp; This is the 1st paragraph.&nbsp; &nbsp; </div>
<div dir="auto">
<body text="#000000" bgcolor="#FFFFFF">
<p>Hello,<br>is it me you're looking for?</p>
> Hello,
> is it me you're looking for?
expect(html_to_markdown("<p>Hello <span hidden>cruel </span>World!</p>")).to eq("Hello World!")
expect(html_to_markdown("<strong>Strong</strong>")).to eq("**Strong**")
expect(html_to_markdown("<strong>Str*ng</strong>")).to eq("__Str*ng__")
it "converts <b>" do
expect(html_to_markdown("<b>Bold</b>")).to eq("**Bold**")
expect(html_to_markdown("<b>B*ld</b>")).to eq("__B*ld__")
<p><b>Bold
</b>
it "converts <em>" do
expect(html_to_markdown("<em>Emphasis</em>")).to eq("*Emphasis*")
expect(html_to_markdown("<em>Emph*sis</em>")).to eq("_Emph*sis_")
it "converts <i>" do
expect(html_to_markdown("<i>Italic</i>")).to eq("*Italic*")
expect(html_to_markdown("<i>It*lic</i>")).to eq("_It*lic_")
it "converts <a>" do
expect(html_to_markdown(%Q{<a href="https://www.discourse.org">Discourse</a>})).to eq(
expect(html_to_markdown(%Q{<a href="steam://store/48000">LIMBO</a>})).to eq(
it "removes empty & invalid <a>" do
expect(html_to_markdown("<a>Discourse</a>")).to eq("Discourse")
expect(html_to_markdown(%Q{<a href="">Discourse</a>})).to eq("Discourse")
expect(html_to_markdown(%Q{<a href="foo.bar">Discourse</a>})).to eq("Discourse")
HTML_WITH_IMG ||= %Q{<img src="https://www.discourse.org/logo.svg" alt="Discourse Logo">}
it "converts <img>" do
it "keeps <img> with 'keep_img_tags'" do
expect(html_to_markdown("<img>")).to eq("")
expect(html_to_markdown(%Q{<img src="">})).to eq("")
expect(html_to_markdown(%Q{<img src="foo.bar">})).to eq("")
it "keeps <img> with src='cid:' with 'keep_cid_imgs'" do
it "skips hidden <img>" do
expect(html_to_markdown(%Q{<img src="https://www.discourse.org/logo.svg" width=0>})).to eq("")
expect(html_to_markdown(%Q{<img src="https://www.discourse.org/logo.svg" height="0">})).to eq(
(1..6).each do |n|
it "converts <h#{n}>" do
expect(html_to_markdown("<h#{n}>Header #{n}</h#{n}>")).to eq("#" * n + " Header #{n}")
it "converts <br>" do
it "skips <br> inside <p> if next character is \n" do
it "converts <hr>" do
it "converts <tt>" do
expect(html_to_markdown("<tt>Teletype</tt>")).to eq("`Teletype`")
it "converts <code>" do
expect(html_to_markdown("<code>Code</code>")).to eq("`Code`")
it "supports <ins>" do
it "supports <del>" do
expect(html_to_markdown("This is a <del>deletion</del>")).to eq("This is a <del>deletion</del>")
it "supports <sub>" do
expect(html_to_markdown("H<sub>2</sub>O")).to eq("H<sub>2</sub>O")
it "supports <mark>" do
it "supports <sup>" do
expect(html_to_markdown("<sup>Super Script!</sup>")).to eq("<sup>Super Script!</sup>")
expect(html_to_markdown("<small>Small</small>")).to eq("<small>Small</small>")
it "supports <kbd>" do
expect(html_to_markdown("<kbd>CTRL</kbd>+<kbd>C</kbd>")).to eq("<kbd>CTRL</kbd>+<kbd>C</kbd>")
it "supports <abbr>" do
it "supports <s>" do
expect(html_to_markdown("<s>Strike Through</s>")).to eq("~~Strike Through~~")
it "supports <ul>" do
it "supports <ol>" do
it "supports <p> inside <li>" do
it "supports <ul> inside <ul>" do
expect(html_to_markdown(<<-HTML)).to eq(
it "supports bare <li>" do
expect(html_to_markdown("<li>I'm alone</li>")).to eq("- I'm alone")
it "supports <pre>" do
expect(html_to_markdown("<pre>var foo = 'bar';</pre>")).to eq("```\nvar foo = 'bar';\n```")
expect(html_to_markdown("<pre><code>var foo = 'bar';</code></pre>")).to eq(
html_to_markdown(%Q{<pre><code class="lang-javascript">var foo = 'bar';</code></pre>}),
).to eq("```javascript\nvar foo = 'bar';\n```")
html_to_markdown("<blockquote><pre><code>var foo = 'bar';</code></pre></blockquote>"),
).to eq("> ```\n> var foo = 'bar';\n> ```")
expect(html_to_markdown("<html><body>Hello<div>World</div></body></html>")).to eq(
it "handles <p>" do
expect(html_to_markdown("<p>1st paragraph</p><p>2nd paragraph</p>")).to eq(
it "handles <div>" do
expect(html_to_markdown("<div>1st div</div><div>2nd div</div>")).to eq("1st div\n2nd div")
it "swallows <span>" do
expect(html_to_markdown("<span>Span</span>")).to eq("Span")
it "swallows <u>" do
expect(html_to_markdown("<u>Underline</u>")).to eq("Underline")
expect(html_to_markdown("<script>var foo = 'bar'</script>")).to eq("")
it "removes <style>" do
expect(html_to_markdown("<style>* { margin: 0 }</style>")).to eq("")
it "handles <p> and <div> within <span>" do
html = "<div>1st paragraph<span><div>2nd paragraph</div><p>3rd paragraph</p></span></div>"
it "handles <p> and <div> within <font>" do
it "handles <em>" do
expect(html_to_markdown("<div>A <b> B <i> C <br> D </i> E <br> F </b> G</div>")).to eq(
expect(html_to_markdown("<strong></strong>")).to eq("")
expect(html_to_markdown("<em></em>")).to eq("")
expect(html_to_markdown("Some<em> </em>text")).to eq("Some text")
expect(html_to_markdown("<strong> Bold</strong>")).to eq("**Bold**")
expect(html_to_markdown("<strong>Bold </strong>")).to eq("**Bold**")
expect(html_to_markdown("Some<strong> bold</strong> text")).to eq("Some **bold** text")
expect(html_to_markdown("Some <strong>bold </strong>text")).to eq("Some **bold** text")
expect(html_to_markdown("<em> Italic</em>")).to eq("*Italic*")
expect(html_to_markdown("<em>Italic </em>")).to eq("*Italic*")
expect(html_to_markdown("Some<em> italic</em> text")).to eq("Some *italic* text")
expect(html_to_markdown("Some <em>italic </em>text")).to eq("Some *italic* text")
<th>This</th>
<th>is</th>
<th>the</th>
<th><i>headers</i></th>
<td>I am</td>
<td>the</td>
<td><b>first</b></td>
<td>row</td>
<td>And this</td>
<td>is the</td>
<td>2<sup>nd</sup></td>
<td>line</td>
| This | is | the | *headers* |
| - | - | - | - |
| I am | the | **first** | row |
| And this | is the | 2<sup>nd</sup> | line |
expect(html_to_markdown("<table><tr><td>Hello</td><td>World</td></tr></table>")).to eq(
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<td>One</td>
<td>Two</td>
<td>Three</td>
expect(html_to_markdown(html)).to eq("1 2 3 4 \nOne Two Three")
t "<p>All's well!</p>", "<p>All&rsquo;s well!</p>"
t "<p>Eatin' Lunch'.</p>", "<p>Eatin&rsquo; Lunch&rsquo;.</p>"
t "<p>a 1/4. is a fraction but not 1/4/2000</p>",
t "<p>Well that'll be the day</p>", "<p>Well that&rsquo;ll be the day</p>"
t %(<p>"Quoted text"</p>), "<p>&ldquo;Quoted text&rdquo;</p>"
t "<p>I've been meaning to tell you ..</p>", "<p>I&rsquo;ve been meaning to tell you ..</p>"
t "<p>double hyphen -- ndash --- mdash</p>", "<p>double hyphen &ndash; ndash &mdash; mdash</p>"
t "a long time ago...", "a long time ago&hellip;"
t "is 'this a mistake'?", "is &lsquo;this a mistake&rsquo;?"
t ERB::Util.html_escape("'that went well'"), "&lsquo;that went well&rsquo;"
t '"that went well"', "&ldquo;that went well&rdquo;"
t ERB::Util.html_escape('"that went well"'), "&ldquo;that went well&rdquo;"
t 'src="test.png"&gt; yay', "src=&ldquo;test.png&rdquo;&gt; yay"
t '\\\\mnt\\c', "\\\\mnt\\c"
t ERB::Util.html_escape('<img src="test.png"> yay'),
def initialize(env = {})
env.merge!("rack.hijack" => lambda { @io }, "rack.input" => StringIO.new)
@calls += 1
@calls = 0
env = create_request_env(path: "/")
expect(@calls).to eq(1)
tester.hijack_test { ran = true }
let(:title_error) { "Title can't be blank" }
let(:invalid_topic) { Fabricate.build(:topic, title: "") }
fab!(:member) { Fabricate(:user) }
fab!(:owner) { Fabricate(:user) }
fab!(:staff_post) { Fabricate(:post, user: moderator) }
fab!(:another_group) { Fabricate(:group) }
fab!(:trust_level_0) { Fabricate(:user, trust_level: 0) }
fab!(:trust_level_1) { Fabricate(:user, trust_level: 1) }
fab!(:trust_level_2) { Fabricate(:user, trust_level: 2) }
fab!(:trust_level_3) { Fabricate(:user, trust_level: 3) }
fab!(:trust_level_4) { Fabricate(:user, trust_level: 4) }
let(:host) { "discourse.org" }
:like,
opts: {
user_output = level == :everyone ? true : false
let(:group_owner) { group_private_topic.user.tap { |u| group.add_owner(u) } }
let(:group_owner) { Fabricate(:user).tap { |user| automatic_group.add_owner(user) } }
email_in: "foo2@bar.com",
before { topic.closed = true }
before { topic.trash!(admin) }
before { user.save! }
let(:post_with_draft) { Fabricate(:post, topic: topic) }
fab!(:cat_mod_user) { Fabricate(:user) }
let(:owner) { old_post.user }
let!(:tos_first_post) { Fabricate(:post, topic: tos_topic, user: tos_topic.user) }
let(:post) { Fabricate(:post, locked_by_id: admin.id) }
let(:old_topic) { Fabricate(:topic, user: user, created_at: 6.minutes.ago) }
before { post.post_number = 2 }
user.id = 1
admin.id = 1
user.id = 2
let(:actor) { moderator }
let(:actor) { admin }
u = Fabricate(:user, created_at: 1.day.ago)
fab!(:title_badge) { Fabricate(:badge, name: "Helper", allow_title: true) }
fab!(:no_title_badge) { Fabricate(:badge, name: "Writer", allow_title: false) }
fab!(:group) { Fabricate(:group, title: "Groupie") }
fab!(:group) { Fabricate(:group, title: "Groupie", flair_icon: "icon") }
fab!(:target_user) { Fabricate(:user, created_at: 1.minute.ago) }
let(:target_user) { Fabricate(:user, created_at: 4.days.ago) }
let!(:trust_level_0) { Fabricate(:user, trust_level: 0) }
let(:post) { Fabricate(:post, created_at: 1.minute.ago) }
let(:old_post) { Fabricate(:post, user: trust_level_2, created_at: 6.minutes.ago) }
name: "group",
fab!(:topic_creator) { Fabricate(:user, trust_level: 2) }
fab!(:topic) { Fabricate(:topic, user: topic_creator) }
fab!(:topic) { Fabricate(:topic, user: Fabricate(:user, trust_level: 1)) }
env = create_request_env(path: "/").merge("HTTP_COOKIE" => "_t=#{cookie};")
u = Upload.new(user_id: 9999, id: 2)
Upload.new(user_id: 9999, id: 3)
let(:trust_level_1) { build(:user, trust_level: 1) }
fab!(:tl3_user) { Fabricate(:trust_level_3) }
fab!(:group1) { Fabricate(:group) }
fab!(:group2) { Fabricate(:smtp_group) }
fab!(:group3) { Fabricate(:imap_group) }
expect(cdn_relative_path("/test")).to eq("/test")
expect(cdn_relative_path("/test")).to eq("/foo/test")
).to eq("https://cdn-aws.com/folder/upload.jpg")
it "has a gap for post 3" do
it "has a gap for post 6" do
it "has the gap" do
expect { I18n.t("i_am_an_unknown_key99", raise: true) }.to raise_error(
orig = I18n.t("i_am_an_unknown_key99")
expect(I18n.t("foo", locale: :en)).to eq("Foo in :en")
expect(I18n.t("foo", locale: :de)).to eq("Foo in :de")
I18n.with_locale(:en) { expect(I18n.t("foo")).to eq("Foo in :en") }
I18n.with_locale(:de) { expect(I18n.t("foo")).to eq("Foo in :de") }
expect(I18n.t("foo", locale: "en")).to eq("Foo in :en")
override_translation("en", "got", "summer")
name: "Foo",
plural: {
expect(I18n.t("items", count: 1)).to eq("one item")
expect(I18n.t("items", count: 3)).to eq("some items")
expect(I18n.t("items", count: 20)).to eq("20 items")
before { I18n.locale = :en }
expect(I18n.t("foo")).to eq("Overwritten foo")
override_translation("en", "foo", "new value")
expect(I18n.t("foo")).to eq("new value")
expect(I18n.t("foo")).to eq("Overwritten foo in EN")
expect(I18n.t("foo")).to eq("Overwritten foo in DE")
orig_title = I18n.t("title")
override_translation("en", "world", "my %{world}")
expect(I18n.t("world", world: "foo")).to eq("my foo")
override_translation("en", "wat", "goodbye %{count}")
expect(I18n.t("wat", count: 123)).to eq("goodbye 123")
override_translation("en", "wat", "bar")
expect(I18n.t("wat", count: 1)).to eq("bar")
expect(I18n.t("items", count: 13)).to eq("13 fishies")
expect(I18n.t("items", count: 1)).to eq("one fish")
override_translation("en", "fish", "trout")
expect(I18n.t(:fish, count: 1)).to eq("trout")
expect(I18n.t("fish", count: 1)).to eq("trout")
expect(I18n.t("keys.magic", count: 1)).to eq("one magic key")
expect(I18n.t("keys.magic", count: 2)).to eq("no magic keys")
expect(I18n.t("got")).to eq("summer")
expect(I18n.with_locale(:zh_TW) { I18n.t("got") }).to eq("summer")
override_translation("en", "throne", "%{title} is the new queen")
expect(I18n.t("throne", title: "snow")).to eq("snow is the new queen")
expect(I18n.with_locale(:en) { I18n.t("throne", title: "snow") }).to eq(
expect(I18n.t("got", default: "")).to eq("winter")
expect(I18n.with_locale(:ru) { I18n.t("got", default: "") }).to eq("winter")
override_translation("ru", "got", "summer")
expect(I18n.with_locale(:ru) { I18n.t("got", default: "") }).to eq("summer")
expect(I18n.t("foo_with_variable")).to eq("Foo in :en with %{variable}")
expect(I18n.t("foo_with_variable")).to eq("Foo in :de with %{variable}")
override_translation("de", "foo", "Override of foo in :de")
override_translation("en", "foo", "Override of foo in :en")
buffer << (+"\330").force_encoding("ASCII-8BIT")
buffer << "hello\330\271"
buffer << (+"hello#{254.chr}").force_encoding("ASCII-8BIT").freeze
let(:smtp) { Mail::SMTP.new(options) }
let(:options) { { enable_starttls_auto: false } }
it "will add a type" do
let(:doc_response) { { status: 200, headers: { "Content-Type" => "text/html" } } }
let(:image_response) { { status: 200, headers: { "Content-Type" => "image/jpeg" } } }
let(:body_response) { { status: 200, body: "<body>test</body>" } }
ip = "1.2.3.4"
stub_request(method, /\A#{matcher}\z/).with(headers: { "Host" => host })
body: "<head><link rel=\"canonical\" href=\"#{dest}\"></head>",
fd_stub_request(:head, from).to_return(status: 302, headers: { "Location" => dest })
fd =
url = "https://force.get.com/posts?page=4"
it "will try a GET" do
body: "<html><head>",
fd.get do |resp, c|
chunk = c
expect(chunk).to eq("<html><head>")
subject(:get) { fd.get {} }
expect(fd("https://eviltrout.com?s=180&#038;d=mm&#038;r=g").normalized_url.to_s).to eq(
expect(fd("http://example.com/?a=\11\15").normalized_url.to_s).to eq(
).to eq("https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D0%BE%D0%B1%D0%BE")
SiteSetting.blocked_ip_blocks = "98.0.0.0/8|78.13.47.0/24|9001:82f3::/32"
stub_tcp_to_raise("2.2.2.2", Errno::EPIPE)
expect_tcp_and_abort("3.3.3.3") { FinalDestination::HTTP.get(URI("https://example.com")) }
.with { |addr| addr == "example.com" }
expect_tcp_and_abort("2.2.2.2") { FinalDestination::HTTP.get(URI("https://example.com")) }
expect_tcp_and_abort("0.0.0.0") do
.stubs(:open)
fab!(:p2) { Fabricate(:post, topic: topic, user: coding_horror, percent_rank: 0.5) }
let(:etag) { "etag" }
.with(regexp_matches(%r{original/\d+X.*/#{upload.sha1}\.png}))
.returns(Aws::S3::Types::PutObjectOutput.new(etag: "\"#{etag}\""))
%r{//s3-upload-bucket\.s3\.dualstack\.us-west-1\.amazonaws\.com/original/\d+X.*/#{upload.sha1}\.png},
s3_object.stubs(:put).returns(Aws::S3::Types::PutObjectOutput.new(etag: "\"#{etag}\""))
.with(regexp_matches(%r{original/\d+X.*/#{upload.sha1}\.pdf}))
acl: "private",
%r{//s3-upload-bucket\.s3\.dualstack\.us-west-1\.amazonaws\.com/original/\d+X.*/#{upload.sha1}\.pdf},
path =
%r{//s3-upload-bucket\.s3\.dualstack\.us-west-1\.amazonaws\.com/#{path}},
destination = source.sub(".png", ".jpg")
let(:tombstone_key) { "tombstone/#{optimized_key}" }
assert_path("/hello", "/hello")
assert_path("//hello", nil)
assert_path("http://hello", nil)
assert_path("https://hello", nil)
uri =
%r{/#{upload_path}/original/.+#{upload.sha1}\.png},
).to match(%r{/#{upload_path}/original/.+#{upload.sha1}\.png})
fab!(:upload) do
before { upload.update!(url: "") }
let!(:upload) { Fabricate.build(:upload, id: 100) }
let!(:optimized_path) { "optimized/1X/#{upload.sha1}_1_100x200.png" }
let!(:optimized_path) { "optimized/1X/#{upload.sha1}_1_100x200.jpg" }
body: "Hello world",
let(:url) { "https://eviltrout.com/trout.png" }
let(:png) { File.read("#{Rails.root}/spec/fixtures/images/cropped.png") }
url = "http://fourohfour.com/404"
stub_request(:get, url).to_return(status: 404, body: "404")
url2 = "https://test.com/image.png"
stub_request(:get, url).to_return(status: 302, body: "", headers: { location: url2 })
stub_request(:get, url2).to_return(status: 200, body: "i am the body")
let(:url) { "https://eviltrout.com/trout.jpg" }
stub_request(:get, url).to_return(body: png, headers: { "content-type": "image/png" })
let(:atom_feed) { RSS::Parser.parse(file_from_fixtures("feed.atom", "feed"), false) }
let(:rss_feed) { RSS::Parser.parse(file_from_fixtures("feed.rss", "feed"), false) }
let(:raw_feed) { file_from_fixtures("feed.rss", "feed").read }
let(:raw_feed) { file_from_fixtures("feed.atom", "feed").read }
html = <<~HTML.strip
</details>
html = "<details><summary>foo</summary><p>bar</p></details>"
html = '<svg class="fa d-icon d-icon-folder svg-icon svg-node"><use href="#folder"></use></svg>'
html = '<svg class="blah"><use href="#folder"></use></svg>'
html = '<svg><use href="#folder"></use></svg>'
<h3>
</h3>
<aside class="quote" data-post="1" data-topic="8">
let(:hash_enum) { Enum.new(jake: 1, finn: 2, princess_bubblegum: 3, peppermint_butler: 4) }
expect(to_utf8("iso-8859-5.txt")).to eq(
expect(EmberCli.ember_version).to match(/\A\d+\.\d+/)
let(:old_email) { "old.email@example.com" }
let(:new_email) { "new.email@example.com" }
let(:user) { Fabricate(:user, email: old_email) }
) { updater.change_to(new_email) }
let(:user) { admin }
) { updater.change_to(new_email, add: true) }
).last,
let(:existing) { Fabricate(:user, email: new_email) }
raw = "**Hello world!**"
expect(cook(raw)).to eq("hello\n<br>world\n<br>")
long = plaintext(<<~EMAIL)
long_cooked = (+<<~HTML).strip!
&lt;/form&gt;
nbsp = "\u00A0"
<br>#{nbsp}#{nbsp}#{nbsp}#{nbsp}this is intended by 4 spaces
<img src='some_image.png' width='100' height='100'>
long_cooked = <<~HTML
<br><img src='some_image.png' width='100' height='100'>
<br><br>
<summary title='Show trimmed content'>&#183;&#183;&#183;</summary>
let(:attachments) { {} }
frag = basic_fragment("<img height='auto' width='auto' src='gigantic.jpg'>")
frag = basic_fragment("<img src='/images/emoji/fish.png' class='emoji'>")
frag =
frag = basic_fragment("<img src='/some-image.png'>")
frag = basic_fragment("<div class='foo' id='bar'><div class='foo' id='bar'></div></div>")
expect(frag.to_html).to eq("<div><div></div></div>")
frag = html_fragment("<h3>hello</h3>")
frag = html_fragment("hello<hr>")
frag = html_fragment("<a href>wat</a>")
frag = html_fragment("<ul><li>hello</li></ul>")
frag = html_fragment("<iframe src=\"#{iframe_url}\"></iframe>")
iframe_url = "alert('xss hole')"
expect(frag.at("a")).to be_blank
frag = html_fragment("<iframe src=''></iframe>")
expect(frag.at("a").text.chomp).to eq("#dev")
frag = html_fragment('<a href="//youtube.com/discourse">hello</a>')
frag = html_fragment('<a href="//test.localhost/discourse">hello</a>')
frag = html_fragment('<img src="//test.localhost/blah.jpg">')
frag = html_fragment('<div class="body">test</div>')
let(:attachments) { { "testimage.png" => stub(url: "email/test.png") } }
frag = html_fragment(<<~HTML)
let(:attachments_index) { { upload.sha1 => 0 } }
let(:attachments_index) { { upload.sha1 => 0, siteicon.sha1 => 1 } }
<a href="https://test.com/article" target="_blank" rel="noopener" title="02:33PM - 24 October 2020">Test</a>
<h3><a href="https://test.com/article" target="_blank" rel="noopener">Test</a></h3>
<p>This is a test onebox.</p>
<div style="clear: both"></div>
<p><a class="mention" href="/u/martin">@martin</a> check this out:</p>
<h4>
</h4>
<div class="date">
<div class="user">
<span class="added">+250</span>
<span class="removed">-224</span>
let(:reply_key) { "abcd" * 8 }
message = Mail::Message.new(to: "eviltrout@test.domain", body: "**hello**")
fab!(:category) { Fabricate(:category, name: "Name With Space") }
fab!(:post_1) { Fabricate(:post, topic: topic, post_number: 1) }
fab!(:post_2) { Fabricate(:post, topic: topic, post_number: 2) }
fab!(:post_3) { Fabricate(:post, topic: topic, post_number: 3) }
fab!(:post_4) { Fabricate(:post, topic: topic, post_number: 4) }
fab!(:post_5) { Fabricate(:post, topic: topic, post_number: 5) }
fab!(:post_6) { Fabricate(:post, topic: topic, post_number: 6) }
let!(:post_reply_1_4) { PostReply.create(post: post_1, reply: post_4) }
let!(:post_reply_2_4) { PostReply.create(post: post_2, reply: post_4) }
let!(:post_reply_3_4) { PostReply.create(post: post_3, reply: post_4) }
let!(:post_reply_4_5) { PostReply.create(post: post_4, reply: post_5) }
let!(:post_reply_4_6) { PostReply.create(post: post_4, reply: post_6) }
let!(:post_reply_5_6) { PostReply.create(post: post_5, reply: post_6) }
post: post_1,
let(:email_log) { EmailLog.last }
let(:group) { Fabricate(:smtp_group) }
fab!(:small_pdf) do
fab!(:large_pdf) do
fab!(:csv_file) do
fab!(:image) do
fab!(:reply) do
reply.update!(raw: reply.raw + "\n wow this is #dev")
<a href=\"#{Discourse.base_url}#{category.url}\" data-type=\"category\" data-slug=\"dev\" style=\"text-decoration: none; font-weight: bold; color: #006699;\"><span>#dev</span>
body: "test body",
mail.text_part = Mail::Part.new { body "Key &amp; Peele" }
body "<h1>Key &amp; Peele</h1>"
def process(email_name, opts = {})
let(:email_address) { "linux-admin@b-s-c.co.jp" }
let(:post) { create_post(topic: topic, user: user1) }
expect(name).to eq("Foo Bar")
fab!(:user) { Fabricate(:user, email: "linux-admin@b-s-c.co.jp") }
let!(:email_log) do
let!(:email_log_2) do
fab!(:user) { Fabricate(:user, email: "discourse@bar.com") }
fab!(:post) { create_post(topic: topic) }
handler = proc { |_| handler_calls += 1 }
expect(topic.posts.last.raw).to eq("This is a **HTML** reply ;)")
expect(topic.posts.last.raw).to eq("This is the **html** part.")
expect(topic.posts.last.raw).to eq("And this is *my* reply :+1:")
expect(topic.posts.last.raw).to eq("This is a reply :)")
expect(post.raw).to eq(<<~MD.chomp)
expect(post.raw).to eq(<<~RAW.chomp)
From: Some One &lt;some@one\\.com&gt;
To: Ba Bar &lt;ba@bar\\.com&gt;
Date: Mon, 1 Dec 2016 00:13:37 \\+0100
fab!(:group) { Fabricate(:group, incoming_email: "team@bar.com|meat@bar.com") }
expect { process(:cc) }.to change(Topic, :count)
expect { process(:cc) }.to change(Topic, :count).by(1).and change(User, :count).by(1)
expect { process(:email_reply_1) }.to change(Topic, :count).by(1) &
change(Post, :count).by(3)
expect { process(:email_reply_2) }.to change { topic.posts.count }.by(1)
expect { process(:email_reply_3) }.to change { topic.posts.count }.by(1)
expect { process(:email_reply_4) }.to change { topic.posts.count }.by(1)
From: Two <two@foo.com>
In-Reply-To: <#{message_id}>
}.to change { Post.count }.by(1)
).and not_change { Topic.count }
fab!(:user_in_group) do
user = User.find_by_email("two@foo.com")
}.and change { Post.count }.by(1)
).and change { Post.count }.by(1)
expect { process(:email_reply_2) }.to change { topic.posts.count }.by(1).and not_change {
expect(Email::Receiver.reply_by_email_address_regex).to eq(/foo\+?(\h{32})?@bar\.com/)
expect(Email::Receiver.reply_by_email_address_regex).to eq(/alt\.foo\+?(\h{32})?@bar\.com/)
/foo\+?(\h{32})?@bar\.com|alt\.foo\+?(\h{32})?@bar\.com/,
).to be_nil
:no_body,
:new_user,
fab!(:user2) { Fabricate(:user, email: "someone_else@bar.com") }
fab!(:post) { create_post(topic: topic, user: user) }
fab!(:group) { Fabricate(:group, incoming_email: "team@bar.com") }
- list
- sub-list
+ list
+ sub-list
1.upto(10).each do |i|
let(:stripped_text) { <<~MD }
--
fab!(:email_log) do
From: someone <#{user.email}>
In-Reply-To: <#{digest_message_id}>
let (:email_1) {
let (:post_2) {
let (:email_3) {
In-Reply-To: <topic/#{post_2.topic_id}/#{post_2.id}@test.localhost>
expect { receive(email_1) }.to change { Topic.count }.by(1).and change {
expect { post_2 }.to not_change { Topic.count }.and change {
expect { receive(email_3) }.to not_change { Topic.count }.and change {
let(:from) { "foo@bar.com" }
let(:mail) { file_from_fixtures("chinese_reply.eml", "emails").read }
expect(rejection_raw.gsub(/\r/, "")).to eq(
).gsub(/\r/, ""),
let(:mail) { "From: #{from}\nTo: bar@foo.com\nSubject: FOO BAR\n\nFoo foo bar bar?" }
let(:mail) { "From: #{from}\nTo: bar@foo.com" }
let(:mail2) { "From: #{from}\nTo: foo@foo.com" }
let(:mail3) { "From: #{from}\nTo: foobar@foo.com" }
fab!(:post) { Fabricate(:post, topic: topic, created_at: 3.days.ago) }
.gsub("424242", topic.id.to_s)
.gsub("123456", post.id.to_s)
short_url: "#{Discourse.base_url}/p/#{post.id}",
let(:mail) { file_from_fixtures("cc.eml", "emails").read }
let(:subject) { "Tree Trunks has made some apple pie!" }
it "has the body" do
SiteSetting.stubs(:title).returns(">>>Obnoxious Title: Deal, \"With\" It<<<")
let(:additional_opts) { {} }
body: "hello world",
let(:additional_opts) { { allow_reply_by_email: true } }
url: "/t/1234",
.expects(:t)
).save!
SiteSetting.stubs(:email_site_title).returns("::>>>Best \"Forum\", EU: Award Winning<<<")
expect(Email.is_valid?("sam@sam.com")).to eq(true)
expect(Email.is_valid?("sam")).to eq(false)
expect(Email.obfuscate("a@b.com")).to eq("*@*.com")
expect(Email.obfuscate("test@test.co.uk")).to eq("t***@t***.**.uk")
expect(Email.obfuscate("simple@example.com")).to eq("s****e@e*****e.com")
expect(Email.obfuscate("very.common@example.com")).to eq("v*********n@e*****e.com")
expect(Email.obfuscate("x@example.com")).to eq("*@e*****e.com")
expect(Email.obfuscate("example@s.example")).to eq("e*****e@*.example")
expect(Email.obfuscate("user%example.com@example.org")).to eq("u**************m@e*****e.org")
expect(Email.obfuscate("user-@example.org")).to eq("u***-@e*****e.org")
foo.example.net (foobar) 1 (baz);
dkim (Because I like it) / 1 (One yay) = (wait for it) fail
it "is #{verdict}" do
let(:headers) { "" }
it "is gray" do
let(:headers) { "valid.com; dmarc=fail" }
let(:headers) { "valid.com; dmarc=pass" }
let(:headers) { "valid.com; dmarc=error" }
let(:headers) { "foobar.com; dmarc=fail" }
let(:headers) { "foobar.com; dmarc=pass" }
let(:key) { "test_mutex_key" }
x = 0
.map do |m|
y = x
x = y + 1
.map(&:join)
expect(x).to eq(10)
m.synchronize { "nop" }
expect(Time.now).to be <= start + 1
before { Discourse.redis.slaveof "127.0.0.1", "65534" }
after { Discourse.redis.slaveof "no", "one" }
3.times do |i|
expect(memoize { "abc" }).to eq("abc")
memoize { "abc" }
expect(memoize { "world" }).to eq("abc")
let(:cache) { described_class.new("mytest") }
MessageBus.track_publish("/distributed_hash") { cache.defer_get_set("key") { "value" } }
let(:time) { 12.hours.ago }
before { stub_data("0.9.0", 2, false, time) }
before { stub_data(nil, nil, false, nil) }
before { stub_data("0.10.10.123", 0, false, 8.hours.ago) }
before { stub_data("0.9.7", 0, false, 8.hours.ago) }
before { stub_data("0.9.7", 1, false, 8.hours.ago) }
let!(:last_item_date) { 5.minutes.ago }
:discourse_version => "2.6.0.beta1",
:discourse_version => "2.7.0.beta2",
:discourse_version => "2.7.0.beta5",
:discourse_version => "2.7.0",
fab!(:tag3) { Fabricate(:tag, name: "Fun3") }
fab!(:group) { Fabricate(:group, name: "my-group") }
fab!(:group_user) { Fabricate(:group_user, group: group, user: user) }
fab!(:tag_group2) do
fab!(:tag_group3) do
fab!(:tag_group4) do
tags =
term: "fun",
).map(&:name)
fab!(:tag_with_colon) { Fabricate(:tag, name: "with:colon") }
term: "with:c",
user_tag_group.update!(permissions: { "my-group" => 1, "another-group" => 1 })
min_count: 1,
order: 2,
fab!(:tag4) { Fabricate(:tag, name: "T4") }
fab!(:tag5) { Fabricate(:tag, name: "T5") }
fab!(:tag6) { Fabricate(:tag, name: "T6") }
fab!(:tag7) { Fabricate(:tag, name: "T7") }
term: "",
fab!(:base_tag) { Fabricate(:tag, name: "discourse") }
fab!(:synonym) { Fabricate(:tag, name: "discource", target_tag: base_tag) }
term: "disc",
fab!(:non_staff_group) { Fabricate(:group, name: "non_staff_group") }
fab!(:post) { Fabricate(:post, user: user, topic: topic, post_number: 1) }
raw: post.raw + " edit",
let(:post) { Fabricate(:post, user: user, topic: topic, post_number: 1) }
let(:tag_group) { Fabricate(:tag_group, parent_tag_id: tag1.id) }
common = Fabricate(:tag, name: "common")
tags: tag_group.tags.pluck(:name).join(", "),
fab!(:syn1) { Fabricate(:tag, name: "synonym1", target_tag: tag1) }
fab!(:syn2) { Fabricate(:tag, name: "synonym2", target_tag: tag1) }
fab!(:staff_tag) { Fabricate(:tag) }
fab!(:other_staff_tag) { Fabricate(:tag) }
it "has a non-ssl base url" do
req = stub(fullpath: "/hello", headers: {})
p.path = "my-plugin-1"
}.to(nil)
job: {
{ Jobs::PollMailbox => 1, Jobs::ReindexSearch => 2 },
) # Raises in test mode, catch it
expect(runner.exec("pwd").strip).to eq("#{Rails.root.to_s}/plugins")
Discourse::Utils.execute_command({ "ENV1" => "VAL" }, "echo a b c")
expect(Discourse::Utils.execute_command("echo", "a", "b", "c").strip).to eq("a b c")
let!(:upload) { Fabricate(:s3_image_upload) }
name: "imajee",
let!(:js_field) do
name: "somefile.js",
value: <<~JS,
let!(:scss_field) do
.something { background: url($imajee); }
.css("script")
.css("link")
expect(css).to include("url(#{old_upload_url})")
expect(css).to include("url(#{new_upload_url})")
def asset_path(path, options = {})
input = { environment: env, data: input, name: "mapped", filename: "mapped.js", metadata: {} }
expect(raw_redis.get("foo")).to eq(nil)
expect(raw_redis.get("bar")).to eq(nil)
expect(redis.get("foo")).to eq("bar")
expect(redis.get("bar")).to eq("foo")
set, incr = nil
set = pipeline.set "foo", "baz"
expect(set.value).to eq("OK")
expect(raw_redis.get("baz")).to eq(nil)
expect(redis.get("foo")).to eq("baz")
expect(redis.get("baz")).to eq("1")
expect(redis.get("foo")).to eq(nil)
expect(redis.get("baz")).to eq(nil)
expect(redis.get("bar")).to eq(nil)
raw_redis.set("test:key2", 1)
redis.del("key", "key3")
raw_redis.set("default:key1", "1")
raw_redis.set("default:key2", "2")
describe "#sadd?" do
redis.sadd?("testset", "1")
describe "#srem?" do
redis.srem?("testset", "1")
raw_redis.set("key1", "1")
raw_redis.set("key2", "2")
redis.del("key1", "key2")
redis.set("key", 1)
expect(Discourse.redis.eval("return { KEYS, ARGV };", keys: keys, argv: argv)).to eq(
let(:cache) { Cache.new(namespace: "foo") }
store.fetch("key") { "key in store" }
r = store.read("key")
expect(r).to eq("key in store")
cache.fetch("key") { "key in cache" }
expect(store.read("key")).to eq(nil)
expect(cache.fetch("key")).to eq("key in cache")
it "works for a set" do
let(:plugin_directory_name) { "hello" }
let(:plugin_directory_name) { "my_plugin" }
script = <<~JS.chomp
try {
} catch {
let a = {
x,
y,
const template = hbs`{{somevalue}}`;
return _r;
{{somevalue}}
let(:theme_id) { 22 }
let(:helpers) { <<~JS }
return `setting(${themeId}:${string})`
return `dummy(${string})`
).read,
expect(render("{{theme-prefix 'translation_key'}}")).to eq(
expect(render("{{theme-i18n 'translation_key'}}")).to eq(
expect(render("{{theme-setting 'setting_key'}}")).to eq("setting(22:setting_key)")
).to include(
script = <<~JS
result.gsub(%r{/\*(.*)\*/}m, "/* (js comment stripped) */")
{ sourceMap: { includeSources: true } },
expect(ctx.eval("multiply(2, 3)")).to eq(6)
expect(ctx.eval("add(2, 3)")).to eq(5)
hub_response = { "success" => "OK", "latest_version" => "0.8.1", "critical_updates" => false }
it "defaults to {}" do
let(:event_handler) { Proc.new { |user| user.name = "Two Face" } }
let(:event_handler_2) { Proc.new { |user| user.job = "Supervillain" } }
Proc.new do |name:, message:|
a = "<test>start</test>"
b = "<test>end</test>"
prev = "<div>#{CGI.escapeHTML(a)}</div>"
cur = "<div>#{CGI.escapeHTML(b)}</div>"
expect(diff.inline_html).not_to match(%r{</?test>})
expect(diff.side_by_side_html).not_to match(%r{</?test>})
expect(DiscourseDiff.new("", "").inline_html).to eq("<div class=\"inline-diff\"></div>")
before = after = "<p>this is a paragraph</p>"
before = "<p>this is a paragraph</p>"
after = "<p>this is a great paragraph</p>"
before = "<p>this is a great paragraph</p>"
after = "<p>this is a paragraph</p>"
before = "<p>this is the first paragraph</p>"
after = "<p>this is the second paragraph</p>"
before = "<p>'</p>"
after = "<p></p>"
expect(DiscourseDiff.new("", "").side_by_side_html).to eq(
before = "<p>this is one paragraph</p><p>here is yet another</p>"
after = "<p>this is one great paragraph</p><p>here is another</p>"
before = "<p data-attr='Some \"quoted\" string'></p>"
after = "<p data-attr='Some \"quoted\" string'></p>"
before = ""
after = "<img src=\"//domain.com/image.png>\""
post = Fabricate(:post, cooked: "test")
post = Fabricate(:post, raw: "This is a test", cooked: "This is a test")
env = create_request_env(path: "/test").merge("HTTP_COOKIE" => "_t=#{cookie};")
crawler! "Java/1.8.0_151"
not_crawler! "Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko"
fab!(:post) { Fabricate(:post, raw: <<~RAW) }
let(:url_hostname) { "meta.discourse.org" }
let(:url) { "https://#{url_hostname}/t/mini-inline-onebox-support-rfc/66400" }
let(:not_oneboxed_url) { "https://#{url_hostname}/t/random-url" }
let(:title) { "some title" }
let(:post) { Fabricate(:post, raw: <<~RAW) }
This is a #{url} with path
<title>#{title}</title>
<meta property='og:title' content="#{title}">
href: url,
without: {
class: "onebox",
fab!(:post) { Fabricate(:post, raw: "Hello #{topic.url}") }
let(:url) { topic.url }
let(:url_with_query_param) { "https://meta.discourse.org?a" }
let(:url_no_path) { "https://meta.discourse.org/" }
let(:title) { "<b>some title</b>" }
- #{url_with_path}
- #{url_with_query_param}
let(:staff_post) { Fabricate(:post, user: Fabricate(:admin), raw: <<~RAW) }
body: "<html><head><title>#{escaped_title}</title></head></html>",
post = Fabricate(:post, raw: "hello <img src='#{upload.url}'>")
url: "/#{upload_path}/666x500.jpg",
extension: ".jpg",
url: "/#{upload_path}/1998x1500.jpg",
url: "http://a.b.c/200x500.jpg",
expect(cpp.html).to match(%r{src="http://foo.bar/image.png" width="" height=""})
expect(cpp.html).to match(%r{src="http://domain.com/picture.jpg" width="50" height="42"})
fab!(:post) { Fabricate(:post_with_image_urls) }
{ "http://foo.bar/image.png" => { "width" => 111, "height" => 222 } }
expect(cpp.html).to match(%r{src="http://foo.bar/image.png" width="111" height="222"})
%r{src="http://domain.com/picture.jpg" width="50" height="42"},
let(:image_sizes) { { "http://foo.bar/image.png" => { "width" => 0, "height" => 222 } } }
let(:image_sizes) { { "http://foo.bar/image.png" => { "width" => 111, "height" => 0 } } }
let(:image_sizes) { { "http://foo.bar/image.png" => { "width" => 0, "height" => 0 } } }
fab!(:upload) { Fabricate(:image_upload, width: 123, height: 456) }
fab!(:post) { Fabricate(:post, raw: <<~HTML) }
expect(cpp.html).to match(/width="123" height="456"/)
fab!(:upload) { Fabricate(:image_upload, width: 1750, height: 2000) }
let(:url) { "https://image.com/my-avatar" }
let(:post) { Fabricate(:post, raw: url) }
let(:optimized_size) { "600x500" }
let(:cooked_html) { <<~HTML }
</div></a></div></p>
fab!(:upload) { Fabricate(:image_upload, width: 500, height: 2200) }
expect(cpp.html).to match(/width="113" height="500">/)
fab!(:upload) { Fabricate(:image_upload, width: 500, height: 2300) }
expect(cpp.html).to match(/width="500" height="500">/)
fab!(:upload) { Fabricate(:image_upload, width: 1125, height: 2436) }
<img src="/subfolder#{upload.url}">
<img src="#{upload.url}" title="WAT" alt="RED">
<img src="#{upload.url}" title="WAT">
<img src="#{upload.url}" alt="RED">
post = Fabricate(:post, raw: <<~MD)
let(:post) { build(:post_with_plenty_of_images) }
let(:post) { build(:post) }
img = { "src" => "http://foo.bar/image3.png", "width" => 50, "height" => 70 }
img = { "src" => "http://foo.bar/image3.png", "width" => 50.2, "height" => 70.1 }
img = { "src" => "http://foo.bar/image3.png", "width" => 100 }
img = { "src" => "http://foo.bar/image3.png", "height" => 100 }
img = { "src" => nil, "height" => 100 }
{ "http://my.discourse.org/image.png" => { "width" => 111, "height" => 222 } }
expect(cpp.is_valid_image_url?("//domain.com")).to eq(false)
expect(cpp.is_valid_image_url?("http://do<main.com")).to eq(nil)
post = Fabricate(:post, raw: "https://discourse.org")
let(:post) { build(:post_with_youtube, id: 123) }
user_id: nil,
let(:image_url) { "https://image.com/avatar.png" }
.returns("<img class='onebox' src='#{image_url}' />")
post = Fabricate(:post, raw: url)
url: "//image.com/avatar.png",
url = "https://image.com/my-avatar"
url: "//example.com/favicon.ico",
let(:post) { build(:post_with_uploads_and_links) }
<img src="http://foo.bar/image.png"><br>
<img src="//test.localhost/images/emoji/twitter/smile.png?v=#{Emoji::EMOJI_VERSION}" title=":smile:" class="emoji only-emoji" alt=":smile:" loading="lazy" width="20" height="20"></p>
<p><a href="//my.cdn.com/#{upload_path}/original/2X/2345678901234567.jpg">Link</a><br>
<img src="//my.cdn.com/images/emoji/twitter/smile.png?v=#{Emoji::EMOJI_VERSION}" title=":smile:" class="emoji only-emoji" alt=":smile:" loading="lazy" width="20" height="20"></p>
<img src="https://my.cdn.com/images/emoji/twitter/smile.png?v=#{Emoji::EMOJI_VERSION}" title=":smile:" class="emoji only-emoji" alt=":smile:" loading="lazy" width="20" height="20"></p>
width: 10,
the_post =
<p><img src="https://s3.cdn.com/#{stored_path}" alt="smallest.png" data-base62-sha1="#{upload.base62_sha1}" width="10" height="20"></p>
<p><img src="/secure-uploads/#{stored_path}" alt="smallest.png" data-base62-sha1="#{upload.base62_sha1}" width="10" height="20"></p>
<p>This post has a custom emoji <img src="#{upload_url}?v=#{Emoji::EMOJI_VERSION}" title=":trout:" class="emoji emoji-custom" alt=":trout:" loading="lazy" width="20" height="20"></p>
fab!(:video_upload) { Fabricate(:upload, extension: "mov") }
<p>This post has an S3 video onebox:</p>
<source src="#{video_upload.url}">
<a href="#{video_upload.url}" rel="nofollow ugc noopener">#{video_upload.url}</a>
<source src="#{secure_url}">
<a href="#{secure_url}">#{secure_url}</a>
raw = <<~RAW.rstrip
<p>This post has a video upload.</p>
<source src="#{secure_video_url}">
<a href="#{secure_video_url}">#{secure_video_url}</a>
<audio controls=""><source src="#{secure_audio_url}"><a href="#{secure_audio_url}">#{secure_audio_url}</a></audio></p>
link to a topic: #{topic.url}?u=foo
expect(cpp.html).to have_tag("a", with: { href: topic.url })
expect(cpp.html).to have_tag("a", with: { href: "#{topic.url}?bob=bob&jane=jane" })
expect(cpp.html).to have_tag("a", with: { href: "https://google.com/?u=bar" })
expect(cpp.html).to have_tag("a", with: { href: "https://www.example.com/#123#4" })
let(:doc) do
let(:post) { Fabricate(:post, raw: "time to eat some sweet :candy: mmmm") }
post = Fabricate(:post, raw: "onebox me:\n\nhttps://discourse.org\n")
post = Fabricate(:post, raw: "onebox me:\n\nhttp://example.com\n")
Fabricate(:post, raw: "This is a **reply** via email ;)", via_email: true, post_number: 2)
let(:pp) { Fabricate(:post, raw: "This post is ripe for quoting!") }
let(:cp) do
let(:external_raw) { <<~RAW.strip }
let(:cp) { Fabricate(:post, raw: external_raw) }
let!(:post) { Fabricate(:post, topic: topic, raw: 'this is the "first" post') }
let(:raw2) { <<~RAW.strip }
let(:raw3) { <<~RAW.strip }
post = Fabricate(:post, topic: topic, raw: "<sunday><monday>")
expect(cp.html).to eq("<p></p>")
reply2 = Fabricate(:post, topic: topic, raw: <<~RAW.strip)
fab!(:user) { Fabricate(:user, name: "james, john, the third") }
let!(:post) { Fabricate(:post, user: user, topic: topic, raw: 'this is the "first" post') }
reply = Fabricate(:post, user: user, topic: topic, raw: <<~RAW.strip)
expect(doc.css(".title").text).to eq("\n\n #{user.name}:")
post = Fabricate(:post, raw: '<img alt="<something>">')
expect(post.cook(post.raw)).to eq('<p><img alt="&lt;something&gt;"></p>')
expect(CookedPostProcessor.new(post).html).to eq('<p><img alt="&lt;something&gt;"></p>')
it "is set to self" do
it "is set to none" do
global_setting(:s3_cdn_url, "https://s3-cdn.com")
settings = <<~YML
theme.set_field(target: :common, name: "header", value: <<~HTML)
theme.set_field(target: :desktop, name: "header", value: "")
def policy(theme_id = nil, path_info: "/")
describe "#<<" do
builder << {
builder << "string"
builder << {}
c = ContentBuffer.new("a\nbc\nc")
c.apply_transform!(start: { row: 0, col: 0 }, finish: { col: 1, row: 1 }, operation: :delete)
expect(c.to_s).to eq("c\nc")
c.apply_transform!(start: { row: 0, col: 1 }, finish: { col: 4, row: 0 }, operation: :delete)
expect(c.to_s).to eq("ho world")
c.apply_transform!(start: { row: 0, col: 5 }, operation: :insert, text: " world")
expect(c.to_s).to eq("hello world!")
c.apply_transform!(start: { row: 0, col: 5 }, operation: :insert, text: "\nworld")
expect(c.to_s).to eq("hello\nworld!")
totp = nil
let(:secure_session) { {} }
let(:invalid_method) { 4 }
let(:token) { "test" }
raw_codes = Array.new(10) { SecureRandom.hex(8) }
5.times { |i| DB.exec("insert into test_items(id,position) values(#{i}, #{i})") }
item.id = 7
search_data: "a",
raw_data: "a",
expect(test_item.custom_fields).to eq("jack" => "jill")
test_item.custom_fields = { "a" => "b" }
expect(db_item.custom_fields).to eq("a" => "b", "c" => "d")
expect(db_item.custom_fields).to eq("a" => "c")
test_item.custom_fields = { "bool" => true, "int" => 1, "json" => { "foo" => "bar" } }
expect((before_ids - after_ids).size).to eq(1)
expect(test_item.custom_fields).to eq("jack" => "black", "bob" => "marley")
expect(test_item2.custom_fields).to eq("sixto" => "rodriguez", "de" => "la playa")
field_type = "bad_json"
value: "{test",
item2.custom_fields = { "e" => "hallo" }
expected = { field_type => { "b" => { "c" => "d", "e" => "f" } } }
item0.custom_fields = { "rare" => "gem" }
test_item.upsert_custom_fields("hello" => "world", "abc" => "def")
test_item.upsert_custom_fields("abc" => "ghi")
@data = nil
@data ||= {}
expect(TestCachedCounting.data).to eq({ "a,a" => 2, "b" => 1 })
@cache_data ||= {}
let(:folder_name) { "test" }
File.write("#{folder_name}/hello.txt", "hello world")
FileUtils.rm_rf("#{folder_name}/")
let(:extension) { ".zip" }
zip_file = "#{temp_folder}/theme.zip"
zipfile.get_output_stream("child-file") { |f| f.puts("child file") }
expect(Dir.glob("**/*")).to contain_exactly(
let(:extension) { ".tar.gz" }
tar_file = "#{temp_folder}/theme.tar"
File.open(tar_file, "wb") do |file|
tar.add_file("child-file", 644) { |tf| tf.write("child file") }
tar.add_file("../escape-extraction-folder", 644) do |tf|
tar.add_file("child-dir/grandchild-file", 644) { |tf| tf.write("grandchild file") }
tar_gz_file = "#{temp_folder}/theme.tar.gz"
let(:extension) { ".tar" }
File.read("#{temp_folder}/#{relative_path}")
topic_id: topic.id + 1,
fab!(:third_user) { Fabricate(:user) }
fab!(:topic) { Fabricate(:topic, user: other_user) }
fab!(:op) { Fabricate(:post, topic_id: topic.id, user: other_user) }
fab!(:first_reply) { Fabricate(:post, topic: topic, user: user, reply_to_user_id: op.user_id) }
fab!(:second_reply) { Fabricate(:post, topic: topic, user: user, reply_to_user_id: op.user_id) }
post_id: op.id,
let!(:message) { finder.check_get_a_room }
let!(:message) { finder.check_get_a_room(min_users_posted: 2) }
expect(ColorMath.dark_light_diff("fff", "eee", 0, -0.5)).to eq("808080")
expect(ColorMath.dark_light_diff("000", "eee", 0.5, 0)).to eq("808080")
fab!(:can_create_user) { Fabricate(:user) }
c = Fabricate(:category, name: "<b>name</b>", description: "<b>title</b>")
expect(html).not_to include("<b>title</b>")
expect(html).not_to include("<b>name</b>")
expect(html).to include(ERB::Util.html_escape("<b>name</b>"))
c = Fabricate(:category, description: '<code>\' &lt;b id="x"&gt;</code>')
expect(html).to include("title='&#39; &lt;b id=&quot;x&quot;&gt;'")
cache.write("float", 1.1)
expect(cache.read("float")).to eq(1.1)
cache.write("num", 1)
expect(cache.read("num")).to eq(1)
Discourse.redis.set("boo", "boo")
cache.write("hello0", "world")
cache.write("hello1", "world")
cache.fetch("key", expires_in: 1.minute) { "test" }
expect(cache.fetch("key")).to eq("test")
cache.fetch("key", expires_in: 1.minute) { "bob" }
cache.fetch("bla") { "hi" }
r =
expect(r).to eq("bob")
cache.write "key", "bill"
expect(r).to eq("bill")
expect(cache.keys("users:*").count).to eq(2)
:ie,
:ipad,
:ios,
:mac,
:edge,
bookmarks = bookmark_query(params: { q: "check" }).list_all
bookmarks = bookmark_query(params: { q: "bugfix" }).list_all
let(:params) { { limit: 1 } }
let(:reminder_at) { 1.day.from_now }
let(:name) { "Check this out!" }
name: "Old name",
let(:new_name) { "Some new name" }
let(:new_reminder_at) { 10.days.from_now }
let(:reminder_at) { 10.days.ago }
let(:reminder_at) { 11.years.from_now }
before { post.trash! }
from:,
to:,
remaps.delete_if { |r| r.delete(:regex) }
site_rename = { from: "/uploads/#{source_site_name}/", to: uploads_path(target_site_name) }
.with do |from, to, args|
remaps.shift == { from: from, to: to }
regex_remaps.shift == { from: from, to: to }
Regexp.escape("//#{bucket}") +
let!(:multisite) { { name: "multisite", value: true } }
let!(:no_multisite) { { name: "multisite", value: false } }
let!(:source_db_name) { { name: "db_name", value: "foo" } }
let!(:base_url) { { name: "base_url", value: "https://test.localhost/forum" } }
let!(:no_cdn_url) { { name: "cdn_url", value: nil } }
let!(:cdn_url) { { name: "cdn_url", value: "https://some-cdn.example.com" } }
let(:target_site_name) { target_site_type == multisite ? "second" : "default" }
from: "/uploads/foo/",
target_site_type == multisite ? "/uploads/#{target_site_name}" : "",
to: "http://localhost",
{ from: "https://some-cdn.example.com/", to: "https://new-cdn.example.com/" },
{ from: "some-cdn.example.com", to: "new-cdn.example.com" },
{ from: "https://some-cdn.example.com/", to: "//example.com/discourse/" },
{ from: "some-cdn.example.com", to: "example.com" },
let!(:s3_base_url) { { name: "s3_base_url", value: nil } }
let!(:s3_cdn_url) { { name: "s3_cdn_url", value: nil } }
let!(:source_site_type) { no_multisite }
let!(:target_site_type) { no_multisite }
let!(:s3_base_url) do
{ name: "s3_base_url", value: "//old-bucket.s3-us-east-1.amazonaws.com" }
let!(:s3_cdn_url) { { name: "s3_cdn_url", value: "https://s3-cdn.example.com" } }
from: s3_url_regex("old-bucket", "/"),
from: "https://s3-cdn.example.com/",
to: "//#{target_hostname}#{uploads_path(target_site_name)}",
{ from: "s3-cdn.example.com", to: target_hostname },
to: "/",
{ from: "https://s3-cdn.example.com/", to: "//#{target_hostname}/" },
{ from: "s3-cdn.example.com", to: "new-s3-cdn.example.com" },
{ from: "https://s3-cdn.example.com/", to: "//new-s3-cdn.example.com/" },
let!(:target_site_name) { "default" }
let!(:target_hostname) { "test.localhost" }
let!(:target_site_name) { "second" }
from: "/uploads/xylan/",
) do |directory|
it "calls pause!" do
Sidekiq.redis { |redis| redis.scan_each { |key| redis.del(key) } }
data = { post_id: 1 }
pid = 7890
key = "#{hostname}:#{pid}"
process = { pid: pid, hostname: hostname }
run_at: Time.now.to_i,
conn.hmset("#{key}:work", "444", data)
filename: "b.tar.gz",
size: 17,
filename: "r.sql.gz",
size: 22,
size: 19,
it "returns only *.gz and *.tgz files" do
expect { store.delete_file("foo.gz") }.to_not change { store.files }
file.write("A" * backup.size)
filename = "foo.tar.gz"
let!(:logger) do
def log(message, ex = nil)
thread = mock("thread")
psql_io = mock("psql")
.with do |env, *command, options|
@s3_options = { client: @s3_client }
@objects << {
key: "default/b.tar.gz",
key: "default/a.tgz",
size: 29,
key: "default/r.sql.gz",
size: 12,
size: 23,
key: "second/multi-2.tar.gz",
key: "second/multi-1.tar.gz",
%r{\Ahttps://#{bucket}.*#{prefix}/#{filename}\?.*X-Amz-Expires=#{expires}.*X-Amz-Signature=.*\z}
multisite ? "\\/#{db_name}" : ""
with_metadata_file("") do |dir|
metadata = '{"source":"discourse","version":""}'
db_name: "default",
filename: "a.tgz",
filename: "c.tar.gz",
db_name: "second",
@paths.each { |path| File.delete(path) if File.exist?(path) }
/^#{Regexp.escape(path)}$/
).and not_change { Upload.count }
1.upto(10).each { |i| backuper.send(:log, "Line #{i}") }
) do |upload_path|
when "both.txt", "only-var.txt"
auth_token = {
uid: "123",
fab!(:initial_name) { "Initial Name" }
let(:new_email) { "newemail@example.org" }
let(:new_username) { "newusername" }
let(:new_name) { "New Name" }
let(:hash) do
uid: "1234",
let(:create_hash) { OmniAuth::AuthHash.new(provider: "myauth", uid: "1234") }
attrs.each { |k, v| auth_result.send("#{k}=", v) }
create_hash.merge(info: { email: "", email_verified: true }),
).to eq(user.id)
hash.deep_merge(info: { image: "https://some.domain/image.jpg" }),
hash.deep_merge(info: { auth_hash_key => "New Value" }),
name: "John Doe",
first_name: "Jane",
last_name: "Doe",
name: "Jane Doe",
group1 = OmniAuth::AuthHash.new(id: "12345", name: "group1")
group2 = OmniAuth::AuthHash.new(id: "67890", name: "group2")
@auth_hash =
token = "abcde"
{ status: 403, body: "Invalid JWT" }
let(:data) { auth_token_for(user) }
{ email: "bob@example.com", primary: false, verified: true },
{ email: "john@example.com", primary: true, verified: true },
name: "John Bob",
nickname: "bob",
uid: "1001",
{ email: "person@example.com", primary: true, verified: true },
email: "bob@bob.com",
first_name: "Bob",
last_name: "Smith",
id: "100",
name: "1337 Krew",
name: "bobbob",
opts ||= { method: "GET" }
info = {}
line = header.split("\n").find { |l| l.start_with?("#{name}=") }
parts = line.split(";").map(&:strip)
key, value = p.split("=")
api_key = ApiKey.create!(user_id: user.id, created_by_id: -1)
api_key = ApiKey.create!(created_by_id: -1)
expect { provider("/?api_user_id=#{user.id}", params).current_user }.to raise_error(
new_provider = provider("/")
provider2 = provider("/", "HTTP_COOKIE" => "_t=#{cookie}")
u.last_seen_at = nil
@provider = provider("/")
ip = "10.0.0.1"
@increase_refreshes = ->(user) { @refreshes += 1 }
RateLimiter.new(nil, "cookie_auth_10.0.0.1", 10, 60).clear!
RateLimiter.new(nil, "cookie_auth_10.0.0.2", 10, 60).clear!
10.times { provider("/", env).current_user }
expect(@provider.cookie_jar.key?("_t")).to eq(false)
@provider2 = provider("/")
prev_auth_token: "abc#{i}",
auth_token: "abc#{i}",
expect(UserAuthToken.where(auth_token: (1..3).map { |i| "abc#{i}" }).count).to eq(3)
expect(UserAuthToken.where(auth_token: (1..3).map { |i| "abc#{i}" }).count).to eq(0)
expect(provider("/", "HTTP_COOKIE" => "_t=#{cookie}").current_user.id).to eq(user.id)
expect(provider("/", "HTTP_COOKIE" => "_t=#{cookie}").current_user).to eq(nil)
client_id: "1234",
dupe =
client_id: "12345",
3.times { provider("/", params).current_user }
expect(provider("/", env).current_user).to eq(nil)
:method => "GET",
provider2 = provider("/", env)
user_provider = provider("/")
create_request_env(path: "/").merge({ :method => "GET", "HTTP_COOKIE" => "_t=#{cookie}" })
expect(Archetype.list.find { |a| a.id == "glados" }).to be_present
it "#{key} returns no records" do
it "finds user with trust #{key}" do
fab!(:user) { Fabricate(:user, active: true, approved: false) }
expect(users.where("users.id > -2").count).to eq(2)
expect(users.where("users.id > -2").order("users.id asc").first.username).to eq("system")
fab!(:user2) { Fabricate(:user, admin: false) }
fab!(:user) { Fabricate(:user, moderator: true) }
fab!(:user2) { Fabricate(:user, moderator: false) }
fab!(:user) { Fabricate(:user, silenced_till: 1.year.from_now) }
fab!(:user) { Fabricate(:user, staged: true) }
fab!(:user2) { Fabricate(:user, staged: false) }
user = Fabricate(:user, email: "sam@Sam.com")
user = Fabricate(:user, email: "sam2@Sam.com")
before(:each) { Fabricate(:user, email: "test1@example.com") }
before(:each) { Fabricate(:user, username: "test_user_1") }
fab!(:user) { Fabricate(:user, ip_address: "117.207.94.9") }
role: :admin,
) { ac.email_confirmed! }
fab!(:user) { Fabricate(:user, last_seen_at: 11.minutes.ago) }
fab!(:staged) { Fabricate(:user, staged: true, last_seen_at: 11.minutes.ago) }
fab!(:user) { Fabricate(:user, last_seen_at: 8.days.ago, last_emailed_at: 8.days.ago) }
type: "signup",
data: { original_post_id: post.id }.to_json,
With a \\0 \\1 \\2 in it
html_part = email.parts.find { |x| x.content_type.include? "html" }
<a class="attachment" href="#{upload.url}">test</a>
<img src="#{upload.url}"/>
fab!(:post) { Fabricate(:post, created_at: 30.seconds.ago) }
post: nil,
let(:requested_by) { Fabricate(:admin) }
let(:requested_by) { user }
let(:requested_by) { nil }
fab!(:regular_user) { Fabricate(:user) }
let(:user) { moderator }
let(:user) { regular_user }
fab!(:users) { Fabricate.times(2, :user) }
2.times { Fabricate(:email_log, user: user, email_type: "blah", to_address: user.email) }
msg, err =
data: { original_post_id: @pm_from_staff.id }.to_json,
data: { original_post_id: pm_from_staff.id }.to_json,
user_id: -999,
id = "original"
filter: {
let!(:gif_upload) { Fabricate(:upload, extension: "gif") }
users.each { |u| u.reload }
p2 = Fabricate(:post, user: user)
fab!(:timer1) do
fab!(:timer2) do
fab!(:topic) { Fabricate(:topic_timer, user: admin).topic }
fab!(:topic) { Fabricate(:topic_timer, user: user).topic }
subject(:run_job) { described_class.new.execute({}) }
fab!(:post3) { Fabricate(:post, topic: topic) }
fab!(:tu1) { Fabricate(:topic_user, topic: topic, bookmarked: false) }
fab!(:tu2) { Fabricate(:topic_user, topic: topic, bookmarked: false) }
fab!(:tu3) { Fabricate(:topic_user, topic: topic, bookmarked: true) }
fab!(:tu4) { Fabricate(:topic_user, topic: topic, bookmarked: true) }
fab!(:tu5) { Fabricate(:topic_user, topic: topic, bookmarked: true) }
let(:upload1) { Fabricate(:upload) }
let(:upload2) { Fabricate(:upload) }
.times(3)
let(:bern) { { latitude: 46.947922, longitude: 7.444608 } } # Bern, Switzerland
let(:london) { { latitude: 51.5073509, longitude: -0.1277583 } } # London, United Kingdom
url: "/t/no-spammers-please/123",
let(:payload) { { notification_type: 1, excerpt: "Hello you" } }
fab!(:user_0) { Fabricate(:user) }
fab!(:user_1) { Fabricate(:user) }
(1..count).each { |i| create_with_score(minimum_threshold + i) }
let(:medium_threshold) { 8.0 }
let(:high_threshold) { 13.0 }
let(:score_to_hide_post) { 8.66 }
low_score = 2
freeze_time(1.day.ago) { topic.trash! }
expect { subject.execute({}) }.to change { TopicSearchData.count }.by(-1)
post2.raw = ""
expect { subject.execute({}) }.to change { PostSearchData.count }.by(-3)
fab!(:group) { Fabricate(:smtp_group, name: "support-group", full_name: "Support Group") }
fab!(:recipient_user) { Fabricate(:user, email: "test@test.com") }
email: "test@test.com",
let(:staged2) { Fabricate(:staged, email: "cormac@lit.com") }
let(:post_id) { post.topic.posts.first.id }
fab!(:badge) { Fabricate(:badge, name: "Protector of the Realm", allow_title: true) }
post = Fabricate(:post, raw: "some post with :test: yay")
expect(post.reload.cooked).to eq("<p>some post with :test: yay</p>")
fab!(:tarek) { Fabricate(:user, username: "tarek") }
fab!(:matt) { Fabricate(:user, username: "matt") }
fab!(:john) { Fabricate(:user, username: "john") }
fab!(:fred) { Fabricate(:user, username: "fred") }
let(:image_url) { "http://wiki.mozilla.org/images/2/2e/Longcat1.png" }
let(:png) do
stub_request(:get, image_url).to_return(body: png, headers: { "Content-Type" => "image/png" })
body: png,
post = Fabricate(:post, raw: "<img src='#{image_url}'>")
post = Fabricate(:post, raw: "bob bob")
expect(post.reload.raw).to eq("<img src=\"#{Upload.last.short_url}\">")
post.update(raw: "<img src='#{image_url}'>")
post = Fabricate(:post, raw: "<img src='#{encoded_image_url}'>")
<a href="https://somelink.com">
<img alt="somelink" src="#{image_url}">
<img alt="somelink" src="#{upload.short_url}">
url = image_url.sub("/2e/Longcat1.png", "")
url = image_url.sub(/^https?\:/, "")
post = Fabricate(:post, raw: "<img alt='test' src='#{url}'>")
expect(post.reload.raw).to eq("<img alt=\"test\" src=\"#{Upload.last.short_url}\">")
stub_request(:get, url).to_return(body: png, headers: { "Content-Type" => "image/png" })
post = Fabricate(:post, raw: "<img src='#{url}'>")
expect(post.raw).to eq("<img src=\"#{Upload.last.short_url}\">")
raw = "<img src=\"#{image_url}\">"
let(:url) { "https://commons.wikimedia.org/wiki/#{media}" }
let(:api_url) do
stub_request(:get, url).to_return(body: "")
\"query\": {
\"pages\": {
\"-1\": {
\"title\": \"#{media}\",
\"thumburl\": \"#{image_url}\",
\"url\": \"#{image_url}\",
\"descriptionurl\": \"#{url}\"
post = Fabricate(:post, raw: "#{url}")
expect(post.cooked).to match(%r{<img src=.*/uploads.*\ class="thumbnail})
<img src='#{image_url}'>
<img src='#{broken_image_url}'>
<a href='#{url}'><img src='#{large_image_url}'></a>
2.times { post.rebake! }
expect(post.cooked).to match(%r{<p><img src=.*/uploads})
expect(post.cooked).to match(%r{<img src=.*/uploads})
raw: "<img src='#{Discourse.base_url}#{upload.url}'>",
expect(post.reload.cooked).to have_tag(:a, with: { class: "lightbox" })
fab!(:post) { Fabricate(:post, created_at: 20.days.ago) }
job.execute({ post_id: post.id })
stub_request(:get, "https:" + upload.url).to_return(
.find { |m| Hash === m.data && m.data.key?(:reload_topic) && m.data.key?(:refresh_stream) }
}.to(true)
post.update_columns(cooked: "frogs", user_id: User.maximum("id") + 1)
post = Fabricate(:post, raw: "Some OP content", cooked: "")
post2 = Fabricate(:post, raw: "Some reply content", cooked: "", topic: post.topic)
let(:job) { Jobs::ProcessPost.new }
let(:mail) { "From: foo@bar.com\nTo: bar@foo.com\nSubject: FOO BAR\n\nFoo foo bar bar?" }
let(:example_email) { email = <<~EMAIL }
From: One <one@foo.com>
Date: #{1.day.ago.strftime("%a, %d %b %Y")} 03:12:43 +0100
mail1 = Net::POPMail.new(1, nil, nil, nil)
mail2 = Net::POPMail.new(2, nil, nil, nil)
mail3 = Net::POPMail.new(3, nil, nil, nil)
mail4 = Net::POPMail.new(4, nil, nil, nil)
pop_mail = stub("pop mail")
let(:job) { described_class.new }
job.tap { job.execute({}) }
{ limit_once_per: false, message_params: { mentions: "", count: 1 } },
expect { job.execute({}) }.to_not change { Post.count }
expect { job.execute({}) }.to change { Post.count }.by(1)
let!(:admin) { Fabricate(:admin) }
let!(:another_admin) { Fabricate(:admin) }
value: "123",
data_type: 1,
:api_key,
expect { described_class.new.execute({}) }.to change { Post.count }.by(1)
fab!(:post) { Fabricate(:post, user: regular_user) }
let!(:hidden_group) { Fabricate(:group, name: "hidden_group") }
let!(:topic_user) do
fab!(:admin) { Fabricate(:admin, moderator: true) }
fab!(:group) { group_user.group }
fab!(:user) { group_user.user }
fab!(:p2) { Fabricate(:post, user: Fabricate(:evil_trout), topic: p1.topic) }
fab!(:p3) { Fabricate(:post, user: p1.user, topic: p1.topic) }
before { post.update_columns(raw: "") }
fab!(:post) { Fabricate(:post, user: mailing_list_user) }
fab!(:category) { Fabricate(:category, name: "test") }
let(:image_url) { "https://omg.aws.somestack/test.png" }
DB.exec(<<~SQL, flair_url: image_url, id: badge.id)
let(:email_mode) { "email" }
expect(instances.pluck(:seq).sort).to eq((0...4).to_a)
before { Jobs.run_later! }
expect(job.slice("class", "args", "queue")).to eq(expected)
.with({ "post_id" => 1, "current_site_id" => "default" })
self.count ||= 0
self.count += 1
@fail_count ||= 0
@fail_count += 1
job.perform({})
::Jobs::Base.any_instance.expects(:execute).with({ "hello" => "world" })
::Jobs::Base.new.perform("hello" => "world")
let(:test_job_1) do
.new(Jobs::Base)
.tap do |klass|
klass.define_method(:execute) { |args| state << "job_1_executed" }
let(:test_job_2) do
job_1 = test_job_1
state << "job_2_started"
state << "job_2_finished"
let (:mailer) {
fab!(:active_admin) { Fabricate(:admin, last_seen_at: 1.hour.ago) }
fab!(:not_seen_admin) { Fabricate(:admin, last_seen_at: 370.days.ago) }
p = Fabricate(:post, user: user)
ua = Fabricate(:user, trust_level: 0, admin: true)
p = Fabricate(:post, user: u1)
p = Fabricate(:post, user: u2)
p = Fabricate(:post, user: u3)
it "doesn't award to a bot" do
freeze_time(400.days.ago) { granter.execute({}) }
group = Fabricate(:group, name: "test")
let(:etag_with_quotes) { '"ETag"' }
let(:etag_without_quotes) { "ETag" }
expect { described_class.new.execute_onceoff({}) }.to change { User.count }.by(-2).and change {
expect(User.where("id > -2")).to contain_exactly(
let!(:post) { create_post }
let!(:third_post) { create_post(topic: topic, user: evil_trout) }
fab!(:user) { Fabricate(:user, username: "john_doe") }
let(:extra) { {} }
let(:job) do
csv_out =
job.public_send(:"#{component}_export") do |row|
csv << row
.zip(row.map(&:to_s))
_ = post
after { user.uploads.each(&:destroy!) }
expect { Jobs::ExportCsvFile.new.execute(user_id: user.id + (1 << 20)) }.to raise_error(
).chomp,
zip_file.each { |entry| files << entry.name }
expect(files.find { |f| f == "user_archive.csv" }).to_not be_nil
expect(files.find { |f| f == "category_preferences.csv" }).to_not be_nil
let(:component) { "user_archive" }
let(:normal_post) { Fabricate(:post, user: user, topic: topic) }
let(:component) { "preferences" }
let(:component) { "auth_tokens" }
let(:component) { "auth_token_logs" }
let(:component) { "badges" }
let(:badge1) { Fabricate(:badge) }
let(:day_ago) { 1.day.ago }
let(:component) { "bookmarks" }
let(:name) { "Collect my thoughts on this" }
let(:topic1) { Fabricate(:topic) }
let(:post1) { Fabricate(:post, topic: topic1, post_number: 5) }
let(:post3) { Fabricate(:post) }
now = freeze_time "2017-03-01 12:00"
update1_at = now + 1.hours
let(:reset_at) { DateTime.parse("2017-03-01 12:00") }
let(:component) { "flags" }
let(:other_post) { Fabricate(:post, user: admin) }
let(:post4) { Fabricate(:post) }
let(:component) { "likes" }
let(:component) { "queued_posts" }
let(:component) { "visits" }
end_date: "not-a-date",
name: "dau_by_mau",
action: "login",
created_at: "2010-01-01",
created_at: "2010-01-01 12:00:00 UTC",
external_id: "123",
last_payload: "xxx",
let!(:suspect_user) { Fabricate(:active_user, created_at: 1.day.ago) }
it "adds a score" do
suspect_user.upsert_custom_fields({ field_a: "value", field_b: "value" })
{ field_a: "value", field_b: "value", import_id: "fake_id" },
let!(:inactive_user) { Fabricate(:user, active: false) }
let!(:bounce_user) { Fabricate(:active_user, last_seen_at: 6.month.ago) }
let!(:user) { Fabricate(:active_user, last_seen_at: 2.months.ago) }
expect_enqueued_with(job: :user_email, args: { type: :digest, user_id: user2.id }) do
).by (1)
expect_enqueued_with(job: :user_email, args: { type: :digest, user_id: user1.id }) do
expect_enqueued_with(job: :user_email, args: { type: :digest, user_id: user.id }) do
expect_not_enqueued_with(job: :user_email, args: { type: :digest, user_id: user.id }) do
fab!(:post_hook) { Fabricate(:web_hook) }
payload: { id: post.id }.to_json,
let(:response_status) { 410 }
event_type: "post",
payload: { test: "some payload" }.to_json,
body: "{\"post\":{\"test\":\"some payload\"}}",
).to_return(body: "OK", status: 200)
event_type: "topic",
body: "{\"topic\":{\"test\":\"some payload\"}}",
event_type: "like",
body: "{\"like\":{\"test\":\"some payload\"}}",
test: "string",
body: "OK",
6.times { Fabricate(:user) }
let(:first_post) { create_post(topic: topic) }
before { 3.times { create_post(topic: topic) } }
expect { described_class.new.execute({}) }.to change { Topic.count }.by(1)
fab!(:post_2) do
expect(DB.query_single(<<~SQL).first).to eq(1)
sha1: "xxx",
extension: ".png",
post_en =
file_name: "xyz_en.gz",
file_size: "55",
post_fr =
file_name: "xyz_fr.gz",
file_size: "56",
raw: "#{upload.short_url}\n#{upload2.short_url}",
raw: "#{upload3.short_url}",
Draft.set(Fabricate(:user), "test", 0, "upload://#{upload.sha1}\n#{upload2.short_url}")
expect { described_class.new.execute({}) }.to change { User.count }.by(-1)
).user
fab!(:email_log) { Fabricate(:email_log, created_at: 2.years.ago) }
fab!(:email_log2) { Fabricate(:email_log, created_at: 2.weeks.ago) }
fab!(:email_log3) { Fabricate(:email_log, created_at: 2.days.ago) }
provider_uid: "12",
provider_uid: "123",
fab!(:user) { Fabricate(:user, created_at: 1.days.ago, previous_visit_at: 1.days.ago) }
fab!(:topic) { Fabricate(:topic, created_at: 5.hours.ago) }
fab!(:user2) { Fabricate(:user, created_at: 1.days.ago, previous_visit_at: 1.days.ago) }
fab!(:topic2) { Fabricate(:topic, created_at: 6.hours.ago) }
fab!(:topic3) { Fabricate(:topic, created_at: 2.hours.ago) }
user_id: 89_432,
link: "https://meta.discourse.org/t/-/238821",
end.to change { topic.posts.count }.by (1)
end.to change { topic.posts.count }.by (0)
let(:email) { "test@discourse.org" }
{ email: user.email },
{ email: staged_user.email },
{ email: "test2@discourse.org" },
{ email: "test@discourse.org", groups: "GROUP1;group2", topic_id: topic.id },
{ email: "invalid" },
/invites/,
end.to change { Invite.count }.by(2)
{ email: user.email, location: "value 1", color: "blue" }, # existing user with user fields
before { 202.times { |i| bulk_invites << { email: "test_#{i}@discourse.org" } } }
user1 = Fabricate(:user, email: "foo@wat.com", trust_level: 0)
user2 = Fabricate(:user, email: "foo@bar.com", trust_level: 2)
let(:five_minutes_ago) { Time.zone.now - 5.minutes }
user1 = Fabricate(:user, email: "no@bar.com")
user2 = Fabricate(:user, email: "no@wat.com")
user3 = Fabricate(:user, email: "noo@wat.com", staged: true)
user4 = Fabricate(:user, email: "yes@wat.com")
user5 = Fabricate(:user, email: "sso@wat.com")
blk =
fab!(:old) do
fab!(:key1) { Fabricate(:readonly_user_api_key) }
fab!(:key2) { Fabricate(:readonly_user_api_key) }
let(:created_at) { 50.hours.ago }
).and change { user.email_tokens.count }.by(1)
let(:site_setting_file) { File.join(Rails.root, "config", "site_settings.yml") }
require_relative "../../app/jobs/onceoff/" + File.basename(f)
.select { |klass| klass.superclass == ::Jobs::Onceoff }
.each { |job| job.new.execute_onceoff(nil) }
tracer = TracePoint.new(:c_call) { |tp| classes << tp.defined_class }
expect("<b>hello</b>".to_json).to eq("\"\\u003cb\\u003ehello\\u003c/b\\u003e\"")
expect('"hello world"'.to_json).to eq('"\"hello world\""')
expect("\u2028\u2029><&".to_json).to eq('"\u2028\u2029\u003e\u003c\u0026"')
let(:ctx) { MiniRacer::Context.new }
source.gsub!(/^export */, "")
english.each do |k, v|
.each do |b|
it "has valid client YAML for '#{path}'" do
I18n.with_locale("pl_PL") { expect(I18n.t("test")).to eq("en test") }
thread = Thread.new { I18n.with_locale("pl_PL") { expect(I18n.t("test")).to eq("en test") } }
html, state, md = nil
failed = 0
.each do |line|
if line == "```````````````````````````````` example\n"
if line == "````````````````````````````````\n"
html ||= String.new
html.gsub!("<br />", "<br>")
html.gsub!("<hr />", "<hr>")
cooked.gsub!(" class=\"lang-auto\"", "")
cooked.gsub!(%r{<span class="hashtag">(.*)</span>}, "\\1")
cooked.gsub!(%r{<a name="(.*)" class="anchor" href="#\1*"></a>}, "")
cooked.gsub!("<pre data-code-startline=\"3\">", "<pre>")
html.gsub!("<blockquote>\n</blockquote>", "<blockquote></blockquote>")
html.gsub!("language-ruby", "lang-ruby")
html.gsub!("language-aa", "lang-aa")
failed += 1
puts "Got: "
if state == :example && line == ".\n"
state = :html
md = (md || String.new) << line if state == :example
html = (html || String.new) << line if state == :html
def list_files(base_dir, pattern = "*")
files.select { |file| grep_file(file, regex) }
lines.count > 0 ? file : nil
migration_files = list_files("db/post_migrate", "**/*.rb")
}.each_pair do |name, dir|
it "do not exist for #{name}" do
fab!(:first_post) { Fabricate(:post, topic: topic) }
}.to_not change { Post.count }
raw: "Want some #{block_word.word} for cheap?",
title: "We sell #{block_word.word} online",
{ raw: "Want some #{block_word.word} for cheap?" },
}.to_not change { post.raw }
raw: "My dog's name is #{require_approval_word.word}.",
raw: "My dog's name is Porkins.",
post = Fabricate(:post, raw: "I said.... #{flag_word.word}", topic: topic, user: tl2_user)
Fabricate(:topic, user: tl2_user, title: "Read my #{flag_word.word} review!"),
ip_address = "182.189.119.174"
raw: "I thought the #{flag_word.word} was bad.",
raw: "Want some #{flag_word.word} for cheap?",
{ raw: "Want some #{flag_word.word} for cheap?" },
}.to change { PostAction.count }.by(1)
raw: "I have coupon codes. Message me.",
created_at: "Sat May 09 17:58:22 +0000 2009",
id_str: "38895958",
name: "Sean Cook",
url: nil,
utc_offset: -28_800,
fab!(:image) { Fabricate(:image_upload, width: 50, height: 50) }
fab!(:topic) { Fabricate(:topic, image_upload_id: image.id) }
let(:job_klass) { Jobs::CloseTopic }
let(:category) { nil }
let(:regular_user) { Fabricate(:user) }
}.by(-1).and change { tag2.reload.public_topic_count }.by(-1)
}.by(1).and change { tag2.reload.public_topic_count }.by(1)
let!(:spam_post) { create_post(user: spammer) }
let!(:spam_post2) { create_post(user: spammer) }
fab!(:another_topic) { Fabricate(:topic) }
let!(:spam_post) { Fabricate(:post, user: spammer) }
let!(:spammer) { Fabricate(*spammer_args) }
stub_request(:get, "https:#{upload.url}").to_return(
raw: "This is a new post <img src=\"#{upload.url}\" />",
let(:ip_address) { "182.189.119.174" }
let!(:spammer1) { Fabricate(:user, ip_address: ip_address) }
let!(:spammer2) { Fabricate(:user, ip_address: ip_address) }
let!(:first_post) { create_post(user: spammer1) }
let!(:old_user) do
let!(:first_post) { create_post(user: old_user) }
let(:api_key) do
get "/u/#{api_key.user.username}.json", headers: { HTTP_API_KEY: api_key.key }
site_1_url =
site_2_url =
get "http://test.localhost/#{site_1_url}.json"
post "/users.json",
name: "bob",
expect(user_id).to be > 0
put "/admin/users/#{user_id}/approve.json",
u = User.find(user_id)
post "/latest.json",
params: "{some: malformed: json",
post "/latest.json", params: { "foo" => "\255bar" }
let(:post) { Fabricate(:post, raw: "mention @#{group.name}") }
expect { post }.not_to change {
let(:client_id) { "abcdef11223344" }
let(:temp_code) { "github_temp_code_544254" }
scope: "user:email",
gravatar_id: "",
type: "User",
blog: "https://github.com/blog",
bio: "There once was...",
plan: {
name: "Medium",
let(:app_id) { "432489234823984" }
first_name: "Robot",
last_name: "Lizard",
).with(headers: { "Authorization" => "OAuth #{access_token}" }).to_return(
SiteSetting.email_custom_template = "<hello>%{email_content}</hello><%= (111 * 333) %>"
SiteSetting.email_custom_css = "h1 { color: red; } div.body { color: #FAB; }"
expect(mail_html.scan('<h1 style="color: red;">FOR YOU</h1>').count).to eq(1)
SiteSetting.email_custom_css = '@import "nope.css"; h1 {{{ size: really big; '
expect(mail_html.scan(/<h1\s*(?:style=""){0,1}>FOR YOU<\/h1>/).count).to eq(1)
expect(mail_html).to_not include('<h1 style="color: red;">FOR YOU</h1>')
def send_email(opts = {})
let(:temp_code) { "discord_temp_code_544254" }
flags: 64,
fab!(:tag1) { Fabricate(:tag, name: "tag1") }
fab!(:tag2) { Fabricate(:tag, name: "tag2") }
fab!(:tag3) { Fabricate(:tag, name: "tag3") }
fab!(:tag4) { Fabricate(:tag, name: "tag4") }
let(:tag_with_colon) { Fabricate(:tag, name: "with:colon") }
msg =
term: "tag",
tags: "newtag",
fab!(:tag_group1) { Fabricate(:tag_group) }
fab!(:tag_group2) { Fabricate(:tag_group) }
fab!(:makes) { Fabricate(:tag_group, name: "Makes") }
fab!(:honda_group) { Fabricate(:tag_group, name: "Honda Models") }
fab!(:ford_group) { Fabricate(:tag_group, name: "Ford Models") }
@tags = {}
expect(names.include?("honda") || names.include?("ford")).to eq(false)
fab!(:post) { Fabricate(:post, user: topic.user, topic: topic) }
).sum(:topic_count),
let(:onebox_url) { "http://example.com/onebox" }
post = Fabricate(:post, raw: "<img src='#{hotlinked_url}'>")
expect(post.cooked).to have_tag("img", with: { "src" => hotlinked_url })
srcset = "#{hotlinked_url} 1x,https://example.com 2x"
post = Fabricate(:post, raw: "<video><source srcset='#{srcset}'></video>")
post = Fabricate(:post, raw: "#{onebox_url}")
expect(post.cooked).to have_tag("img", with: { src: src })
post = Fabricate :post, raw: <<~RAW
expect(post.cooked).to have_tag("img", with: { "src" => "https://example.com" })
expect(post.cooked).to have_tag("img", with: { "src" => "https://example.com/myimage.png" })
expect(post.cooked).to have_tag("img", with: { "src" => "https://exampleb.com/myimage.png" })
Oneboxer.stubs(:onebox).returns("<aside class='onebox'><img src='#{hotlinked_url}'></aside>")
<img src='#{hotlinked_url}'>
count: 4,
get "/session/current.json", params: { api_key: api_key.key }
post "/admin/email/handle_mail.json?api_key=#{admin_api_key.key}", params: { email: "blah" }
get "/latest.rss?user_api_key=#{user_api_key.key}"
let(:user_api_key) { Fabricate(:user_api_key) }
let(:new_threshold) { 5 }
}.and change { Topic.count }.by(2).and change { User.count }.by(2)
expect { import(data) }.to change { Category.count }.by(6).and change { Group.count }.by(
).and change { Topic.count }.by(6).and not_change { User.count }
expect { import(data) }.to change { Category.count }.by(6).and change {
}.from(2).to(3)
}.from(nil).to(1)
).and change { Topic.count }.by(6).and change { User.count }.by(2)
).and not_change { Topic.count }.and not_change { User.count }
it "all" do
}.by(2).and change { Topic.count }.by(8).and change { User.count }.by(2).and change {
let(:cooked) { paragraphs.join("\n") }
let(:post_quote) { <<~HTML }
<img alt width="20" height="20" src="https://example.com/m.png" class="avatar"> modman:</div>
<p>This is a post quote</p>
let(:lightbox_image) { <<~HTML }
<p>This is a user quote</p>
<div class="title">A Title</div>
let(:upload) { Fabricate(:upload, sha1: "somesha1") }
let(:upload) { Fabricate(:upload, extension: "svg") }
let(:upload) { Fabricate(:upload_s3, sha1: "somesha1") }
before { SiteSetting.s3_cdn_url = "https://some.cdn.com" }
<link rel="preload" href="#{url}" as="script">
<script defer src="#{url}"></script>
expect(helper.escape_unicode("<tag>")).to eq("\u003ctag>")
name: "Dark",
_dark_theme =
<meta name=\"twitter:image\" content=\"#{SiteSetting.site_logo_url}\" />
let(:tags) { <<~HTML.strip }
let(:output_tags) { <<~HTML.strip }
user_agent { sequence(:ua) { |i| "Googlebot #{i}.0" } }
date { Time.zone.now.to_date }
word { sequence(:word) { |i| "word#{i}" } }
set_at { Time.zone.now }
emoji { "tooth" }
name { sequence(:name) { |i| "Security Key #{i + 1}" } }
bio_raw "I'm batman!"
Fabricator(:user_profile_long, from: :user_profile) { bio_raw ("trout" * 1000) }
value { sequence(:name) { |i| "field_option_#{i}" } }
name { sequence(:name) { |i| "field_#{i}" } }
username { sequence(:username) { |i| "bruce#{i}" } }
email { sequence(:email) { |i| "bruce#{i}@wayne.com" } }
ip_address { sequence(:ip_address) { |i| "99.232.23.#{i % 254}" } }
name { sequence(:name) { |i| "A#{i} Moderator" } }
username { sequence(:username) { |i| "moderator#{i}" } }
email { sequence(:email) { |i| "moderator#{i}@discourse.org" } }
username { sequence(:username) { |i| "anne#{i}" } }
email { sequence(:email) { |i| "anne#{i}@discourse.org" } }
username { sequence(:username) { |i| "luke#{i}" } }
email { sequence(:email) { |i| "luke#{i}@skywalker.com" } }
username { sequence(:username) { |i| "leader#{i}" } }
email { sequence(:email) { |i| "leader#{i}@leaderfun.com" } }
username { sequence(:username) { |i| "tl4#{i}" } }
email { sequence(:email) { |i| "tl4#{i}@elderfun.com" } }
name ""
username { sequence(:username) { |i| "anonymous#{i}" } }
email { sequence(:email) { |i| "anonymous#{i}@anonymous.com" } }
min_id = User.minimum(:id)
email { sequence(:email) { |i| "bwayne#{i}@wayne.com" } }
sha1 { sequence(:sha1) { |n| Digest::SHA1.hexdigest("#{n}#{Process.pid}") } }
sequence(:url) do |n|
original_sha1 { sequence(:sha1) { |n| Digest::SHA1.hexdigest(n.to_s) } }
execute_at { 1.hour.from_now }
title { sequence(:title) { |i| "This is a test topic #{i}" } }
Fabricator(:deleted_topic, from: :topic) { deleted_at { 1.minute.ago } }
category_id { nil }
title { sequence(:title) { |i| "This is a private message #{i}" } }
target_id { 0 }
name { sequence(:name) { |i| "scss_#{i + 1}" } }
value { ".test {color: blue;}" }
error { nil }
name { sequence(:name) { |i| "Cool theme #{i + 1}" } }
Fabricator(:tag_group) { name { sequence(:name) { |i| "tag_group_#{i}" } } }
Fabricator(:tag) { name { sequence(:name) { |i| "tag#{i + 1}" } } }
to_address { sequence(:address) { |i| "blah#{i}@example.com" } }
external_id { sequence(:external_id) { |i| "ext_#{i}" } }
external_username { sequence(:username) { |i| "bruce#{i}" } }
external_email { sequence(:email) { |i| "bruce#{i}@wayne.com" } }
value "/tags"
ip_address "127.0.0.1"
url { sequence(:url) { |n| "spammers#{n}.org/buy/stuff" } }
domain { sequence(:domain) { |n| "spammers#{n}.org" } }
ip_address { sequence(:ip_address) { |n| "123.#{(n * 3) % 255}.#{(n * 2) % 255}.#{n % 255}" } }
email { sequence(:email) { |n| "bad#{n}@spammers.org" } }
user { Fabricate(:user) }
status { 1 }
score { 11.0 }
target_id { Fabricate(:user).id }
raw_email: "store_me",
hello: "world",
cat: "hat",
data '{"endpoint": "https://example.com/send","keys": {"p256dh": "BJpN7S_sh_RX5atymPB7J1","auth": "5M-xiXhbcFhkkw3YE7uIK"}}'
raw '
<p>With an emoji! <img src="//cdn.discourse.org/meta/images/emoji/twitter/smile.png?v=#{Emoji::EMOJI_VERSION}" title=":smile:" class="emoji" alt="smile" loading="lazy" width="20" height="20"></p>
raw { "<img src=\"#{Fabricate(:image_upload)}\" width=\"1500\" height=\"2000\">" }
raw "
<img src=\"http://foo.bar/image.png\">
<img src="http://foo.bar/image.png">
<img src="http://domain.com/picture.jpg" width="50" height="42">
Fabricator(:post_with_uploads_and_links, from: :post) { raw <<~MD }
<a href="http://www.google.com">Google</a>
key { sequence(:key) { |i| "key#{i}" } }
name { sequence(:key) { |i| "key#{i}" } }
Fabricator(:permalink) { url { sequence(:url) { |i| "my/#{i}/url" } } }
data '{"poison":"ivy","killer":"croc"}'
reason { sequence(:reason) { |n| "group request #{n}" } }
Fabricator(:group) { name { sequence(:name) { |n| "my_group_#{n}" } } }
name { sequence(:name) { |i| "template_#{i}" } }
old_email { sequence(:old_email) { |i| "bruce#{i}@wayne.com" } }
new_email { sequence(:new_email) { |i| "super#{i}@man.com" } }
ends_at { 1.hour.from_now }
name { sequence(:name) { |i| "Palette #{i}" } }
name { sequence(:name) { |i| "color_#{i}" } }
name { sequence(:name) { |n| "Amazing Category #{n}" } }
name { sequence(:name) { |n| "Private Category #{n}" } }
slug { sequence(:slug) { |n| "private#{n}" } }
date =
Fabricator(:badge_type) { name { sequence(:name) { |i| "Silver #{i}" } } }
name { sequence(:name) { |i| "Badge #{i}" } }
name { sequence(:name) { |n| "group_#{n}" } }
Fabricator(:api_key) {}
user_id = nil
@gabbler ||=
story = File.read(File.dirname(__FILE__) + "/alice.txt")
sentence = +""
sentence << "\n"
.new do |opts|
opts.on("-u", "--user NUMBER", "user id") { |u| user_id = u.to_i }
Thread.new { sleep 1 }
@thread ||= Thread.new { self.new.monitor(max_threads) }
str = +("-" * 60)
str << "#{threads.length} found in Process #{Process.pid}!\n"
str << ("-" * 60)
PrettyText.v8.eval("gc()")
$mwrap = true
allocated = (current.dig(:arenas, i, :bins, size, :allocated) || 0)
puts "bin #{size} delta #{diff}"
ObjectSpace.each_object(klass).max { |a, b| a.length <=> b.length }
I18n.t("too_late_to_edit")
mwrap_delta = "(mwrap delta #{mwrap_delta})"
if i == cols - 1
buffer << "\n"
buffer << " | "
buffer << ("-" * (width.sum + width.length))
.drop(1)
.each do |row|
report = +""
report << "\n"
frees == 0 ? -1 : (age_sum / frees.to_f).round(2),
puts "Bootup time: #{Time.now - start} secs"
puts "RSS: #{`ps -o rss -p #{$$}`.chomp.split("\n").last.to_i} KB"
s =
.map do |o|
puts "Total strings: #{s.count} space used: #{s.sum} bytes"
print "Delivery failed: " + e.message.strip() + "\n"
DATA = "/tmp/test_data/pg"
if a == "--skip-setup"
elsif a == "--skip-run"
elsif a == "--exec"
run "echo fsync = off >> #{DATA}/postgresql.conf"
run "echo full_page_writes = off >> #{DATA}/postgresql.conf"
def start(tmp_options = {})
::Kernel,
class << ::Kernel
self.stats ||= {}
stat =
@stack << stat
delta = Time.now - time
@redis.scan_each do |k|
type = @redis.type k
.first(50)
.each do |k, (len, type, elems)|
puts "#{k} #{type} #{len}#{elems}"
spec_path = Dir.glob("#{Gem.dir}/specifications/#{gem}-*.gemspec").last
user.username = username || "user#{seq}"
putc "."
10.times.map do |i|
b.report("simple") { User.first.name }
b.report("pluck with first") { User.pluck(:name).first }
b.report("pluck with limit") { User.limit(1).pluck(:name).first }
b.report("pluck with pick") { User.pick(:name) }
b.report("raw") { conn.exec("SELECT name FROM users LIMIT 1").getvalue(0, 0) }
FIELDS.each { |field| self.public_send("#{field}=", 0) }
lines.each { |l| parse_field_line(l) }
if respond_to? "#{field}="
self.public_send("#{field}=", value)
totals = Hash.new(0)
File.open("/proc/#{pid}/smaps") do |smaps|
when /\w+:\s+/
n.to_s.gsub(/(\d)(?=\d{3}+(?:\.|$))(\d{3}\..*)?/, '\1,\2')
commandline = File.read("/proc/#{pid}/cmdline").split("\0")
loop { break if commandline.shift == "-jar" }
if ARGV.include? "--yaml"
puts "#{"Process:".ljust(20)} #{pid}"
puts "#{"Command Line:".ljust(20)} #{get_commandline(pid)}"
puts "#{name} changes"
.each do |a, b|
next if b <= 0
puts "#{a} #{a == :T_HASH ? b - 1 : b}"
ObjectSpace.each_object { |o| objs << o }
objs.each do |o|
items << "Allocated #{c} in #{m} #{f}:#{l}"
.group_by { |x| x }
.each { |row, group| puts "#{row} x #{group.length}" }
r = TopicQuery.new(u, {}).list_latest
require File.expand_path(File.dirname(__FILE__) + "/base.rb")
@topic_mapping = {}
puts "", "Importing users"
create_users(CSV.parse(File.read(File.join(@path, "users.csv")))) do |u|
puts "", "Parsing posts CSV"
csv_parse(File.join(@path, "posts.csv")) do |row|
@all_posts << row.dup
c = create_category({ name: parent }, parent)
create_category({ name: subcat, parent_category_id: c.id }, "#{parent}:#{subcat}")
u =
email: "#{username}@example.com",
user_id = u.id
puts "Created: #{created}"
puts "Skipped: #{skipped}"
x.gsub!(/( )*<ol>(\s)*/, "")
x.gsub!(%r{( )*</ol>}, "")
x.gsub!("<li>", "")
x.gsub!("</li>", "")
x.gsub!("\n", " ")
x.gsub!("<div>", "\n\n")
x.gsub("</div>", " ")
x.gsub!("<br />", "\n")
x.gsub!("<span>", "")
x.gsub!("</span>", "")
x.gsub!("</font>", "")
puts "", "fetching categories..."
puts "", "fetching topics..."
puts "", "fetching posts..."
last_id = ""
) do |row|
puts "", "fetching users..."
get_from_api(url, "votes") do |row|
puts "", "creating users"
rows, last_id = @db.fetch_users(last_id)
puts "", "creating topics"
puts "", "creating posts"
last_row_id = 0
puts "", "importing likes..."
if post && user
puts "error acting on post #{e}"
raw = raw.gsub('\n', "")
image_url = $1
filename = $2
.open do |image|
url.sub(@source_url, "")
@_connection ||=
@_authorization ||=
auth_str = "#{@auth_email}/token:#{@auth_token}"
url = "#{@source_url}#{path}"
puts "Request failed #{url}. Waiting and will retry. #{e.class.name} #{e.message}"
retry_count += 1
puts "",
puts "", "reading CSV files"
csv_parse("topics") do |row|
csv_parse("users") do |row|
csv_parse("posts") do |row|
csv_parse("comments") do |row|
return nil if text.blank? || text == "null"
File.join(@path, "#{table_name}.csv"),
encoding: "bom|utf-8",
) { |row| yield row }
puts "", "Usage:", "", "bundle exec ruby script/import_scripts/zendesk.rb DIRNAME", ""
.split(",")
u_count = 0
csv_parse("Users") do |row|
u_count += 1
bio: "",
csv_parse("Groups") do |row|
csv_parse("Files") do |row|
csv_parse("Messages") do |row|
title = ""
url = ""
description = ""
raw += "\n***\n#{description}\n#{url}\n" unless raw.include?(url)
@tag_map = {}
puts "", "Got #{total_count} users!"
puts "", "creating pm topics"
puts "", "creating pm posts"
puts "", "Usage:", "", "bundle exec ruby script/import_scripts/yammer.rb DIRNAME", ""
puts "connected to db...."
@user_profile_map = {}
puts "", "Importing from Mongodb...."
puts "", "Done"
user_id = 0
user_id = user_id + 1
.sort("ygData.msgId": -1)
.limit(1)
topic = {
id: tidx + 1,
post = {
id: pidx + 1,
posts_count += 1
puts "echo gem \\'php-serialize\\' >> Gemfile"
@client =
password: "pa$$word",
@category_mappings = {}
filename = File.join(AVATAR_DIR, "l", (id / 1000).to_s, "#{id}.jpg")
puts "", "importing categories..."
parent = c
tag: Tag.find_by_name(tag_name) || Tag.create(name: tag_name),
puts "", "importing likes"
results = mysql_query("#{posts_sql} OFFSET #{offset};").to_a
mapped = {}
skip ? nil : mapped
puts "", "importing private messages..."
posts = mysql_query <<-SQL
msg = {
if t = topic_lookup_from_imported_post_id("pm_#{topic_id}")
s = raw.dup
s = s.encode("UTF-16be", invalid: :replace, replace: "?").encode("UTF-8") if !s.valid_encoding?
username, imported_post_id, _imported_user_id = $1, $2, $3
ids = Set.new
if xf_type == :attachment && import_id > 0
ids.each do |id|
sql = get_xf_sql(xf_type, id).dup.squish!
s.gsub!(get_xf_regexp(xf_type, id), "")
s = s + "\n\n#{html}\n\n" unless s.gsub!(get_xf_regexp(xf_type, id), html)
current_filename = "#{data_id}-#{file_hash}.data"
path = Pathname.new(ATTACHMENT_DIR + "/#{data_id / 1000}/#{current_filename}")
def get_xf_regexp(type, id = nil)
puts "", "importing groups..."
puts "", "importing users"
users = mysql_query <<-SQL
IF(ug.title = 'Administrators', 1, 0) AS admin
proc do |u|
query = mysql_query <<-SQL
puts "", "importing child categories..."
puts "", "importing topics..."
t = {
id: topic_id,
puts "", "importing posts..."
p = {
puts "", "importing attachments..."
ext =
post_id =
.where(name: "import_id")
filename = File.join("/tmp/", tmpfile)
File.open(filename, "wb") do |f|
post.raw += "\n\n#{html}\n\n"
puts "", "Closing topics..."
puts "", "Postprocessing posts..."
if new_raw != post.raw
return "" if raw.blank?
raw = raw.gsub(/(\\r)?\\n/, "\n").gsub("\\t", "\t")
.gsub("<", "&lt;")
.gsub("\u2603", "<")
.gsub(">", "&gt;")
.gsub("\u2603", ">")
user_id, old_username = $1, $2
old_username, quote = $1, $2
old_username, post_id, quote = $1, $2, $3
thread_id = $1
thread_id, link = $1, $2
post_id = $1
post_id, link = $1, $2
puts "", "creating permalinks..."
cats = mysql_query <<-SQL
cats.each do |c|
puts "", "importing tags..."
records = mysql_query(<<~SQL).to_a
@bbcode_to_md = true
@usernames = {}
puts "=" * 50
last_user_id = -1
users = mysql_query(<<-SQL).to_a
, salt
WHERE userid > #{last_user_id}
.joins(:user)
puts "", "Creating groups membership..."
puts "\t#{group.name}"
.join(",")
last_topic_id = -1
topics = mysql_query(<<-SQL).to_a
last_post_id = -1
posts = mysql_query(<<-SQL).to_a
AND p.postid > #{last_post_id}
if upload.nil? || !upload.valid?
puts "Upload not valid :("
if title =~ /^Re:/
if t = topic_lookup_from_imported_post_id("pm-#{parent_id}")
mapping = {}
fail_count += 1
if new_raw == post.raw
{ raw: new_raw },
if new_raw != old_raw
raw.gsub!(/(\\r)?\\n/, "\n")
raw.gsub!("\\t", "\t")
raw.gsub!("<", "&lt;")
raw.gsub!("\u2603", "<")
raw.gsub!(">", "&gt;")
raw.gsub!("\u2603", ">")
rows =
header, rest = rows.split "\n", 2
c = header.count "|"
sep = "|---" * (c - 1)
quote.gsub!(/\n(.+?)/) { "\n> #{$1}" }
puts "", "Creating Permalink File...", ""
CSV.open(File.expand_path("../vb_map.csv", __FILE__), "w") do |csv|
banned = 0
banned += 1
puts "Tags won't be imported. #{e.message}"
@last_user_id = -1
trust_level: !banned && commented ? 2 : 0,
parts = photo.squeeze("/").split("/")
full_guess = File.join(path, "#{prefix}#{base_guess}")
puts "", "importing group users..."
tag = Tag.find_by_name(tag_name) || Tag.create(name: tag_name)
@last_topic_id = -1
user_id =
@last_post_id = -1
puts "", "importing messages..."
@last_message_id = -1
common = {
raw: body,
return if raw == nil
raw.gsub!(%r{<a.*>(@\S+?)</a>}) { $1 }
puts "", "Creating redirects...", ""
external_url: "/users/#{u.username}",
Permalink.create(url: "discussion/#{id}/#{slug}", topic_id: topic.id)
cdn_regex = %r{https://us.v-cdn.net/1234567/uploads/(\S+/(\w|-)+.\w+)}i
.find_each do |post|
path.gsub!("s3://content/", "")
path.gsub!("s3://uploads/", "")
new_raw.gsub!(cdn_regex) do |s|
puts "", "Marking topics as solved..."
@@host = host
@row = row
@user_id = user_id
text = text.gsub(%r{\<pre class="CodeBlock"\>(.*?)\</pre\>}im) { "\n```\n#{$1}\n```\n" }
text = text.gsub(%r{\<pre\>(.*?)\</pre\>}im) { "\n```\n#{$1}\n```\n" }
text = text.gsub("\<code\>\</code\>", "").gsub(%r{\<code\>(.*?)\</code\>}im) { "#{$1}" }
.gsub(/^ +/, "")
.gsub(/ +/, " ")
if insert.respond_to?(:dig) && insert.dig(:mention, :userID)
quoting = embed_type == "quote"
text = text.gsub(/\\n(.*?)\\n/) { "\n```\n#{$1}\n```\n" }
last_pos = text.rindex(/\n/)
text = array.join("\n```\n")
text = "\n```\n#{text}"
text = "\n```\n#{text}" unless second_next_code
text = "<li>" + text
list_tag = next_list == "ordered" ? "<ol>" : "<ul>"
text = "\n#{list_tag}\n#{text}" unless previous_list
tag_closings = "</li>"
list_tag = current_list == "ordered" ? "</ol>" : "</ul>"
if topic && user
if %r{https?\://#{@@host}/uploads/.*}.match?(url)
remote_path = url.scan(%r{uploads/(.*)})
if embed_type == "link"
code_matcher = /```(.*\n)+```/
text.split("\n").map(&:strip).map(&:presence).compact.join("\n\n")
puts "parsing file..."
next if line.start_with?("//")
if m = /^Table: (\w+)/.match(line)
puts "parsing #{table}..."
.map { |row| row.to_hash }
puts "reading file..."
.gsub("\\N", "")
.gsub(/\\$\n/m, "\\n")
.gsub("\\,", ",")
.gsub(/(?<!\\)\\"/, '""')
.gsub(/\\\\\\"/, '\\""')
puts "", "importing users..."
u = {
c = {
date == "0000-00-00 00:00:00" ? @root_category_created_at : parse_date(date)
puts "", "importing private topics..."
.select do |uc|
puts "", "importing private posts..."
DateTime.strptime(date, "%Y-%m-%d %H:%M:%S")
.gsub("\\n", "\n")
.gsub(%r{</?pre\s*>}i, "\n```\n")
.gsub(%r{</?code\s*>}i, "`")
.gsub("&lt;", "<")
.gsub("&gt;", ">")
@files = {}
puts "", "Indexing filestore..."
puts "", "Importing users..."
total_count = count(<<~SQL)
rows = query(<<~SQL)
puts "", "Importing categories..."
@forum_ids_to_tags = {}
categories << {
forum_ids: index == last_index ? forum_ids : nil,
url = "f/#{id}"
puts "", "Importing child categories..."
count == 1
puts "", "Importing topics..."
batches do |_|
WHERE ContentId = '#{content_id}' AND UserId > #{last_user_id}
@ignored_forum_ids.present? ? "t.ForumId NOT IN (#{@ignored_forum_ids.join(",")})" : "1 = 1"
puts "", "Importing posts..."
puts "", "Importing messages..."
conditions = ""
conditions = <<~SQL
AND tu.user_id > 0
AND tcf.name = 'import_id'
user_ids.map!(&:strip)
.map! { |import_user_id| find_user_by_import_id(import_user_id).try(:username) }
next if directory_name == "." || directory_name == ".."
path.delete_prefix!("/")
raw = html_to_markdown(raw) || ""
raw = "#{raw}\n#{@uploader.html_for_upload(upload, filename)}"
STDERR.puts "Could not find file for #{type} #{id}: #{path}"
filename.gsub!("-", " ")
first_directory.gsub!("-", ".")
directories.map! { |d| d.gsub("+", " ").strip }
filename.gsub!(/(?:\:\d+)+$/, "")
path_regex = Regexp.new("^#{Regexp.escape(path)}-\\d+x\\d+\\.\\w+$", Regexp::IGNORECASE)
keys = @files.keys.filter { |key| regex =~ key }
path.present? && File.file?(path)
text.gsub!(/_(\h{4}+)_/i) do
class Saxy < Ox::Sax
@stack << { elem: name }
@tables = {}
old = @stack.pop
cols =
.map do |col|
.join(", ")
col_names = row.keys.join(",")
vals = row.values.map { |v| "'#{v.gsub("'", "''").gsub('\\', '\\\\\\')}'" }.join(",")
users = query(<<~SQL).to_a
AND Id > #{last_user_id}
posts = query(<<~SQL).to_a
, Body
, Tags
AND Id > #{last_post_id}
comments = query(<<~SQL).to_a
, Text
puts "", "Importing post likes..."
last_like_id = -1
likes = query(<<~SQL).to_a
AND Id > #{last_like_id}
puts "", "Importing comment likes..."
puts "", "Importing from SourceForge..."
opts = { revised_at: Time.now, bypass_bump: true }
puts "", "importing posts"
next if posts.size == 0
mapped = {
text.gsub!(/~{3,}/, "```") # Discourse doesn't recognize ~~~ as beginning/end of code blocks
user_without_profile = username == "anonymous" || username == "nobody"
post_url =
require File.expand_path(File.dirname(__FILE__) + "/../base.rb")
topics = 0
next if filename == (".") || filename == ("..")
topics += 1
puts "", "Imported #{topics} topics. Skipped #{total - topics}."
Dir.foreach(path).select { |f| f != "." && f != ".." }.count
config = YAML.load_file(File.join(__dir__, "config.ex.yml"))
expected.keys.each { |k| assert (actual.keys.include? k), "#{k}" }
}'
body = "foo\nbar\nbaz"
user = {}
topic = {}
tags << group
post = {}
encoded = Base64.encode64 "#{@username}:#{@password}"
def list_users(opts = {})
response = request "#{base_url}/users?page=#{page}"
def list_messages(opts = {})
puts "", "Importing Socialcast Users..."
imported += 1
puts "", "Imported #{imported} topics. Skipped #{total - imported}."
users = 0
user_json = File.read USERS_DIR + "/" + filename
users += 1
config = YAML.load_file(File.join(__dir__, file))
path = File.join(__dir__, path)
lines = text.split("\n").select { |t| t.strip.size >= 20 }
options.password = HighLine.new.ask("") { |q| q.echo = false }
puts "", "creating groups"
total = query(<<-SQL, as: :single)
create_groups(query(<<-SQL), total: total) { |group| group }
create_users(query(<<-SQL), total: total) do |member|
ip_addr =
(group_id = group_id_from_imported_group_id(gid)) &&
) &&
@guardian ||=
proc do |p|
puts $!
puts "", "rebaking posts"
tags_done = 0
def query(sql, **opts, &block)
__query(db, sql, stream: true)
def __query(db, sql, **opts)
TRTR_TABLE.each { |from, to| cleaned_name.gsub!(from, to) }
cleaned_name.gsub!(/\s/, "_")
.detect { |file| File.exist?(file) }
body = decode_entities(body.gsub(%r{<br\s*/>}, "\n"))
use_count = Hash.new(0)
body.gsub!(pattern) do |s|
body = "#{body}\n\n---"
.to_s
raw.gsub!(%r{<br\s*/?>}i, "\n")
raw.gsub!(/Sent from .+? using .+?\z/i, "")
if params.has_key?("link")
.scan(/(?<param>\w+)=(?<value>(?:(?>\S+)|\s+(?!\w+=))*)/)
.inject({}) do |h, e|
rtag ||= "/" + ltag
(?<inner>(?:
)*
)*)
QuoteParamsPattern = /^topic=(?<topic>\d+).msg(?<msg>\d+)#msg\k<msg>$/
def parse!(args = ARGV)
self.host ||= "localhost"
self.prefix ||= "smf_"
phpinfo, status = Open3.capture2("php", "-i")
key, *vals = line.split(" => ").map(&:strip)
rescue => err
@parser ||=
self.host = s
o.on(
) { |s| self.password = s || :ask }
@prev = prev
.tap do |deps|
@id.eql?(other)
serialized = query(<<-SQL, as: :single)
topic_urls = query(<<-SQL, as: :array)
.pluck("value", "users.username")
@pm_mapping = {}
.order(:id)
.each do |users, title, topic_id|
SiteSetting.permalink_normalizations = "/(.+)\\?.*/\\1"
puts "", "Importing groups..."
users = mysql_query(<<~SQL).to_a
, id_group
WHERE m.id_member > #{last_user_id}
avatar_url ||=
, name
posts = mysql_query(<<~SQL).to_a
, m.id_topic
, m.id_board
, m.id_member
, m.body
, t.id_first_msg
WHERE m.id_msg > #{last_post_id}
post_id: pp.id,
puts "", "Importing personal posts..."
, body
AND id_pm > #{last_post_id}
title = title.gsub(/^(Re: )+/i, "")
puts "", "Importing attachments..."
last_upload_id = -1
uploads = mysql_query(<<~SQL).to_a
, id_msg
AND id_attach > #{last_upload_id}
.joins(:post)
&.post
next unless File.exist?(path) && File.size(path) > 0
puts "", "Importing likes..."
).each do |l|
print_status(count += 1, total, get_start_time("likes"))
puts "", "Importing feedbacks..."
mysql_query(<<~SQL).each do |f|
feedbacks << {
puts "", "Importing banned emails..."
puts "", "Importing banned IPs..."
banned_ips = mysql_query(<<~SQL).to_a
, CONCAT_WS('.', ip_high1, ip_high2, ip_high3, ip_high4) high
, hits
WHERE (ip_low1 + ip_low2 + ip_low3 + ip_low4 + ip_high1 + ip_high2 + ip_high3 + ip_high4) > 0
first_diff = low_values.zip(high_values).count { |a, b| a == b }
mask = 8 * (first_diff + 1)
ip_address = "#{range_values.join(".")}/#{mask}"
puts "", "Rolling up..."
params = $1
AND id > #{last_user_id}
user_ids_sql = user_ids.join(",")
category = {
AND p.post_index = 1
topic_first_post_id = {}
AND p.post_index <> 1
s.gsub!(/<!-- s(\S+) -->(?:.*)<!-- s(?:\S+) -->/, '\1')
puts "", "loading external users..."
@personify_id_to_contact_key = {}
@external_users = {}
CSV.foreach("/Users/zogstrip/Desktop/sfn.csv", col_sep: ";") do |row|
bio_raw: bio,
raw.gsub!(/^This message has been cross posted to the following eGroups: .+\n-{3,}/i, "")
raw.gsub!(/-{3,}.+/m, "")
@client ||= Mysql2::Client.new(username: "root", database: "sfn")
WHERE u.userid > #{last_user_id}
AND p.postid > #{last_topic_id}
word_lengths = {}
if word_lengths.inject(0) { |sum, (_, v)| sum + v } > remaining
words = words.compact.join("-")
puts "", "importing best answers..."
likes = mysql_query(<<-SQL).to_a
raw.gsub!(%r{<p>(.+?)</p>}im) { "#{$1}\n\n" }
raw.gsub!("<br />", "\n")
puts "", "Creating permalinks..."
url = "#{question_id}"
author = {}
answer = {}
comment = {}
parent = { "uid" => "parent-uid" }
parent = { "created" => "2013-01-06T18:24:54.62Z" }
parent = { "uid" => "parent-uid", "created" => "2013-01-06T18:24:54.62Z" }
config = YAML.load_file(File.join(__dir__, "config.yml"))
user = "Aladdin"
users = {}
{ Authorization: "Basic #{encoded.strip!}" }
url = "#{base_url @domain}/kb/#{kb_id}/list"
url = "#{url}?l=#{limit}" if limit
url = "#{base_url @domain}/q/#{question_id}"
puts "", "Importing from Quandora..."
puts "", "Imported #{topics} topics."
File.open("output/#{question_id}.json", "w") do |f|
text.gsub!(@short_internal_link_regexp) { |link| replace_internal_link(link, $1, $2) }
text.gsub!(@long_internal_link_regexp) { |link| replace_internal_link(link, $1, $2) }
index = $1.to_i
host = original_site_prefix.gsub(".", '\.')
%Q|<!-- l --><a(?:.+)href="#{link_regex}"(?:.*)</a><!-- l -->|,
text.gsub!(%r{<span class="syntax.*?>(.*?)</span>}) { "#{$1}" }
text.gsub!(%r{<br />}, "\n")
@smiley_map = {}
) { emoji($1) }
html = nil
require_relative "../../base"
@site_name.present? && val.present? ? "#{@site_name}:#{val}" : val
def initialize(xml, opts = {})
node.content = node.content.gsub(/\A\n+\s*/, "")
visitor = "visit_#{xml_node.name}"
after_hook = "after_#{xml_node.name}"
if xml_node.name == "br"
md_node.text << text(xml_node)
md_node.enclosed_with = "**" if xml_node.parent&.name != "B"
md_node.enclosed_with = "_" if xml_node.parent&.name != "I"
if xml_node.parent&.name != "U"
if !@allow_inline_code || content.include?("\n")
md_node.prefix = "```text\n"
md_node.postfix = "\n```"
md_node.enclosed_with = "`"
@list_stack << { unordered: xml_node.attribute("type").nil?, item_count: 0 }
depth = @list_stack.size - 1
indentation = " " * 2 * depth
md_node.prefix = "#{indentation}#{symbol} "
md_node.prefix = "<"
md_node.postfix = ">"
md_node.text = "https://www.youtube.com/watch?v=" + youtube_id
md_node.prefix_children = "> "
post_id = to_i(xml_node.attr("post_id"))
user_id = to_i(xml_node.attr("user_id"))
string.to_i if string&.match(/\A\d+\z/)
index = to_i(xml_node.attr("index"))
size = to_i(xml_node.attr("size"))
if size.between?(1, 99)
md_node.prefix = "<small>"
md_node.postfix = "</small>"
md_node.prefix = "<big>"
md_node.postfix = "</big>"
markdown = +""
if parent_prefix && md_node.xml_node_name != "br" &&
prefix = "#{parent_prefix}#{prefix}"
if md_node.xml_node_name != "CODE"
text = text.lstrip if markdown.end_with?("\n")
markdown << (linebreak == "\n" ? prefix.rstrip : prefix) if prefix && index > 0
markdown.gsub!(/\s*(?:\\?\n|<br>\n)*\z/, "")
return "<br>\n"
return "\\\n"
text.match?(/\A\s/)
text.match?(/\s\z/)
@text = +""
@prefix = +""
@postfix = +""
@prefix = @postfix = text
name: @settings.username_as_name ? username : "",
@user_fields ||=
@field_mappings ||=
custom_fields = {}
value = value == 1 ? true : nil
text.gsub!(/^(\d+)\./, '\1\.')
text = +"#{title}\n\n"
arguments << "type=multiple" <<
option_ids = {}
url = "viewforum.php?f=#{import_id}"
url = "viewtopic.php?t=#{import_id}"
url = "viewtopic.php?p=#{import_id}"
normalization = "/#{prefix.gsub("/", '\/')}\\#{normalization}"
user_ids = to_address.split(":")
group_ids = to_address.split(":")
@settings.prefix("pm:#{msg_id}")
{ titles: topic_titles, user_ids: current_user_ids.join(",") },
.try(:topic_id)
@text_processor ||=
File.join(@uploaded_avatar_path, "#{@avatar_salt}_#{filename}")
last_user_id = 0
last_username = ""
bio_raw =
next if row == "SKIP"
last_post_id = 0
last_msg_id = 0
last_user_id = last_topic_id = 0
last_post_id = last_user_id = 0
last_index = rows.size - 1
query(<<-SQL, :user_id)
JOIN #{@table_prefix}groups g ON (g.group_id = u.group_id)
u.user_id = b.ban_userid AND b.ban_exclude = 0 AND
JOIN #{@table_prefix}users u ON (p.poster_id = u.user_id)
query(<<-SQL, :post_username)
) x ON (f.forum_id = x.forum_id)
query(<<-SQL, :post_id)
JOIN #{@table_prefix}topics t ON (p.topic_id = t.topic_id)
WHERE p.post_id > #{last_post_id}
WHERE topic_id = #{topic_id}
JOIN #{@table_prefix}users u ON (v.vote_user_id = u.user_id)
JOIN #{@table_prefix}topics t ON (v.topic_id = t.topic_id)
WHERE o.topic_id = #{topic_id}
WHERE v.topic_id = #{topic_id}
query(<<-SQL).first
MAX(x.total_voters) - (
) x
WHERE topic_id = #{topic_id} AND post_msg_id = #{post_id}
query(<<-SQL, :msg_id)
WHERE a.topic_id = 0 AND m.msg_id = a.post_msg_id
WHERE m.msg_id > #{last_msg_id}
query(<<-SQL, :user_id, :topic_first_post_id)
JOIN #{@table_prefix}topics t ON (b.topic_id = t.topic_id)
WHERE (b.user_id, b.topic_id) > (#{last_user_id}, #{last_topic_id})
query(<<-SQL, :post_id, :user_id)
AND (post_id, user_id) > (#{last_post_id}, #{last_user_id})
WHERE code = '#{smiley_code}'
if version.start_with?("3.0")
elsif version.start_with?("3.1") || version.start_with?("3.2") || version.start_with?("3.3")
s = s.chomp("<br>")
@redis = ::Redis.new(params)
group = redis.hgetall("group:#{id}")
user_keys = redis.zrange("users:joindate", 0, -1)
user_keys.map { |user_key| user(user_key) }
user = redis.hgetall("user:#{id}")
{}.tap do |categories|
def topics(offset = 0, page_size = 2000)
offset = offset + 1 unless offset == 0
to = page_size + offset
topic = redis.hgetall("topic:#{id}")
def posts(offset = 0, page_size = 2000)
post_keys.map { |post_key| post(post_key) }
post = redis.hgetall("post:#{id}")
@client = adapter.new(host: "localhost", port: "6379", db: 14)
@merged_posts_map = {}
.pluck(:post_id, :value)
.each do |post_id, import_id|
picture = picture.gsub("/assets/uploads", "")
picture = picture.gsub("/uploads", "")
puts "", "adding users to groups..."
id: post_id,
parent_id ||=
text, filepath = $1, $2
text, post_id = $1, $2
text, topic_id = $1, $2
group = mongo.find(_key: "group:#{id}").first
if mongo.find(_key: "group:#{id}:owners").first
user = mongo.find(_key: "user:#{id}").first
topic = mongo.find(_key: "topic:#{id}").first
post = mongo.find(_key: "post:#{id}").first
puts "", "Importing from Ning..."
arg.gsub!(/^\(/, "") # content of file is surround by ( )
arg.gsub!(/\)$/, "")
arg.gsub!(/\}\{/, "},{") # missing commas sometimes!
@users_json.each do |u|
puts "", "Marked #{suspended} users as suspended."
) do |name|
puts "", "Importing blogs"
puts "", "Importing pages"
posts = 0
if new_post.is_a?(Post)
posts += 1
puts "", "Imported #{topics} topics with #{topics + posts} posts."
@_attachment_regex ||=
@_youtube_iframe_regex ||=
return "" if arg.nil?
raw = arg.gsub("</p>\n", "</p>")
raw = arg
raw += "\n" + embedded_image_html(upload)
raw += "\n\nhttps://www.youtube.com/watch?v=#{video_id}\n" if video_id
raw += "\n" + embed_code + "\n"
ImportScripts::Ning.new.perform if __FILE__ == $0
users = @client.query(<<-SQL)
filename = "avatar" + org_id.to_s
path = File.join("/tmp/nab", filename)
res =
File.open(path, "wb") { |f| f.write(PG::Connection.unescape_bytea(binary)) }
topics = @client.exec <<-SQL
WHERE n.parent_id = #{app_node_id}
raw = body_from(t)
txt.gsub!(%r{\<raw\>(.*?)\</raw\>}m) do |match|
txt.gsub! /\n#/m, " #"
txt.gsub!(/<nabble_img src="(.*?)" (.*?)>/m) do |match|
txt.gsub!(%r{<nabble_a href="(.*?)">(.*?)</nabble_a>}m) do |match|
fn = File.join("/tmp/nab", basename)
File.open(fn, "wb") { |f| f.write(PG::Connection.unescape_bytea(binary)) }
topic_ids = {}
posts = @client.exec <<-SQL
WHERE n.parent_id != #{app_node_id}
raw = body_from(p)
def indent(count, char = " ")
last_iteration = ($1 == "" && $2 == "")
line = +""
line << $1
line << $2
username.gsub!(/Dr\. /, "Dr") # no &
username.gsub!(/&/, "_and_") # no &
username.gsub!(/@/, "_at_") # no @
username.gsub!(/#/, "_hash_") # no &
username.gsub!(/\'/, "") # seriously?
username.gsub!(/_+/, "_") # could result in dupes, but wtf?
username.gsub!(/_$/, "") # could result in dupes, but wtf?
print_warning ("#{olduser} --> #{username}") if olduser != username
raw += "\n#{youtube}\n"
raw: clean_up(raw),
re = %r{<iframe.+?src="(\S+?)".+?</iframe>}mix
youtube_cooked.gsub!(re) { "\n#{$1}\n" }
re = %r{<object.+?src="(\S+?)".+?</object>}mix
youtube_cooked.gsub!(%r{^//}, "https://") # make sure it has a protocol
youtube_cooked = ""
print_warning("#{"-" * 40}\nBefore: #{youtube_raw}\nAfter: #{youtube_cooked}") unless QUIET
raw = raw.gsub('\\"', '"')
raw = raw.gsub("\\'", "'")
raw = raw.gsub(%r{(https://youtu\S+)}i) { "\n#{$1}\n" } #youtube links on line by themselves
puts "", "Users...", ""
external_url: "/u/#{u.username}",
puts "", "Posts...", ""
Permalink.create(url: "#{BASE}/forum_entry-id-#{id}.html", topic_id: topic.id)
print_warning("forum_entry-id-#{id}.html --> http://localhost:3000/t/#{topic.id}")
Permalink.create(url: "#{BASE}/forum_entry-id-#{id}.html", post_id: post.id)
puts "", "Categories...", ""
print_warning("forum-category-#{id}.html --> /t/#{cat.id}") unless QUIET
$stderr.puts "#{message}"
puts "", "Importing from JSON file..."
name.gsub(/ /, "")
if avatar.match(/^http.*/)
h = {
username.gsub!(/\s+/) do |a|
puts ("forum-#{id}.html --> /c/#{cat.id}") unless QUIET
Permalink.create(url: "#{BASE}/forum-#{id}.html", category_id: cat.id)
puts "", "Topics...", ""
puts "", "Importing from Muut..."
raw = arg.dup
raw = raw.to_s
raw.gsub!(/\\n/, "\n")
raw.gsub!("---", "```\n")
raw.gsub!(/\\\"/, '"')
ImportScripts::Muut.new.perform if __FILE__ == $0
WHERE id > #{last_user_id}
User.where("id > 0 and admin != true").update_all(active: true)
).each do |b|
@tags << {
directories.select! { |f| File.directory?(f) }
yaml = File.read(metadata_file).sub(/^--- !.*$/, "---")
metadata = {}
from_email = from_email.sub(/^(.*)=/, "") if @settings.elide_equals_in_addresses
email = {
msg_id: msg_id,
rows.each_with_object({}) do |row, hash|
raw_message = +""
raw_file = File.open(filename, "r")
text_file = filename.end_with?(".gz") ? Zlib::GzipReader.new(raw_file) : raw_file
subject.blank? ? nil : subject.strip.gsub(/\t+/, " ")
@db.execute(<<-SQL, category)
@db.execute(<<-SQL, email)
VALUES (:msg_id, :from_email, :from_name, :subject,
VALUES (:msg_id, :in_reply_to)
@db.prepare(sql) do |stmt|
@db.execute <<-SQL
SET in_reply_to = (
JOIN email e ON (r.in_reply_to = e.msg_id)
JOIN email_order o ON (e.msg_id = o.msg_id)
), msg_id)
SELECT e.msg_id, m.level + 1, e.email_date, e.in_reply_to
@db.get_first_value <<-SQL
rows = @db.execute(<<-SQL, last_email)
rows = @db.execute(<<-SQL, last_row_id)
puts "", "creating index"
last_email = ""
raw: format_raw(row, user_id),
body = "#{body}#{Email::Receiver.elided_html(elided)}"
{ name: "sso_id", user: "sso_id" },
{ name: "user_field_1", profile: "jobtitle" },
{ name: "user_field_2", profile: "company" },
{ name: "user_field_3", profile: "industry" },
@max_start_id = Post.maximum(:id)
id: user_id,
file = get_file(prefix + "actual.jpeg")
file ||= get_file(prefix + "profile.jpeg")
Time.at(t / 1000.0)
roles = mysql_query <<-SQL
WHERE node_id = #{node_id}
type_name: "String",
puts "", "importing posts... (#{post_count})"
posts.map { |post|
new_post = {
value: "Post 'body' is empty",
existing_map = {}
SELECT pa.user_id, 1, p.topic_id, p.id, pa.user_id, pa.created_at, pa.created_at
JOIN posts p ON p.id = pa.post_id
SELECT p.user_id, 2, p.topic_id, p.id, pa.user_id, pa.created_at, pa.created_at
JOIN posts p ON p.id = a.post_id
puts "", "importing pms..."
r.each do |row|
ary << user_id if user_id
note_to_subject = {}
subject_to_first_note = {}
).each do |row|
user_map = {}
if subject =~ /^Re: /
if t = topic_lookup_from_imported_post_id("pm_#{parent_id}")
value: "PM 'body' is empty",
.each_slice(500) do |ids|
SiteSetting.permalink_normalizations = '/t5\\/.*p\\/(\\d+).*//p/\\1'
JOIN posts p on f.post_id = p.id AND post_number = 1
r = DB.exec sql
JOIN posts p on f.post_id = p.id AND post_number <> 1
filename = attachment_id.to_s.rjust(4, "0")
.where("id > ?", @max_start_id)
puts "Missing raw for post: #{post.id}"
puts "GOT A JS error on post: #{post.id}"
.css("a,img,li-image")
.each do |l|
if uri && !uri.hostname
linked_upload = "#{$1}.#{$2}"
png = UPLOAD_DIR + "/" + upload_name + ".png"
jpg = UPLOAD_DIR + "/" + upload_name + ".jpg"
gif = UPLOAD_DIR + "/" + upload_name + ".gif"
l.name = "img" if l.name == "li-image"
where m.id = #{lithium_post_id} AND a.attach_num = #{attachment_number} limit 0, 1",
.css("li-user")
span.inner_html = "@#{username}"
raw.gsub!(/^\s*&nbsp;\s*$/, "")
html = +""
html << "\n" if html.present?
@users = {}
@users = nil
) do |c|
id: username_for(u),
name: u,
email: "#{username_for(u)}@example.com",
type: 37,
id: 1004,
type: "post",
type: 14,
id: 2006,
id: 2052,
{ jive_object: { type: 37, id: 1284 }, filters: { type: "post" }, category_id: 6 },
{ jive_object: { type: 37, id: 1319 }, filters: { type: "post" }, category_id: 6 },
{ jive_object: { type: 37, id: 1177 }, filters: { type: "post" }, category_id: 6 },
{ jive_object: { type: 37, id: 1165 }, filters: { type: "post" }, category_id: 6 },
type: 700,
id: 1001,
id: 1034,
{ jive_object: { type: 14, id: 2015 }, filters: { type: "idea" }, category_id: 31 },
puts "", "updating existing users..."
puts "", "importing contents..."
likes = get("#{url}?&count=#{USER_COUNT}&startIndex=#{start_index}", true)
if Post === post
puts "", "importing bookmarks..."
{ user_id: user_id, post_id: post_id }
.each do |span|
name && Emoji.exists?(name) ? span.replace(":#{name}:") : span.remove
doc.css("a.jive-link-profile-small").each { |a| a.replace("@#{a.content}") }
.each do |a|
tries ||= 3
command << "--user \"#{@username}:#{@password}\"" if !!authenticated
command << (
JSON.parse `#{command.join(" ")}`
retry if (tries -= 1) >= 0
@post_number_map = {}
.pluck(:id, :post_number)
filename = "#{@path}/#{name}.csv"
row = nil
current_row = +""
.each_line do |line|
double_quote_count += line.scan('"').count
next if double_quote_count % 2 == 1
puts "*" * 100
puts "Bad row skipped, line is: #{line}"
current_row = ""
File.foreach("#{@path}/#{table}.csv").inject(0) { |c, line| c + 1 } - 1
csv_parse("groups") { |row| rows << { id: row.groupid, name: row.name } }
create_groups(rows) { |row| row }
email = "#{row.email}"
email = fake_email if row.email.blank? || row.email !~ /@/
name = "#{row.firstname} #{row.lastname}"
users << {
active: is_activated.to_i == 1,
puts "", "importing group members..."
rows << { id: row.communityid, name: "#{row.name} (#{row.communityid})" }
raw = raw.dup
topic_map = {}
thread_map = {}
) do |item|
next if item == (".") || item == ("..") || item == (".DS_Store")
thread.body << "<br/><br/> #{attachment_html(upload, item)}"
body: normalize_raw!(thread.body || thread.subject || "<missing>"),
topic_map.each do |_, topic|
row = {
posts << row
if posts.length > 0 && posts.length % BATCH_SIZE == 0
puts "", "Usage:", "", "bundle exec ruby script/import_scripts/jive.rb DIRNAME", ""
rows, last_user_id = query(<<~SQL, :user_id)
WHERE user_id > #{last_user_id}
puts "", "creating tags"
@tags_by_import_forum_id = {}
rows, last_post_id = query(<<~SQL, :post_id)
post_text << "\n" << attachments.join("\n")
WHERE a.post_id = #{post_id}
rows, last_post_id, last_user_id = query(<<~SQL, :post_id, :from_user_id)
WHERE k.points >= 2 AND ((k.post_id = #{last_post_id} AND k.from_user_id > #{last_user_id}) OR k.post_id > #{last_post_id})
rows, last_forum_id, last_user_id = query(<<~SQL, :forum_id, :user_id)
WHERE ((x.forum_id = #{last_forum_id} AND x.user_id > #{last_user_id}) OR x.forum_id > #{last_forum_id})
tags = Tag.all.pluck(:name, :id).to_h
if user_id && tag_ids.present?
user = User.find_by(id: user_id)
rows, last_topic_id, last_user_id = query(<<~SQL, :topic_id, :user_id)
WHERE ((x.topic_id = #{last_topic_id} AND x.user_id > #{last_user_id}) OR x.topic_id > #{last_topic_id})
if user_id && topic
text.gsub!(/\r\n/, "\n")
fix_bbcode_tag!(tag: "quote", text: text)
fix_bbcode_tag!(tag: "code", text: text)
fix_bbcode_tag!(tag: "list", text: text)
fix_bbcode_tag!(tag: "center", text: text)
fix_bbcode_tag!(tag: "right", text: text)
fix_bbcode_tag!(tag: "left", text: text)
fix_inline_bbcode!(tag: "i", text: text)
fix_inline_bbcode!(tag: "b", text: text)
fix_inline_bbcode!(tag: "s", text: text)
fix_inline_bbcode!(tag: "u", text: text)
fix_inline_bbcode!(tag: "size", text: text)
fix_inline_bbcode!(tag: "font", text: text)
def fix_bbcode_tag!(tag:, text:)
, CONCAT(bday_year, '-', bday_month, '-', bday_day) date_of_birth
, g_title
, pp_about_me
WHERE member_id > #{last_user_id}
topics = mysql_query(<<~SQL).to_a
, forum_id
, post
AND tid > #{last_topic_id}
, topic_id
AND pid > #{last_post_id}
puts "", "closing #{@closed_topic_ids.size} topics..."
puts "", "import personal topics..."
, mt_date
, mt_title
, msg_post
user_ids =
user_ids.map! { |id| user_id_from_imported_user_id(id) }
puts "", "importing personal posts..."
, msg_date
def clean_up(raw, user_id = -1)
raw.encode!("utf-8", "utf-8", invalid: :replace, undef: :replace, replace: "")
raw.gsub!(%r{<(.+)>&nbsp;</\1>}, "\n\n")
.each do |bq|
if post = Post.find_by(id: post_id)
if a =
puts "echo gem \\'reverse_markdown\\' >> Gemfile"
puts "", "importing image categories..."
cat_map = {}
puts "Processing #{word_key}: #{title}"
id = word_key.gsub("gallery_category_", "")
id: id + "gal",
{ id: id, name: name }
AND new_topic=1;",
def array_from_members_string(invited_members = "a:3:{i:0;i:22629;i:1;i:21837;i:2;i:22234;}")
count_regex = /a:(\d)+:/
i_regex = /i:\d+;i:(\d+);/
rest.sub!(i_regex, "")
puts "i: #{i}, #{rest}"
puts "Processing . . . "
puts "Found user: #{to_user} -- #{user_id} -- #{username}"
puts "Can't find user: #{to_user}"
puts "", "importing gallery albums..."
;",
images = mysql_query(<<-SQL)
if id == last_id
raw +=
puts "", "importing gallery comments..."
comments = mysql_query(<<-SQL)
AND new_topic=0;",
@doc = Nokogiri.XML("<html>" + raw + "</html>")
new_text = ""
if content_type.length > 0 && content_type != "forums"
if post && topic && username
b.name = "div"
raw = @doc.to_html
raw.gsub!(/<br>/, "\n\n")
raw.gsub!(%r{<br />}, "\n\n")
raw.gsub!(%r{<p>&nbsp;</p>}, "\n\n")
raw.gsub!(/&#39;/, "'")
raw.gsub!(/date=\'(.+?)\'/, "")
raw.gsub!(/timestamp=\'(.+?)\' /, "")
puts "username: #{username}, post_id: #{post_num}, topic_id: #{topic_num}" unless QUIET
puts "Before fixing a quote: #{raw}\n**************************************** " unless QUIET
post_string = post_num ? ", post:#{post_num}" : ""
topic_string = topic_num ? ", topic:#{topic_num}" : ""
WHERE attach_id=#{attach_id}",
raw.gsub!(/<___base_url___>/, URL)
raw.gsub!(/<br>/, "\n")
.each do |d|
url = URL + "/t/#{topic}"
content_id = $1 || "-1"
url += "/#{post}"
d.name = "div"
raw = raw.gsub(/^\t+/, "")
match = match.gsub('\_', "_")
Permalink.create(url: "topic/#{id}-#{slug}", topic_id: topic.id)
Permalink.create(url: "#{slug}-#{id}t", topic_id: topic.id)
print_warning("#{URL}/#{slug}-#{id}t --> http://localhost:3000/t/#{topic.id}")
print_warning("/forum/#{URL}-#{slug}-#{id} --> /c/#{slug}") unless QUIET
Permalink.create(url: "/forum/#{id}-#{slug}", category_id: cat.id)
group_users = mysql_query(<<-SQL).to_a
puts "", "."
post.raw << "\n\n" << html
raw = raw.slice(0..(raw.index("------"))) || raw
@driver ||=
File.foreach("/proc/1/cgroup") { |line| return true if line.include?("docker") }
retries ||= 0
.step(nil, 100)
.each do |start|
exit_with_error(<<~TEXT.red.bold) if start == 1 && find("h2").text == "Error 403"
puts "Skipping".green << " #{url}"
puts "Scraping #{url}"
exit_with_error(<<~TEXT.red.bold) if content.match?(/From:.*\.\.\.@.*/i) && !@force_import
old_md5 ? old_md5 != Digest::MD5.file(filename) : true
puts "Logging in..."
get("https://google.com/404")
wait_for_url { |url| url.start_with?("https://accounts.google.com") }
parts = line.chomp.split("\t")
opts.on("-g", "--groupname GROUPNAME") { |v| @groupname = v }
opts.on("-d", "--domain DOMAIN") { |v| @domain = v }
opts.on("-c", "--cookies PATH", "path to cookies.txt") { |v| @cookies = v }
opts.on("--path PATH", "output path for emails") { |v| @path = v }
opts.on("-h", "--help") do
missing = mandatory.select { |name| instance_variable_get("@#{name}").nil? }
exit_with_error("Missing arguments: #{missing.join(", ")}".red.bold, "", parser, "")
exit_with_error("cookies.txt not found at #{@cookies}".red.bold, "") if !File.exist?(@cookies)
@topic_slug = {}
@topic_categories = {}
filename = File.join(@path, "#{table_name}_fixed.csv")
File.join(@path, "#{table_name}.csv")
puts "", "fixing CSV files"
line.gsub!(/\\\\/, '\\')
previous_line << "\n" unless line.starts_with?(",")
line = "#{previous_line}#{line}"
if line.gsub!(/,\+1\\\R$/m, ',"+1"').present?
.inject(0) { |c, _| c + 1 }
rows << {
csv_parse("replies") do |row|
post = map_post(row)
posts << post
hoisted = {}
raw.gsub!(%r{(<pre>\s*)?<code>(.*?)</code>(\s*</pre>)?}mi) do
code = $2
code.gsub!(/^\s*\n$/, "\n")
code.gsub!(/\n+/m, "\n")
hoisted.each { |hoist, code| raw.gsub!(hoist, "\n```\n#{code}\n```\n") }
puts "", "Creating Permalinks...", ""
@site_base_url = "http://localhost:3000"
@min_title_words = 3
@images = {}
@usermap = {}
@categories = {}
@last_date = nil
if arg.end_with?(".csv")
CSV.foreach(arg, headers: true, col_sep: ";") do |row|
@imagefiles = File.open(arg, "w")
@blocklist = load_fmgp_json(arg).map { |i| i.to_s }.to_set
@allowlist = load_fmgp_json(arg).map { |i| i.to_s }.to_set
elsif arg.end_with?(".json")
@feeds << load_fmgp_json(arg)
elsif arg == "--dry-run"
elsif arg.start_with?("--last-date=")
@last_date = Time.zone.parse(arg.gsub(/.*=/, ""))
elsif arg.start_with?("--first-date=")
@first_date = Time.zone.parse(arg.gsub(/.*=/, ""))
@cats = {}
@emails = {}
@newusers = {}
@uploaded = {}
File.open(categories_new, "w") do |f|
email = "#{id}@gplus.invalid"
puts "", "Importing Google+ posts and comments..."
p = Post.find_by(id: topic_id)
@topics_skipped += 1
@blocked_topics += 1
@posts_skipped += 1
@blocked_posts += 1
@posts_imported += 1
return nil if !@last_date.nil? && created_at > @last_date
return nil if !@frst_date.nil? && created_at < @first_date
if words.empty? || words.join("").length < @min_title_characters ||
(@min_title_words..(words.length - 1)).each do |i|
lines.join("")
text = "<s>#{text}</s>"
if upload_name =~ /\.(mov|mp4|webm|ogv)$/i
url = text
if upload.nil? || upload.id.nil?
if text == url
Mysql2::Client.new(host: "127.0.0.1", port: "3306", username: "", database: "", password: "")
puts "#{@path}"
if is_admin == "yes"
puts "", "#{user.username} is granted admin!"
and eue.guid > #{last_user_id}
require File.expand_path(File.dirname(__FILE__) + "/drupal.rb")
AND n.status = 1
categories = {}
tids = tids.split(",")
AND n.status = 1;",
n.uid,
AND n.type = 'answer'
SELECT (c.cid + 1000000) as cid,
c.nid,
c.uid,
AND n.type = 'question'
puts "", "Importing from Drupal..."
WHERE uid > #{last_user_id}
blogs = mysql_query(<<-SQL).to_a
AND n.nid = f.entity_id
AND fi.nid = n.nid
results = mysql_query(<<-SQL).to_a
n.uid uid,
AND c.status = 1
AND n.type IN ('article', 'forum')
SELECT c.cid, c.pid, c.nid, c.uid, c.created,
AND n.nid = c.nid
AND n.type IN ('blog', 'forum')
OR fid = 6
new_raw = "#{new_raw}\n\n#{upload_html}" unless new_raw.include?(upload_html)
slug = "/node/#{node_id}"
username, quote = $1, $2
new_raw.gsub!(%r{https://site.com/forum/topic/(\d+)}im) do
post_id = post_id_from_imported_post_id("nid:#{$1}")
new_raw.gsub!(%r{https://site.com/comment/(\d+)#comment-\d+}im) do
post_id = post_id_from_imported_post_id("cid:#{$1}")
if raw != new_raw
puts "", "Failed rewrite on post: #{post.id}"
puts "", 'Failed avatar update on user #{user.id}'
create_category({ name: "Blog", user_id: -1, description: "Articles from the blog" }, nil)
f.tid tid,
node_types = "('forum','blog')"
node_types = "('forum')"
c.pid,
require File.expand_path(File.dirname(__FILE__) + "/base")
by_email = {}
@parser.posts.each do |id, p|
title.gsub!(/&#8220;/, '"')
title.gsub!(/&#8221;/, '"')
title.gsub!(/&#8217;/, "'")
title.gsub!(/&#8212;/, "--")
title.gsub!(/&#8211;/, "-")
attrs = {
abort("No user found named: '#{username}'") if user.nil?
@inside = {}
@posts = {}
@post = {}
@post = nil
if @post.nil?
record(@post, :author_email, str, "author", "email")
record(@post, :author_name, str, "author", "name")
record(@post, :is_spam, str, "isSpam")
record(@thread, :link, str, "link")
record(@thread, :title, str, "title")
record(@thread, :author_email, str, "author", "email")
record(@thread, :author_name, str, "author", "name")
record(@post, :cooked, str, "message")
@threads.each do |id, t|
existing_title = {}
NEW_SITE_PREFIX = "http://discourse.example.com" # with http:// or https://
@first_post_id_by_topic_id = {}
FROM #{group_table};",
@category_slug = {}
WHERE skey = 'forumkeys'",
@duplicated_email = {}
where a.uid != b.uid",
FROM #{user_table} u
if (
).reject { |location| location.blank? }.join(" "),
JOIN #{posts_table} p2 ON p2.first AND p2.tid = p.tid
JOIN #{topics_table} t ON t.tid = p.tid
poll = results.first || {}
if (post = Post.find_by(id: post_id))
JOIN #{posts_table} p ON f.id = p.tid
.map! do |import_user_id|
WHERE plid = #{thread_id}
content = $1
s.gsub!(
s.gsub!(/\{(\:\S*?\:)\}/, '\1')
when "stat", "stats", "ranklist"
@pm_url_regexp ||=
puts "", "Importing attachments...", ""
attachment_id = $1.to_i
sql = "#{sql} AND aid NOT IN (#{inline_attachments.join(",")})" if !inline_attachments.empty?
new_raw << "\n"
new_raw << html
puts "", ""
padded_id = user_id.to_s.rjust(9, "0")
file_name = "#{part_4}_avatar_big.jpg"
AND a.aid = #{upload_id};"
WHERE a.aid = #{upload_id};"
items.find { |item| !item.blank? } || ""
puts "", "Importing from CSV file..."
users << u
puts "File doesn't exist: #{path}"
topics << t
id = row.id
users << { id: id, email: email, name: name, username: username, created_at: created_at }
rows << { id: row.id, name: row.name, description: row.description }
csv_parse("topics") do |topic|
id: topic.id,
deleted: topic.is_deleted.to_i == 1,
locked: topic.is_locked.to_i == 1,
pinned: topic.is_pinned.to_i == 1,
id: row.id,
deleted: row.is_deleted.to_i == 1,
puts "", "Usage:", "", "bundle exec ruby script/import_scripts/bespoke_1.rb DIRNAME", ""
WHERE p.post_type IN ('forum', 'reply', 'topic')
users = bbpress_query(<<-SQL).to_a
AND p.post_type IN ('forum', 'reply', 'topic')
AND u.id > #{last_user_id}
puts "", "importing anonymous users..."
bbpress_query(<<-SQL).each do |pm|
puts "", "importing topics and posts..."
AND post_type IN ('topic', 'reply')
posts = bbpress_query(<<-SQL).to_a
AND id > #{last_post_id}
post_ids_sql = post_ids.join(",")
posts_likes = {}
AND meta_key = 'Likes'
anon_names = {}
skip ? nil : post
AND id > #{last_attachment_id}
count += 1,
@attachments.find { |p| p.end_with?("/#{id}.#{filename}") }
topics = bbpress_query(<<-SQL).to_a
AND post_type IN ('topic')
AND id > #{last_topic_id}
threads = {}
rows = bbpress_query(<<-SQL).to_a
WHERE id > #{last_post_id}
name: "bb_thread_id",
@topics = {}
.each do |p|
@users.has_key?(import_id) || @users.has_key?(import_id.to_s)
@posts.has_key?(import_id) || @posts.has_key?(import_id.to_s)
VALUES (:id, :name, :description, :position, :url)
@db.execute(<<-SQL, prepare(upload))
@db.execute(<<-SQL, prepare(user))
VALUES (:id, :email, :username, :name, :bio, :avatar_path, :created_at, :last_seen_at, :active)
@db.execute(<<-SQL, prepare(like))
VALUES (:id, :user_id, :post_id, :topic)
@db.execute(<<-SQL, prepare(topic))
VALUES (:id, :title, :raw, :category_id, :closed, :user_id, :created_at, :url, :upload_count)
VALUES (:id, :title, :raw, :category_id, :closed, :user_id, :created_at, :url, :upload_count, :target_users)
@db.execute(<<-SQL, prepare(post))
VALUES (:id, :raw, :topic_id, :user_id, :created_at, :reply_to_post_id, :url, :upload_count)
@db.execute <<~SQL
@db.execute(<<-SQL)
@db.get_first_value(<<-SQL)
rows = @db.execute(<<-SQL, last_id)
@db.execute(<<-SQL, topic_id)
@db.execute(<<-SQL, id)
JOIN post_order o ON (p.id = o.post_id)
@db.execute(<<-SQL, post_id)
topic_id #{key_data_type},
def csv_parse(filename, col_sep = ",")
@old_site_settings = {}
@start_times = { import: Time.now }
I18n.t("test")
def create_admin(opts = {})
skipped += 1
created += 1
opts = opts.dup.tap { |o| o.delete(:id) }
g = existing || Group.new(opts)
g.tap(&:save)
import_ids.map { |id| "('#{PG::Connection.escape_string(id.to_s)}')" }.join(",")
def create_users(results, opts = {})
if u.nil?
puts "Failed to create user id: #{import_id}, username: #{new_user.try(:username)}, email: #{new_user.try(:email)}"
u = User.new(opts)
u,
UserEmail.where("lower(email) = ?", email.downcase).first&.user ||
top = top.parent_category while (top&.height_of_ancestors || -1) + 1 >=
index + 1
def create_posts(results, opts = {})
if user.id.nil? || post.id.nil?
def create_likes(results, opts = {})
WHERE f.topic_id = t.id AND f.name = 'import_closed' AND f.value = 't'
WHERE f.topic_id = t.id AND f.name = 'import_archived' AND f.value = 't'
puts "", "Updating first_post_created_at..."
puts "", "Updating user post_count..."
puts "", "Updating user topic_count..."
SELECT user_id, topic_id, 't' , MAX(post_number), MIN(created_at), MAX(created_at), COUNT(id) * 5000
.find_each do |user|
@thread_parents = {}
Category.new(name: cat, user_id: -1).save!
puts "", "reading thread tags..."
tags = @client.exec(<<-SQL)
tags_done += 1
puts "", "importing questions..."
ON A.thread_id = B.id
posts = @client.exec(<<-SQL)
SELECT A.id, A.author_id, A.added_at, A.text, A.thread_id, B.title
cat = nil
id: pid,
tmp = Regexp.quote("http://#{OLD_SITE}")
.gsub(r1) do
if raw != post.raw
AND c_active = 1
AND c_system <> 1;"
AND c_system <> 1
AND c_id > #{@last_user_id}
AND (c_type = 'question'
OR c_type = 'kbentry');"
WHERE c_id > #{@last_topic_id}
OR c_type = 'kbentry')
AND (c_type = 'answer'
OR c_type = 'comment'
WHERE c_id > #{@last_post_id}
AND c_id > 6;" # Ignore Anonymous, Users, Moderators, etc.
puts "", "adding moderators..."
user = User.find(id)
puts "", "adding admins..."
filename = "avatar-#{user_id}.png"
f << open(
).read
original_image_html = '<img src="/forums/storage/attachments/' + filename + '">'
original_file_html = '<a href="/forums/storage/attachments/' + filename + '">'
legacy_url = $1
Permalink.create(url: "questions/#{id}/#{slug}.html", topic_id: topic.id)
@db =
@path,
puts "", "reading CSV files..."
text.split(";").map { |filename| File.join(@path, directory, filename.strip) }
DateTime.strptime(text, "%m/%d/%y")
last_id = 0
raw = ReverseMarkdown.convert(raw) || ""
text.include?(OLD_DOMAIN) ? url : "<a href='#{url}'>#{text}</a>"
puts "", "Usage:", "", "bundle exec ruby script/import_scripts/answerbase.rb DIRNAME", ""
@errors = {}
@errors.any? { |_, value| value.any? }
puts "", "Errors in #{@filename}".red
current_key = parent_key.empty? ? key : "#{parent_key}.#{key}"
if Hash === value
if value.match?(/{{.+?}}/) && !key.end_with?("_MF")
if one_value && one_value.include?("1") && !one_value.match?(/%{count}|{{count}}/)
exit 1 unless $?.exitstatus == 0
run_or_fail("git reset --hard")
require File.expand_path("../../../config/environment", __FILE__)
if @pid = fork
exec "./child #{parent_pid}"
days = (Date.today.prev_day - date).to_i
WHERE c.table_schema = '#{@schema}'
AND t.table_schema = '#{@schema}'
AND c.data_type = '#{data_type}'
AND a.attnum = ANY (ix.indkey)
AND ns.nspname = '#{@schema}'
AND t.relname = '#{table}'
AND a.attname = '#{column}'
operator = days < 0 ? "-" : "+"
operator = days < 0 ? "+" : "-"
puts "<before>"
AND t.parentid != 7
next if post_id.nil? || user_id.nil?
allowed_users_sql = <<-SQL
added = 0
added += 1
{ topic_id: topic_id, user_id: user_id }
AND p.parentid != 8
puts "", "creating permalinks...", ""
url = "#{id}-#{topic.slug}"
def find_upload(post, opts = {})
filename = File.join(ATTACH_DIR, user_id.to_s.split("").join("/"), "#{attachment_id}.attach")
upload, filename = find_upload(post, { node_id: node_id })
puts "", "imported #{success_count} attachments... failed: #{fail_count}"
normalize_text(title).scrub.gsub(/^Re\s*:\s*/i, "")
return "" if raw.nil?
@has_post_thanks = mysql_query(<<-SQL).to_a.count > 0
@user_ids_by_email = {}
puts "", "Importing user emails..."
puts "", "Importing user stats..."
puts "", "Importing group users..."
puts "", "Importing user passwords..."
puts "", "Importing user salts..."
puts "", "Importing user profiles..."
group by replace(replace(title, ':', ''), '&', '')
puts "", "Importing private topics..."
@imported_topics = {}
puts "", "Importing topic allowed users..."
mysql_stream(<<-SQL).each do |row|
.scan(/i:(\d+)/)
.each do |id|
puts "", "Importing private posts..."
File.open(File.expand_path("../vb_map.csv", __FILE__), "w") do |f|
File.join(ATTACHMENT_DIR, user_id.to_s.split("").join("/"), "#{attachment_id}.attach")
puts "", "imported #{success_count} attachments... failed: #{fail_count}."
next unless item =~ /avatar(\d+)_(\d).gif/
scan = item.scan(/avatar(\d+)_(\d).gif/)
puts "", "imported #{count} avatars..."
user_id: u.id,
duplicated = {}
.select { |e, ids| ids.count > 1 }
.each_with_index do |(email, ids), i|
first, *rest =
user_ids.map do |id|
printf "."
File.open("duplicated_users.json", "w+") { |f| f.puts @user_ids_by_email.to_json }
password: "",
puts "", "importing first posts..."
puts "", "Importing tags..."
tag_mapping = {}
puts "", "importing topic_allowed_users..."
puts "", "importing private replies..."
puts "", "Creating permalinks...", ""
.find_each do |u|
if format == "Html"
doc.css("font").reverse.each { |f| f.replace f.inner_html }
doc.css("span").reverse.each { |f| f.replace f.inner_html }
doc.css("sub").reverse.each { |f| f.replace f.inner_html }
doc.css("u").reverse.each { |f| f.replace f.inner_html }
groups = psql_query <<-SQL
users = psql_query <<-SQL
b.ban_end = 0
WHERE u.user_id > #{@last_imported_user_id}
categories = psql_query(<<-SQL).to_a
topics = psql_query <<-SQL
posts = psql_query <<-SQL
WHERE p.post_id > #{@last_imported_post_id}
psql_query(<<-SQL).each do |row|
user_ids = to.split(":")
pm_title =
title.gsub(/^Re\s*:\s*/i, "")
smiley = $1
NOW ||= "now()"
@source_db_config = {
@tag_groups = {}
@uploads = {}
@post_actions = {}
@notifications = {}
@badge_groupings = {}
@badges = {}
@email_tokens = {}
@sequences = {}
@first_new_user_id = @last_user_id + 1
@first_new_topic_id = @last_topic_id + 1
puts "", "merging users..."
sql = "COPY users (#{columns.map { |c| "\"#{c}\"" }.join(",")}) FROM STDIN"
.exec(
sql = "COPY categories (#{columns.map { |c| "\"#{c}\"" }.join(", ")}) FROM STDIN"
) x ON c.id = x.id
source_category_path = row.delete("path")&.squeeze("/")
if existing && source_category_path == "/c/#{parent_slug}/#{existing.slug}".squeeze("/")
puts "merging tags..."
last_id = Tag.unscoped.maximum(:id) || 1
sql = "COPY tags (#{columns.map { |c| "\"#{c}\"" }.join(", ")}) FROM STDIN"
.exec("SELECT #{columns.map { |c| "\"#{c}\"" }.join(", ")} FROM tags")
col_list = TagGroupPermission.columns.map { |c| "\"#{c.name}\"" }.join(", ")
File.join(@uploads_path, "."),
File.join(Rails.root, "public", "uploads", "default"),
last_id = Upload.unscoped.maximum(:id) || 1
sql = "COPY uploads (#{columns.map { |c| "\"#{c}\"" }.join(", ")}) FROM STDIN"
.exec("SELECT #{columns.map { |c| "\"#{c}\"" }.join(", ")} FROM uploads")
if old_id && last_id
if old_user_id >= 1
.where("id >= ?", @first_new_user_id)
col_list = k.columns.map { |c| "\"#{c.name}\"" }.join(", ")
k,
last_id = Badge.unscoped.maximum(:id) || 1
sql = "COPY badges (#{columns.map { |c| "\"#{c}\"" }.join(", ")}) FROM STDIN"
.exec("SELECT #{columns.map { |c| "\"#{c}\"" }.join(", ")} FROM badges")
puts "copying #{klass.table_name}..."
last_id = columns.include?("id") ? (klass.unscoped.maximum(:id) || 1) : nil
sql = "COPY #{klass.table_name} (#{columns.map { |c| "\"#{c}\"" }.join(", ")}) FROM STDIN"
select_sql ||
next if old_user_id < 1
raise "user_id nil for user id '#{old_user_id}'"
@imported_post_uploads ||= {}
return id if id.to_i < 1
sql = "SELECT setval('#{sequence_name}', #{val})"
arr << " approved_by_id = #{new_approved_by_id}"
arr << " primary_group_id = #{new_primary_group_id}"
arr << " seen_notification_id = #{new_notification_id}"
sql << arr.join(", ")
sql << " WHERE id = #{u.id}"
percent = (current * 100) / total
if current % 200 == 0
puts "#{current} (#{percent}\%) completed. #{update_count} rows updated."
SET raw = replace(raw, $1, $2)
AND topic_id >= #{@first_new_topic_id}
AND raw <> replace(raw, $1, $2)",
SET cooked = replace(cooked, $1, $2)
AND cooked <> replace(cooked, $1, $2)",
puts "Starting..."
ids << id
@last_imported_topic_id = imported_topic_ids.select { |id| id < PRIVATE_OFFSET }.max || -1
@last_imported_post_id = imported_post_ids.select { |id| id < PRIVATE_OFFSET }.max || -1
@raw_connection.send_query("SELECT id, #{column} FROM #{name}")
@last_user_id = last_id(User)
@emails =
.map { |pci, name| "#{pci}-#{name}" }
@last_post_id = last_id(Post)
@post_number_by_post_id = load_values("posts", "post_number", @last_post_id)
@topic_id_by_post_id = load_values("posts", "topic_id", @last_post_id)
if @last_group_id > 0
@raw_connection.exec("SELECT setval('#{Group.sequence_name}', #{@last_group_id})")
if @last_user_id > 0
@raw_connection.exec("SELECT setval('#{User.sequence_name}', #{@last_user_id})")
if @last_user_email_id > 0
if @last_topic_id > 0
@raw_connection.exec("SELECT setval('#{Topic.sequence_name}', #{@last_topic_id})")
if @last_post_id > 0
@raw_connection.exec("SELECT setval('#{Post.sequence_name}', #{@last_post_id})")
sql = "COPY #{name.pluralize} (#{columns.map { |c| "\"#{c}\"" }.join(",")}) FROM STDIN"
if rows_created % 100 == 0
puts "ERROR: #{e.message}"
name = "import_#{name}"
name.gsub!(/^\W+/, "")
cooked.gsub!(%r{\nhttps\://www.youtube.com/watch\?v=(\w+)\n}) do
video_id = $1
username, post_id, topic_id, quote = $1, $2, $3, $4
quote.gsub!(/^(<br>\n?)+/, "")
quote.gsub!(/(<br>\n?)+$/, "")
<aside class="quote" data-post="#{post_id}" data-topic="#{topic_id}">
url = user.avatar_template.gsub("{size}", "45")
.sort { |a, b| b.length <=> a.length }
.each do |obj|
require File.expand_path("../../../../config/environment", __FILE__)
SiteSetting.default_locale = SiteSetting.default_locale == "en" ? "zh_CN" : "en"
profile { SiteSetting.default_locale = SiteSetting.default_locale == "en" ? "zh_CN" : "en" }
lambda { SiteSetting.default_locale = SiteSetting.default_locale == "en" ? "zh_CN" : "en" },
Benchmark.ips { |x| tests.each { |test, proc| x.report(test, proc) } }
data = data.map { |k, v| "#{CGI.escape(k)}=#{v}" }.join("&")
s = Time.now
puts(Time.now - s)
StackProf.run(mode: :wall, out: "report.dump") { 1000.times { Rails.application.call(req) } }
times -= 1
@best_of = 1
o.on("-n", "--with_default_env", "Include recommended Discourse env") { @include_env = true }
@iterations = i.to_i
@best_of = i.to_i
o.on("-d", "--heap_dump") do
o.on("-m", "--memory_stats") { @mem_stats = true }
o.on("-u", "--unicorn", "Use unicorn to serve pages as opposed to puma") { @unicorn = true }
) { |i| @concurrency = i.to_i }
) { |i| @unicorn_workers = i.to_i }
o.on("-s", "--skip-bundle-assets", "Skip bundling assets") { @skip_asset_bundle = true }
) { |i| @tests = i.split(",") }
if opt == :quiet
system(command, out: "/dev/null", err: :out)
system(command, out: $stdout, err: :out)
@timings = {}
if run("bundle", :quiet)
unless $? == 0
server = TCPServer.open("0.0.0.0", port)
@port = 60_079
@port += 1 while !port_available? @port
add = ""
add = "-c #{@concurrency} " if @concurrency > 1
header_string = headers&.map { |k, v| "-H \"#{k}:#{v}\"" }&.join(" ")
puts "Benchmarking #{name} @ #{path}"
pid =
FileUtils.mkdir_p(File.join("tmp", "pids"))
) == 0
while `ps -f --ppid #{unicorn_master_pid} | grep worker | awk '{ print $2 }'`.split("\n")
.map(&:to_i)
.size != @unicorn_workers.to_i
spawn("bundle exec puma -p #{@port} -e production")
admin_headers = { "Api-Key" => admin_api_key, "Api-Username" => "admin1" }
user_headers = { "User-Api-Key" => user_api_key }
run "curl -s -o /dev/null http://127.0.0.1:#{@port}/"
redirect_response = `curl -s -I "http://127.0.0.1:#{@port}/t/i-am-a-topic-used-for-perf-tests"`
tests_to_run = all_tests.select { |test_name, path| @tests.include?(test_name) }
uri = URI.parse("http://127.0.0.1:#{@port}#{path}")
def best_of(a, b)
puts "Unicorn: (workers: #{@unicorn_workers})"
puts "Include env: #{@include_env}"
puts "Iterations: #{@iterations}, Best of: #{@best_of}"
facts.delete_if do |k, v|
mem = get_mem(pid)
child_pids = `ps --ppid #{pid} | awk '{ print $1; }' | grep -v PID`.split("\n")
mem = get_mem(child)
puts open("http://127.0.0.1:#{@port}/admin/memory_stats", headers).read
puts open("http://127.0.0.1:#{@port}/admin/dump_heap", headers).read
File.open(@result_file, "wb") { |f| f.write(results) } if @result_file
stats = Hash.new(0)
stats.sort_by { |a, b| -b }.each { |name, count| puts "#{name}: #{count}" }
key = "#{j.klass} #{j.args}"
dupes.each do |k, jobs|
total += job.length - 1
channel += " (#{info})"
puts "All done!"
puts "Saw no messages :("
sorted_results = channel_counters.sort_by { |k, v| -v }
puts "| #{"channel".ljust(max_channel_name_length)} | #{"message count".rjust(max_count_length)} |"
puts "|#{"-" * (max_channel_name_length + 2)}|#{"-" * (max_count_length + 2)}|"
.each do |name, value|
name = "`#{name}`"
puts "| #{name.ljust(max_channel_name_length)} | #{value.to_s.rjust(max_count_length)} |"
puts "| #{"(other)".ljust(max_channel_name_length)} | #{other_count.to_s.rjust(max_count_length)} |"
puts "|#{" " * (max_channel_name_length + 2)}|#{" " * (max_count_length + 2)}|"
puts "| #{"TOTAL".ljust(max_channel_name_length)} | #{messages_seen.to_s.rjust(max_count_length)} |"
load File.expand_path("../lib/styleguide/engine.rb", __FILE__)
get "/" => "styleguide#index"
scope: {
let(:voter) { Fabricate(:user) }
let(:poll) { post.polls.first }
let(:delete_me) { Fabricate(:user) }
let!(:topic) { Fabricate(:topic, user: admin) }
fab!(:regular_post) { Fabricate(:post, topic: topic, raw: <<~RAW) }
fab!(:post_with_poll) { Fabricate(:post, topic: topic2, raw: <<~RAW) }
expect(cooked.scan("<li").length).to eq(20)
- i am a list
1. test 1
2. test 2
1. test 1 :) <b>test</b>
<ol>
</ol>
<div class="poll-info">
expect(excerpt).to eq("A post with a poll \n<a href=\"#{post.url}\">poll</a>")
I18n.t("poll.invalid_argument", argument: "type", value: "not_good1"),
it "ensure that min < max" do
it "ensure max > 0" do
it "ensure that min >= 0" do
let(:post_with_3_options) { Fabricate(:post, raw: <<~RAW) }
- a
- b
- c
let(:post_with_some_attributes) { Fabricate(:post, raw: <<~RAW) }
let(:post) { Fabricate(:post, raw: raw) }
update(post, {})
it "at any time" do
}.to change { PollVote.count }.by(1)
.track_publish("/polls/#{post.topic_id}") do
fab!(:post_with_regular_poll) { Fabricate(:post, raw: <<~RAW) }
fab!(:post_with_multiple_poll) { Fabricate(:post, raw: <<~RAW) }
{ "html" => "3", "id" => "68b434ff88aeae7054e42cd05a4d9056" },
{ "html" => "4", "id" => "aa2393b424f2f395abb63bf785760a3b" },
invalid_raw_poll = <<~MD
fab!(:post_with_multiple_poll) { Fabricate(:post, raw: <<~SQL) }
post_id: -1,
get "/polls/voters.json", params: { post_id: post.id }
get "/polls/voters.json", params: { post_id: post.id, poll_name: "wrongpoll" }
fab!(:post) { Fabricate(:post, raw: <<~SQL) }
user_votes = { user_0: option_a, user_1: option_a, user_2: option_b }
group: "Value0",
{ digest: option_a, html: "A", votes: 1 },
{ digest: option_b, html: "B", votes: 0 },
group: "Value1",
{ digest: option_a, html: "A", votes: 2 },
{ digest: option_b, html: "B", votes: 1 },
group: "Value2",
{ digest: option_a, html: "A", votes: 0 },
let!(:user) { log_in }
let!(:title) { "Testing Poll Plugin" }
name = "auto_close"
end.to change { Jobs::ClosePoll.jobs.size }.by(1) & change { Poll.count }.by(1)
(SiteSetting.poll_maximum_options + 1).times { |n| raw << "\n- #{n}" }
post :create, params: { title: title, raw: raw }, format: :json
let(:post_id) do
post :create, params: { title: title, raw: poll }, format: :json
let(:poll_edit_window_mins) { 6 }
put :update, params: { id: post_id, post: { raw: new_option } }, format: :json
put :update, params: { id: post_id, post: { raw: updated } }, format: :json
post :create, params: { title: title, raw: title }, format: :json
channel = "/polls/#{poll.topic_id}"
put :vote,
poll_name: "poll",
it "works in PM" do
delete :remove_vote, params: { post_id: poll.id, poll_name: "poll" }, format: :json
it "works for OP" do
get :voters, params: { poll_name: "poll", post_id: multi_poll.id, limit: 2 }, format: :json
get :voters, params: { poll_name: "poll", post_id: public_poll_on_vote.id }, format: :json
_user2 = log_in
get :voters, params: { poll_name: "poll", post_id: public_poll_on_close.id }, format: :json
put "/vote" => "polls#vote"
delete "/vote" => "polls#remove_vote"
get "/voters" => "polls#voters"
next if polls.blank? || !polls.is_a?(Hash)
if post.nil? || post.trashed?
.each do |poll|
poll.replace "<p><a href='#{post_url}'>#{I18n.t("poll.email.link_to_poll")}</a></p>"
I18n.t("poll.poll")
on(:post_created) do |post, _opts, user|
post.publish_message!("/polls/#{post.topic_id}", post_id: post.id, polls: polls)
@polls ||=
polls = {}
@preloaded_polls ||=
.map do |poll|
preloaded_polls.any? { |p| p.has_voted?(scope.user) }
@post = post
@post.acting_user &&
) || @post.topic&.pm_with_non_human_user?
.extract(@post.raw, @post.topic_id, @post.user_id)
:base,
if min > max || min <= 0 || max <= 0 || max > options || min >= options
if min < 0
@post.errors.add(:base, "Min #{I18n.t("errors.messages.greater_than", count: 0)}")
@post.errors.add(:base, "Min #{I18n.t("errors.messages.less_than", count: MAX_VALUE)}")
if max < min
@post.errors.add(:base, "Max #{I18n.t("errors.messages.greater_than", count: "min")}")
@post.errors.add(:base, "Max #{I18n.t("errors.messages.less_than", count: MAX_VALUE)}")
if step <= 0
@post.errors.add(:base, "Step #{I18n.t("errors.messages.greater_than", count: 0)}")
elsif ((max - min + 1) / step) < 2
::Poll
old_poll.public_send("#{attr}=", poll.public_send(attr))
if ::Poll.exists?(post: post)
poll_id = nil
DB.query(<<~SQL, poll_id: poll_id, user_id: user.id, offset: offset)
AND user_id = :user_id
post = Post.find_by(id: post_id)
unless post.user_id == user&.id || user&.staff?
limit = 0 if limit < 0
limit = 50 if limit > 50
page = 1 if page < 1
offset = (page - 1) * limit
.group(:user_id)
.order("MIN(created_at)")
.pluck(:user_id)
result = { option_digest => user_hashes }
, user_id
WHERE pv.poll_id = #{poll.id}
AND po.poll_id = #{poll.id}
) v
user_ids = votes.map(&:user_id).uniq
.where(id: user_ids)
poll =
poll_options = {}
user_field_map = {}
.find_each do |poll|
job_args = { post_id: post.id, poll_name: poll.name }
if poll.open? && poll.close_at && poll.close_at > Time.zone.now
close_at =
.css("div.poll")
.map do |p|
attribute.value || "",
.each do |o|
if poll.min && (num_of_options < poll.min)
elsif poll.max && (num_of_options > poll.max)
poll_groups = poll.groups.split(",").map(&:downcase)
user_groups = user.groups.map { |g| g.name.downcase }
POLL_TYPES ||= { "regular" => 0, "multiple" => 1, "number" => 2 }
SELECT post_id, 'polls-votes', '{}', created_at, updated_at
.each do |r|
votes = {}
type =
r.post_id,
).first > 0
.map do |option|
.select { |o| option_ids.has_key?(o) }
VALUES #{poll_votes.join(",")}
SELECT 'has_polls', 't', post_id, MIN(created_at), MIN(updated_at)
.joins(post: :topic)
.where("post_custom_fields.name = 'polls'")
.find_each do |pcf|
polls = ::JSON.parse(pcf.value || "{}")
.where(name: "polls")
.order(:post_id)
.pluck(:post_id)
.each do |post_id|
polls_votes = {}
.where("name LIKE 'polls-votes-%'")
pcf.value = ::JSON.parse(pcf.value || "{}").merge(polls_votes).to_json
:type,
:min,
:max,
:step,
belongs_to :post, -> { with_deleted }
has_many :poll_options, -> { order(:id) }, dependent: :destroy
enum type: { regular: 0, multiple: 1, number: 2 }, _scopes: false
enum status: { open: 0, closed: 1 }, _scopes: false
enum results: { always: 0, on_vote: 1, on_close: 2, staff_only: 3 }, _scopes: false
enum visibility: { secret: 0, everyone: 1 }, _scopes: false
enum chart_type: { bar: 0, pie: 1 }, _scopes: false
closed? || (close_at && close_at <= Time.zone.now)
!!(always? || (on_vote? && (is_me?(user) || has_voted?(user))) || is_closed?)
def is_me?(user)
user && post && post.user&.id == user&.id
render json: { poll: poll, vote: options }
render json: { poll: poll }
data-youtube-id="#{video_id}"
<a href="https://www.youtube.com/watch?v=#{video_id}" target="_blank">
src="#{thumbnail_url}"
title="#{escaped_title}">
.css(".lazyYT")
.each do |yt|
yt.replace %{<p><a href="#{uri.to_s}">https://#{uri.host}#{uri.path}</a></p>}
expect(c.can_view?(user_id: user.id)).to eq(true)
expect(c.can_enter?(user_id: user.id)).to eq(true)
expect(c.can_view?(user_id: user.id)).to eq(false)
let(:profile_page_url) { "#{Discourse.base_url}/users/#{user.username}" }
def i18n_post_args(extra = {})
{ base_uri: "" }.merge(extra)
def i18n_t(key, params = {})
expect { user }.to_not change { Post.count }
expect { user }.to change { Topic.count }.by(1)
/:robot:/,
let(:user) { Fabricate(:user, staged: true) }
expect { user.user_option.save! }.to change { Topic.count }.by(-1).and not_change {
let!(:invite) do
let(:user) { Fabricate(:user, name: "Jeff Atwood") }
let(:params) { { date: Time.zone.now.strftime("%b %d %Y"), user_id: user.id } }
params.each do |key, _|
let(:avatar_url) { "http://test.localhost/cdn/avatar.png" }
let(:date) { "2017-00-10" }
before { SiteSetting.logo_small = "" }
let(:invite) { Fabricate(:invite, email: "foo@bar.com") }
user: Fabricate(:user, email: "foo@bar.com"),
body: "{\"quoteText\":\"Be Like Water\",\"quoteAuthor\":\"Bruce Lee\"}",
end_message = <<~RAW
raw: "show me what you can do",
expected_raw = <<~RAW
post.update!(raw: "thanks!")
state: :end,
).id,
post.update!(raw: "roll 2d1")
before { srand(1) }
post.update!(raw: "roll 0d1")
post.update!(raw: "@discobot")
.to_i,
quote: "Be Like Water",
author: "Bruce Lee",
user.update!(locale: "it")
quote: I18n.t("#{key}.quote"),
author: I18n.t("#{key}.author"),
after { @overrides.each(&:destroy!) }
key = "somekey"
key: "somekey",
type_name: "string",
fab!(:first_post) { Fabricate(:post, user: discobot_user) }
fab!(:other_post) { Fabricate(:post, topic: other_topic) }
fab!(:profile_page_url) { "#{Discourse.base_url}/users/#{user.username}" }
base_uri: "",
job: :bot_input,
let(:post_2) { Fabricate(:post, topic: topic) }
new_post = Fabricate(:post, user: user, topic: topic, raw: url)
url: post_2.url,
post.update!(raw: ":monkey: :fries:")
let(:post) { Fabricate(:post, user: discobot_user, topic: topic) }
let(:flag) do
let(:other_post) { Fabricate(:post, user: user, topic: topic) }
let(:flag) { Fabricate(:flag, post: post, user: user) }
end.to change { Post.count }.by(1)
end.to change { Post.count }.by(2)
expect { narrative.input(:reply, user, post: post) }.to change { Post.count }.by(1)
let(:post_2) { Fabricate(:post, user: post.user, topic: post.topic) }
category: "#a:b",
post.update!(raw: "Check out this ##{category.slug}")
}.to change { Topic.count }
.join("plugins", "discourse-narrative-bot", "db", "fixtures")
svg =
respond_to { |format| format.svg { render inline: svg } }
get "/certificate" => "certificates#generate", :format => :svg
!self.staged &&
.split("|".freeze)
Jobs.enqueue(:bot_input, user_id: user.id, post_id: post.id, input: "reply")
Jobs.enqueue(:bot_input, user_id: post.user.id, post_id: post.id, input: "edit")
input: "delete",
self.on(:post_recovered) do |post, _, user|
@post_id = post_id
@topic_id = topic_id
@post = Post.find_by(id: post_id)
data = Store.get(@user.id)
is_reply = @input == :reply
@is_pm_to_bot = pm_to_bot?(@post)
elsif state&.to_sym == :end && is_reply
klass.new.input(@input, @user, post: @post, skip: skip_track?)
elsif is_reply && (@is_pm_to_bot || public_reply?)
elsif data && data.dig(:state)&.to_sym != :end && is_topic_action?
klass.new.input(@input, @user, post: @post, topic_id: @topic_id)
@post.raw.match(Regexp.new("\\b\\W\?#{trigger}\\W\?\\b", "i"))
elsif match_data = match_trigger?("#{self.class.dice_trigger} (\\d+)d(\\d+)")
@post.post_number - 10 > last_bot_help_post_number.to_i &&
(1.day.to_i - Discourse.redis.ttl(key)) > 6.hours.to_i
message << "\n\n#{
}"
if state && state.to_sym != :end
reply_to(@post, raw)
@post,
if @is_pm_to_bot
/((^@#{self.discobot_username} #{self.class.skip_trigger})|(^#{self.class.skip_trigger}$))/i,
@@cooked_triggers = {}
match || @post.raw.strip.match(Regexp.new("^#{trigger}$", "i"))
@bot_mentioned ||=
(reply_to_bot_post?(@post) || bot_mentioned?)
Store.set(@user.id, data.merge!(track: nil, state: nil, topic_id: nil))
begin: {
init: {
reply: {
like: {
flag: {
if pm_to_bot?(post)
{ raw: raw },
if @post && @post.topic.private_message? &&
post = reply_to(@post, raw, opts)
reply_to(@post, I18n.t("#{I18N_KEY}.bookmark.not_found", i18n_post_args))
reply = reply_to(@post, raw)
@post.post_analyzer.cook(@post.raw, {})
reply_to(@post, I18n.t("#{I18N_KEY}.onebox.not_found", i18n_post_args))
user_id: @user.id,
if (post_id = get_state_data(:post_id)) && (post = Post.find_by(id: post_id))
cooked = @post.post_analyzer.cook(@post.raw, {})
reply_to(@post, I18n.t("#{I18N_KEY}.likes.not_found", i18n_post_args(url: last_post.url)))
.css("b", "strong", "em", "i", ".bbcode-i", ".bbcode-b")
.size > 0
if doc.css(".quote").size > 0
reply_to(@post, I18n.t("#{I18N_KEY}.quoting.not_found", i18n_post_args))
if doc.css(".emoji").size > 0
reply_to(@post, I18n.t("#{I18N_KEY}.emoji.not_found", i18n_post_args))
if @post.user_id == -2
.where(user_id: @user.id)
return unless @post.user.id == -2
reply_to(@post, I18n.t("#{I18N_KEY}.search.not_found", i18n_post_args))
def url_helpers(url, opts = {})
if num_of_dice == 0 || range_of_dice == 0
output << "\n\n"
output << I18n.t(
results: num_of_dice.times.map { rand(1..range_of_dice) }.join(", "),
if e.message == "invalid date"
@date = I18n.l(date, format: :date_only)
File.read(File.expand_path("../templates/#{filename}.svg.erb", __FILE__))
date: @date,
logo_uri =
URI("#{Discourse.base_url}/#{uri.path}")
{ size: size, width: width, height: height, logo_uri: logo_uri }
@skip = skip
@data = get_data(user) || {}
!(
.split("|")
old_data = @data.dup
if (@skip && @state != :end)
state_changed = (old_state.to_s != next_state.to_s)
set_data(@user, @data)
if next_state == :end
@data = old_data
options = { user_id: @user.id, date: Time.zone.now.strftime("%b %d %Y"), format: :svg }
src =
if next_state != :end
clean_up_method = "clean_up_#{state}"
init_method = "init_#{state}"
edit: {
delete: {
i18n_post_args(category: "##{slug}"),
recover: {
data = get_data(@user)
opts = { skip_bot: true }
title: I18n.t("#{I18N_KEY}.title"),
return unless valid_topic?(@post.topic_id) && post_id != @post.id
I18n.t("#{I18N_KEY}.edit.not_found", i18n_post_args(url: Post.find_by(id: post_id).url)),
reply_to(@post, I18n.t("#{I18N_KEY}.delete.not_found", i18n_post_args))
post_id = get_state_data(:post_id) && @post.id != post_id
reply_to(@post, I18n.t("#{I18N_KEY}.recover.not_found", i18n_post_args))
reply_to(@post, I18n.t("#{I18N_KEY}.poll.not_found", i18n_post_args))
reply_to(@post, I18n.t("#{I18N_KEY}.details.reply", i18n_post_args))
reply_to(@post, I18n.t("#{I18N_KEY}.details.not_found", i18n_post_args))
reply_to(@post, I18n.t("#{I18N_KEY}.wiki.reply", i18n_post_args))
reply_to(@post, I18n.t("#{I18N_KEY}.wiki.not_found", i18n_post_args))
@discobot ||= User.find(-2)
def reply_to(post, raw, opts = {}, post_alert_options = {})
default_opts = {
if user && user.new_user?
if count.to_i < 2
.css(".mention")
post&.reply_to_post && post.reply_to_post.user_id == -2
def pm_to_bot?(post)
SET icon = 'stamp'
icon: "stamp",
User.seed do |u|
.raw_match("/images/")
.where(user_id: -2)
post.raw.scan(%r{(?<!/plugins/discourse-narrative-bot)(#{paths.join("|")})})
).present?
.find_each do |row|
user = User.find_by(id: row.key)
before { create_post(user: user, topic: topic, title: "Date range test post", raw: <<~RAW) }
post = Fabricate(:post, raw: <<~SQL)
post = Fabricate(:post, raw: "https://example.com")
def generate_html(text, opts = {})
output = "<p><span"
output += " class=\"discourse-local-date\""
output += ">"
output + "</span></p>"
date: "2018-05-08",
time: "20:00:00",
cooked_mail = generate_html("08/05 UTC", date: "2018-05-08", email_preview: "08/05 UTC")
it "adds UTC" do
date = {}
data_name = attribute.name&.gsub("data-", "")
dates << date
.each { |container| container.content = "#{container.content} (UTC)" }
cooked_html = <<~HTML.gsub("\n", "")
<p>bar</p>
mail_html = "<p>Hello World</p>\n<a href=\"http://test.localhost\">(click for more details)</a>"
md = PrettyText.cook(<<~MD)
html = "<p>hello</p>\n\nSummary <a href=\"#{post.full_url}\">(click for more details)</a>"
expect(md.scan(/First/).size).to eq(1)
expect(md.scan(/Third/).size).to eq(1)
.css("details")
summary.name = "p"
.each do |el|
text = el.css("summary").text
el.replace CGI.escapeHTML(text) + " " + link.to_html
let(:chat) { PageObjects::Pages::Chat.new }
visit("/chat/c/-/999")
visit("/chat/c/-/#{category_channel_1.id}/-999")
visit("/chat/c/-/#{category_channel_1.id}")
fab!(:message_1) do
visit("/chat/c/-/#{dm_channel_1.id}")
visit("/")
href: "/chat/c/#{other_user.username}/#{dm_channel_1.id}/#{message.id}",
fab!(:channel_1) { Fabricate(:chat_channel) }
content: "this is fine @#{group.name}",
identifier: "@#{group.name}",
href: "/chat/c/#{channel_1.slug}/#{channel_1.id}/#{message.id}",
content: "this is fine @all",
identifier: "@all",
find(".invite-link", wait: 5).click
fab!(:topic_1) { Fabricate(:topic) }
before { find(".user-card-chat-btn").click }
let!(:chat_page) { PageObjects::Pages::Chat.new }
find(".channel-#{dm_channel_1.id}").hover
expect(page).to have_no_css(".channel-#{dm_channel_1.id}")
text = "this is fine"
expect(page).to have_css(".channel-#{dm_channel_1.id} .urgent")
fab!(:chat_channel_1) { Fabricate(:chat_channel) }
cdp_params = {
fab!(:post_1) { Fabricate(:post) }
within(".d-editor-preview") { expect(page).to have_css(".chat-transcript") }
within(".d-editor-preview") { expect(page).to have_css(".chat-transcript", count: 2) }
fab!(:channel) { Fabricate(:chat_channel) }
fab!(:silenced_user) { Fabricate(:user) }
visit("/chat")
visit("/?mobile_view=1")
expect(page).to have_link(channel_1.name, href: "/chat/c/#{channel_1.slug}/#{channel_1.id}")
fab!(:group_1) { Fabricate(:group) }
fab!(:channel_1) { Fabricate(:chat_channel, name: "test :heart:") }
fab!(:channel_2) { Fabricate(:chat_channel) }
before { channel_1.update!(description: "<script>alert('hello')</script>") }
).to eq("&lt;script&gt;alert(&#x27;hello&#x27;)&lt;/script&gt;")
fab!(:user_1) { Fabricate(:user, username: "zoesmith") }
fab!(:user_2) { Fabricate(:user, username: "alansmith") }
fab!(:dm_channel_1) do
fab!(:user_1) { Fabricate(:admin) }
before { visit("/") }
find("body").send_keys("-")
fab!(:reaction_1) do
fab!(:reaction_2) do
emoji: "heart",
has_no_css?(".chat-skeleton")
def has_message?(text: nil, id: nil)
has_css?(".chat-message-text", text: text)
visit(channel.url + (mobile ? "?mobile_view=1" : ""))
has_no_css?(".not-loaded-once")
visit(channel.url + "/info")
has_css?(".new-channel-btn")
expect(page).to have_current_path("/t/#{topic.slug}/#{topic.id}")
let(:link) { "My favorite message" }
raw: "<a href=\"/chat/c/-/#{channel_1.id}/#{first_message.id}\">#{link}</a>",
visit("/t/-/#{topic_1.id}")
visit("/chat/c/-/#{channel_1.id}/#{first_message.id}")
fab!(:message_2) do
before { channel_1.add(user_1) }
text: "hey what's going on @#{current_user.username}?",
text: "hello @#{current_user.username} what's up?",
text: "1",
text: 1,
fab!(:channel_1) { Fabricate(:category_channel, name: ":art: b channel") }
fab!(:channel_2) { Fabricate(:category_channel, name: ":art: a channel") }
fab!(:channel_1) { Fabricate(:category_channel, name: "b channel") }
fab!(:channel_2) { Fabricate(:category_channel, name: "a channel") }
wait: 5,
channel.send_message("hi @#{group_1.name}")
fab!(:channel1) { Fabricate(:chat_channel, name: "Music Lounge", slug: "music") }
fab!(:channel2) { Fabricate(:chat_channel, name: "Random", slug: "random") }
fab!(:tag) { Fabricate(:tag, name: "razed") }
fab!(:editing_user) { Fabricate(:user) }
expect(page.find(".chat-drawer").native.style("width")).to eq("500px")
expect(page.find(".chat-drawer").native.style("width")).to eq("400px")
fab!(:category_1) { Fabricate(:category) }
fab!(:group_1) do
group = Group.new(name: "<script>e</script>")
name = "Cats & Dogs"
let(:name) { "Cats & Dogs" }
group: "@#{group_1.name}",
group1: "@#{group_1.name}",
group2: "@#{group_2.name}",
fab!(:group_3) { Fabricate(:group) }
find(".chat-composer-input").fill_in(with: ":gri")
find(".chat-composer-input").fill_in(with: ":fr")
find("body").send_keys("b")
expect(find(".chat-composer-input").value).to eq("b")
visit("/chat/c/-/#{channel_1.id}/#{message_1.id}")
visit("/chat/message/#{message_1.id}")
text: "@#{current_user.username}",
\`\`\`ruby
\`\`\`
}.to change { channel_1.reload.status }.from("open").to("closed")
channel_1.update!(name: "<script>alert('hello')</script>")
name = "A new name"
slug = "gonzo-slug"
slug_input.fill_in(with: "")
fab!(:category_channel_1) { Fabricate(:chat_channel, name: "foo") }
fab!(:category_channel_2) { Fabricate(:chat_channel, name: "bar") }
find(".dc-filter-input").fill_in(with: "x")
before { 25.times { Fabricate(:chat_channel, status: :open) } }
before { visit("/chat/browse/all") }
before { visit("/chat/browse/open") }
before { visit("/chat/browse/closed") }
i = 0.5
i += 0.1
with: "An interesting topic for cats :cat: :cat2: :smile_cat:",
let(:name) { "a custom name" }
fab!(:staff) { Fabricate(:user, admin: true) }
open: 0,
read_only: 1,
closed: 2,
describe "#open!" do
endpoint ||= ".json"
params ||= {}
message = "Expected #{type} '#{name}' (key: '#{step}') to succeed but it failed."
self.class.name.split("::").last.sub("Fail", "").downcase
def fail_to_find_a_model(name = "model")
puts "Steps:"
message: "Chat message for test #{n}",
schema_path = "#{schema_directory}/#{schema}.json"
expect { result }.to change {
let(:status) { "open" }
context "when status is '#{na_status}'" do
let(:status) { na_status }
slug: "snail",
) { result }
fab!(:message_1) { Fabricate(:chat_message) }
user: user_1,
fab!(:guardian) { Guardian.new(user1) }
.find { |channel| channel.id == channel1.id }
.as_json,
.find { |channel| channel.id == channel3.id }
user = Fabricate(:user, **params)
fab!(:message_poster) { Fabricate(:user) }
fab!(:guardian_user) { Fabricate(:user) }
let(:options) { { scope: guardian, root: nil, chat_channel: message_1.chat_channel } }
fab!(:dm_channel) do
let(:options) { { scope: guardian, root: nil, chat_channel: dm_channel } }
let(:message) { Fabricate(:chat_message, message: "ok #{watched_word.word}") }
let(:guardian_user) { user }
let(:guardian_user) { admin }
post "/chat/hooks/#{webhook.key}.json",
text: "$" * (SiteSetting.chat_maximum_message_length + 1),
post "/chat/hooks/#{webhook.key}.json", params: { text: "A new signup woo!" }
post "/chat/hooks/#{webhook.key}.json", params: { text: "hey #{watched_word.word}" }
post "/chat/hooks/#{webhook.key}.json", params: { text: "hey this is a message" }
10.times { post "/chat/hooks/#{webhook.key}.json", params: { text: "A new signup woo!" } }
post "/chat/hooks/#{webhook.key}/slack.json", params: { text: "A new signup woo <!here>!" }
payload_data = {
color: "#F4511E",
title: "New+alert:+#46353",
never_freq = "never"
fab!(:category) { Fabricate(:category, user: admin) }
fab!("message_#{n}") do
message: "message #{n}",
let(:page_size) { 30 }
get "/chat/#{chat_channel.id}/messages.json", params: { page_size: page_size }
get "/chat/#{chat_channel.id}/messages.json", params: { page_size: 51 }
get "/chat/#{dm_chat_channel.id}/messages.json", params: { page_size: page_size }
1.upto(4) do |n|
heart_emoji = ":heart:"
smile_emoji = ":smile"
get "/chat/#{new_channel.id}/messages.json", params: { page_size: chat_messages_qty + 1 }
let!(:category) { Fabricate(:category) }
let(:message) { "This is a message" }
post "/chat/#{chat_channel.id}.json", params: { message: message }
expect { post "/chat/#{chat_channel.id}.json", params: { message: message } }.to change {
put "/chat/#{chat_channel.id}/edit/#{chat_message.id}.json", params: { new_message: "Hi" }
put "/chat/#{chat_channel.id}/edit/#{chat_message.id}.json", params: { new_message: "edit!" }
put "/chat/#{chat_channel.id}/edit/#{chat_message.id}.json",
expect { delete "/chat/#{chat_channel.id}/#{ChatMessage.last.id}.json" }.not_to change {
expect { delete "/chat/#{chat_channel.id}/#{ChatMessage.last.id}.json" }.to change {
fab!(:second_user) { Fabricate(:user) }
let(:other_user) { second_user }
put "/chat/#{chat_channel.id}/read/#{message_1.id}.json"
put "/chat/#{chat_channel.id}/read/-999.json"
expect { put "/chat/#{chat_channel.id}/read/#{message_1.id}.json" }.not_to change {
put "/chat/#{chat_channel.id}/read/#{message_2.id}.json"
put "/chat/#{chat_channel.id}/react/#{chat_message.id}.json",
emoji: 12,
react_action: "add",
emoji: ":heart:",
react_action: "sdf",
emoji = ":heart:"
.map(&:name)
.take(29)
emoji: ":wink:",
emoji: ":wave:",
emoji = ":wink:"
put "/chat/#{chat_channel.id}/invite.json",
let(:message3) { Fabricate(:chat_message, user: user, chat_channel: channel, message: "aw :(") }
post "/chat/#{channel.id}/quote.json",
aw :(
put "/chat/flag.json",
post "/chat/drafts.json", params: { chat_channel_id: chat_channel.id, data: "{}" }
}.to change { ChatDraft.count }.by(1)
expect { post "/chat/drafts.json", params: { chat_channel_id: chat_channel.id } }.to change {
post "/chat/drafts.json", params: { chat_channel_id: dm_channel.id, data: "{}" }
data: { value: "a" * (SiteSetting.max_chat_draft_length + 1) }.to_json,
get "/chat/lookup/#{message.id}.json", params: { chat_channel_id: channel.id }
let!(:message) { Fabricate(:chat_message) }
fab!(:user) { Fabricate(:user, username: "johndoe", name: "John Doe") }
get "/chat/api/chatables", params: { filter: "so" }
fab!(:other_user) { Fabricate(:user, username: "janemay", name: "Jane May") }
fab!(:admin) { Fabricate(:admin, username: "andyjones", name: "Andy Jones") }
get "/chat/api/chatables", params: { filter: "something" }
get "/chat/api/chatables", params: { filter: "andyjones" }
get "/chat/api/chatables", params: { filter: "andy" }
get "/chat/api/chatables", params: { filter: "hello good sir" }
get "/chat/api/chatables", params: { filter: "Andy J" }
get "/chat/api/chatables", params: { filter: "janemay" }
{ status: status }
before { channel_1.update!(status: "read_only") }
}.to change { channel_1.reload.status }.to("closed").from("open")
before { channel_1.update!(status: "closed") }
}.to change { channel_1.reload.status }.to("open").from("closed")
70.times { |n| fab!("message_#{n}") { Fabricate(:chat_message, chat_channel: channel) } }
move: {
{ notifications_settings: { muted: true } }
foo: 1,
it "raises a 404" do
fab!(:readonly_group_1) { Fabricate(:group) }
}.to(true).from(false)
}.to(false).from(true)
get "/chat/api/channels/#{channel_1.id}"
omission: "",
channel: {
fab!(:chatters_group) { Fabricate(:group) }
fab!(:user) { Fabricate(:user, last_seen_at: 15.minute.ago) }
put "/chat/api/channels/#{channel.id}",
name: "joffrey",
put "/chat/api/channels/#{channel.id}", params: { user_count: 40 }
put "/chat/api/channels/#{channel.id}", params: { channel: { slug: " " } }
it "raises a 403" do
slug: "cat-king",
put "/chat/api/channels/#{channel.id}", params: { channel: { name: "A new cat is born" } }
put "/chat/api/channels/#{channel.id}", params: { channel: { auto_join_users: true } }
put "/chat/api/channels/#{channel.id}", params: { channel: { auto_join_users: false } }
fab!(:another_user) { Fabricate(:user, last_seen_at: 15.minute.ago) }
archive: {
type: "new_topic",
{ archive: { type: "existing_topic", topic_id: Fabricate(:topic).id } }
post "/chat/api/channels/#{channel.id}/archives", params: { type: "new_topic" }
fab!(:thread) do
let(:attrs) { { name: "Test1", chat_channel_id: chat_channel1.id } }
post "/admin/plugins/chat/hooks.json", params: { name: "test1a" }
name: "test1a",
name: "update test",
emoji: ":slight_smile:",
{ mention_count: 0, unread_count: 1 },
{ mention_count: 1, unread_count: 0 },
{ mention_count: 0, unread_count: 0 },
fab!(:user_1) { Fabricate(:user, username: "Aline", name: "Boetie") }
fab!(:user_2) { Fabricate(:user, username: "Bertrand", name: "Arlan") }
user_1.id,
fab!(:channel_1) do
fab!(:upload) { Fabricate(:upload, user: user, created_at: 1.month.ago) }
fab!(:unused_upload) { Fabricate(:upload, user: user, created_at: 1.month.ago) }
in_reply_to_id: nil,
expect { Jobs::CleanUpUploads.new.execute({}) }.to change { Upload.count }.by(-1)
fab!(:draft_upload) { Fabricate(:upload, user: user, created_at: 1.month.ago) }
let!(:guardian) { Guardian.new(user) }
fab!(:user) { Fabricate(:user, active: true) }
fab!(:user_2) { Fabricate(:user, active: false) }
fab!(:user_3) { Fabricate(:user, staged: true) }
fab!(:user_4) { Fabricate(:user, suspended_till: 3.weeks.from_now) }
let(:chat_url) { "#{Discourse.base_url}/chat/c/-/#{chat_channel.id}" }
<a href="#{chat_url}">
<svg class="fa d-icon d-icon-hashtag svg-icon svg-string" xmlns="http://www.w3.org/2000/svg"><use href="#hashtag"></use></svg>
</span>
<img loading="lazy" alt="#{user.username}" width="30" height="30" src="#{user.avatar_template_url.gsub("{size}", "60")}" class="avatar">
expect(Oneboxer.preview("#{chat_url}/#{chat_message.id}")).to match_html <<~HTML
<img loading="lazy" alt="#{user.username}" width="20" height="20" src="#{user.avatar_template_url.gsub("{size}", "20")}" class="avatar">
<a href="#{chat_url}/#{chat_message.id}" title="#{chat_message.created_at}">#{chat_message.created_at}</a>
<a class="chat-transcript-channel" href="/chat/c/-/#{chat_channel.id}">
fab!(:user) { Fabricate(:user, last_seen_at: 15.minutes.ago) }
let(:user) { Fabricate(:user, last_seen_at: nil, first_seen_at: nil) }
in_reply_to = i.zero? ? nil : last_message.id
thread_id = i.zero? ? nil : last_message.thread_id
fab!(:user1) { Fabricate(:user, username: "chatdmfellow1") }
fab!(:user2) { Fabricate(:user, username: "chatdmuser") }
5.times.map.with_index { |i| Fabricate(:user, username: "chatdmuser#{i}") },
.sort_by(&:username)
.map { |u| "@#{u.username}" }
let(:user) { stub }
fab!(:message) { Fabricate(:chat_message, message: "hey friend, what's up?!") }
cooked = ChatMessage.cook("<h1>test</h1>")
expect(cooked).to eq("<p>&lt;h1&gt;test&lt;/h1&gt;</p>")
expect(cooked).to eq("<p>## heading 2</p>")
cooked = ChatMessage.cook("---")
expect(cooked).to eq("<p>---</p>")
expect(cooked).to eq("<p><code>test</code></p>")
expect(cooked).to eq("<pre><code>something = test\n</code></pre>")
expect(cooked).to eq("<blockquote>\n<p>a quote</p>\n</blockquote>")
<p>Mark me...this will go down in history.</p>
msg1 =
msg2 =
Originally sent in <a href="/chat/c/-/#{chat_channel.id}">testchannel</a>
<img loading="lazy" alt="" width="20" height="20" src="#{avatar_src}" class="avatar">
<a href="/chat/c/-/#{chat_channel.id}/#{msg1.id}" title="#{msg1.created_at.iso8601}"></a>
<img loading="lazy" alt="" width="20" height="20" src="#{avatar_src2}" class="avatar">
<span title="#{msg2.created_at.iso8601}"></span>
cooked = ChatMessage.cook("~~test~~")
expect(cooked).to eq("<p><s>test</s></p>")
cooked = ChatMessage.cook("**bold**")
expect(cooked).to eq("<p><strong>bold</strong></p>")
| --- | --- |
<th>Command</th>
<td>git status</td>
expect(cooked).to eq("<p><span class=\"mention\">@mention</span></p>")
gif =
<p>wow look it's a list</p>
<li>item 1</li>
<li>item 2</li>
<p><img src="/images/emoji/twitter/smiley.png?v=12" title=":smiley:" class="emoji only-emoji" alt=":smiley:" loading=\"lazy\" width=\"20\" height=\"20\"></p>
cooked = ChatMessage.cook("<h1>@#{user.username}</h1>")
expect(cooked).to eq("<p>&lt;h1&gt;@#{user.username}&lt;/h1&gt;</p>")
hey friend, what's up?!
fab!(:channel) { Fabricate(:chat_channel, user_count: 10) }
fab!(:upload_1) { Fabricate(:upload) }
fab!(:upload_2) { Fabricate(:upload) }
fab!(:message) { Fabricate(:chat_message) }
data: { value: "A" * (SiteSetting.max_chat_draft_length + 1) }.to_json,
it "uses a - instead" do
fab!(:chatable) { Fabricate(:category) }
let(:custom_name) { "a custom name" }
let(:custom_name) { nil }
before { channel.slug = nil }
expect(channel.slug).to eq("%E6%B5%8B%E8%AF%95")
channel.slug = "-"
expect(channel.slug).to eq("")
let(:parameter) { "present" }
let(:parameter) { nil }
fail!("step error")
fail!("error")
let(:result) { object.result }
let(:actions) { "proc {}" }
.new(Chat::Api) do
let(:actions) { <<-BLOCK }
on_success { :success }
on_failure { :fail }
->(*) do
on_model_not_found(:fake_model) { :no_model }
on_failure { :failure }
let(:acting_user) { Fabricate(:user) }
post.update!(raw: post.raw + "\n\n" + quote_markdown)
.order("created_at ASC, id ASC")
.last(3)
expect { move! }.to change { ChatThread.count }.by(1)
fab!(:chat_group) { Fabricate(:group) }
message = "this is a 21 char msg"
message = "10 char msg"
.filter { |m| m.channel == "/chat/new-channel" }
expect(messages.map { |m| m.dig(:data, :channel, :id) }).to eq(
before { user_1.update!(admin: true) }
}.to change { ChatChannel.count }.by(1)
let(:user1) { Fabricate(:user, username: "martinchat") }
let(:user2) { Fabricate(:user, username: "brucechat") }
message: "if i say so myself",
message: "yay!",
emoji: "+1",
emoji: "sob",
fab!(:frozen_time) { DateTime.parse("2022-07-08 09:30:00") }
fab!(:flagger) { Fabricate(:user) }
.map(&:data)
let(:flag_message) { "I just flagged your chat message..." }
expect(scores.all?(&:pending?)).to eq(true)
expect(scores.all?(&:agreed?)).to eq(true)
12.times do |i|
fab!("dm_message_#{i + 1}") do
message: "This is my message number #{i + 1}. Hello chat!",
@chat_group =
).tap(&:cook)
msg = build_cooked_msg(mention.gsub("@", ""), user_1)
let(:mention) { "hello @all!" }
let(:list_key) { :global_mentions }
let(:mention) { "hello @here!" }
let(:list_key) { :here_mentions }
msg = build_cooked_msg("hello @here @#{user_2.username}!", user_1)
msg = build_cooked_msg("Is @#{user_3.username} here? And @#{user_2.username}", user_1)
msg = build_cooked_msg("Hello @here and @#{user_2.username}", user_1)
msg = build_cooked_msg("Hello @all and @#{user_2.username}", user_1)
msg = build_cooked_msg("hey @#{user_2.username} stop muting me!", user_1)
msg = build_cooked_msg("hey @#{user_2.username} stop ignoring me!", user_1)
before { @chat_group.add(user_3) }
let(:mention) { "hello @#{group.name}!" }
let(:list_key) { group.name }
msg = build_cooked_msg("Hello @#{group.name} and @#{user_2.username}", user_1)
msg = build_cooked_msg("Hello @#{@chat_group.name} and @#{group.name}", user_1)
second_msg = build_cooked_msg("Hello @#{group.name} and @#{@chat_group.name}", user_1)
msg = build_cooked_msg("Hello @#{group.name}", user_1)
msg = build_cooked_msg("Hello @#{user_2.username} and @#{user_3.username}", user_1)
msg = build_cooked_msg("Hello @#{user_2.username} and @#{group.name}", user_1)
msg = build_cooked_msg("Hello @#{user_3.username}", user_1)
fab!(:reacting_user) { Fabricate(:user) }
subject.react!(message_id: message_1.id, react_action: :add, emoji: ":+1:")
reactor.react!(message_id: message_1.id, react_action: :foo, emoji: ":+1:")
reactor.react!(message_id: -999, react_action: :add, emoji: ":woohoo:")
emoji: ":#{emoji.name}:",
emoji: ":#{Emoji.all.last.name}:",
emoji: ":#{Emoji.all.first.name}:",
fab!(:channel_member_1) { Fabricate(:user) }
fab!(:channel_member_2) { Fabricate(:user) }
fab!(:channel_member_3) { Fabricate(:user) }
fab!(:not_a_channel_member) { Fabricate(:user) }
fab!(:guardian) { Guardian.new(user) }
ts_query = Search.ts_query(term: "good soup", ts_config: "simple")
slug: "random",
name: "Zany Things",
slug: "secret",
text: "Zany Things",
icon: "comment",
type: "channel",
ref: nil,
expect(result.to_h).to eq({})
fab!(:channel4) { Fabricate(:chat_channel, slug: "chat", messages_count: 435) }
fab!(:category) { Fabricate(:category, name: "support") }
fab!(:group_user) { Fabricate(:group_user, group: group, user: user1) }
let(:following) { false }
it "ensures offset is >= 0" do
it "ensures limit is > 0" do
let(:following) { true }
let(:topic_params) { { topic_title: "This will be a new topic", category_id: category.id } }
.each do |post|
expect(post.raw).to include("noLink=\"true\"")
if post.raw.include?(";#{reaction_message.id};")
.map(&:user)
.each do |user|
let(:topic_params) { { topic_id: topic.id } }
before { 3.times { Fabricate(:post, topic: topic) } }
.track_publish { run_job }
.filter { |m| m.channel == "/chat/notification-alert/#{user.id}" }
post_url: "/chat/c/#{public_channel.slug}/#{public_channel.id}/#{message.id}",
identifier: "@here",
identifier: "",
identifier: "@#{@chat_group.name}",
let(:user) { Fabricate(:user, last_seen_at: 15.minutes.ago) }
chatable_id: -1,
let!(:user) { Fabricate(:user, last_seen_at: 15.minutes.ago) }
message: "hi",
created_at: base_date - 10.days - 1.second,
created_at: base_date - 20.days - 1.second,
created_at: base_date - 30.days - 1.second,
fab!(:dm_days_old_0) do
fab!(:dm_days_old_10) do
fab!(:dm_days_old_20) do
fab!(:dm_days_old_30) do
@message_ids = messages.map(&:id)
).first,
expect { run_job }.not_to change { Topic.count }
<span title="2022-01-25T05:40:39Z"></span>
<p>This is a chat message.</p>
Originally sent in <a href="/chat/c/-/1234">Cool Cats Club</a>
<a href="/chat/c/-/1234/2321" title="2022-01-25T05:40:39Z"></a>
<img width="20" height="20" src="/images/emoji/twitter/+1.png?v=12" title="+1" loading="lazy" alt="+1" class="emoji"> 1</div>
<img width="20" height="20" src="/images/emoji/twitter/heart.png?v=12" title="heart" loading="lazy" alt="heart" class="emoji"> 2</div>
<p>This is a test</p>
body: "<html><head><title>Hyperlink - Wikipedia</title></head></html>",
post.update!(raw: <<~MD)
md_for_post =
<img loading="lazy" alt="" width="20" height="20" src="//test.localhost#{post.user.avatar_template.gsub("{size}", "40")}" class="avatar">
<a href="/chat/c/-/#{channel.id}/#{message1.id}" title="#{message1.created_at.iso8601}"></a>
<a class="chat-transcript-channel" href="/chat/c/-/#{channel.id}">
<a href="/chat/c/-/#{channel.id}/#{message2.id}" title="#{message1.created_at.iso8601}"></a>
<p>#{message2.message}</p>
api_key_id: key.id,
get "/latest.json", headers: { "Api-Key" => chat_api_key.key, "Api-Username" => admin.username }
post "/chat/#{chat_channel.id}.json",
post "/chat/#{chat_channel_2.id}.json",
sequence(:name) do |n|
status { :open }
name { sequence(:name) { |i| "#{i + 1}" } }
key { sequence(:key) { |i| "#{i + 1}" } }
new_message = "2 short"
new_message = "2 long" * 100
message = "ping @#{user2.username} @#{user3.username}"
message = "ping"
new_content: "ping @#{user3.username}",
new_content: "ping @#{user3.username} @#{user4.username}",
new_content: "ping @#{admin1.username}",
new_content: "ping @#{admin_group.name}",
new_content: "ping @#{admin_group.name} @#{admin2.username}",
old_message = "It's a thrsday!"
new_message = "It's a thursday!"
fab!(:upload1) { Fabricate(:upload, user: user1) }
fab!(:upload2) { Fabricate(:upload, user: user1) }
new_message = "hi :)"
content: "bad word - #{watched_word.word}",
content: "2 short",
}.to change { ChatMessage.count }.by(1)
content: "@all",
}.to change { ChatMention.count }.by(4)
content: "again! @all",
}.to change { ChatMention.count }.by(3)
content: "@here",
}.to change { ChatMention.count }.by(2)
content: "@here @#{user2.username}",
content: "@here plus @#{user3.username}",
content: "hi @#{user2.username} @#{user3.username}",
content: "hi @#{user2.username}",
content: "hello there @#{user_group.name}",
content: "hello @#{user4.username}",
content: "hello @#{user3.username}",
content: "hello @#{user2.username}",
content: "hi! @all",
}.to change { ChatThread.count }.by(1)
fab!(:old_message_1) do
fab!(:old_message_2) do
fab!(:old_message_3) do
content: "hello @#{admin_group.name}",
content: "hello @#{admin_group.name} @#{admin1.username} and @#{admin2.username}",
content: "hello @#{admin_group.name} @#{user2.username}",
}.by(1).and change { user2.chat_mentions.count }.by(1)
content: "hello @#{admin_group.name} @#{user_group.name}",
}.by(1).and change { user2.chat_mentions.count }.by(1).and change {
content: "Hi @#{user2.username}",
end.to change { ChatDraft.count }.by(-1)
job_enqueued?(job: :user_email, args: { type: "chat_summary", user_id: user_1.id }),
expect_job_enqueued(job: :user_email, args: { type: "chat_summary", user_id: user_1.id })
.where(user_id: user_1.id)
expect_job_enqueued(job: :user_email, args: { type: "chat_summary", user_id: user_2.id })
@onebox_template ||=
load File.expand_path("../app/models/deleted_chat_user.rb", __FILE__)
load File.expand_path("../app/models/chat_channel.rb", __FILE__)
load File.expand_path("../app/models/chat_draft.rb", __FILE__)
load File.expand_path("../app/models/chat_message.rb", __FILE__)
load File.expand_path("../app/models/chat_mention.rb", __FILE__)
load File.expand_path("../app/models/chat_thread.rb", __FILE__)
load File.expand_path("../app/models/chat_upload.rb", __FILE__)
load File.expand_path("../app/models/chat_webhook_event.rb", __FILE__)
load File.expand_path("../app/models/direct_message.rb", __FILE__)
load File.expand_path("../app/models/chat_view.rb", __FILE__)
load File.expand_path("../app/services/base.rb", __FILE__)
load File.expand_path("../lib/chat_channel_fetcher.rb", __FILE__)
load File.expand_path("../lib/chat_mailer.rb", __FILE__)
load File.expand_path("../lib/chat_message_creator.rb", __FILE__)
load File.expand_path("../lib/chat_message_updater.rb", __FILE__)
load File.expand_path("../lib/chat_message_rate_limiter.rb", __FILE__)
load File.expand_path("../lib/chat_message_reactor.rb", __FILE__)
load File.expand_path("../lib/chat_message_mentions.rb", __FILE__)
load File.expand_path("../lib/chat_notifier.rb", __FILE__)
load File.expand_path("../lib/chat_seeder.rb", __FILE__)
load File.expand_path("../lib/chat_statistics.rb", __FILE__)
load File.expand_path("../lib/message_mover.rb", __FILE__)
load File.expand_path("../lib/chat_review_queue.rb", __FILE__)
load File.expand_path("../lib/service_runner.rb", __FILE__)
load File.expand_path("../lib/steps_inspector.rb", __FILE__)
load File.expand_path("../app/jobs/service_job.rb", __FILE__)
load File.expand_path("../lib/discourse_dev/message.rb", __FILE__)
next if !chat_channel || !user
.limit(10)
{ url: url, title: title }
).exists? ||
scope.user.id != object.id && scope.can_chat? && Guardian.new(object).can_chat?
limit: 1,
.limit(20)
if user_option_field && old_value != new_value && !new_value.zero?
if name == :secure_uploads && old_value == false && new_value == true
on(:user_seen) do |user|
namespace :api, defaults: { format: :json } do
get "/channels" => "chat_channels#index"
:format => :json,
get "/mentions/groups" => "hints#check_group_mentions", :format => :json
get "/" => "chat#respond"
get "/browse" => "chat#respond"
get "/browse/all" => "chat#respond"
get "/browse/closed" => "chat#respond"
get "/browse/open" => "chat#respond"
get "/browse/archived" => "chat#respond"
get "/draft-channel" => "chat#respond"
post "/enable" => "chat#enable_chat"
post "/disable" => "chat#disable_chat"
get "/message/:message_id" => "chat#message_link"
put ":chat_channel_id/react/:message_id" => "chat#react"
delete "/:chat_channel_id/:message_id" => "chat#delete"
put "/:chat_channel_id/:message_id/rebake" => "chat#rebake"
post "/:chat_channel_id/:message_id/flag" => "chat#flag"
get "/lookup/:message_id" => "chat#lookup_message"
put "/:chat_channel_id/invite" => "chat#invite_users"
post "/drafts" => "chat#set_draft"
post "/:chat_channel_id" => "chat#create_message"
put "/flag" => "chat#flag"
get "/emojis" => "emojis#index"
base_c_route = "/c/:channel_title/:channel_id"
get base_c_route => "chat#respond", :as => "channel"
get "#{base_c_route}/:message_id" => "chat#respond"
get "#{base_c_route}/#{route}" => "chat#respond"
get "/channel/:channel_id", to: redirect("/chat/c/-/%{channel_id}")
get "#{base_c_route}/t/:thread_id" => "chat#respond"
redirect_base = "/chat/c/%{channel_title}/%{channel_id}"
get "#{base_channel_route}/#{route}", to: redirect("#{redirect_base}/#{route}")
mount ::Chat::Engine, at: "/chat"
:chat,
if Rails.env == "test"
val.present? && val != ""
!!(value == "" || ChatChannel.find_by(id: value.to_i)&.public_channel?)
@step = step
@steps = result.__steps__.map { Step.for(_1, result).steps }.flatten
.join("\n")
text = text.gsub("<!here>", "@here")
text = text.gsub("<!all>", "@all")
if match.include?("|")
title = title&.gsub(/<|>/, "")
link = link&.gsub(/<|>/, "")
text = text.gsub(match, "#{link}")
on_success: -> { result.success? },
on_failure: -> { result.failure? },
on_failed_policy: ->(name = "default") { failure_for?("result.policy.#{name}") },
on_failed_contract: ->(name = "default") { failure_for?("result.contract.#{name}") },
on_model_not_found: ->(name = "model") { failure_for?("result.model.#{name}") },
@actions = {}
-> { object.instance_eval(&block) },
query_args = {
SET deleted_at = NOW(), deleted_by_id = :deleted_by_id
message.user_id == @user.id && !@user.silenced?
@chat_email_frequencies ||= { never: 0, when_away: 1 }
@chat_header_indicator_preferences ||= { all_new: 0, dm_and_mentions: 1, never: 2 }
.where("chat_messages.created_at > ?", 1.week.ago)
.where(<<~SQL, user_id: user.id)
dm_users = dm_messages.sort_by(&:created_at).uniq { |m| m.user_id }.map(&:user)
count: total_count - 1,
elsif channels.size == 1 && dm_users.size == 0
elsif channels.size == 1 && dm_users.size == 1
count: dm_users.size - 1,
min_user_count: (-1.0 * 105.5 * sensitivity + 110.55).to_i,
min_message_length: (-1.0 * 22.2 * sensitivity + 32.22).to_i,
min_past_seconds: (55.55 * sensitivity + 4.5).to_i,
.between(from: 5, to: 10)
sql_params = {
user_ids: target_users.map(&:id),
DB.exec(<<~SQL, sql_params)
@no_link = no_link
if messages_or_ids.all? { |m| m.is_a?(Numeric) }
@messages ||=
@reactions ||= DB.query(<<~SQL, @messages.map(&:id))
:last_day => ChatMessage.where("created_at > ?", 1.days.ago).count,
:previous_30_days =>
:last_day => ChatChannel.where(status: :open).where("created_at > ?", 1.days.ago).count,
.where("created_at BETWEEN ? AND ?", 60.days.ago, 30.days.ago)
:last_day => ChatMessage.where("created_at > ?", 1.days.ago).distinct.count(:user_id),
.count(:user_id),
def execute(args = {})
create_args = {
.where("id < ?", chat_message.id)
.pluck(:id)
reviewable.reviewable_scores.any? { |rs| rs.user == flagger && rs.pending? }
reason: "edit",
reason: "new",
{}.tap do |to_notify|
@user.id,
.each do |key, user_ids|
instance = new(**opts)
@previous_cooked = (chat_message.cooked || "").dup
@size_cache = {}
@opts = {}
.where("last_seen_at > ?", 5.minutes.ago)
@visible_groups ||=
user:,
@in_reply_to_id = in_reply_to_id
in_reply_to_id: @in_reply_to_id,
WHERE id = #{@in_reply_to_id}
SET thread_id = #{thread.id}
DB.query(<<~SQL, grace_time: 3.days.ago)
AND (cm.deleted_at < :grace_time)
.where("users.last_seen_at < ?", 15.minutes.ago)
.where("c_msg.deleted_at IS NULL AND c_msg.user_id <> users.id")
.where("c_msg.created_at > ?", 1.week.ago)
.group("users.id, uccm.user_id")
params = { user_id: user.id, chat_channel_id: channel.id }
find_for_user(user) ||
dm_channel_sql = ""
dm_channel_sql = <<~SQL
.select(:id)
channels.select { |c| c.chatable_type == "Category" }.map(&:chatable),
unread_counts = DB.query_array(<<~SQL, channel_ids: channels.map(&:id), user_id: user_id).to_h
AND cm.user_id != :user_id
) { delete_message_batch(chat_messages.map(&:id)) }
pc = nil
if result == :failed || result == :failed_no_topic
archive_status: result != :success ? :failed : :success,
channels = DB.query(<<~SQL)
taken_slugs = {}
.tr("'", "")
.tr("_", "-")
.truncate(255, omission: "")
.squeeze("-")
.gsub(/\A-+|-+\z/, "")
channels.map { |channel| "(#{channel.id}, '#{PG::Connection.escape_string(channel.slug)}')" }
VALUES #{values_to_insert.join(",\n")}",
SET (chatable_type, chatable_id, name) = (
VALUES ('chat_allowed_groups', 20, '3', now(), now())
.where("chat_messages.id <= ?", message_id)
content = {
}.as_json,
cannot_see: cannot_chat_users.map { |u| { username: u.username, id: u.id } }.as_json,
without_membership.map { |u| { username: u.username, id: u.id } }.as_json,
def fail!(context = {})
def fail(context = {})
def merge(other_context = {})
def self.build(context = {})
self === context ? context : new(context)
def model(name = :model, step_name = :"fetch_#{name}")
steps << Step.new(name)
self.class.name.split("::").last.downcase.sub(/^(\w+)step$/, "\\1")
default_values = {}
:"#{name}_contract"
def call(context = {})
def call!(context = {})
last_ids = {
if id =
@chat_message_bus_last_ids ||=
meta_hash = {
!!(object&.moderator?)
!!(object&.admin?)
!!(object&.staff?)
.group_by(&:emoji)
@users_reactions ||=
if sym == :notify_user &&
scope.current_user == user || user.bot? ||
:slug,
AND (data::json->>'chat_channel_id')::bigint = :channel_id
query = query.where("users.username_lower ILIKE ?", "%#{username}%")
enum :join_mode, { manual: 0, automatic: 1 }
icon: "ban",
icon:,
usernames_formatted = users.sort_by(&:username).map { |u| "@#{u.username}" }
ids = {}
s.user_id = :user_id AND
statuses = {}
.query(sql, message_ids: @chat_messages.map(&:id), user_id: @user.id)
-> { order("chat_messages.created_at ASC, chat_messages.id ASC") },
enum :status, { open: 0, read_only: 1, closed: 2, archived: 3 }, scopes: false
-> {
-> { joins(:chat_channel).where(chat_channel: { chatable_type: "DirectMessage" }) }
scope :created_before, ->(date) { where("chat_messages.created_at < ?", date) }
(cooked.blank? && uploads.present?) ? "<p>#{uploads.first.original_filename}</p>" : cooked
.map(&:to_markdown)
.reject(&:empty?)
args = { chat_message_id: self.id }
def self.cook(message, opts = {})
mentions << { chat_message_id: self.id, user_id: user.id, created_at: now, updated_at: now }
-> { where(chat_channels: { chatable_type: "DirectMessage" }) },
length: {
).joins(
def title(_ = nil)
self.slug = Slug.for(self.title.strip, "")
self.slug = "" if duplicate_slug?
self.slug = Slug.for(slug, "", method: :encoded)
if reason == "new"
elsif reason == "edit"
.where(user_option: { chat_enabled: true })
.each do |user_id|
if @chat_message.nil? ||
post_url: "#{@chat_channel.relative_url}/#{@chat_message.id}",
.select(:id, "users.id AS query_user_id")
.where("last_seen_at > ?", 3.months.ago)
.where("cg.category_id = ?", channel.chatable_id)
query += <<~SQL
(last_seen_at > :last_seen_at) AND
instance_exec(&(block || proc {}))
proc {}
root: "channel",
if page_size > 50 ||
condition = direction == PAST ? "<" : ">"
messages = messages.where("id #{condition} ?", message_id.to_i)
messages = messages.order("created_at #{order}, id #{order}").limit(page_size).to_a
.where("created_at < ?", @message.created_at)
.where("created_at > ?", @message.created_at)
.map(&:name),
.where(groups: { id: Chat.allowed_group_ids })
like_filter = "%#{filter}%"
.group(1)
users.map(&:id),
meta: {
@channel ||=
@membership ||=
@archive_params ||=
.tap do |ca|
@topic_params ||= {
.group("groups.id", "groups.name")
value = Upload.get_from_url(value) || ""
if value.to_s == "true"
ids.each { |id| apply_setting(id) }
@fields << field
attr_reader :id, :label, :icon, :data, :extra_label
attrs = attrs || {}
def add_choice(id, opts = nil)
choice = Choice.new(id, opts || {})
step.emoji = "wave"
id: "title",
type: "text",
step.emoji = "hugs"
icon: "unlock",
id: "invite_only",
icon: "user-plus",
icon: "user-shield",
id: "chat_enabled",
icon: "bars",
step.emoji = "art"
id: "color_scheme",
id: "body_font",
id: "heading_font",
name = I18n.t("color_schemes.#{scheme_name.downcase.gsub(" ", "_")}_theme_name")
scheme ||=
raw.gsub!("<ins>#{old_value}</ins>", new_value) || raw.gsub!(old_value, new_value)
before_step = @steps.detect { |s| s.id == after }
step.index += 1 while (step = step.next)
@steps << step
if @steps.size == 1
@steps_with_fields ||= @steps.select(&:has_fields?)
step = @steps.find { |s| s.id == step_id.dasherize }
if @user&.id && User.first_login_admin_id == @user.id
if @params.blank? || (!@params.is_a?(Hash) && !@params.is_a?(ActionController::Parameters))
version_list = version_list.sort_by { |v, pin| Gem::Version.new(v) }.reverse
if matches.size == 1
translation_args = { words: CGI.escapeHTML(matches.join(", ")) }
!val.present? || (User.where(username: val).exists? && regex_match?(val))
uri.is_a?(URI::HTTP) && !uri.host.nil? && uri.host.include?(".")
rescue URI::Error => e
if (e.message =~ /URI must be ascii only/)
!upload.new_record? &&
max_size_kb =
dupes = dupes.where("id != ?", record.id) if record.persisted?
value.gsub!(/<!--(.*?)-->/, "") # strip HTML comments
value.gsub!(/:\w+(:\w+)?:/, "X") # replace emojis with a single character
value.gsub!(/\,{2,}/, ",") # replace multiple ,,, with ,
return true if val == "f"
return false if !val.include?("%{reply_key}")
val.sub(/\+?%{reply_key}/, "") != SiteSetting.notification_email
.all? do |regexp|
!val.present? || valid_regex?(val)
r = Regexp.new(val)
if @regex && !(val =~ @regex)
val.present? && regex_match?(val)
post.errors.add(:user_id, :blank, **options) if post.new_record? && post.user_id.nil?
elsif post.is_first_post? || (post.topic.present? && post.topic.posts_count == 0)
if (post.link_count == 0 && !post.has_oneboxes?) || private_message?(post)
if post.linked_hosts.keys.all? { |h| guardian.can_post_link?(host: h) }
) c
WHERE c.user_id = :user_id
if max_count == 0
@username = User.where("length(username) < ?", value).pick(:username)
@username = User.where("length(username) > ?", value).pick(:username)
unescaped_title.scan(/<img.+?class\s*=\s*'(emoji|emoji emoji-custom)'/).size >
value.present? && value.split("|").size == QUOTE_COUNT
!value.include?("*")
return false if val.to_i.to_s != val.to_s
val.exclude?("*") && val.exclude?("?")
val.blank? || Group.exists?(name: val)
@valid =
value == "f" ||
valid_types: allowed_types.join(", "),
@valid = value == "t" || !SiteSetting.unicode_usernames
return true if value == "f"
if Invite === record && attribute == :email
domains = setting.gsub(".", '\.')
regexp = Regexp.new("@(.+\\.)?(#{domains})$", true)
drop_from: "2.9.0",
hex_regex = /\A\h{6}\z/
value.split("|").all? { |c| c =~ hex_regex }
censored_words = regexps.map { |r| value.scan(r) }
censored_words.join(", ")
val = val.to_f
val < 1
val > 1
num = val.to_i
return false if num.to_s != val.to_s
val.split("|").all? { |v| validator.valid_value?(v) }
name =
i = 1
similar = "#{normalized}(0|1|2|3|4|5|6|7|8|9)+"
count = DB.query_single(<<~SQL, like: "#{normalized}%", similar: similar).first
if count > 0
count: count + 10,
username_lower = :name || n::varchar
offset = 0 if offset < 0
suffix = (i + offset).to_s
attempt = "#{truncate(name, max_length)}#{suffix}"
name = name.to_s.dup
name = ctx.eval("#{name.to_s.to_json}.toLowerCase()")
name.grapheme_clusters.map { |c| UsernameValidator.allowed_char?(c) ? c : "_" }.join
name << "1" * missing_char_count if missing_char_count > 0
@user_ids = user_ids.tap(&:compact!).tap(&:uniq!).tap(&:flatten!)
@primary_groups ||=
.each_with_object({}) do |user, hash|
@flair_groups ||=
@group_lookup ||=
.index_by(&:id)
).uniq
url, fragment = url.split("#", 2)
) if fragment&.include?("#")
url.present? &&
!!(url =~ Regexp.new("^#{Discourse.base_path}/(assets|plugins|images)/")) ||
cdn = "https:#{cdn}" if cdn && cdn =~ %r{\A//}
url.sub(/\Ahttp:/i, "")
drop_from: "3.0",
url = uri.to_s
if url.include?("?")
u.host = ::Addressable::IDNA.to_ascii(u.host) if u.host && !u.host.ascii_only?
u.to_s
u = URI.parse(url)
u.host = u.host.downcase if u.host && u.host != u.host.downcase
def initialize(upload, opts = {})
send("#{check}_check")
return true if Emoji.all.map(&:url).include?("#{uri.path}?#{uri.query}")
@upload_type == "composer"
@dry_run = dry_run
.css("img", "a")
.each do |media|
puts "#{post.full_url} #{orig_src}"
puts "#{post.full_url} #{url}"
puts "#{post.full_url} #{e.class}: #{e.message}"
attributes = { post: post, sha1: sha1 }
@paths ||=
Dir.glob(File.join(Discourse.store.tombstone_dir, "original", "**", "*.*")).concat(
Dir.glob(File.join(Discourse.store.upload_path, "original", "**", "*.*")),
if path =~ /#{sha1}/
@object_keys ||=
.map(&:key)
).map(&:key),
if key =~ /#{sha1}/
old_key = key
key = key.sub(tombstone_prefix, "")
tmp =
human_filesize = with_filesize ? " (#{@upload.human_filesize})" : ""
new_url = "/#{new_url}"
url: new_url,
dirname = pathname.dirname.to_s != "." ? "#{pathname.dirname}/" : ""
if filesize <= 0
@image_info =
is_image ||= @image_info && FileHelper.is_supported_image?("test.#{@image_info.type}")
if @image_info.type == :svg
elsif @image_info.type == :ico
if @upload && @upload.url.blank?
@upload = nil
expected_extension = ".#{image_type}".downcase.sub("jpeg", "jpg")
@upload.url = ""
if @image_info.type.to_s == "svg"
w, h =
.split(" ")
w, h = @image_info.size
@upload.width, @upload.height = w, h
File.open(@file.path) { |f| url = store.store_upload(f, @upload) }
:url,
@file.respond_to?(:close!) ? @file.close! : @file.close
elsif pixels == 0 && @image_info.type.to_s != "svg"
elsif max_image_pixels > 0 && pixels >= max_image_pixels * 2
File.extname(@filename).downcase.match?(/\.hei(f|c)\z/)
execute_convert(from, to, { debug: true })
def execute_convert(from, to, opts = {})
command << to
if @image_info.type == :png
max_image_size > 0 && filesize >= max_image_size && !animated?
return if filesize >= original_size || pixels == 0 || !should_downsize?
if max_image_pixels > 0 && pixels >= max_image_pixels
.css("use")
.each do |use_el|
if use_el.attr("href")
use_el.remove_attribute("href") unless use_el.attr("href").starts_with?("#")
return false if @file.path =~ /\.(gif|svg)\z/i
return pixels < 2_000_000 if @file.path =~ /\.png/i
@filesize || File.size?(@file.path).to_i
@image_info.size&.reduce(:*).to_i
@@svg_allowlist_xpath ||=
@animated ||=
elsif type == "gif" || type == "webp"
frames > 1
unread = 0 if unread < 0
logger.error "#{prefix}: #{message} (#{exc.class})\n#{exc.backtrace.join("\n")}"
BASE_URL = "https://api.twitter.com"
result = Rinku.auto_link(text, :all, 'target="_blank"').to_s
<div class='aspect-image-full-size' style='--aspect-ratio:#{width}/#{height};'>
width='#{width}'
height='#{height}'
<source src='#{url}' type="video/mp4">
format: "%n%u",
thousand: "K",
million: "M",
billion: "B",
.gsub(/(?:^|\s)@\w+/) do |match|
.gsub(/(?:^|\s)#\w+/) do |match|
request = Net::HTTP::Get.new(uri)
Net::HTTP.new(uri.host, uri.port).tap { |http| http.use_ssl = true }
def self.run(opts = {})
start_time = opts.fetch(:start_time) { Time.now }
.entries("#{Rails.root}/spec")
.map { |entry| "spec/#{entry}" }
group_opts = {}
.find_db_config("test")
.merge("database" => "discourse_test_1")
@messages << { type: "exit", process_id: process_id }
rand(2**16).to_s,
.join(" ")
@threads << Thread.new { @messages << { type: "error" } if wait_thr.value.exitstatus != 0 }
exited = 0
@failure_count += 1
@error = true
exited += 1
!@fail_fast.nil? && @failure_count >= @fail_fast
outputs.map! { |filename| filename == "-" ? STDOUT : File.open(filename, "w") }
when "p", "progress"
end_time - @start_time,
:seed,
@levels ||= Enum.new(:newuser, :basic, :member, :regular, :leader, start: 0)
(0..4)
(current_level || 0) >= level
@@filters ||= {}
.map do |(word, _)|
WHERE t.id = tu.topic_id AND tu.user_id = :user_id AND t.id IN (:topic_ids)
DB.exec(sql, user_id: @user.id, topic_ids: @topic_ids)
.where(id: @topic_ids)
.map { |topic| { topic_id: topic.id, user_id: @user.id, created_at: Time.zone.now } }
@changed_ids << t.id
@guardian ||= Guardian.new(@user)
@topics ||= Topic.where(id: @topic_ids)
(@preload ||= Set.new) << blk
@preload = nil if @preload.length == 0
:page,
wpcf =
@custom_filters ||= {}
@custom_filters || {}
def initialize(topic_or_topic_id, user = nil, options = {})
@message_bus_last_id = MessageBus.last_id("/topic/#{@topic.id}")
options.each { |key, value| self.instance_variable_set("@#{key}".to_sym, value) }
@chunk_size =
@limit ||= @chunk_size
@page = @page.to_i > 1 ? @page.to_i : calculate_page
if @posts && !@skip_custom_fields
path << ((@page > 1) ? "?page=#{@page}" : "")
@gaps ||=
@last_post ||= @posts.last
@page > 1 && posts.size > 0 ? @page - 1 : nil
@next_page ||=
@page + 1
if prev_page > 1
if @post_number > 1
title += " - "
title +=
title += " - #{@topic.category.name}"
@desired_post = posts.detect { |p| p.post_number == @post_number }
def summary(opts = {})
(excerpt || "").gsub(/\n/, " ").strip
def filter_posts(opts = {})
@posts.each do |p|
posts_before = (@limit.to_f / 4).floor
.where("posts.sort_order < ?", sort_order)
post_ids =
.where("posts.sort_order >= ?", sort_order)
post_ids +
min = @limit * (page - 1)
min = 1 if min == 0 && @exclude_first
def filter_best(max, opts = {})
.where("posts.post_number > 1")
@topic_user ||=
@bookmarks ||=
@post_counts_by_user ||=
posts_user_ids = Set.new(@posts.map(&:user_id))
r.target_id IN (:post_ids) AND
r.target_type = 'Post' AND
counts = {}
@pending_posts ||=
@actions_summary << {
count: 0,
@filtered_post_ids ||=
@mentioned_users ||=
@read_posts_set ||=
.where(topic_id: @topic.id, user_id: @user.id)
post_numbers.each { |pn| result << pn }
((posts_count - 1) / @limit) + 1
AND posts.topic_id = #{@topic.id.to_i}
WHERE posts.topic_id = #{@topic.id.to_i}
ORDER BY @(post_number - #{post_number.to_i})
posts.where("posts.user_id = ? OR post_type IN (?)", @user.id, visible_types)
@posts =
if @filter == "summary"
{ post_number: @replies_to_post_number.to_i, post_id: post_id },
post_ids = DB.query_single(<<~SQL, post_id: post.id, topic_id: post.topic_id)
AND p.topic_id = :topic_id
OR posts.id IN (:post_ids)
OR posts.id > :max_post_id",
{ post_ids: post_ids, max_post_id: post_ids.max },
.where("created_at > ?", 1.hour.ago)
{ "id" => @id, "options" => @options }
@subtypes ||= {}
@opts = opts || {}
since: "3.1.0.beta1",
drop_from: "3.2",
create_list(:private_messages, {}, list, &blk)
list = list.where(<<~SQL, user.id)
list = list.joins(<<~SQL)
ON gm.topic_id = topics.id AND gm.group_id = #{group.id.to_i}
list = list.where("gm.id IS NULL")
list = list.where("topics.user_id <> ?", user.id)
if type == :group
elsif type == :user
elsif type == :all
AND gm.group_id IN (#{group_ids.join(",")})
ON um.user_id = #{user.id.to_i}
ON um.user_id = #{user.id.to_i} AND um.topic_id = topics.id",
list.where(<<~SQL, user.id.to_i)
AND topics.user_id = ?
@group ||=
@group_with_messages_ids ||= {}
user.id.to_i,
result.where(<<~SQL, user_id: user.id.to_i, group_ids: group_ids)
result.joins(<<~SQL)
AND tau.user_id = #{user.id.to_i}
@validators ||=
zero_up_to_max_int = lambda { |x| int.call(x) && x.to_i.between?(0, PG_MAX_INT) }
array_or_string = lambda { |x| Array === x || String === x }
@valid_options ||=
def initialize(user = nil, options = {})
(list || Topic).joins(
AND gu.user_id = #{@user.id.to_i}
).where("gu.group_id IS NULL")
params = { unordered: true }
:high,
create_list(:posted) { |l| l.where("tu.posted") }
create_list(:bookmarks) { |l| l.where("tu.bookmarked") }
topics = topics.joins(:top_topic).where("top_topics.#{score_column} > 0")
topics.order(<<~SQL)
create_list(:group_topics, {}, list)
WHERE (c.id IN (#{tracked_category_ids_sql}))
unpinned_topics = topics.where("NOT ( #{pinned_clause} )")
if page == 0
offset = 0 if offset <= 0
def create_list(filter, options = {}, topics = nil)
user_ids << ft.user_id << ft.last_post_user_id << ft.featured_user_ids <<
def new_results(options = {})
if sort_dir == "DESC"
if sort_column == "op_likes"
result.order("topics.#{sort_column} #{sort_dir}")
if category_id == 0
).references("tu")
if tags_arg && tags_arg.size > 0
tags_arg =
tags_arg.map do |t|
if String === t
tags = tags_query.select(:id, :target_tag_id).map { |t| t.target_tag_id || t.id }.uniq
result = result.joins(:tags).where("tags.id in (?)", tags)
notification_level = ?)",
if (before = before.to_i) > 0
if (bumped_before = bumped_before.to_i) > 0
)",
category_id: category_id || -1,
def self.remove_muted_tags(list, user, opts = {})
.joins(:tag)
AND tt.topic_id = topics.id)",
AND #{DB.sql_fragment("ta2.user_id IN (?)", user_ids)}
AND #{DB.sql_fragment("tg2.group_id IN (?)", group_ids)}
ON gu.user_id = #{@user.id.to_i}
AND gu.group_id = _tg.group_id
WHERE #{DB.sql_fragment("gu.group_id IN (?)", group_ids)}
) tg ON topics.id = tg.topic_id
AND ta.user_id = #{@user.id.to_i}
max = (count * 1.3).to_i
list = list.where("topics.bumped_at >= ?", user_first_seen_at)
unread_at ||= max_age_date
unread_at = unread_at > max_age_date ? unread_at : max_age_date
results = results.where("topics.updated_at >= ?", unread_at)
diff_tags: @topic.tags.map(&:name),
@list = list
next if tau.user_id == -1 || tau.user_id == topic.user_id
topic_params = {
@category ||=
len = 0
.where("username_lower in (?)", names)
@added_users << user
len += 1
names = groups.split(",").flatten.map(&:downcase)
.where("lower(name) in (?)", names)
.each do |group|
BC1 = { "HH" => 6, "II" => 2461, "KH" => 406, "OH" => -1378 }
BP1 = { "BB" => 295, "OB" => 304, "OO" => -125, "UB" => 352 }
BP2 = { "BO" => 60, "OO" => -1762 }
UC1 = { "A" => 484, "K" => 93, "M" => 645, "O" => -505 }
UC2 = { "A" => 819, "H" => 1059, "I" => 409, "M" => 3987, "N" => 5775, "O" => 646 }
UC3 = { "A" => -1370, "I" => 2311 }
UC5 = { "H" => 313, "I" => -1238, "K" => -799, "M" => 539, "O" => -831 }
UC6 = { "H" => -506, "I" => -253, "K" => 87, "M" => 247, "O" => -387 }
UP1 = { "O" => -214 }
UP2 = { "B" => 69, "O" => 935 }
UP3 = { "B" => 189 }
UQ2 = { "BH" => 216, "BI" => 113, "OK" => 1759 }
p1 = "U"
p2 = "U"
p3 = "U"
4.upto(segments.size - 4) do |i|
p = "O"
if score > 0
word = ""
p = "B"
p1 = p2
p2 = p3
p3 = p
last_days_ago = -1
if idx != tuples.size - 1
next unless (idx % every) === 0
if (days_ago != last_days_ago)
hash.all? do |_key, value|
value.is_a?(String) || (value.is_a?(Hash) && self.check_contains_hashes(value))
.map do |key, value|
i.locale.to_s == @locale.to_s && i.translation_key.to_s == key.to_s
.tap do |engine|
root_files = Dir.glob("#{@temp_folder}/*")
FileUtils.mv(Dir.glob("#{@temp_folder}/*/*"), @temp_folder)
fullpath = "#{@temp_folder}/#{relative}"
Dir.glob("**/**", base: @temp_folder).reject { |f| File.directory?(File.join(@temp_folder, f)) }
execute "git", "cat-file", "-e", version
execute "git", "rev-parse", "--abbrev-ref", "--symbolic-full-name", "@{upstream}"
execute "git", "fetch", remote_name, "#{version}:#{version}"
execute "git", "reset", "--hard", version
commit_hash = execute("git", "rev-parse", "HEAD").strip
execute("git", "rev-list", "#{hash}..HEAD", "--count").strip
execute("git", "rev-parse", "HEAD").strip
Dir.glob("**/*", base: @temp_folder).reject { |f| File.directory?(File.join(@temp_folder, f)) }
first_clone_uri.path.gsub!(%r{/\z}, "")
first_clone_uri.path += "/info/refs"
redirected_uri.path.gsub!(%r{/info/refs\z}, "")
@uri = URI.parse(@url)
when "ssh"
def clone_args(url, config = {})
args << "clone"
args =
uri.to_s,
args = clone_args(@url)
File.write("#{ssh_folder}/id_rsa", @private_key)
if desc.is_a?(Hash)
def create_opts(default, type, raw_opts = {})
elsif (hash = value).is_a?(Hash)
def self.create(name, default, type, theme, opts = {})
@name = name.to_sym
i.name.to_s == @name.to_s && i.data_type.to_s == type.to_s
secondary_key += "_min" if has_min?
secondary_key += "_max" if has_max?
(min.is_a?(::Integer) || min.is_a?(::Float)) && min != -::Float::INFINITY
(max.is_a?(::Integer) || max.is_a?(::Float)) && max != ::Float::INFINITY
match = choices.find { |choice| choice == val || choice.to_s == val }
match || val
@theme_id = theme_id
{ "code" => "" }
{ "code" => raw_content }
@content = "console.error(#{message.to_json});\n"
root: "theme-#{@theme_id}/",
output: {
@output_tree.map { |filename, source| source }.join("")
(function() {
if ('require' in window) {
})();
filename.sub(/\.js\.es6\z/, ".js")
filename.sub(/\.raw\.hbs\z/, ".hbr")
filename.end_with?(".hbs") &&
prefix = <<~JS
js_filename = filename.sub(/\.hbs\z/, ".js")
js_contents += "throw new Error(#{message.to_json});"
js_contents = <<~JS
if extension == "js"
append_js_error filename, "#{e.message} (#{filename})"
module_name = "/#{module_name}" if !module_name.start_with?("/")
if ('define' in window) {
name = name.sub(/\.(raw|hbr)\z/, "")
source_for_comment = hbs_template.gsub("*/", '*\/').indent(4, " ")
name = "discourse/theme-#{@theme_id}/#{name.gsub(%r{\Adiscourse/}, "")}"
const themePrefix = (key) => `theme_translations.#{@theme_id}.${key}`;
@text = text.to_s.encode("UTF-8", invalid: :replace, undef: :replace, replace: "")
def self.body_sentinel(text, opts = {})
chars = @text.to_s.strip.split("")
@entropy ||= chars.pack("M*" * chars.size).gsub("\n", "").split("=").uniq.size
@text.gsub(symbols_regex, "").size > 0
@text != @text.mb_chars.upcase.to_s
def self.clean(text, opts = {})
text.scrub!("")
(text == upcase(text.mb_chars, opts))
first, rest = text.split(" ", 2)
text = +"#{capitalize(first.mb_chars, opts)}#{rest ? " " + rest : ""}"
text&.gsub(@@whitespaces_regexp, " ")
@port ||= find_free_port(11_000..11_900)
@thread =
port.to_s,
config = { port: port, host: "127.0.0.1", db: 0 }
success = instance.ping == "PONG"
if !success && (Time.now - start) >= 5
if path.size < 1
bin_path = "/usr/lib/postgresql/#{v}/bin"
if File.exist?("#{bin_path}/pg_ctl")
@pg_bin_path = bin_path
if !@pg_bin_path
@pg_bin_path = bin_path if File.exist?("#{bin_path}/pg_ctl")
@initdb_path = "#{pg_bin_path}/initdb" if @initdb_path.length == 0
@pg_port ||= find_free_port(11_000..11_900)
@pg_ctl_path = `which pg_ctl 2> /dev/null`.strip
@pg_ctl_path = "#{pg_bin_path}/pg_ctl" if @pg_ctl_path.length == 0
File.write(PG_CONF, conf + "\nport = #{pg_port}\nunix_socket_directories = '#{PG_SOCK_PATH}'")
sleep 0.1 while !`#{pg_ctl_path} -D '#{PG_TEMP_PATH}' status`.include?("server is running")
$stdout.reopen(File.new("/dev/null", "w"))
$stderr.reopen(File.new("/dev/null", "w"))
def create(type, params = {})
site_password: "",
FA_ICON_MAP = { "far fa-" => "far-", "fab fa-" => "fab-", "fas fa-" => "", "fa-" => "" }
.map { |plugin| File.dirname(plugin.path) }
.each { |path| plugin_paths << "#{path}/svg-icons/*.svg" }
{ filename: "#{File.basename(path, ".svg")}", sprite: File.read(path) }
.pluck(:upload_id, :theme_id)
custom_sprites << {
filename: "theme_#{theme_id}_#{upload_id}.svg",
get_set_cache("icons_#{Theme.transform_ids(theme_id).join(",")}") do
.new()
.delete_if { |i| i.blank? || i.include?("/") }
.map! { |i| process(i.dup) }
get_set_cache("version_#{Theme.transform_ids(theme_id).join(",")}") do
sprites << { filename: "#{File.basename(path, ".svg")}", sprite: File.read(path) }
@core_svgs ||=
symbols = {}
svg_filename = "#{File.basename(filename, ".svg")}"
.css("symbol")
.each do |sym|
-->
<svg xmlns='http://www.w3.org/2000/svg' style='display: none;'>
core_svgs.each { |icon_id, sym| svg_subset << sym if icons.include?(icon_id) }
svg_file =
sym.css("title").each(&:remove)
svg_subset << "</svg>"
get_set_cache("raw_svg_#{name}") do
symbol.name = "svg"
<svg class="fa d-icon svg-icon svg-node" aria-hidden="true">#{symbol}</svg>
icon_id = symbol.attr("id")
icon_id = icon_id.prepend("far-")
icon_id = icon_id.prepend("fab-")
site_setting_icons |= value.split("|") if key.to_s.include?("_icon") && String === value
get_set_cache("badge_icons") { Badge.pluck(:icon).uniq }
.each do |theme|
if key.to_s.include?("_icon") && String === value
theme_icon_settings |= value.split("|")
FA_ICON_MAP.each { |k, v| icon_name = icon_name.sub(k, v) }
temp.each do |r|
results << r
elsif @category_id && priority == :high
other_category_index = @results.index { |r| r.category_id != @category_id }
results.partition { |r| r.category_id == @category_id }
@default_paths << File.dirname(plugin.path).sub(Rails.root.to_s, "").sub(%r{\A/}, "")
listener_opts = { ignore: /xxxx/, only: /\.(css|scss)\z/ }
.glob("#{Rails.root}/plugins/*")
.map do |file|
paths.map! do |long|
if long.include?("#{plugin_path}/")
targets.push("#{plugin_name}_#{target.to_s}")
paths.each { |path| @queue.push path }
@themes_with_scss ||=
name = @target == :embedded_theme ? :embedded_scss : :scss
.where(id: @theme_ids)
def compile(opts = {})
rtl = @target.to_s =~ /_rtl\z/
rtl: rtl,
theme_id: theme&.id,
File.open(stylesheet_fullpath, "w") { |f| f.puts css }
scheme_string = theme&.color_scheme ? "_#{theme.color_scheme.id}" : ""
@digest ||=
theme.with_scss_load_paths { |p| yield p }
resolve_baked_field(@target.to_s.sub("_theme", ""), :scss)
timestamps = fields.concat(settings).map!(&:to_f).sort!.join(",")
digest_string += "-#{cdn_url}"
.map do |f|
@@lock = Mutex.new
cache.hash.keys.select { |k| k =~ /theme/ }.each { |k| cache.delete(k) }
cache.hash.keys.select { |k| k =~ /color_definitions/ }.each { |k| cache.delete(k) }
cache.hash.keys.select { |k| k =~ /#{targets.join("|")}/ }.each { |k| cache.delete(k) }
cache.hash.keys.select { |k| k =~ /#{plugin}/ }.each { |k| cache.delete(k) }
theme_string = theme_id ? "_theme#{theme_id}" : ""
targets +=
next if theme_id == -1
next if compiled.include?("#{target}_#{theme.id}")
compiled << "#{target}_#{theme.id}"
@cachebuster ||=
File.open(manifest_full_path, "w") { |f| f.print(cachebuster) }
globs << "#{path}/plugin.rb"
globs << "#{path}/assets/stylesheets/**/*.*css"
globs.flat_map { |g| Dir.glob(g) }.compact
list_files.map { |x| File.mtime(x) }.compact.max.to_i
hashes = list_files.sort.map { |x| Digest::SHA1.hexdigest("#{x}: #{File.read(x)}") }
@themes_cache = {}
data_theme_id = theme_id ? "data-theme-id=\"#{theme_id}\"" : ""
data_theme_name = theme_name ? "data-theme-name=\"#{CGI.escapeHTML(theme_name)}\"" : ""
theme_id = theme&.id
data = { target: target, new_href: href }
return false if media != "all"
css_class = media == "all" ? "light-scheme" : "dark-scheme"
@plugin_assets ||= {}
contents = +""
contents << <<~CSS if body_font.present?
:root {
contents << <<~CSS
.each { |c| contents << category_css(c) if c.uploaded_background&.url.present? }
contents << "\n\n// Color definitions from #{name}\n\n"
contents << "\n\n"
.each do |field|
contents << "\n\n// Color definitions from #{field.theme.name}\n\n"
return "@import \"wcag\";"
colors.each { |n, hex| contents << "$#{n}: ##{hex} !default; " }
if @theme && !@theme_id
@theme_id = @theme.id || -1
return "" if !@theme_id
attr = target == :embedded_theme ? :embedded_scss : :scss
target = target.to_s.gsub("_theme", "").to_sym
// Theme: #{field.theme.name}
// Target: #{field.target_name} #{field.name}
// Last Edited: #{field.updated_at}
@theme = (@theme_id && Theme.find(@theme_id)) || :nil unless @theme
@theme == :nil ? nil : @theme
@font-face {
src: #{src};
filename = "#{asset.to_s}.scss"
filename = "#{asset}.scss"
when "embed", "publish"
result = +""
result << "\n\n#{@message}" if @message.present?
@blk = blk if blk
@blk = nil
break if line.include?("\n")
Rails.logger.warn("Failed to handle connection #{e}:\n#{e.backtrace.join("\n")}")
slug =
(slug.blank? || slug_is_only_numbers?(slug)) ? default : slug
slug = (slug_is_only_numbers?(slug) ? "" : slug)
.gsub(/\A-+|-+\z/, "") # remove possible trailing and preceding dashes
yaml = load_yaml(@file)
if hash.is_a?(Hash)
os\ x
def validate_error(key, opts = {})
category_ids = category_ids.split("|").map(&:to_i).to_set
tag_names = new_val.split("|").to_set
return if new_val == "f"
return if new_val == "no"
return if new_val == "t"
return if new_val.split("|").none?(%r{/\z})
prefix&.chomp!("/")
@types ||=
string: 1,
time: 2,
float: 4,
bool: 5,
null: 6,
enum: 7,
list: 8,
url_list: 9,
regex: 13,
email: 14,
group: 19,
tag_list: 21,
color: 22,
@enums = {}
@static_types = {}
@choices = {}
@validators = {}
@types = {}
@allow_any = {}
@list_type = {}
@textareas = {}
@json_schemas = {}
def load_setting(name_arg, opts = {})
if type.to_sym == :list
value == true || value == "t" || value == "true"
result = { type: type.to_s }
if type == :enum
if (klass = enum_class(name))
val = (val == true || val == "t" || val == "true") ? "t" : "f"
val = val.to_i
val = val.is_a?(String) ? val : val.map(&:id).join("|")
val = val.is_a?(Integer) ? val : val.id
split = val.to_s.split("|")
name: diff.join(","),
@settings = {}
:"_#{old_setting}",
:"#{old_setting}",
self.public_send(override ? new_setting : "_#{old_setting}")
:"_#{old_setting}?",
:"#{old_setting}?",
self.public_send("#{override ? new_setting : "_" + old_setting}?")
:"_#{old_setting}=",
:"#{old_setting}=",
self.public_send("#{override ? new_setting : "_" + old_setting}=", val)
@defaults = {}
@defaults.each { |_, hash| hash.delete(name) }
has_key?(name.to_sym) || has_key?("#{name.to_s}?".to_sym) || name.to_sym == :default_locale
model ||= @model.new
@table_exists ||= {}
val = val.to_s
@mutex ||= Mutex.new
@containers ||= {}
@categories ||= {}
@previews ||= {}
@plugins ||= {}
def setting(name_arg, default = nil, opts = {})
unless val.nil? || (val == "")
.map do |name|
value = value.to_s if type == :upload
value = value.map(&:to_s).join("|") if type == :uploaded_image_list
.map do |s, v|
}.merge!(type_hash)
if !I18n.t("site_settings.placeholder.#{setting}", default: "").empty?
new_hash =
.map do |s|
.map do |url|
.join("|")
self.public_send("#{name}=", value, options)
self.public_send("#{name}=", value)
clean_name = name.to_s.sub("?", "").to_sym
if value != val
value = value.split("|").map(&:to_i)
self.public_send(clean_name).to_s.split("|").map(&:to_i)
host =
host ||=
URI.parse("http://#{url}")&.host
@default_uploads ||= {}
@uploads ||= {}
) && uploads.has_key?(name)
large_icon: {
favicon: {
width: 32,
get_set_cache("#{name}_url") do
icon ? full_cdn_url(icon.url) : ""
def call(ex, context = {})
fake_env = {}
context.each { |key, value| Logster.add_to_env(fake_env, key, value) }
text = "Job exception: #{ex}\n"
@dbs ||= Set.new
def pause!(value = "paused")
@dbs = Set.new
@dbs.each do |db|
sleep(Rails.env.test? ? 0.01 : TTL / 2)
def self.pause!(key = nil)
key ? @pauser.pause!(key) : @pauser.pause!
if sidekiq_paused?(msg) && !(Jobs::RunHeartbeat === worker)
.sort_by(&:created_at)
if !w || !h
ww, hh = ImageSizer.resize(w, h)
width: w,
height: h,
log "sha: #{original_upload.sha1} -> #{sha1}"
if post.raw.include?("#{Discourse.base_url.sub(%r{\Ahttps?://}i, "")}/t/")
log "#{Discourse.base_url}/p/#{post.id}"
puts " k"
%r{upload://#{upload_before.base62_sha1}(\.#{upload_before.extension})?}i,
.gsub!(
.map do |params|
title: I18n.t("tos_topic.title"),
topics << {
raw:,
return if topic_id > 0 || Topic.find_by(id: topic_id)
changes = { title: title, raw: raw }
if static_first_reply && (reply = first_reply(post)) && (!skip_changed || unchanged?(reply))
changes = { raw: first_reply_raw(title) }
color: "0088CC",
color: "808281",
color: "E45735",
staff: :full,
color: "25AAE2",
name:,
category_exists ? "#{name}#{SecureRandom.hex}" : name
category.slug = Slug.for(name, "")
@expiry ||= 1.hour.to_i
@expiry = val
if val == nil
challenge = {
user = User.find_by(id: id)
sso = get_sso(pl)
base_url =
:tags,
:term,
term:,
@term = term
@blurb_term = blurb_term || term
topics = @posts.map(&:topic)
opts = { term: @blurb_term, blurb_length: @blurb_length }
cooked.scan(Discourse::Utils::URI_REGEXP) { urls << $& }
case File.extname(URI(url).path || "")
if purpose != :topic
segments = segments.filter { |s| s.present? }
segmented_data << segments.join(" ")
data = segmented_data.join(" ")
data = data.filter { |s| s.present? }
data = data.join(" ")
data.gsub!(/\S+/) do |str|
str = uri.to_s
year = $1.to_i
month = $2 ? $3.to_i : 1
day = $4 ? $5.to_i : 1
return if day == 0 || month == 0 || day > 31 || month > 12
Time.zone.parse("#{year}-#{month}-#{day}")
delta += 12 if delta < 0
.order("id desc")
has_more ? offset : 0
@valid = true
term = term.to_s.dup
@term = Search.prepare_data(term, Topic === @search_context ? :topic : nil)
@results =
(@page - 1) * Search.per_filter
@term = ""
if @term =~ /\A\d+\z/
AND tau2.id != tau.id
).where("topic_tags.id IS NULL")
advanced_filter(/\Aposts_count:(\d+)\z/i) do |posts, match|
posts.where("topics.posts_count = ?", match.to_i)
advanced_filter(/\Amin_post_count:(\d+)\z/i) do |posts, match|
posts.where("topics.posts_count >= ?", match.to_i)
advanced_filter(/\Amin_posts:(\d+)\z/i) do |posts, match|
advanced_filter(/\Amax_posts:(\d+)\z/i) do |posts, match|
posts.where("topics.posts_count <= ?", match.to_i)
advanced_filter(/\Ain:first|^f\z/i) { |posts| posts.where("posts.post_number = 1") }
advanced_filter(/\Ain:wiki\z/i) { |posts, match| posts.where(wiki: true) }
advanced_filter(/\Abadge:(.*)\z/i) do |posts, match|
badge_id = Badge.where("name ilike ? OR id = ?", match, match.to_i).pick(:id)
posts.where("1 = 0")
pa.post_action_type_id = ? AND
advanced_filter(/\Ain:(likes)\z/i) do |posts, match|
posts.id IN (
advanced_filter(/\Acreated:@(.*)\z/i) do |posts, match|
advanced_filter(/\Acategory:(.+)\z/i) do |posts, match|
Category.where("slug ilike ? OR name ilike ? OR id = ?", match, match, match.to_i).pluck(:id)
.pick(:id)
.where("lower(slug) = ?", category_slug.downcase)
if (tag_id)
posts.where(<<~SQL, tag_id)
posts.where(<<~SQL, tag_group_id)
WHERE pd1.search_data @@ #{Search.ts_query(term: "##{match}")})
advanced_filter(/\Agroup:(.+)\z/i) do |posts, match|
.where("groups.name ILIKE ? OR (id = ? AND id > 0)", match, match.to_i)
advanced_filter(/\Agroup_messages:(.+)\z/i) do |posts, match|
group_id =
.where("name ilike ? OR (id = ? AND id > 0)", match, match.to_i)
advanced_filter(/\Auser:(.+)\z/i) do |posts, match|
.where("username_lower = ? OR id = ?", match.downcase, match.to_i)
posts.where("posts.user_id = ?", user_id)
advanced_filter(/\A\@(\S+)\z/i) do |posts, match|
user_id = @guardian.user&.id if !user_id && username == "me"
advanced_filter(/\Abefore:(.*)\z/i) do |posts, match|
posts.where("posts.created_at < ?", date)
advanced_filter(/\Aafter:(.*)\z/i) do |posts, match|
posts.where("posts.created_at > ?", date)
file_extensions = match.split(",").map(&:downcase)
advanced_filter(/\Amin_views:(\d+)\z/i) do |posts, match|
posts.where("topics.views >= ?", match.to_i)
advanced_filter(/\Amax_views:(\d+)\z/i) do |posts, match|
posts.where("topics.views <= ?", match.to_i)
modifier = positive ? "" : "NOT"
if match.include?("+")
tags = match.split("+")
HAVING to_tsvector(#{default_ts_config}, #{Search.wrap_unaccent("array_to_string(array_agg(lower(tags.name)), ' ')")}) @@ to_tsquery(#{default_ts_config}, #{Search.wrap_unaccent("?")})
tags.join("&"),
tags = match.split(",")
WHERE tt.tag_id = tags.id AND lower(tags.name) IN (?)
if word == "l"
@order = :latest
elsif word =~ /\Aorder:\w+\z/i
@order = word.downcase.gsub("order:", "").to_sym
elsif word =~ /\Ain:title\z/i || word == "t"
@in_title = true
elsif word =~ /\Atopic:(\d+)\z/i
topic_id = $1.to_i
if topic_id > 1
elsif word =~ /\Ain:all\z/i
elsif word =~ /\Ain:personal\z/i
elsif word =~ /\Ain:messages\z/i
elsif word =~ /\Ain:all-pms\z/i
elsif word =~ /\Agroup_messages:(.+)\z/i
elsif word =~ /\Apersonal_messages:(.+)\z/i
found ? nil : word
.where("user_search_data.search_data @@ #{ts_query("simple")}")
DB.query(<<~SQL, user_ids: users.pluck(:id), term: "%#{@original_term.downcase}%")
term: "%#{@term}%",
groups.each { |group| @results.add(group) }
.where("tag_search_data.search_data @@ #{ts_query}")
.order("name asc")
term_without_quote = $1 if @term =~ /"(.+)"/
term_without_quote = $1 if @term =~ /'(.+)'/
posts = posts.joins("JOIN users u ON u.id = posts.user_id")
weights = @in_title ? "A" : (SiteSetting.tagging_enabled ? "ABCD" : "ABD")
if block.arity == 1
if @guardian.is_admin? && !@search_all_pms
posts.where("posts.user_id = #{@search_context.id}")
posts.where("topics.id = ?", @search_context.id).order(
posts.where("tags.id = ?", @search_context.id)
if @order == :latest
elsif @order == :views
elsif @order == :likes
posts.order("MAX(#{data_ranking}) DESC")
escaped_term = wrap_unaccent("'#{escape_string(term)}'")
tsquery = "TO_TSQUERY(#{ts_config || default_ts_config}, #{escaped_term})"
tsquery = "REPLACE(#{tsquery}::text, '<->', '&')::tsquery"
tsquery = "REPLACE(#{tsquery}::text, '&', '#{escape_string(joiner)}')::tsquery" if joiner
PG::Connection.escape_string(term).gsub('\\', '\\\\\\')
@ts_query_cache ||= {}
term: @term,
min_id =
min_or_max = @order == :latest ? "max" : "min"
if @order == :likes
).group("topics.id")
if min_id > 0
low_set = query.dup.where("post_search_data.post_id < ?", min_id)
high_set = query.where("post_search_data.post_id >= ?", min_id)
{ default: wrap_rows(query) }
).order("row_number")
posts.each { |post| @results.add(post) }
) AS headline",
@actions ||= Enum.new(:block, :do_nothing, :allow_admin)
if arg.nil? || !self.class.actions.has_key?(arg.to_sym)
{ reply_count: 5, like_score: 15, incoming_link_count: 5, bookmark_count: 2, reads: 0.2 }
@weightings.each_key { |k| components << "COALESCE(posts.#{k}, 0) * :#{k}" }
components = components.join(" + ")
/*where*/
builder = DB.build <<~SQL
) Y ON Y.id = posts.id
x.max_score >= :score_required),
@async = !Rails.env.test?
@mutex.synchronize { @timeout = t }
@async = val
start_thread if !@thread&.alive? && !@paused
!@thread&.alive?
end if !@thread&.alive?
db, job, desc = @queue.deq(non_block)
if type == :upload
@type = "original"
@type = "optimized"
next if key.exclude?("#{type}/")
SET etag = #{table_name}.etag
).where("#{table_name}.etag IS NULL")
.select(:id, :url)
policy: {
Version: "2012-10-17",
Effect: "Allow",
ArnLike: {
db_files = {}
@files ||=
.map do |key|
key = key.sub("s3://#{bucket_name}/", "").sub("\n", "")
@tmp_directory ||=
@s3_helper.list(hive_path).each { |obj| objects << obj if obj.key.match?(/symlink\.txt\z/i) }
@inventory_id ||=
bucket_folder_path.present? ? "#{bucket_folder_path}-#{id}" : id
def upload(file, path, options = {})
etag =
s3_bucket.delete_objects({ delete: { objects: keys.map { |k| { key: k } }, quiet: true } })
folder, filename = source.split("/", 2)
filter = {}
rule = { id: id, status: "Enabled", expiration: { days: days }, filter: filter }
rules.delete_if { |r| r.id.gsub("_", "-") == id.gsub("_", "-") }
rules << rule
rules.map do |r|
r = r.to_h
def list(prefix = "", marker = nil)
tags.each { |k, v| tag_array << { key: k.to_s, value: v.to_s } }
tagging: {
opts = { region: obj.s3_region }
@s3_client ||= Aws::S3::Client.new(@s3_options)
{ upload_id: response.upload_id, key: key }
{ bucket: s3_bucket_name, key: key, expires_in: expires_in }.merge(opts),
@s3_bucket ||=
enabled? ? "rtl" : ""
def match?(env:)
return true if actions.include?("message_bus") && request.fullpath =~ %r{\A/message-bus/.*/poll}
parts = category_slug_with_id.split("/")
!parts.empty? && parts.last =~ /\A\d+\Z/ ? parts.pop : nil
/.+\.(sql\.gz|tar\.gz|tgz)/i
@status == :success
@content << Field.new(id, type)
@id = post.id
@id = meta_topic.id
args ||= {}
def has?(id)
@content.any? { |a| a.id.to_s == id.to_s }
@content.each { |i| yield i }
@icon = icon
def initialize(id, icon = nil, button_class = nil, label = nil)
bundle ||= add_bundle(id)
return nil if html =~ /<title>/ && html !~ %r{</title>}
doc = nil
title = doc.at("title")&.inner_text
if title == "YouTube" && html =~ /document\.title *= *"(.*)";/
title.gsub!(/\n/, " ")
title.gsub!(/ +/, " ")
if uri.host =~
/(^|\.)amazon\.(com|ca|co\.uk|es|fr|de|it|com\.au|com\.br|cn|in|co\.jp|com\.mx)\z/
return 300 if uri.host =~ /(^|\.)youtube\.com\z/ || uri.host =~ /(^|\.)youtu\.be\z/
return 50 if uri.host =~ /(^|\.)github\.com\z/
fd.get do |_response, chunk, uri|
return if name == "jobs/base"
return super(name.sub(%r{\Alib/}, "")) if name.start_with?("lib/")
values = redis.pipelined { |batch| keys.each { |key| batch.dump(key) } }
new(keys.zip(values).delete_if { |k, v| v.nil? })
@dump = dump
@dump.each { |key, value| batch.restore(key, 0, value) }
if user && user.new_user? && SiteSetting.has_setting?("rate_limit_new_user_#{limit_key}")
@performed ||= {}
if available_in <= 3
I18n.t("rate_limiter.hours", count: (available_in / 1.hour.to_i))
type_key = @type.tr("-", "_")
msg = I18n.t("rate_limiter.by_type.#{type_key}", time_left: time_left, default: "")
attr_reader :max, :secs, :user, :key, :error_code
.keys("GLOBAL::#{key_prefix}*")
staff_limit: { max: nil, secs: nil }
@key = build_key(type)
@max = max
@secs = secs
@secs - age_of_oldest(now)
if ((tonumber(redis.call("LLEN", key)) < max) or
redis.call("LPUSH", key, now)
redis.call("LTRIM", key, 0, max - 1)
redis.call("EXPIRE", key, secs * 2)
if ((@max || 0) <= 0) || rate_limiter_allowed?(now)
return @max if @user && @user.staff?
t0 = Time.now.to_i
arr.reject! { |a| (t0 - a.to_i) > @secs }
@max - arr.size
lua, lua_sha = nil
now - redis.lrange(prefixed_key, -1, -1).first.to_i
(redis.llen(prefixed_key) < @max) ||
(age_of_oldest(now) >= @secs)
!!(
def change_trust_level!(level, opts = {})
next_up = new_level + 1
key = "tl#{next_up}_met?"
def t(key, opts)
key = "js." + key
opts.each { |k, v| str.gsub!("{{#{k.to_s}}}", v.to_s) }
user.primary_group.try(:name) || ""
reverse_map = {}
elsif (!is_tag && tag = Tag.find_by(name: text)) ||
{ staff: User.where(id: user_id).where("moderator OR admin").exists? }
es6_name = "#{filename}.js.es6"
return es6_name if File.file?("#{root}#{es6_name}")
js_name = "#{filename}.js"
return js_name if File.file?("#{root}#{js_name}")
erb_name = "#{filename}.js.es6.erb"
return erb_name if File.file?("#{root}#{erb_name}")
erb_name = "#{filename}.js.erb"
source = File.read("#{root_path}#{filename}")
source = ERB.new(source).result(binding) if filename =~ /\.erb\z/
apply_es6_file(ctx, root_path, f.sub(root_path, "").sub(/\.js(.es6)?\z/, ""))
ctx.attach("rails.logger.info", proc { |err| Rails.logger.info(err.to_s) })
ctx.attach("rails.logger.warn", proc { |err| Rails.logger.warn(err.to_s) })
ctx.eval <<~JS
console = {
log: function(...args){ rails.logger.info(console.prefix + args.join(" ")); },
warn: function(...args){ rails.logger.warn(console.prefix + args.join(" ")); },
error: function(...args){ rails.logger.error(console.prefix + args.join(" ")); }
to_load << a if File.file?(a) && a =~ /discourse-markdown/
if f =~ %r{\A.+assets/javascripts/}
apply_es6_file(ctx, root, f.sub(root, "").sub(/\.js(\.es6)?\z/, ""))
@ctx = nil
def self.markdown(text, opts = {})
text = text || ""
custom_emoji = {}
buffer = +<<~JS
__optInput = {};
__paths = #{paths_json};
.map { |t| "'#{t}'" }
HashtagAutocompleteService.data_source_icons.map { |i| "'#{i}'" }.join(",")
buffer << "__textOptions = __buildOptions(__optInput);\n"
buffer << ("__pt = new __PrettyText(__textOptions);")
baked = context.eval("__pt.cook(#{text.inspect})")
protect { v8.eval(<<~JS) }
emojiSet: #{set},
def self.cook(text, opts = {})
scrubber = Loofah::Scrubber.new { |node| node.remove if node.name == "script" }
.css("code,pre")
.each do |code_tag|
formatted = "&lt;U+#{bidi.ord.to_s(16).upcase}&gt;"
if srcs.any? { |src| !src.match?(allowed_pattern) }
.css("a")
!uri.host.present? || uri.host == site_uri.host ||
uri.host.ends_with?(".#{site_uri.host}") ||
allowlist.any? { |u| uri.host == u || uri.host.ends_with?(".#{u}") }
doc.css("a.onebox > img").each { |img| img.parent.remove }
.each do |aside|
.each do |div|
.css(".mention, .mention-group")
.map do |e|
if (name = e.inner_text)
fragment.css("a").each { |a| a.replace(a.inner_html) }
.each do |link|
uri = URI(href)
vimeo_url = "https://vimeo.com/#{vimeo_id}"
iframe.replace Nokogiri::HTML5.fragment("<p><a href='#{vimeo_url}'>#{vimeo_url}</a></p>")
target = non_image_media ? a.parent : a
url = srcset.split(",").first
width = non_image_media ? nil : a.at_css("img").attr("width")
height = non_image_media ? nil : a.at_css("img").attr("height")
.each do |img|
srcset.split(",").first
width = 16
data_width = width ? "data-width=#{width}" : ""
data_height = height ? "data-height=#{height}" : ""
data_onebox_type = onebox_type ? "data-onebox-type='#{onebox_type}'" : ""
rval = nil
files.each { |file| ctx.load(app_root + file) }
element.name = "a"
mentions = {}
pattern += '(?:/|\z)' if !pattern.ends_with?("\/")
/\A(data:|#{patterns.join("|")})/
@user_ids = user_ids
@count = count || user_ids.count
data = {} if !data.is_a? Hash
data = { public: public }
@@configuration_blocks ||= {}
def can_view?(user_id: nil, group_ids: nil)
if result == 1
count ||= ids&.count
last_id = nil if last_id == -1
config_block ||=
to_cache =
message = {}
attempts ||= 0
local zlist_elem = tostring(user_id) .. " " .. tostring(client_id)
if new_count == 1 then
local val = redis.call('HINCRBY', hash_key, user_id, -1)
if val <= 0 then
if redis.call('EXISTS', mutex_key) > 0 then
message_bus_id = -1
if redis.call('SETNX', mutex_key, mutex_value) == 0 then
if (not has_mutex) and (tonumber(redis.call('HGET', hash_key, user_id)) == 1) then
redis.call('ZREM', zlist_key, v)
@changed = {}
@errored = true if !res
@diff ||= {}
@@tracked_topic_fields ||= {}
if category_id != 0 &&
diff_tags: ((tags - prev_tags) | (prev_tags - tags)),
def revise!(editor, fields, opts = {})
old_raw = @post.raw
SiteSetting.staff_edit_locks_post? && !@post.wiki? && @fields.has_key?("raw") &&
@editor.staff? && @editor != Discourse.system_user && !@post.user&.staff?
@editor.staff? ||
edited_by_another_user? || !grace_period_edit? || owner_changed? || force_new_version? ||
@diff_size ||=
ONPDiff.new(before, after).short_diff.sum { |str, type| type == :common ? 0 : str.size }
if @editor.staff? || (@editor.trust_level > 1)
if (original_raw.size - new_raw.size).abs > max_diff ||
@post.version += 1
if @post.post_number == 1
@post.self_edits += 1 if self_edit?
if prev_owner && new_owner && prev_owner != new_owner
@editor == @post.user
self_edit? && @post.hidden &&
if !@topic_changes.errored? && @fields.has_key?(f)
if old_value.to_s != new_value.to_s
@post.version -= 1
return if bypass_bump? || !is_last_post?
changed_tags = ((a + b) - (a & b)).map(&:presence).compact
!Post.where(topic_id: @topic.id).where("post_number > ?", @post.post_number).exists?
if html = doc.css("p").first&.inner_html&.strip
SET word_count = (
WHERE topics.id = :topic_id",
{ reload_topic: true }
merged_post_raw = post_content.join("\n\n")
.revise!(@user, changes) { posts.each { |p| PostDestroyer.new(@user, p).destroy } }
if @posts.map(&:topic_id).uniq.size != 1
if @posts.map(&:user_id).uniq.size != 1
@post, @user = post, user
def initialize(post, topic, new_topic, opts = {})
.where("hidden_at < ?", 30.days.ago)
AND pa.post_action_type_id IN (?)
def initialize(user, post, opts = {})
is_first_post = @post.is_first_post? && @topic
elsif @user.id == @post.user_id
if (post_is_reviewable? || Guardian.new(@user).can_moderate_topic?(@post.topic)) &&
elsif @user.staff? || @user.id == @post.user_id
if @user.id != @post.user_id
new_post_attrs = { user_deleted: false }
if @topic && @post.is_first_post? && permanent?
permanent? ? @post.destroy! : @post.trash!(@user)
if @post.topic && @post.is_first_post?
if @topic && @post.is_first_post?
permanent? ? @topic.destroy! : @topic.trash!(@user)
if @post.topic && @post.post_number == 1
{ raw: I18n.t(key) },
DB.exec(<<~SQL, updated_at: Time.now, id: @post.topic_id)
.where("topic_id = ? and id <> ?", @post.topic_id, @post.id)
public_post_actions.each { |pa| permanent? ? pa.destroy! : pa.trash!(@user) }
allowed_user = @user.human? && @user.staff?
.each do |ua|
user_id: ua.user_id,
if @post.id != @post.topic.category.latest_post_id &&
!(@post.is_first_post? && @post.topic_id == @post.topic.category.latest_topic_id)
if @post.is_first_post? && @post.topic && !@post.topic.private_message?
.where("post_number > 1")
@spam = false
str.gsub("\u0000", "")
@topic = nil
tu = TopicUser.find_by(user: @user, topic: @topic)
@spam = true
handle_spam if (@spam || @post)
Rails.env != "test" || @track_post_stats
post.post_number ||=
.select(:user_id, :post_type)
@draft_key ||= @topic ? @topic.draft_key : Draft::NEW_TOPIC
@opts,
user: @user,
domains: @post.linked_hosts.keys.join(", "),
elsif @post && errors.blank? && !skip_validations?
return unless @post && @post.errors.count == 0 && @topic && @topic.category_id
.where("group_id IN (SELECT group_id FROM group_users where user_id = ?)", @user.id)
.each do |group_id|
@post.topic_id = @topic.id
@post.topic = @topic
attrs = { updated_at: Time.now }
topic_id: @topic.try(:id),
@destroyed_by, @post, @post_action_type_id, @opts =
if name == :like
{ likes_count: @post.like_count, user_id: @destroyed_by.id },
@meta_post = nil
@reason = "queued_by_staff" if reason.nil? && @queue_for_review
if !post_can_act? || (@queue_for_review && !guardian.is_staff?)
post: @post,
if @post_action_name == :like
return if !@created_by.staff? && @post.user&.staff?
@post.hide!(
@targets_topic = !!(@post.topic.reload.posts_count != 1 if @flag_topic && @post.topic)
where_attrs = {
action_attrs = {
action_attrs.each { |attr, val| post_action.public_send("#{attr}=", val) }
link: "#{Discourse.base_url}#{@post.url}",
return if @post.user_id.to_i < 0
opts ||= {}
spec_file = spec_path + "/#{name}-#{version}"
spec_file += ".gemspec"
puts "Looked for: #{spec_file}"
exit(-1)
attribute = attribute.strip.gsub(/ /, "_").to_sym
@@emojis ||= {}
@@emojis = {}
@@translations = {}
@@translations ||= {}
def #{att}
@idx = 0
key_method = "key_#{key}"
base =
klass.public_send(:define_method, "include_#{attr}?") { plugin.enabled? }
drop_from: "2.6",
if !(size.kind_of?(Array) && size.length == 2)
method_name = "#{plugin.name}_#{klass.name}_#{callback}#{@idx}".underscore
@idx += 1
klass.validate(name, if: -> { plugin.enabled? })
filenames = good_paths.map { |f| File.basename(f) }
File.delete(auto_generated_path + "/#{p}")
DiscourseEvent.on(event_name) { |*args, **kwargs| block.call(*args, **kwargs) if enabled? }
raise <<~ERROR if file.end_with?(".hbs", ".handlebars")
full_path = File.dirname(path) << "/assets/" << file
color_schemes << { name: name, colors: colors }
css = styles.join("\n")
js = javascripts.join("\n")
js = "(function(){#{js}})();" if js.present?
%r{\A/*},
target = Rails.root.to_s + "/public/plugins/"
target << name.gsub(/\s/, "_")
handlebars_includes.each { |hb| contents << "require_asset('#{hb}')" }
javascript_includes.each { |js| contents << "require_asset('#{js}')" }
contents.insert(0, "<%")
contents << "%>"
provider.public_send("#{sym}=", opts.delete(sym)) if opts.has_key?(sym)
def gem(name, version, opts = {})
.map do |asset, opts|
next if opts == :admin
.each do |f|
f_str = f.to_s
elsif f_str.end_with?(".js.es6") || f_str.end_with?(".hbs") || f_str.end_with?(".hbr")
elsif f_str.end_with?(".js")
@directory_name ||= File.dirname(path).split("/").last
prefixed_scope_name = :"#{(name || directory_name).parameterize}:#{scope_name}"
{ prefixed_scope_name => matcher_parameters&.map { |m| RouteMatcher.new(**m) } },
if Array(format).include?("*")
drop_from: "2.7",
if method || route || format
def add_topic_static_page(page, options = {}, &blk)
{ name: plugin_stat_group_name, show_in_ui: show_in_ui, block: block },
@extra_js_file_path ||= "#{Plugin::Instance.js_path}/#{directory_name}_extra.js.erb"
msg = "Invalid locale! #{opts.inspect}"
File.open(path, "w") { |f| f.write(contents) }
filename = File.join(path, "#{locale}.js")
.find { |path| path.parent == plugins_directory }
if index == 0
messages << "#{line}: #{error} (#{error.class})"
messages << "\t#{index}: from #{line}"
markdown << quote_identifiers << "\n"
markdown << "\n" unless last_quote_level == 0 || current_line_blank
markdown << "\n"
@lines << line
match_data = line.text.match(/\A(?<indicators>>+)\s?(?<text>.*)/)
return unless line.text =~ /\A\s{0,3}```/
text.sub(/\A\s+/) do |s|
s.length > 1 ? "&nbsp;" * s.length : s
hoisted.each { |h, url| text.gsub!(url, h) }
hoisted.each { |h, url| text.gsub!(h, url) }
!!topic.pinned_at && !unpinned?(topic, topic_user)
u = prf(h, password, u)
Xorcist.xor!(ret, u)
@m, @n = a.size, b.size
if @reverse = @m > @n
@a, @b = @b, @a
@m, @n = @n, @m
@offset = @m + 1
@delta = @n - @m
size = @m + @n + 3
fp = Array.new(size, -1)
@path = Array.new(size, -1)
p = -1
p += 1
k = -p
while k <= @delta - 1
k += 1
k = @delta + p
while k >= @delta + 1
k -= 1
while r != -1
def snake(k, p, pp)
x = y - k
x += 1
y += 1
x, y = 1, 1
px, py = 0, 0
i = shortest_path.size - 1
while i >= 0
t = @reverse ? :delete : :add
py += 1
t = @reverse ? :add : :delete
px += 1
i -= 1
op_code = :add
j = i + 1
if j >= ses.size
i = j
k = j
j -= 1
num_before = j - i + 1
num_after = k - j
if num_after > 1
i2 = i + num_before - num_after
i = i2
k -= num_after - num_before
i = k
num_pairs = j - i + 1
VIDEO_REGEX = /\A\.(mov|mp4|webm|m4v|3gp|ogv|avi|mpeg|ogv)\z/i
hosts += SiteSetting.force_get_hosts.split("|").collect { |domain| "https://#{domain}" }
hosts +=
.collect { |domain| "https://www.#{domain}" }
@local_handlers ||= {}
uri = URI.parse(uri) if uri.is_a?(String)
.any? { |domain| uri.hostname.ends_with?(domain) }
onebox, _ = yield(url, element)
if parent&.node_name&.downcase == "p" &&
if before_idx < 0 && after_idx >= siblings.size
while index >= 0 && index < elements.size &&
index = index + step
{ preview: "", onebox: "" }
def self.onebox_raw(url, opts = {})
Rails.logger.info("Failed to onebox #{url} #{e} #{e.backtrace}")
def self.local_onebox(url, opts = {})
html = html.presence || "<a href='#{normalized_url}'>#{normalized_url}</a>"
{ onebox: html, preview: html }
<video #{additional_controls} width="100%" height="100%" controls="">
<source src='#{normalized_url}'>
<a href='#{normalized_url}'>
category.subcategories.collect { |sc| { name: sc.name, color: sc.color, url: sc.url } },
args = { link: url }
aside = doc.at("aside")
@template_cache ||= {}
default: {
force_get_and_ua: {
fd_options = {
@status = -1
status > 199 && status < 300
check if @status == -1
@status = 0
.each do |e|
if (height > 0)
ratio = (height.to_f / width.to_f)
@engine = @engine_class.new(@url)
@data = extract(doc)
get(:title, 80)
!title.nil? ? "title='#{title}'" : ""
secure_url = URI(get(:image))
.css("meta")
.each do |m|
key = $1.tr("-:", "_").to_sym
collection_name = "#{key}s".to_sym
get(:html, nil, false)
def get(attr, *args)
return value.map { |v| sanitize_value(v, *args) } if value.is_a?(Array)
value = get(attr, *args)
if body.length == 0
range_provided = !(from.nil? && to.nil?) #true if "from" or "to" provided in URL
if to === -1 && range_provided #case "from" exists but no valid "to". aka ONE_LINER
to = from
from = 1
a_lines.each do |l|
l = l.chomp("\n") # remove new line
l.gsub!(re, "")
lnum = (i.to_i + start)
data: line.gsub("\n", ""),
selected: (selected == lnum) ? true : false,
output_builder.push "#{lnum}: #{line}"
if @lang == "stl" && link.match?(%r{\Ahttps?://(www\.)?github\.com.*/blob/})
@model_file = @lang.dup
@raw = nil
@cr_results = cr
@data ||= {
lang: "lang-#{@lang}",
@uri = URI(url)
@ordered_engines ||=
Engine.engines.sort_by { |e| e.respond_to?(:priority) ? e.priority : 100 }
engine.iframe_origins.all? { |o| allowed_regexes.any? { |r| o =~ r } }
@md5 = Digest::MD5.new
@view = View.new(name, @record)
@template_name = "_layout"
return {} if hash.nil?
hash.inject({}) do |result, (key, value)|
new_key = key.is_a?(String) ? key.to_sym : key
) do |http|
redir_header = { "Cookie" => cookie.join("; ") }
unless code === 200
domain: "#{uri.scheme}://#{uri.host}",
ndx = 1
size = size.to_f
ndx = 7
value.respond_to?(:empty?) ? !!value.empty? : !value
url = url.dup
url.gsub!(" ", "%20")
url.gsub!("'", "&apos;")
url.gsub!('"', "&quot;")
@long_file_types = {
dot_spot = lower_name.rindex(".")
matches_regexp(%r{^https?://(?:www\.)?(?:m\.)?(?:youtube\.com|youtu\.be)/.+$})
embed_url = "https://www.youtube.com/embed/#{video_id}"
@embed_doc.xpath("//script").find { |tag| tag.to_s.include?("ytcfg.set") }.to_s
match = script_tag.to_s.match(/ytcfg\.set\((?<json>.*)\)/)
if video_id || list_id
src="https://www.youtube.com/embed/#{video_id}?#{embed_params}"
></iframe>
@video_title ||=
@video_id ||=
p = { "feature" => "oembed", "wmode" => "opaque" }
($1.to_i * 3600) + ($2.to_i * 60) + $3.to_i if string =~ /(\d+h)?(\d+m)?(\d+s?)?/
@params ||=
matches_regexp(%r{^https?://(www\.)?(m\.)?xkcd\.com/\d+})
@match ||= @url.match(%{xkcd\.com/(?<comic_id>\\d+)})
matches_regexp(%r{https?://(.+)?(wistia.com|wi.st)/(medias|embed)/.*})
extracted_url = oembed.html.match(/iframe\ src\=\"(.*?)\"/)
src="#{iframe_src}"
width="#{oembed.width}"
title="#{oembed.title}"
matches_regexp(%r{^https?://.*\.wikipedia\.(com|org)})
((next_sibling = cur_element.next_sibling).name =~ /p|text|div|ul/) ||
if (cur_element.name == "p" || cur_element.name == "ul") #we treat a list as we detect a p to avoid showing
text += " " unless cnt == 0
li_index = 1
.css("li")
.each do |li|
list_items.push "#{li_index}." + li.inner_text
li_index += 1
cnt += 1
raw.css("html body h1").inner_text +
(section_title_text ? " | " + section_title_text : ""), #if a section sub title exists add it to the main article title
img = raw.css(".image img")
if img && img.size > 0
img.each do |i|
if src !~ /Question_book/
matches_regexp(%r{^https?://commons\.wikimedia\.org/wiki/(File:.+)})
@match ||= @url.match(%r{^https?://commons\.wikimedia\.org/wiki/(?<name>File:.+)})
matches_regexp(%r{^https?://(www\.)?vimeo\.com/\d+(/\w+)?/?})
video_src = video_src.gsub("autoplay=1", "").chomp("?")
src="#{video_src}"
matches_regexp(%r{^(https?:)?//.*\.(mov|mp4|webm|ogv)(\?.*)?$}i)
<source src='#{escaped_url}'>
<a href='#{escaped_url}'>#{@url}</a>
src="#{typeform_src}"
width="100%"
query_params = CGI.parse(URI.parse(escaped_src).query || "")
escaped_src += "?" unless escaped_src.end_with?("?")
escaped_src += "&"
%r{^https?://(mobile\.|www\.)?twitter\.com/.+?/status(es)?/\d+(/(video|photo)/\d?+)?+(/?\?.*)?/?$},
{ "User-Agent" => "DiscourseBot/1.0" }
raw.present? ? super : ""
@match ||= @url.match(%r{twitter\.com/.+?/status(es)?/(?<id>\d+)})
date = DateTime.strptime(access(:created_at), "%a %b %d %H:%M:%S %z %Y")
offset = (user_offset >= 0 ? "+" : "-") + Time.at(user_offset.abs).gmtime.strftime("%H%M")
date.new_offset(offset).strftime("%-l:%M %p - %-d %b %Y")
access(:user, :name)
<iframe src="#{src}" width="100%" height="#{height}" frameborder="0" style="border:0"></iframe>
matches_regexp(%r{^https?://((?:m|www)\.)?tiktok\.com(?:/@(.+)\/video/|/v/)\d+(/\w+)?/?})
height = (323.0 / 576) * video_height
height: #{height}px;
matches_regexp(%r{^https?://store\.steampowered\.com/app/\d+})
<h3 style='color:#fff; margin:10px 0 10px 5px;'>#{og.title}</h3>
<img src='#{og.image}' style='float:left; max-width:184px; margin:5px 15px 0 5px'/>
<p>#{og.description}</p>
src='#{escaped_src}'
width='100%'
@@oembed_providers ||= {}
@raw = {}
twitter = {}
Onebox::Helpers.blank?(value) || value == "0 minutes"
if url =~ regexp
oembed_url = "#{endpoint}?url=#{url}"
@json_ld ||= Onebox::JsonLd.new(html_doc)
uri.host.split(".").length <= 3
@match ||= @url.match(@@matcher)
src = og.video_url.gsub("autostart=1", "")
src="#{src}"
width="#{og.video_width}"
matches_regexp(%r{https?://(.+)?simplecast.com/(episodes|s)/.*})
matches_regexp(%r{^https?://(replit\.com|repl\.it)/.+})
<img src="#{oembed.thumbnail_url}" style="max-width: #{oembed.width}px; max-height: #{oembed.height}px;" #{oembed.title_attr}>
matches_regexp(%r{^https?://(www\.)?reddit\.com})
<span class="video-icon"></span>
matches_regexp(%r{^https?://(?:(?:\w)+\.)?(www.ncbi.nlm.nih)\.gov(?:/)?/pubmed/\d+})
pre = doc.xpath("//pre")
@xml = Nokogiri.XML("<root>" + pre.text + "</root>")
initials = xml.css("Initials").map { |x| x.content }
last_names = xml.css("LastName").map { |x| x.content }
author_list = (initials.zip(last_names)).map { |i, l| i + " " + l }
author_list.join(", ")
.css("PubDate")
.map { |x| x.content }
.select { |s| !s.match(/^\s+$/) }
.map { |s| s.split }
.join(" ") # Reverse sort so month before year.
link: @url,
matches_regexp(%r{^(https?:)?//.*\.pdf(\?.*)?$}i)
raise "Unable to read pdf file: #{@url}"
matches_regexp(%r{^http?://pastebin\.com})
@data ||= { title: "pastebin.com", link: link, content: content, truncated?: truncated? }
@lines = response.split("\n")
when %r{/raw/}
when %r{/download/}
when %r{/embed/}
matches_regexp(%r{^https?://embed\.smartcontracts\.org/?.*})
matches_regexp(%r{^https?://www\.mixcloud\.com/})
<img src="#{oembed.image}">
<div class="video-icon"></div>
<h3><a href="#{oembed.url}" target="_blank" rel="nofollow ugc noopener">#{oembed.title}</a></h3>
<h4>#{oembed.author_name}</h4>
<img src="#{og.image_secure_url}" width="#{og.video_width}" height="#{og.video_height}">
src="#{og.video_secure_url}"
.scan(
@data ||=
link: clean_url.gsub("/#{oembed.author_name}/", "/") + "/embed",
title: "@#{oembed.author_name}",
if access_token != ""
matches_regexp(%r{^https?://(www\.)?imgur\.com})
<video width='#{og.video_width}' height='#{og.video_height}' #{og.title_attr} controls loop>
<source src='#{og.video_secure_url}' type='video/mp4'>
<source src='#{og.video_secure_url.gsub("mp4", "webm")}' type='video/webm'>
<a href='#{escaped_url}' target='_blank' rel='noopener'>
<img src='#{og.secure_image_url}' #{og.title_attr} height='#{og.image_height}' width='#{og.image_width}'>
<a href='#{escaped_url}' target='_blank' rel='noopener' class="onebox">
<img src='#{og.secure_image_url.chomp("?fb")}' #{og.title_attr} alt='Imgur'>
matches_regexp(%r{^(https?:)?//.+\.(png|jpg|jpeg|gif|bmp|tif|tiff)(\?.*)?$}i)
<a href="#{escaped_url}" target="_blank" rel="noopener" class="onebox">
<img src="#{escaped_url}">
REGEX = %r{^https?://news\.ycombinator\.com/item\?id=(?<item_id>\d+)}
@match ||= @url.match(REGEX)
matches_regexp(%r{^https?://play\.(?:(?:\w)+\.)?(google)\.com(?:/)?/store/apps/})
price: price == "0" ? "Free" : price,
matches_regexp(%r{^https?://(photos)\.(app\.goo\.gl|google\.com)})
<h3><a href="#{escaped_url}" target="_blank" rel="nofollow ugc noopener">#{og.title}</a></h3>
<img src="#{og.secure_image_url}" class="scale-image"/>
<img src='#{og.secure_image_url}' #{og.title_attr} alt='Google Photos' height='#{og.image_height}' width='#{og.image_width}'>
matches_regexp :short, %r{^(https?:)?//goo\.gl/maps/}
%r"^(?:https?:)?//www\.google(?:\.(?:\w{2,}))+/maps/d/(?:edit|viewer|embed)\?mid=.+$"
matches_regexp :standard, %r"^(?:https?:)?//www\.google(?:\.(?:\w{2,}))+/maps"
matches_regexp :canonical, %r"^(?:https?:)?//maps\.google(?:\.(?:\w{2,}))+/maps\?"
{ link: url, title: url }
if type == :short
if type == :standard
while (retry_count -= 1) > 0
url = "https://maps.google.com/maps?ll=#{location}&z=#{zoom}&output=embed&dg=ntvb"
url += "&cid=#{($1 + $2).to_i(16)}" if @url.match(/!3m1!1s0x(\h{16}):0x(\h{16})/)
url = @url.dup
@url = rewrite_custom_url(url, "embed")
if !query.has_key?("ll")
if !query.has_key?("z")
unless query.has_key?("spn") || query.has_key?("sspn")
if !query.has_key?("spn")
zoom = (Math.log(690.0 * 360.0 / angle / 256.0) / Math.log(2)).round
@url = @url.sub("output=classic", "output=embed")
uri.path = uri.path.sub(%r{(?<=^/maps/d/)\w+$}, target)
http =
use_ssl: uri.scheme == "https",
@uri = URI(@url)
title = og_data.title || "Google Drive"
title: og_data.title || "Google #{short_type.to_s.capitalize}",
url = @url.split("&").first
%r{^https?://(www\.)?gitlab\.com.*/blob/}
Sanitize.fragment(Onebox::Helpers.uri_unencode(link).sub(%r{^https?\://gitlab\.com/}, ""))
matches_regexp(%r{^https?://(?:www\.)?(?:(?:\w)+\.)?(github)\.com(?:/)?(?:.)*/pull})
@match ||=
if commit_match = link.match(%r{commits/(\h+)})
if comment_match = link.match(/#issuecomment-(\d+)/)
if review_match = link.match(/#discussion_r(\d+)/)
m = match
created_at: created_at.strftime("%I:%M%p - %d %b %y %Z"),
closed_at: closed_at&.strftime("%I:%M%p - %d %b %y %Z"),
closed_at_date: closed_at&.strftime("%F"),
closed_at_time: closed_at&.strftime("%T"),
matches_regexp(%r{^http(?:s)?://gist\.(?:(?:\w)+\.)?(github)\.com(?:/)?})
@raw ||= raw.clone
@json = json
if html_doc.css(".Box.md, .Box.rdoc").present?
title = "#{title} - #{subtitle}" if subtitle
link: url,
desc_end = " - #{title}"
matches_regexp(%r{^https?://(?:www\.)?(?:(?:\w)+\.)?(github)\.com(?:/)?(?:.)*/commit/})
@match =
%r{^https?://(www\.)?github\.com.*/blob/}
Sanitize.fragment(Onebox::Helpers.uri_unencode(link).sub(%r{^https?\://github\.com/}, ""))
if type == :actions_run
elsif type == :pr_run
return if defined?(@match) && defined?(@type)
if match =
@type = :actions_run
@type = :pr_run
pr_url =
:link => @url,
:title => title,
status => true,
matches_regexp(%r{^https?://gfycat\.com/})
@match ||= @url.match(%r{^https?://gfycat\.com/(gifs/detail/)?(?<name>.+)})
@og_data = {}
url: @url,
.map { |keyword| "<a href='https://gfycat.com/gifs/search/#{keyword}'>##{keyword}</a>" }
matches_regexp(%r{^https?://flic\.kr/p/})
matches_regexp(%r{^https?://www\.flickr\.com/photos/})
return album_html(og) if og.url =~ %r{/sets/}
<img src='#{og.secure_image_url}' #{og.title_attr} alt='Imgur' height='#{og.image_height}' width='#{og.image_width}'>
matches_regexp(%r{^https?://500px\.com/photo/\d+/})
matches_regexp(%r{^https?://.*\.facebook\.com/(\w+)/(videos|\?).*})
matches_regexp(%r{/t/.*(/\d+)?})
article_published_time_title: published_time.strftime("%I:%M%p - %d %B %Y"),
matches_regexp(%r{^https?://coub\.com/view/})
matches_regexp(%r{^https?://cl\.ly})
<a href='#{og.url}' target='_blank' rel='noopener'>
direct_src = ::Onebox::Helpers.normalize_url_for_output("#{og.get(:url)}/#{og.title}")
<source src='#{direct_src}' type='video/mp4'>
<a href='#{og.url}' target='_blank' class='onebox' rel='noopener'>
<img src='#{og.image}' #{og.title_attr} alt='CloudApp' width='480'>
matches_regexp(%r{^https?://.*\.bandcamp\.com/(album|track)/})
src="#{escaped_src}"
matches_regexp(%r{^https?://audioboom\.com/posts/\d+})
matches_regexp(%r{^(https?:)?//.*\.(mp3|ogg|opus|wav|m4a)(\?.*)?$}i)
<source src="#{escaped_url}">
<a href="#{escaped_url}">#{@url}</a>
matches_regexp(%r{^https?://.*(giphy\.com|gph\.is|tenor\.com)/})
@raw ||= nil
if !@raw && has_cached_body
return "https://www.amazon.#{tld}/dp/#{id}"
@verified_data ||=
if (main_image = raw.css("#main-image")) && main_image.any?
raw.xpath(authors_xpath).map { |a| a.inner_text.strip }.join(", ")
og = ::Onebox::OpenGraph.new(raw)
title = raw.at("h1#title")&.inner_text
raw.at("#byline")&.inner_text
if /^\d(\-?\d){12}$/.match(isbn)
image: og.image || image,
rating: "#{rating}#{", " if rating && (!isbn&.empty? || !price&.empty?)}",
isbn_asin_text: "ISBN",
published: "#{published}#{", " if published && !price&.empty?}",
(raw.at("#byline")&.inner_text&.strip || raw.at("#bylineInfo")&.inner_text&.strip)
raw.at("#cmrsArcLink .a-icon")&.inner_text ||
rating: "#{rating}#{", " if rating && (!asin&.empty? || !price&.empty?)}",
isbn_asin_text: "ASIN",
result = { link: url, title: title, image: og.image || image, price: price }
!!list.find { |h| /(^|\.)#{Regexp.escape(h)}$/.match(uri.host) }
if other.is_a?(URI)
).nil?
d = { link: link }.merge(raw)
d.each do |k, v|
if v == nil || v == ""
html = html.gsub("http://", "https://")
has_title? && has_image?
(has_text? || is_image_article?)
<iframe src="#{escaped_url}"
</iframe>
<source src='#{escaped_video_src}'>
constants.select { |constant| constant.to_s =~ /Onebox\z/ }.sort.map(&method(:const_get))
if origin.start_with?("*.", "https://*.", "http://*.")
escaped_origin = escaped_origin.sub("\\*", '\S*')
Regexp.new("\\A#{escaped_origin}", "i")
class_name = self.class.name.split("::").last.to_s
@uri.scheme = "https"
@url = @uri.to_s
!!(other.to_s =~ class_variable_get(:@@matcher_content_type))
!!(other.to_s =~ class_variable_get(:@@matcher))
name.split("::").last.downcase.gsub(/onebox/, "")
@https = true
defined?(@https) ? @https : false
&.split("|")
.any? { |blocked| hostname == blocked || hostname.end_with?(".#{blocked}") }
max_download_kb: (10 * 1024), # 10MB
@all_levels ||=
muted: 0,
@topic_levels ||=
is_first_post?(manager) &&
@args = args.delete_if { |_, v| v.nil? }
if !self.class.exempt_user?(@user) &&
user_agent =~ /Mobile/ && !(user_agent =~ /iPad/)
ON #{table_name}
@@enable_safe = true
if direction == :up && version &&
@@enable_safe != false && !is_post_deploy_migration?
:up
frame =~ /safe_migrate\.rb/ || frame =~ /schema_migration_details\.rb/
def exec(*args, &blk)
if sql =~ /\A\s*(?:drop\s+table|alter\s+table.*rename\s+to)\s+/i
$stdout.puts("", <<~TEXT)
SQL used was: '#{sql}'
elsif sql =~ /\A\s*alter\s+table.*(?:rename|drop)\s+/i
DB.exec(<<~SQL).to_s == "1"
etag = etag.gsub "\"", ""
@@ip_skipper = nil
@@ip_skipper = blk
if status >= 500
track_view = status == 200
track_view &&= env_track_view != "0" && env_track_view != "false"
track_view &&=
is_api: is_api,
if queue_start.start_with?("t=")
queue_time = (Time.now.to_f - queue_start)
info = nil
Error code: #{error_code}.
ip = IPAddr.new(ip)
!!(ip && (ip.private? || ip.loopback?))
warn =
return if !block && !warn
ip_or_id = ip
error_code: limit_on_id ? "id_10_secs_limit" : "ip_10_secs_limit",
error_code: limit_on_id ? "id_60_secs_limit" : "ip_60_secs_limit",
error_code: limit_on_id ? "id_assets_10_secs_limit" : "ip_assets_10_secs_limit",
type = 10
type = 60
{ "Cache-Control" => "private, max-age=0, must-revalidate" },
e,
@@cache_key_segments ||= {
m: "key_is_mobile?",
c: "key_is_crawler?",
o: "key_is_old_browser?",
b: "key_has_brotli?",
t: "key_cache_theme_ids",
l: "key_locale",
method << "|#{k}=#\{h.#{v}}"
method << "\"\nend"
@request = request || Rack::Request.new(@env)
@request.get? && !@request.xhr? && !@request.path.ends_with?("robots.txt") &&
!@request.path.ends_with?("srv/status") &&
@is_mobile = val ? :true : :false
@is_mobile ||=
@is_mobile == :true
@has_brotli ||=
@has_brotli == :true
@is_crawler ||=
@is_crawler == :true
@cache_key =
theme_ids.join(",")
id = ids&.split(",")&.map(&:to_i)&.first
@cache_key_count ||= "#{cache_key}_count"
@cache_key_body ||= "#{cache_key}_body"
@cache_key_other || "#{cache_key}_other"
!!(!has_auth_cookie? && get? && no_cache_bypass)
def cached(env = {})
def cache(result, env = {})
response.each { |part| parts << part }
if max_time > 0 && queue_time.to_f > max_time
{ "content-type" => "application/json; charset=utf-8" },
wait_seconds: 5 + (5 * rand).round(2),
def #{method_name}(*args, &blk)
STDERR.puts "debugsql (sql): " + query
STDERR.puts "debugsql (sec): " + duration.round(3).to_s
start = data.delete(:__start)
:sql,
@host_info = {}
@my_id ||= "#{Discourse.os_hostname}-#{Process.pid}"
@mem_total ||=
if system == "Darwin"
s = `sysctl -n hw.memsize`.strip
s.to_i / 1.kilobyte
@base_url = base_url
@index = 1
@markdown_links = {}
@rendered = 1
dir = "#{cache_path}/#{identity.letter}/#{identity.color.join("_")}"
File.expand_path "#{dir}/#{size}.png"
xc:#{to_rgb(color)}
r, g, b = color
.each do |path|
return { errors: obj.map(&:to_s) } if obj.is_a?(Array) && obj.present?
translations = { locale_str => { "js" => {}, "admin_js" => {}, "wizard_js" => {} } }
new_hash.delete(key) if checking_hashes.any? { |h| h.include?(key) }
@loaded_merges ||= {}
.map(&:to_s)
if locale_sym == :en
result << "I18n.locale = '#{locale_str}';\n"
result << "I18n.fallbackLocale = '#{fallback_locale_str}';\n"
if mf_locale != "en"
all_overrides = {}
result = +"I18n._overrides = {};"
if key.end_with?("_MF")
message_formats << "#{key.inspect}: #{compiled_js}"
result << "I18n._mfOverrides = {#{message_formats.join(", ")}};"
output = +"if (!I18n.extras) { I18n.extras = {}; }"
locales.each { |l| output << <<~JS }
locale.tr("_", "-").downcase
locale_chain.map!(&:to_s)
format = I18n.t("dates.#{name}")
filename && File.exist?(filename) ? File.read(filename) << "\n" : ""
.map { |k, v| k.inspect << " : " << compile_message_format(filename, locale, v) }
result = +"MessageFormat = {locale: {}};\n"
result << "I18n._compiledMFs = {#{formats}};\n"
result << File.read(filename) << "\n"
if locale != "en"
result << File.read(en_filename) << "\n"
@ctx ||=
ctx.eval("mf = new MessageFormat('#{locale}');")
message = +"Invalid Format: " << e.message
message_formats = {}
def self.strip_out_message_formats!(hash, prefix = "", message_formats = {})
elsif key.to_s.end_with?("_MF")
prefix.blank? ? key : "#{prefix}.#{key}"
@urls = urls
if uri.present? && uri.hostname.present? &&
onebox = { url: url, title: title }
@users.each do |u|
user_ids = g.delete(:user_ids)
.where("name = 'import_id' AND value IN (?)", import_ids)
id = cat_attrs.delete(:id)
import_id = "#{id}#{import_source}"
puts "Importing topics...", ""
@topics.each do |t|
next if i == 0
ucf =
.where(name: "import_id", value: "#{external_category_id}#{import_source}")
@levels ||=
levels = {}
puts "Exporting all user groups...", ""
puts "Exporting all the categories...", ""
data << attrs
x =
data << x
File.join("#{default_filename_prefix}-#{Time.now.strftime("%Y-%m-%d-%H%M%S")}.json")
File.open(output_basename, "w:UTF-8") { |f| f.write(@export_data.to_json) }
File.open(filename, "r:UTF-8") { |f| JSON.parse(f.read) },
code.gsub(%r{<pre>\s*<code>\n?(.*?)\n?</code>\s*</pre>}m) do
def initialize(group, opts = {})
if idle && !can_idle?
db: false,
if resp.kind_of?(Net::IMAP::UntaggedResponse) && resp.name == "EXISTS"
if @group.imap_last_uid == 0
old_uids = @provider.uids(to: @group.imap_last_uid) # 1 .. seen
new_uids = @provider.uids(from: @group.imap_last_uid + 1) # seen+1 .. inf
new_uids = new_uids - old_uids
import_mode = import_limit > -1 && new_uids.size > import_limit
.where("to_addresses LIKE ?", "%#{@group.email_username}%")
.map(&:message_id)
if to_sync.size > 0
new_labels << "\\Inbox"
new_flags = tags.map { |tag| @provider.tag_to_flag(tag) }.reject(&:blank?)
new_labels.concat(tags.map { |tag| @provider.tag_to_label(tag) }.reject(&:blank?))
@imap ||= super.tap { |imap| apply_gmail_patch(imap) }
def emails(uids, fields, opts = {})
return '\\Important' if tag == "important"
return '\\Starred' if tag == "starred"
new_labels = labels.reject { |l| l == "\\Inbox" }
new_labels << "\\Inbox" if !new_labels.include?("\\Inbox")
uids_to_fetch = imap.uid_search("#{X_GM_THRID} #{thread_id}")
attr = {}
when /\A(?:UID)\z/ni
name, val = uid_data
parse_error("unknown attribute `%s' for {%d}", token.value, n)
@uid = uid
@account_digest ||= Digest::MD5.hexdigest("#{@username}:#{@server}")
@imap ||= Net::IMAP.new(@server, port: @port, ssl: @ssl, open_timeout: @timeout)
def uids(opts = {})
@labels ||=
labels = {}
if tag = to_tag(name)
additions = new_set.reject { |val| old_set.include?(val) }
removals = old_set.reject { |val| new_set.include?(val) }
label if label != "inbox" && label != "sent"
:Seen if tag == "seen"
.list("", "*")
.reject do |m|
.select do |m|
or_clauses = "OR " * (header_message_id_terms.length - 1)
query = "#{or_clauses}#{header_message_id_terms.join(" ")}"
def self.resize(width, height, opts = {})
w = width.to_f
h = height.to_f
return w.floor, h.floor if w <= max_width && h <= max_height
def self.crop(width, height, opts = {})
ratio = max_width / w
keys = parent_keys.dup << key
parent_key = keys.join(".")
ctx.eval("mf = new MessageFormat('#{mf_locale}');")
@plural_keys ||=
@keys_with_count = Hash.new { 0 }
@keys_with_count.select { |key, count| count > 1 }.keys
locale_list << :en
@pluralizers = {}
as_string ? regexp : /#{regexp}/i
k = k_sym.to_s
key_path = path ? "#{path}.#{k}" : k
if v.is_a?(String)
.each do |k, v|
available_locales = I18n.available_locales.map { |locale| locale.to_s.tr("_", "-") }
def initialize(html, opts = {})
@doc = Nokogiri.HTML5(html).at("body")
traverse(@doc).gsub(/\n{2,}/, "\n\n").strip
klass = "_" + SecureRandom.hex
doc.css("br").each { |br| br.add_class(klass) }
.css("br.#{klass}")
.each do |br|
before, after = parent.children.slice_when { |n| n == br }.to_a
after.each { |c| a.add_child(c) }
return true if "pre" == node.name
.chunk { |n| is_inline?(n) }
nodes.each { |n| remove_whitespaces!(n) }
node.text? ||
("br" != node.name && node.description&.inline? && node.children.all? { |n| is_inline?(n) })
text << " " if !was_space
text << c
node.children.map { |n| visit(n) }.join
visitor = "visit_#{node.name}"
@allowed_hrefs ||=
hrefs = SiteSetting.allowed_href_schemes.split("|").map { |scheme| "#{scheme}:" }.to_set
hrefs << "mailto:"
dimensions = "|#{width}x#{height}" if width > 0 && height > 0
define_method("visit_#{tag}") { |node| "<#{tag}>#{traverse(node)}</#{tag}>" }
text.gsub!(/\n{2,}/, "\n\n")
text.gsub!(/^/, "> ")
define_method("visit_#{tag}") do |node|
prefix = block?(node.previous_element) ? "" : "\n"
TRAVERSABLES.each { |tag| define_method("visit_#{tag}") { |node| traverse(node) } }
code = node.at("code")
(1..6).each { |n| define_method("visit_h#{n}") { |node| "#{"#" * n} #{traverse(node)}" } }
CELLS.each { |tag| define_method("visit_#{tag}") { |node| "#{traverse(node)} " } }
text = "| " + headers.map { |td| traverse(td).gsub(/\n/, "<br>") }.join(" | ") + " |\n"
text << "| " + row.css("td").map { |td| traverse(td).gsub(/\n/, "<br>") }.join(" | ") +
return if (rows = table.css("tr")).empty?
suffix = node.ancestors("ul, ol, li").size > 0 ? "" : "\n"
lists = node.ancestors("ul, ol")
text.gsub!(/^(?!\s*$)/, indent)
return " " if text.blank?
if token.first == :tag
in_pre = ($1 != "/") # Opening or closing tag?
t.gsub!("&#39;", "'")
t.gsub!("&quot;", '"')
if t == "'"
if prev_token_last_char =~ /\S/
elsif t == '"'
result << t
str.gsub(/--/, entity(:em_dash))
str.gsub(/---/, entity(:em_dash)).gsub(/--/, entity(:en_dash))
str.gsub(/---/, entity(:en_dash)).gsub(/--/, entity(:em_dash))
str.gsub("...", entity(:ellipsis)).gsub(". . .", entity(:ellipsis))
str.gsub("``", entity(:double_left_quote)).gsub("''", entity(:double_right_quote))
str.gsub("`", entity(:single_left_quote)).gsub("'", entity(:single_right_quote))
frac =
if $2 == "1/2"
elsif $2 == "1/4"
elsif $2 == "3/4"
str.gsub!(/\A'(?=#{punct_class}\B)/, entity(:single_right_quote))
str.gsub!(/\A"(?=#{punct_class}\B)/, entity(:double_right_quote))
str.gsub!(/"'(?=\w)/, "#{entity(:double_left_quote)}#{entity(:single_left_quote)}")
str.gsub!(/'"(?=\w)/, "#{entity(:single_left_quote)}#{entity(:double_left_quote)}")
str.gsub!(/'(?=\d\ds)/, entity(:single_right_quote))
dec_dashes = "#{entity(:en_dash)}|#{entity(:em_dash)}"
str.gsub!(
str.gsub!(/(#{close_class})'/, '\1' + entity(:single_right_quote))
str.gsub!(/'(\s|s\b|$)/, entity(:single_right_quote) + '\1')
str.gsub!(/'/, entity(:single_left_quote))
str.gsub!(/(#{close_class})"/, '\1' + entity(:double_right_quote))
str.gsub!(/"(\s|s\b|$)/, entity(:double_right_quote) + '\1')
str.gsub!(/"/, entity(:double_left_quote))
en_dash: "-",
em_dash: "--",
single_left_quote: "'",
single_right_quote: "'",
double_left_quote: '"',
double_right_quote: '"',
ellipsis: "...",
}.each { |k, v| new_str.gsub!(/#{entity(k)}/, v) }
prev_end = 0
prev_end = $~.end(0)
single_left_quote: "&lsquo;",
double_left_quote: "&ldquo;",
single_right_quote: "&rsquo;",
double_right_quote: "&rdquo;",
em_dash: "&mdash;",
en_dash: "&ndash;",
ellipsis: "&hellip;",
html_quote: "&quot;",
frac12: "&frac12;",
frac14: "&frac14;",
frac34: "&frac34;",
io.write "HTTP/1.1 "
env: env,
io.write "#{response.status} #{status_string}\r\n"
headers.each { |name, val| io.write "#{name}: #{val}\r\n" }
io.write "\r\n"
io = nil
render plain: "", status: 418
is_me?(user) || is_staff?
is_me?(user) || is_admin?
user && is_staff? && not(user.staff?)
user && is_staff?
if is_me?(user)
is_staff? &&
is_staff? && !user.nil? && !user.staff?
is_admin? && !user.nil? && !user.staff?
user && (is_me?(user) || is_staff?)
user && is_admin?
user == @user || is_staff?
return true if !@user.anonymous? && (@user.id == user.id || is_admin?)
@allowed_user_field_ids ||= {}
is_staff_or_is_me = is_staff? || is_me?(user)
cache_key = is_staff_or_is_me ? :staff_or_me : :other
return false if !is_me?(user) && !is_staff?
is_staff? ||
is_me?(user) &&
) || is_staff?
topic.allowed_users.count > 1 && topic.user != target_user &&
!!(target_user && user == target_user)
can_create_topic?(nil) &&
(!(topic.closed? || topic.archived?) || trusted) && can_create_post?(topic)
is_my_own?(topic) && !topic.edit_time_limit_expired?(user) && !first_post&.locked? &&
(!first_post&.hidden? || can_edit_hidden_post?(first_post))
!!(topic && topic.deleted_at)
!topic.trashed? &&
is_my_own?(topic) && topic.posts_count <= 1 && topic.created_at &&
return false if !is_admin? || !can_see_topic?(topic)
if hide_deleted && !is_staff?
topic && authenticated? && !topic.private_message? && is_staff?
if topic&.first_post&.wiki &&
topic&.slow_mode_seconds.to_i > 0 && @user.human? && !is_staff?
pm_scope = pm_scope.or(scope.where(<<~SQL)) if is_moderator?
def can_see_tag?(_tag)
@hidden_tag_names ||=
def post_can_act?(post, action_key, opts: {}, can_see_post: nil)
return false if !(can_see_post.nil? && can_see_post?(post)) && !can_see_post
if action_key == :notify_user &&
post.user.blank? ||
is_flag =
if authenticated? && post && !@user.anonymous?
is_flag && not(already_did_flagging) &&
) ||
not(post.topic&.archived?) &&
not(post.trashed?) &&
not(action_key == :like && (post.user.blank? || is_my_own?(post)))
can_see_post?(post) && is_staff?
is_staff? && user && !user.admin? &&
is_admin? ||
@can_create_post ||= {}
can_see_post?(post) && can_create_post?(post.topic) &&
if is_my_own?(post)
post.hidden_at.nil? ||
return false if !is_admin? || !can_edit_post?(post)
authenticated? && (is_staff? || @user.id == post.user_id) && can_see_post?(post)
post && is_staff?
post.try(:hidden) && is_staff?
!topic || !topic.category ||
@can_see_post_topic ||= {}
if method.to_s =~ /\Aensure_(.*)\!\z/
@user && is_admin? &&
create_method = :"can_create_#{target}?"
can_do?(:edit, obj)
can_do?(:delete, obj)
obj && authenticated? && !is_silenced? &&
target &&
is_admin? &&
(!target.admin? || is_developer?)
is_staff? && target && target.active? && !target.approved?
is_staff? && target && not(target.active?)
user && is_staff? && user.regular?
.pluck(:name)
.any? { |name| Badge.display_name(name) == title }
group = Group.find_by(id: group_id.to_i)
user.group_ids.include?(group_id.to_i) && (group ? !group.automatic : false)
return false if !user || !group_id || !user.group_ids.include?(group_id.to_i)
user && can_edit_group?(group)
is_staff? || is_me?(user)
(is_admin? || groups.blank? || groups.all? { |g| can_edit_group?(g) })
return false if !object.is_a?(Topic) || !can_see?(object)
is_admin? || (authenticated? && @user.id == user_id)
from_bot = @user.bot?
is_staff? || from_bot || from_system ||
(is_staff? || target_is_group || !target.suspended?) &&
(!is_silenced? || target.staff?)
).count == 0
can_mute_users? && @user.id != target_user.id && !target_user.staff?
can_ignore_users? && @user.id != target_user.id && !target_user.staff?
urls = allowed_repos.split(",").map(&:strip)
other && authenticated? && other.is_a?(User) && @user == other
def is_my_own?(obj)
return obj.user_id == @user.id if obj.respond_to?(:user_id) && obj.user_id && @user.id
return obj.user == @user if obj.respond_to?(:user)
@user.blank? || !is_me?(other)
is_admin? && obj.present? && obj.id&.positive?
method_name = :"can_#{action}_#{obj.class.name.underscore}?"
).where("group_users.user_id = ?", user.id)
GlobalSetting.cdn_url.blank? ? p : "#{GlobalSetting.cdn_url}#{path(p)}"
(p =~ /\Ahttp/ || p =~ %r{\A//}) ? p : cdn_path(p)
if url.start_with?("https://github.com/") && !url.end_with?(".git")
url = url.gsub(%r{/\z}, "")
url += ".git"
@before = {}
@after = {}
@before.size == 0 && @after.size == 0
return if @subset.nil? || @original.nil?
i = j = 0
gaps = {}
if (e1 == e2)
i = i + 1
j = j + 1
break if (i == @subset.size) || (j == @original.size)
I18n.load_path.grep(%r{.*faker.*/#{Regexp.escape locale}\.yml\z}),
I18n.load_path.grep(%r{.*faker.*/#{Regexp.escape locale}/.*\.yml\z}),
def search(query, opts = {})
k = "#{key}#{locale}#{config.backend.object_id}"
-"translation missing: #{locale}.#{key}"
by_site ||= {}
if PG::UndefinedTable === e.cause || PG::UndefinedColumn === e.cause
options = args.last.is_a?(Hash) ? args.pop.dup : {}
overrides = {}
no_options = options.empty? || (options.size == 1 && options.has_key?(:locale))
def exists?(key, locale = nil)
@overrides_by_site = {}
buf << ";" # unless string_end_with_semicolon?(buf)
buf << "\n" # unless buf.end_with?("\n")
buf << source
:data,
proc { +"" },
) values (
version: version || "",
duration: (time.real * 1000).to_i,
encoding_diags << " my encoding is #{encoding} "
encode!("utf-16", "utf-8", invalid: :replace)
encode!("utf-8", "utf-16")
reading_role = :"#{db}_#{ActiveRecord.reading_role}"
to_time = 0,
distance = (to_time.to_f - from_time.to_f).abs
when 0..4
when 5..9
when 2..44
locale.t :x_days, count: 1
fyear += 1 if from_time.month >= 3
tyear -= 1 if to_time.month < 3
leap_years = (fyear > tyear) ? 0 : (fyear..tyear).count { |x| Date.leap?(x) }
num_wildcards = val.count("*")
v = val.gsub(%r{/.*}, "")
parts = v.split(".")
(4 - parts.size).times { parts << "*" } # support strings like 192.*
v = parts.join(".")
mask = @mask_addr.to_s(2).count("1")
if mask == 32
if loaded? &&
File.open(path()) do |s|
File.open(dest, "wb", s.stat.mode) do |f|
IO.copy_stream(s, f)
def include!(name, options = {})
@plugin_post_custom_fields ||= {}
IPAddr.new("0.0.0.0/8"),
IPAddr.new("127.0.0.1"),
IPAddr.new("172.16.0.0/12"),
IPAddr.new("192.168.0.0/16"),
IPAddr.new("10.0.0.0/8"),
IPAddr.new("::1"),
IPAddr.new("fc00::/7"),
IPAddr.new("fe80::/10"),
.filter_map do |r|
ip = ip.is_a?(IPAddr) ? ip : IPAddr.new(ip)
ranges.any? { |r| r === ip }
@queue ||= Queue.new
@queue << ""
@error = e
was_last_attempt = index == ips.length - 1
if @limit > 0
@status = :ready
@cookie = nil
@validate_uri = @opts.fetch(:validate_uri) { true }
@user_agent =
@uri.host,
@uri.port,
def get(redirects = @limit, extra_headers: {}, &blk)
if @uri && @uri.port == 80 && FinalDestination.is_https_domain?(@uri.hostname)
@uri = URI(@uri.to_s)
old_uri = @uri
@uri = uri(location)
if @uri && redirects == @max_redirects && @https_redirect_ignore_limit &&
if old_uri.port == 80 && @uri&.port == 443 && (URI::HTTPS === @uri)
extra = { "Cookie" => cookie } if cookie
elsif result == :ok
@uri.to_s
if @limit < 0
response_body = +""
headers: { "Host" => @uri.hostname }.merge(headers),
if @http_verb == :get
if next_url.to_s.present? && next_url != @uri
@uri = next_url
@cookie = Array.wrap(cookies).map { |c| c.split(";").first.strip }.join("; ")
if @uri.host == redirect_uri.host &&
(redirect_uri.path =~ %r{/login} || redirect_uri.path =~ %r{/session})
if @uri && @limit == @max_redirects && @https_redirect_ignore_limit &&
@limit += 1
@limit -= 1
return false if @uri.scheme == "http" && @uri.port != 80
return false if @uri.scheme == "https" && @uri.port != 443
url = uri(url)
has_wildcard = hostname_parts.first == "*"
headers = request_headers.merge("Accept-Encoding" => "gzip", "Host" => uri.host)
catch(:done) { yield resp, nil, nil }
log(:warn, "An error with SSL occurred: #{@uri} #{exception.message}")
use_ssl: (uri.scheme == "https"),
complete_url = canonical_uri.to_s.starts_with?("/") ? parts.join("") : parts.join("/")
complete_url = "#{@uri.scheme}://#{complete_url}" if @uri.scheme
before.start_with?("http://") && after.start_with?("https://") &&
before.sub("http://", "") == after.sub("https://", "")
if @min_replies && @topic.posts_count < @min_replies + 1
return unless @min_trust_level.try(">", 0)
if @bypass_trust_level_score.try(">", 0)
@posts.where("COALESCE(users.trust_level,0) >= ?", @min_trust_level)
return unless @min_score.try(">", 0)
@posts = @posts.where("posts.score >= ?", @min_score)
@posts = Post.from(@posts, :posts).order(post_number: :asc)
prefix = @migrate_to_multisite ? "uploads/#{@current_db}/original/" : "original/"
count = Upload.by_users.where("url NOT LIKE '#{base_url}%'").count
cdn_path = SiteSetting.cdn_path("/uploads/#{@current_db}/original").sub(/https?:/, "")
count = Post.where("cooked LIKE '%#{cdn_path}%'").count
seeded_image_url = "uploads/#{@current_db}/original/_X/"
!Upload.by_users.where("url NOT LIKE '//%' AND url NOT LIKE '/%#{seeded_image_url}%'").exists?
log "*" * 30 + " DRY RUN " + "*" * 30 if @dry_run
log "Migrating uploads to S3 for '#{@current_db}'..."
folder = File.join(folder, "/")
bucket, folder = @s3_bucket, ""
log "Uploading files to S3..."
.popen("cd #{public_directory} && find uploads/#{@current_db}/original -type f")
.each do |file|
putc "." if local_files.size % 1000 == 0
log " => #{local_files.size} files"
log " - Listing S3 files"
options = { bucket: bucket, prefix: folder + prefix }
log " => #{s3_objects.size} files"
log " - Syncing files to S3"
synced = 0
lock.synchronize { synced += 1 }
putc "X"
original_path = file.sub("uploads/#{@current_db}", "")
body: File.open(path, "rb"),
upload = Upload.find_by(url: "/#{file}")
synced += 1
queue << { path: path, options: options, etag: etag }
log failed.join("\n")
from = "/uploads/#{@current_db}/original/"
to = "#{SiteSetting.Upload.s3_base_url}/#{prefix}"
.each do |upload_url, _|
to = "#{SiteSetting.Upload.s3_cdn_url}/#{prefix}"
from = "#{Discourse.base_url}/uploads/#{@current_db}/original/"
log "Done!"
@s3_helper ||=
def store_file(file, path, opts = {})
s3_cdn_url = URI.parse(SiteSetting.Upload.s3_cdn_url || "")
folder = s3_bucket_folder_path.nil? ? "" : "#{s3_bucket_folder_path}/"
File.join("#{schema}#{absolute_base_url}", folder),
key = path.sub(absolute_base_url + "/", "")
metadata: {}
source = avatar.url.sub(absolute_base_url + "/", "")
destination = avatar_template(avatar, user_id).sub(absolute_base_url + "/", "")
opts = { expires_in: expires_in }
object_from_path(key).acl.put(acl: secure ? "private" : "public-read")
id = model.where("url LIKE '%#{f.key}' AND etag = '#{f.etag}'").pick(:id)
verified_ids.map { |id| "('#{PG::Connection.escape_string(id.to_s)}')" }.join(",")
copy_file(file, "#{public_dir}#{path}")
def remove_file(url, _)
source = "#{public_dir}#{url}"
destination = "#{public_dir}#{url.sub("/uploads/", "/uploads/tombstone/")}"
is_relative?(url) || is_local?(url)
url = upload.try(:url)
File.open(path, "wb") { |f| f.write(file.read) }
absolute_url = url.start_with?("//") ? SiteSetting.scheme + ":" + url : url
path = "#{public_dir}#{upload.url}"
bad = true
bad = false if File.size(path) != 0
File.join("/", upload_path, path)
filename = "#{object.sha1}#{extension}"
url = SiteSetting.scheme + ":" + url if url =~ %r{\A//}
file =
CACHE_DIR ||= "#{Rails.root}/tmp/download_cache/"
files.sort_by! do |f|
depths << Math.log(id / 1_000.0, 16).ceil if id.positive?
url = "https:" + url if url.start_with?("//")
tmp = nil
ext = "jpg" if ext == "jpe"
tmp_file_ext = "." + ext if ext.present?
oxipng: {
level: 3,
strip: strip_image_metadata ? "all" : "none",
@@supported_video_regexp ||= /\.(#{supported_video.to_a.join("|")})\z/i
@@supported_audio_regexp ||= /\.(#{supported_audio.to_a.join("|")})\z/i
@@supported_images_regexp ||= /\.(#{supported_images.to_a.join("|")})\z/i
@@inline_images_regexp ||= /\.(#{inline_images.to_a.join("|")})\z/i
/\.(#{media.to_a.join("|")})\z/i
@rss_item = rss_item
link = rss_item.links&.find { |l| l.rel == "alternate" && l.type == "text/html" }
@feed = feed
@element_accessor = "#{@element_namespace}_#{@element_name}"
@element_uri ||=
@next_page = (@next_page || 0) + 1
url = URI("https://picsum.photos/v2/list?page=#{@next_page}&limit=50")
@image_cache_dir ||= ::File.join(Rails.root, "tmp", "discourse_dev", "images")
if !::File.exist?(cache_path)
tmp_file_name: "image",
presigned_urls = {}
max_parts: 1,
.map do |part|
{ part_number: part_number, etag: etag }
@excerpt = +""
options || {}
@summary_contents = +""
@detail_contents = +""
html ||= ""
catch(:done) { parser.parse(html) }
v = v.dup
v.gsub!("&", "&amp;")
v.gsub!("\"", "&#34;")
v.gsub!("<", "&lt;")
v.gsub!(">", "&gt;")
when "img"
when "a"
@in_a = true
@in_quote = true
when "div", "span"
@detail_contents = +"" if @in_details_depth == 0
@in_details_depth += 1
if @in_details_depth == 1 && !@in_summary
when "svg"
@in_svg = true
when "use"
@in_a = false
when "p", "br"
characters(" ")
@in_details_depth -= 1
if @in_details_depth == 0
after_string: "</summary></details>",
after_string: "</summary>",
@in_summary = false if @in_details_depth == 1
@in_svg = false
encode = encode ? lambda { |s| ERB::Util.html_escape(s) } : lambda { |s| s }
@excerpt << (@text_entities ? "..." : "&hellip;")
@excerpt << "</a>" if @in_a
string.match?(/\A:\w+:\Z/)
super({})
start = options.fetch(:start) { 1 }
fetch(id_or_value) { key(id_or_value) }
dup.tap { |d| d.keep_if { |k| keys.include?(k) } }
dup.tap { |d| d.delete_if { |k| keys.include?(k) } }
string.sub!(/\A\xEF\xBB\xBF/, "") unless string.blank?
@assets ||=
assets +=
assets << "#{file}.js"
.map do |info|
assets.include?(name) || name.start_with?("chunk.")
@version ||=
if @guardian.is_staff? && @guardian.user != @user
@change_req =
if !@user.staff?
type: old_email ? "notify_old_email" : "notify_old_email_add",
@raw_regexp ||=
@raw = raw
return if buffer =~ /\A(<br>)+\z\z/
result << "<blockquote>#{buffer}</blockquote>"
line.gsub!(/\S+/) do |str|
url = URI.parse(str).to_s
str = %|<a href="#{url}" class="onebox" target="_blank">#{url}</a>|
str = %|<a href="#{url}">#{url}</a>|
quote_buffer = +""
line.sub!(/\A\s{2,}/) { |s| "\u00A0" * s.length }
if line =~ /\A\s*>/
quote_buffer << line << "<br>"
quote_buffer = ""
if sz < 60
result << "<br>" if in_text && line == "\n"
result << "<br>"
result.gsub!(/(<br>\n*){3,10}/, "<br><br>")
def cook(opts = {})
result << "\n<br>" << @attachment_html if @attachment_html.present?
result << "\n<br><br>" << Email::Receiver.elided_html(htmlify(@elided)) if @elided.present?
) do |memo, v|
memo.tap do |m|
.tap do |r|
token == self.get(user_id)
@html = html
@custom_styles = {}
.css("img")
.css("a.attachment")
style("aside.quote div.info-line", "color: #666; margin: 10px 0")
style(".onebox-metadata", "color: #919191")
style(".github-info", "margin-top: 10px;")
style(".github-info .added", "color: #090;")
style(".github-info .removed", "color: #e45735;")
style(".github-icon-container *", "fill: #646464; width: 40px; height: 40px;")
.css("aside.quote")
.each do |n|
@fragment.css("aside, article, header").each { |n| n.name = "div" }
.css("iframe")
.each do |i|
src_uri =
html_lang = SiteSetting.default_locale.sub("_", "-")
style("html", nil, :lang => html_lang, "xml:lang" => html_lang)
style("body", "line-height: 1.4; text-align:#{Rtl.new(nil).enabled? ? "right" : "left"};")
style("body", nil, dir: Rtl.new(nil).enabled? ? "rtl" : "ltr")
dir: Rtl.new(nil).enabled? ? "rtl" : "ltr",
style("blockquote > :first-child", "margin-top: 0;")
style("blockquote > :last-child", "margin-bottom: 0;")
style("blockquote > p", "padding: 0;")
style("h4", "color: #222;")
style("h3", "margin: 30px 0 10px;")
style("hr", "background-color: #ddd; height: 1px; border: 1px;")
style("ul", "margin: 0 0 0 10px; padding: 0 0 0 20px;")
style("li", "padding-bottom: 10px")
style("span.post-count", "margin: 0 5px; color: #777;")
style("pre", "word-wrap: break-word; max-width: 694px;")
style("pre code li", "white-space: pre;")
style(".user-avatar img", nil, width: "45", height: "45")
style(".rtl", "direction: rtl;")
style("div.body", "padding-top:5px;")
style(".whisper div.body", "font-style: italic; color: #9c9c9c;")
upload_shas = {}
upl.sha1 ==
<img src="#{url}" data-embedded-secure-image="true" style="#{style}" />
.search("img")
dm: "header",
dm: "body",
style(".digest-topic-body", nil, dm: "topic-body")
style(".summary-footer", nil, dm: "text-color")
style("code, pre code, blockquote", nil, dm: "bg")
.css(".footer")
.each do |inner|
if footernum == (0) && linknum == (0)
.css("*")
style("table", nil, cellspacing: "0", cellpadding: "0", border: "0")
def style(selector, style, attribs = {})
@message.charset = "UTF-8"
user_id = @user&.id
post = Post.find_by(id: post_id, topic_id: topic_id)
list_id =
list_id = "#{SiteSetting.title} <#{host}>"
.each do |key, _|
if value&.include?("%{reply_key}")
when /\.mailjet\.com/
@to_address ||=
to = @message.try(:to)
to = to.first if Array === to
@cc_addresses ||=
@bcc_addresses ||=
user_id: @user&.id,
if !user_id || !post_id ||
.where("post_replies.reply_post_id = ?", post.id)
.order(id: :desc)
results = DB.query(<<~SQL, start_post_id: post.id)
results.inject({}) do |hash, value|
@text =
(+(@message.text_part ? @message.text_part : @message).body.to_s).force_encoding("UTF-8")
locals: {
@formats ||= Enum.new(plaintext: 1, markdown: 2)
@mail = Mail.new(@raw_email)
body ||= ""
@bounce_key ||=
text = nil
text_content_type ||= ""
in_code = nil
.map! do |line|
stripped = line.strip << "\n"
in_code = "```"
elided = doc.css("#Signature, #Signature ~ *, hr, #divRplyFwdMsg, #divRplyFwdMsg ~ *").remove
.map do |locale|
@reply_above_line_regex ||= /\n(?:#{strings.map { |x| Regexp.escape(x) }.join("|")})\n/im
mail ||= @mail
:reply_to,
next if !from_address&.include?("@")
@subject ||=
body + "\n\n----\n\n" +
.where("posts.topic_id = ?", post_reply_key.post.topic_id)
text = fix_charset(@mail.multipart? ? @mail.text_part : @mail)
@embedded_email ||=
reply_addresses.map! { |a| Regexp.escape(a) }
reply_addresses.map! { |a| a.gsub("\+", "\+?") }
reply_addresses.map! { |a| a.gsub(Regexp.escape("%{reply_key}"), "(\\h{32})?") }
/$a/ # a regex that can never match
/#{reply_addresses.join("|")}/
Regexp.union(DB.query_single(<<~SQL).map { |e| e.split("|") }.flatten.compact_blank.uniq)
.select(&:present?)
.map { |e| e.split("|") }
def create_topic(options = {})
def create_reply(options = {})
@attachments ||=
attachments << @mail if @mail.attachment? && is_allowed?(@mail)
@mail.parts.each { |part| attachments << part if part.attachment? && is_allowed?(part) }
File.open(tmp.path, "w+b") { |f| f.write attachment.body.decoded }
uploads: {
) do |match, src, replacement, _|
raw << "\n\n#{UploadMarkdown.new(upload).to_markdown}\n\n"
errors << "#{a.original_filename}: #{error}"
def create_post(options = {})
if errors.any? { |message|
html = +"\n\n" << "<details class='elided'>" << "\n"
html << "<summary title='#{I18n.t("emails.incoming.show_trimmed_content")}'>&#183;&#183;&#183;</summary>" <<
html << elided << "\n\n"
html << "</details>" << "\n"
if (!user || user.staged) &&
if user && can_invite?(post.topic, user)
if !user.staged &&
num_of_days > 0 && post.created_at < num_of_days.days.ago
def initialize(mail, opts = {})
@mail = mail
def self.process!(mail, opts = {})
template_args = {}
msg += "\n\nMail:\n#{mail_string}"
key = "rejection_email:#{email}:#{type}:#{Date.today}"
DB.exec(<<~SQL, host: host)
SET outbound_message_id = 'discourse/post/' || posts.id || '@' || :host
SELECT '<' || posts.outbound_message_id || '>'
WHERE posts.id IN (#{post_ids.join(",")})
post_ids << Post
!!(message_id =~ message_id_post_id_regexp) ||
!!(message_id =~ message_id_topic_id_regexp) ||
Regexp.new "topic/\\d+/(\\d+|\\d+\.\\w+)@#{Regexp.escape(host)}"
Regexp.new "topic/(\\d+|\\d+\.\\w+)@#{Regexp.escape(host)}"
Regexp.new "discourse/post/(\\d+)@#{Regexp.escape(host)}"
message_id.present? && !is_message_id_rfc?(message_id) ? "<#{message_id}>" : message_id
message_id.gsub(/\A<|>\z/, "")
message_id.start_with?("<") && message_id.include?("@") && message_id.end_with?(">")
@to = to
@template_args = {
}.merge!(@opts)
html_override.gsub!("%{header_instructions}", "")
html_override.gsub!("%{respond_instructions}", "")
body << "\n"
to: @to,
charset: "UTF-8",
.each do |item|
header = item.split(":", 2)
%Q|"#{Email.cleanup_alias(from_alias)}" <#{source}>|
@mail = Mail.new(mail)
@mail.charset = "UTF-8"
message.gsub!("\x00", "")
VERDICT = Enum.new(:gray, :pass, :fail, start: 0)
@results ||=
.map { |header| parse_header(header.to_s) }
@action ||= calc_action
if verdict == :fail
verdict = v if v > verdict
authres_version = /\d+#{cfws}?/
no_result = /#{cfws}?;#{cfws}?none/
method = %r{#{keyword}\s*(?:#{cfws}?/#{cfws}?#{method_version})?}
methodspec = /#{cfws}?#{method}#{cfws}?=#{cfws}?#{result}/
reasonspec = /reason#{cfws}?=#{cfws}?#{value}/
pvalue = /#{cfws}?#{value}#{cfws}?/
propspec = /#{ptype}#{cfws}?\.#{cfws}?#{property}#{cfws}?=#{pvalue}/
first, _, last = email.rpartition("@")
last = last.split(".")
last.map! { |part| obfuscate_part(part) }
last << tld
mail = Mail.new(raw)
if part.size < 3
limit = (limit * multiplier).to_i
super(user, "edit-post", limit, 1.day.to_i)
interval = attempts < 10 ? (0.001 * 2**attempts) : 1
def defer_set(k, v)
output = Discourse::Utils.execute_command("df", "-Pk", path)
output = Discourse::Utils.execute_command("df", "-P", path)
Discourse::Utils.execute_command("du", "-s", path).to_i * 1024
if version_info.installed_describe =~ /-(\d+)-/
version_info.installed_describe.gsub(/-(\d+)-.*/, " +#{$1}")
t ? Time.zone.parse(t) : nil
@term_types ||= Enum.new(contains: 0, starts_with: 1)
tags += Tag.where(name: old_tag_names & tag_names)
tags = Tag.where(id: tags.map(&:id)).all.to_a if tags.size > 0
if tags.size < tag_names.size &&
(category.tags.count == 0 && category.tag_groups.count == 0)
tag_ids = tags.map(&:id)
.inject({}) do |h, v|
.map do |_, parent_tag_ids|
(tag_ids & parent_tag_ids).size == 0 ? parent_tag_ids.first : nil
if tags.size == 0
crtg.tag_group.tags.where("tags.id in (?)", tags.map(&:id)).count < crtg.min_count
tags: crtg.tag_group.tags.order(:id).pluck(:name).join(", "),
.pluck(:name, "categories.id")
tags: unallowed_tags.sort.join(", "),
tags: unrestricted_tags.sort.join(", "),
ON tg.id = tgp.tag_group_id /*and_group_ids*/
builder_params = {}
sql.gsub!("/*and_group_ids*/", "AND group_id IN (:group_ids)")
/*order_by*/
/*limit*/
category.allow_global_tags ? "category_id = ? OR category_id IS NULL" : "category_id = ?",
term = term.gsub("_", "\\_").downcase
sql.gsub!("/*and_name_like*/", "AND LOWER(t.name) LIKE :term")
sql.gsub!("/*and_name_like*/", "")
builder.where("id IN (?)", required_tag_ids)
result = builder.query(builder_params).uniq { |t| t.id }
context = {}
.or(
id:
).select(:id)
tag = tag.dup
tag.squeeze!("-")
tag_names += (tags_arg - tag_names).map { |t| clean_tag(t) }
tag_names.delete_if { |t| t.blank? }
new_tag_names.each { |name| taggable.tags << Tag.create(name: name) }
(tag_names - target_tag.synonyms.map(&:name)).each do |name|
define_method m do |*args, **kwargs|
args.map! { |a| "#{namespace}:#{a}" } if @namespace
keys.map! { |k| "#{namespace}:#{k}" } if @namespace
def scan_each(options = {}, &block)
@redis.scan_each(**options) do |key|
pattern = pattern || "*"
pattern = "#{namespace}:#{pattern}" if @namespace
DiscourseRedis.ignore_readonly { keys("#{prefix}*").each { |k| Discourse.redis.del(k) } }
def eval(redis, *args, **kwargs)
@@register_names ||= Set.new
instance_variable_get(:"@#{register_name}") ||
unfiltered = public_send(:"_raw_#{register_name}")
public_send(:"_raw_#{register_name}") << { plugin: plugin, value: value }
each_options ||= {}
root, ext, options = *g
Dir.glob("#{root}/**/*.#{ext}") { |f| yield f }
JS_REGEX = /\.js$|\.js\.erb$|\.js\.es6\z/
if opts == :admin
elsif asset =~ /\.css$|\.scss\z/
if opts == :mobile
builders.map { |b| b.call(ctx) }.join("\n").html_safe
seed_path_builders.each { |b| result += b.call }
@@register_names.each { |name| instance_variable_set(:"@#{name}", nil) }
uri: uri,
data = "eval(#{data.inspect} + \"\\n//# sourceURL=#{source_url}\");\n"
{ data: data }
filename ||= ""
return true if filename.end_with?(".es6") || filename.end_with?(".es6.erb")
return false unless filename.end_with?(".js") || filename.end_with?(".js.erb")
relative_path = filename.sub(Rails.root.to_s, "").sub(%r{^/*}, "")
!!(data.present? && data =~ %r{^// discourse-skip-module$})
window = {};
def self.v8_call(*args, **kwargs)
result = v8.call(*args, **kwargs)
message = "Error: #{decoded}"
plugin = Discourse.plugins.find { |p| p.path == plugin_path }
path || logical_path&.gsub("app/", "")&.gsub("addon/", "")&.gsub("admin/addon", "admin")
@path ||= File.join(Rails.root, "vendor", "data")
File.join(path, "#{name}.mmdb")
gz_file =
tmp_file_name: "#{name}.gz",
dir = "#{Dir.tmpdir}/#{SecureRandom.hex}"
Discourse::Utils.execute_command("cp", gz_file.path, "#{dir}/#{filename}")
Discourse::Utils.execute_command("tar", "-xzvf", "#{dir}/#{filename}", chdir: dir)
Rails.logger.warn("MaxMindDB (#{filepath}) could not be found: #{e}")
ip = ip.to_s
locale = locale.to_s.sub("_", "-")
ip,
Discourse.git_branch == "unknown" ? {} : { branch: Discourse.git_branch },
def self.get(rel_url, params = {})
def self.post(rel_url, params = {})
def self.put(rel_url, params = {})
def self.delete(rel_url, params = {})
).body,
if (status = response.status) != 200
params.delete(:connect_opts)&.except(:body, :headers, :query) || {}
t ? Time.zone.at(t.to_i) : 1.year.ago
since: "2.3.0beta8",
drop_from: "2.4",
if op_code == :common
if op_code == :delete
klass = "del"
first = i
second = i + 1
klass = "ins"
first = i + 1
second = i
diff =
).diff
table << "<tr>"
table << "<td class=\"diff-del\">#{deleted.join}</td>"
table << "<td class=\"diff-ins\">#{inserted.join}</td>"
table << "<td></td>"
table << "</tr>"
tokens << t.join
tokens << t.join if t.size > 0
Nokogiri::HTML5.fragment(html).search("./*").map(&:to_html)
result.insert(index_of_next_chevron, " class=\"diff-#{klass}\"")
if classes.include?("diff-#{klass}")
result.insert(index_of_class + "class=".size + 1, "diff-#{klass} ")
diff.each do |d|
me = new
parser.parse("<html><body>#{html}</body></html>")
@tokens << "<#{name}#{attrs}>"
@tokens << "</#{name}>"
.between(from: 0, to: 2)
max_views = 0
topic_opts: {
.chomp(".")
.between(from: @settings.dig(:tags, :min), to: @settings.dig(:tags, :max))
.times { @tags << Faker::Discourse.tag }
from: @settings.dig(:replies, :min),
to: @settings.dig(:replies, :max),
@@initialized ||=
puts "There are #{current_count} #{type} records. Creating #{@count} more."
putc "." unless type == :post
model.joins(:_custom_fields).where("#{:type}_custom_fields.name = '#{AUTO_POPULATED}'")
raise "#{:type} records are not yet populated" if count == 0
offset = Faker::Number.between(from: 0, to: count - 1)
@count.times { create! }
super(::Post, count)
@max_likes_count = @user_count - 1
.between(from: 0, to: @max_likes_count)
user_ids << user.id
position = Faker::Number.between(from: 0, to: @user_count - 1)
puts "Creating #{count} replies in '#{topic.title}'"
puts "Done!"
super(::Post)
@file_path = File.join(Rails.root, "config", "dev.yml")
user_config = {}
puts "#{key} = #{value}"
::User.create!(
seed = self.seed || 1
File.open(file_path, "a") do |file|
file.puts("admin:")
permission = {}
@config ||= Config.new
.split("\n")
.map { |row| row.split("|", 2) }
.sort_by { |k, _| k }
pair =
sso = new(**init_kwargs)
sso.public_send("#{k}=", val)
DiscourseConnectBase::ACCESSORS.map { |a| "#{a}: #{public_send(a)}" }.join("\n")
@sso_url || self.class.sso_url
@custom_fields ||= {}
def to_url(base_url = nil)
base = "#{base_url || sso_url}"
next if (val = public_send(k)) == nil
logs.join("\n")
type: "backup_logs",
for_export: "true",
...
File.open(temp_destination, "w") do |fd|
fd.fsync()
failure_message: "",
chdir: ".",
env = nil
context ||= {}
if Hash === job
ex,
def initialize(msg = nil, obj = nil, opts = nil)
msg = nil,
set = Set.new
.each { |size| PIXEL_RATIOS.each { |pixel_ratio| set << (size * pixel_ratio).to_i } }
.find_all("#{Rails.root}/plugins")
@plugins << p
plugins.select { |p| !p.enabled? }.map(&:name)
plugins.find_all { |p| !p.metadata.official? }
plugins.select { |plugin| plugin.asset_filters.all? { |b| b.call(type, request, filter_opts) } }
.map do |plugin|
@assets_digest ||=
@cache ||=
@os_hostname ||=
SiteSetting.force_https? ? "https" : "http"
result = +"#{current_hostname}"
result << ":#{SiteSetting.port}"
path = +(uri.path || "")
if !uri.host ||
ttl =
@threads ||= {}
while @dbs.size > 0
sleep ttl / 2
@redis_last_read_only ||= {}
(redis_read_only.present? && redis_read_only > 15.seconds.ago) ||
@git_version ||=
git_cmd = "git rev-parse HEAD"
@git_branch ||=
git_cmd = "git rev-parse --abbrev-ref HEAD"
@full_version ||=
@last_commit_date ||=
git_cmd = 'git log -1 --format="%ct"'
seconds.nil? ? nil : DateTime.strptime(seconds, "%s")
version_value = `#{git_cmd}`.strip
user ||= (system_user || User.admins.real.order(:id).first)
@system_users ||= {}
append = env ? (+" ") << env.map { |k, v| "#{k}: #{v}" }.join(" ") : ""
if !(Logster::Logger === Rails.logger)
Rails.logger.warn("#{message}#{append}")
if !(Logster::Logger === logger)
logger.warn("#{message} #{append}")
env.each do |k, v|
def self.warn_exception(e, message: "", env: nil)
env ||= {}
Rails.logger.warn("#{message} #{e}\n#{e.backtrace.join("\n")}")
warning << "\nAt #{location}"
warning = warning.join(" ")
if e && e.message =~ /UndefinedColumn/ &&
locale ||=
f = File.join(Rails.root, "tmp", Time.now.strftime("#{prefix}%Y%m%d%H%M%S"))
@directory_cache ||= {}
blk ? (@blk = blk) : @blk
options << "-q"
options << "#{queue_name},#{weight}"
Discourse::Utils.execute_command("renice", "-n", "5", "-p", Process.pid.to_s)
@sync_data.each { |db, sync_data| sync_data.each { |_, data| kill_and_disconnect!(data) } }
@sync_data = {}
trap("INT") { kill_threads }
trap("TERM") { kill_threads }
trap("HUP") { kill_threads }
sync_data.each { |_, data| kill_and_disconnect!(data) }
@demons ||= {}
@pid = nil
def alive?(pid = nil)
pid ||= @pid
while alive? && timeout > 0
timeout -= (@stop_timeout / 10.0)
Process.kill("KILL", @pid)
if !@pid
dead =
return if @pid || @started
@pid =
pid = File.read(pid_file).to_i
verbose("writing pid file #{pid_file} for #{@pid}")
File.open(pid_file, "w") { |f| f.write(@pid) }
to,
like = "#{anchor_left ? "" : "%"}#{from}#{anchor_right ? "" : "%"}"
set =
.map do |column|
.join(" OR ")
rows = DB.exec(<<~SQL, from: from, to: to, like: like)
puts "#{table}=#{rows}" if verbose && rows > 0
flags: "gi",
match: "~*",
found = {}
like = "#{anchor_left ? "" : "%"}#{needle}#{anchor_right ? "" : "%"}"
rows = DB.query(<<~SQL, like: like)
FROM \"#{r.table_name}\"
if rows.size > 0
def log_on_user(user, opts = {})
escaped = string.split("|").map { |agent| Regexp.escape(agent) }.join("|")
if type == :real && Rails.env == "test"
@non_crawler_matchers ||= {}
@matchers ||= {}
type: :real,
@browser_update_matchers ||= {}
@allowlisted_matchers ||= {}
@blocklisted_matchers ||= {}
oneboxes = {}
limit -= 1
user_id: @model&.user_id,
parent = parent&.parent if parent&.name == "a"
if parent_class&.include?("onebox-body") && width > 0 && height > 0
if width < 64 && height < 64
) && width > 0 && height > 0
return w, h if w > 0 && h > 0
if w > 0 || h > 0
w = w.to_f
h = h.to_f
if w > 0
def add_to_size_cache(url, w, h)
absolute_url = SiteSetting.scheme + ":" + absolute_url if absolute_url.start_with?("//")
if upload && upload.width && upload.width > 0
a = create_link_node(nil, url, true)
span = create_span_node("url", url)
img.name = "span"
img << "<svg class=\"fa d-icon d-icon-unlink svg-icon\" aria-hidden=\"true\"><use href=\"#unlink\"></use></svg>"
el.name = "a"
el << "<svg class=\"fa d-icon d-icon-link svg-icon\" aria-hidden=\"true\"><use href=\"#link\"></use></svg>"
placeholder << "<svg class=\"fa d-icon d-icon-link svg-icon\" aria-hidden=\"true\"><use href=\"#link\"></use></svg>"
@doc.css(".onebox-body img, .onebox img, img.onebox")
return true if parent.name == "a"
@doc.try(:to_html)
a = create_node("a", klass)
icon = create_node("svg", "fa d-icon d-icon-#{klass} svg-icon")
icon << "<use href=\"##{klass}\"></use>"
span = create_node("span", klass)
def initialize(post, opts = {})
@model = post
@previous_cooked = (@post.cooked || "").dup
(@doc.css("img.emoji") - @doc.css(".quote img")).size > 0
return if @post.user.blank? || !Guardian.new.can_see?(@post)
.each do |q|
return if previous_text.gsub(/(\s){2,}/, '\1') != quoted_text.gsub(/(\s){2,}/, '\1')
@doc.css("img.emoji")
@doc.css("img.emoji") -
@doc.css(".quote img") -
@doc.css("img.site-icon") -
@doc.css("img.onebox-avatar") - @doc.css("img.onebox-avatar-inline") -
return if src.blank? || is_a_hyperlink?(img) || is_svg?(img)
if original_width == 0 || original_height == 0
user_height.to_i <= 0
crop =
resized_w = (width * ratio).to_i
resized_h = (height * ratio).to_i
if img.ancestors(".onebox, .onebox-body, .quote").blank? && !img.classes.include?("onebox")
.map(&:to_f)
.each { |r| yield r if r > 1 }
srcset = +""
resized_w = (w * ratio).to_i
resized_h = (h * ratio).to_i
srcset << ", #{cooked_url} #{ratio.to_s.sub(/\.0\z/, "")}x"
meta = create_node("div", "meta")
next if !query.delete("u")
uri.query = query.map { |k, v| "#{k}=#{v}" }.join("&").presence
.css(
if el.name == "img"
def is_svg?(img)
File.extname(path) == ".svg" if path
protocol = (SiteSetting.force_https || request.ssl?) ? "https://" : "http://"
{}.tap do |obj|
for_qunit_route ||= "/theme-qunit" == path_info
key = "theme_extensions_#{theme_id}"
doc = html_fields.map(&:value_baked).join("\n")
.each do |node|
uri_string = uri.to_s.sub(%r{\A//}, "") # Protocol-less CSP should not have // at beginning of URL
{}.tap do |extension|
directive, source = entry.split(":", 2).map(&:strip)
{}.tap do |directives|
base = base_url,
.map do |dir, can_use_s3_cdn, can_use_cdn, for_worker|
if can_use_s3_cdn && s3_cdn
s3_cdn + dir
base + dir
sources << "#{base_url}/ember-cli-live-reload.js"
sources << "#{base_url}/_lr/"
directive.to_s.gsub("-", "_").to_sym
if source.starts_with?("/")
sources = Array(sources).map { |s| normalize_source(s) }
def policy(theme_id = nil, base_url: Discourse.base_url, path_info: "/")
def build(theme_id, base_url:, path_info: "/")
@lines = @initial_content.split("\n")
if (finish_row == start_row)
(finish_row - start_row).times { l = @lines.delete_at start_row + 1 }
@lines.insert(i, "") if @lines.length <= i
@lines.join("\n")
absolute_path = sanitize_path("#{path}/#{target_name}")
::Zip::File.open(zip_filename, ::Zip::File::CREATE) do |zipfile|
::File.open(entry_path, "wb") do |os|
buf = "".dup
os << buf
sanitize_path("#{path}/#{tar_filename}")
name.sub! %r{\A.*(\\|/)}, ""
1024**2 * (max_size / 1.049) # Mb to Mib
@chunk_size ||= 1024**2 * 2 # 2MiB
@strategies.reduce("") { |ext, strategy| ext += strategy.extension }
gzip_target = sanitize_path("#{path}/#{target_name}")
def is_file?(_)
basename.gsub!(/#{Regexp.escape(extension)}\z/, "")
@check_methods ||= instance_methods.find_all { |m| m =~ /\Acheck\_/ }
msg = public_send(m)
id: "education",
id: "too_many_replies",
id: "avatar",
.where("created_at > ?", 1.day.ago)
recent_posts_user_ids.detect { |u| u != @user.id }
if @topic.blank? || @topic.user_id == @user.id ||
ratio = (posts_by_user.to_f / @topic.posts_count.to_f)
.find_all { |uid| uid != @user.id && uid == reply_to_user_id }
id: "get_a_room",
if @topic.nil? || SiteSetting.warn_reviving_old_topic_age < 1 || @topic.last_posted_at.nil? ||
id: "reviving_old",
if column_name == :_table
.each do |table|
h, s, l = Converters.rgb_to_hsl(*rgb)
l =
l + (100 - l) * adjustment
l + l * adjustment
rgb = Converters.hsl_to_rgb(h, s, l)
color = color.gsub(/(.)/, '\1\1') if color.length == 3
color.scan(/../).map { |c| c.to_i(16) }
rgb.map { |c| c.to_s(16).rjust(2, "0") }.join("")
def self.rgb_to_hsl(r, g, b)
r /= 255.0
g /= 255.0
b /= 255.0
h = (max + min) / 2.0
s = (max + min) / 2.0
l = (max + min) / 2.0
if (max == min)
h = 0
s = 0 # achromatic
d = max - min
s = l >= 0.5 ? d / (2.0 - max - min) : d / (max + min)
h = (g - b) / d + (g < b ? 6.0 : 0)
h = (b - r) / d + 2.0
h = (r - g) / d + 4.0
h /= 6.0
def self.hsl_to_rgb(h, s, l)
h = h / 360.0
s = s / 100.0
l = l / 100.0
r = 0.0
g = 0.0
b = 0.0
if (s == 0.0)
r = l.to_f
g = l.to_f
b = l.to_f #achromatic
q = l < 0.5 ? l * (1 + s) : l + s - l * s
p = 2 * l - q
r = hue_to_rgb(p, q, h + 1 / 3.0)
g = hue_to_rgb(p, q, h)
b = hue_to_rgb(p, q, h - 1 / 3.0)
def self.hue_to_rgb(p, q, t)
t += 1 if (t < 0)
t -= 1 if (t > 1)
return(p + (q - p) * 6 * t) if (t < 1 / 6.0)
return q if (t < 1 / 2.0)
return(p + (q - p) * (2 / 3.0 - t) * 6) if (t < 2 / 3.0)
binary ||= "google-chrome" if system("command -v google-chrome >/dev/null;")
binary ||= "chromium" if system("command -v chromium >/dev/null;")
version = `\"#{binary}\" --version`
style = color ? "style='background-color: ##{color};'" : ""
opts = opts || {}
result << "<span style='#{extra_span_classes}' data-drop-close='true' class='#{class_names}'
result << ERB::Util.html_escape(category.name) << "</span>"
canonical << "?#{allowed_params.keys.zip(allowed_params.values).map { |key, value| "#{key}=#{value}" }.join("&")}"
tag("link", rel: "canonical", href: url || @canonical_url || default_canonical)
def keys(pattern = "*")
redis.scan_each(match: "#{@namespace}:#{pattern}").to_a
keys.each { |k| redis.del(k) }
def fetch(name, expires_in: nil, force: nil, &blk)
raw = nil
raw = redis.get(key) if !force
when /Opera/i, /OPR/i
:ie
search_term_wildcard = search_term.present? ? "%#{search_term}%" : nil
union_sql = queries.join("\n\nUNION\n\n")
results = Bookmark.select("bookmarks.*").from("(\n\n#{union_sql}\n\n) as bookmarks")
def destroy_for_topic(topic, filter = {}, opts = {})
def update(bookmark_id:, name:, reminder_at:, options: {})
{ name: name, reminder_set_at: Time.zone.now }.merge(
return "0" if num == 0
str = ""
while num > 0
num = 0
len = str.length - 1
pow = BASE**(len - i)
HAVING count(*) >= t.posts_count
WHERE (:backfill OR ( p1.id IN (:post_ids) ))
) ids
(:backfill OR ( p1.id in (:post_ids) ))
JOIN users u on u.id = i.user_id
) as views
(:backfill OR pa.post_id IN (:post_ids) )
(:backfill OR p.id IN (:post_ids) )
AND (:backfill OR p.id IN (:post_ids))
) as X
(:backfill OR u.id IN (:user_ids) )
AND i.invited_by_id <> u2.id
AND u2.trust_level >= #{trust_level.to_i}
WHERE #{is_topic ? "p.post_number = 1" : "p.post_number > 1"} AND p.like_count >= #{count.to_i} AND
WHERE trust_level >= #{level.to_i} AND (
:backfill OR u.id IN (:user_ids)
AND tl.clicks >= #{count}
WHERE p.like_count >= #{like_count}
AND (:backfill OR p.user_id IN (:user_ids))
HAVING count(*) > #{post_count}
AND (:backfill OR gdl.user_id IN (:user_ids))
AND us.likes_given >= #{likes_given}
AND (:backfill OR us.user_id IN (:user_ids))
), visits AS (
, MIN(visited_at) "start"
, "start" + interval '#{days} days' "granted_at"
AND (u.silenced_till IS NULL OR u.silenced_till < '#{start_date}')
AND u.created_at <= '#{start_date}'
p.post_type IN (1,2,3)
IN ('public')
DB.exec(sql) == 1
.map { |s| Regexp.escape(s) }
.join("")
.glob(File.join(tmp_directory, "uploads", "*"))
uploads_folder = was_multisite ? "/" : upload_path
if (old_s3_base_url = BackupMetadata.value_for("s3_base_url")) &&
remap_s3("#{old_s3_base_url}/", uploads_folder)
if (old_s3_cdn_url = BackupMetadata.value_for("s3_cdn_url")) &&
remap("#{old_s3_cdn_url}/", UrlHelper.schemaless("#{base_url}#{uploads_folder}"))
remap("#{old_cdn_url}/", UrlHelper.schemaless("#{base_url}/"))
remap("/uploads/#{@previous_db_name}/", upload_path) if @previous_db_name != @current_db_name
log "Remapping '#{from}' to '#{to}'"
redis.scan_each(match: "*") { |key| redis.del(key) unless key == SidekiqPauser::PAUSED_KEY }
Sidekiq::Workers.new.each do |_, _, work|
args = work&.dig("payload", "args")&.first
@file_regex ||=
path = s3_helper.s3_bucket_folder_path || ""
path = "#{path}/" unless path.end_with?("/")
user = User.find_by(id: @user_id)
@user_info = { id: user.id, username: user.username, email: user.email }
log "Notifying '#{user.username}' of the end of the restore..."
log "Cleaning stuff up..."
timestamp = Time.now.strftime("%Y-%m-%d %H:%M:%S")
formatted_ex = "#{ex}\n" + ex.backtrace.join("\n")
files = Dir.glob(File.join(@base_directory, "*.{gz,tgz}"))
@logger ||= Logger.new(user_id: @user_id, client_id: @client_id)
log "Rolling back..."
logs << line
logs << ""
command = "sed -E '/^(#{unwanted_sql})/d' #{@db_dump_path}"
host_argument = "--host=#{db_conf.host}" if db_conf.host.present?
port_argument = "--port=#{db_conf.port}" if db_conf.port.present?
class_name = File.basename(path, ".rb").sub(/\A\d+_/, "").camelize
def initialize(user_id, opts = {})
log "'#{@user.username}' has started the backup!"
@user = User.find_by(id: @user_id)
@timestamp = Time.now.strftime("%Y-%m-%d-%H%M%S")
name: "s3_base_url",
name: "s3_cdn_url",
name: "db_name",
IO.popen("#{pg_dump_command} 2>&1") do |pipe|
Discourse::Utils.execute_command("rm", "-f", "#{tar_filename}.gz")
log "Notifying '#{@user.username}' of the end of the backup..."
log "Removing '.tar' leftovers..."
log "Removing tmp '#{@tmp_directory}' directory..."
log "Making sure '#{directory}' exists..."
Rails.logger.error("#{ex}\n" + ex.backtrace.join("\n")) if ex
def self.create(opts = {})
@files ||= unsorted_files.sort_by { |file| -file.last_modified.to_i }
@files = nil
files.sum { |file| file.size }
@is_archive = !(@filename =~ /\.sql\.gz\z/)
timestamp = Time.zone.now.strftime("%Y-%m-%d-%H%M%S")
log "Making sure #{directory} exists..."
@db_dump_path =
if File.extname(@db_dump_path) == ".gz"
@db_dump_path.delete_suffix!(".gz")
@tar_version ||=
def self.backup!(user_id, opts = {})
def self.restore!(user_id, opts = {})
WHERE typcategory = 'E' AND n.nspname = '#{source}' AND pg_catalog.pg_get_userbyid(typowner) = '#{owner}'
puts "Running Rspec: #{specs}"
line_specified = specs.split.any? { |s| s =~ /\:/ } # Parallel spec can't run specific line
if specs.split(" ").any? { |s| s =~ %r{\A(./)?plugins} }
pid = @mutex.synchronize { @pid = Process.spawn(env, command) }
_, status = Process.wait2(pid)
if pid = @pid
i = 3000
i > 0 && Process.getpgid(pid)
watch(%r{\Aspec/.+_spec\.rb\z})
watch(%r{\Aspec/support/.+\.rb\z}) { "spec" }
watch(%r{\Aspec/fabricators/.+_fabricator\.rb\z}) { "spec" }
watch(%r{\Aplugins/.*/discourse-markdown/.*\.js\.es6\z}) do
watch(%r{\Aplugins/.*/spec/.*\.rb})
watch(%r{config/.+\.rb})
path = "./tmp/rspec_result"
watch(/\.css\z/)
watch(/\.ca?ss\.erb\z/)
watch(/\.hbs\z/)
watch(/\.hbr\z/)
paths.map! do |p|
hash = nil
fullpath = "#{Rails.root}/#{p}"
p = p.sub(/\.sass\.erb/, "")
p = p.sub(/\.sass/, "")
p = p.sub(/\.scss/, "")
p = p.sub(%r{\Aapp/assets/stylesheets}, "assets")
{ name: p, hash: hash || SecureRandom.hex }
fail(e, "failed in run")
puts "@@@@@@@@@@@@ ensure_all_specs_will_run" if @debug
@queue.reject! { |_, s, _| s == "spec" }
unless @queue.any? { |_, s, r| s == "spec" && r == runner }
puts "@@@@@@@@@@@@ #{verb}_runners" if @debug
puts "@@@@@@@@@@@@ start_service_queue" if @debug
puts "@@@@@@@@@@@@ thread_loop" if @debug
puts "@@@@@@@@@@@@ waiting because..."
puts "@@@@@@@@@@@@ ...current spec has failed" if last_failed
puts "@@@@@@@@@@@@ ...queue is empty" if @queue.length == 0
@signal.wait(@mutex) if @queue.length == 0 || last_failed
fail(e, "failed in main loop")
puts "@@@@@@@@@@@@ process_spec --> #{current}" if @debug
puts "@@@@@@@@@@@@ success" if @debug
puts "@@@@@@@@@@@@ failure" if @debug
if result > 0
puts "@@@@@@@@@@@@ focus_on_failed_tests --> #{current}" if @debug
puts "@@@@@@@@@@@@ failed_specs --> #{failed_specs}" if @debug
start, _ = spec.split(/\S*#focus\S*\z/)
line = start.scan(/\n/).length + 1
puts "Found #focus tag on line #{line}!"
root_path ||= File.expand_path(File.dirname(__FILE__) + "../../..")
puts "@@@@@@@@@@@@ listen_for_changes" if @debug
options = { ignore: %r{\Alib/autospec} }
socket_path = (Rails.root + "tmp/file_change.sock").to_s
file, line = line.split(" ")
file = file.sub(Rails.root.to_s + "/", "")
if file =~ /(es6|js)\z/
puts "@@@@@@@@@ Listen to #{path}/#{watch} #{options}" if @debug
Listen.to("#{path}/#{watch}", options) do |modified, added, _|
puts "@@@@@@@@@@@@ process_change --> #{files}" if @debug
puts "@@@@@@@@@@@@ #{file} matched a reloader for #{runner}" if @debug
if m = k.match(file)
puts "@@@@@@@@@@@@ #{file} matched a watcher for #{runner}" if @debug
spec = v ? (v.arity == 1 ? v.call(m) : v.call) : file
with_line = spec + ":" << line.to_s if spec == file && line
if File.exist?(spec) || Dir.exist?(spec)
puts "@@@@@@@@@@@@ queue_specs --> #{specs}" if @debug
if specs.length == 0
puts "@@@@@@@@@@@@ waiting for the mutex" if @debug
puts "@@@@@@@@@@@@ queueing specs" if @debug
puts "@@@@@@@@@@@@ #{@queue}" if @debug
@queue.delete_if { |_, s, r| s.strip.start_with?(spec.strip) && r == runner }
puts "@@@@@@@@@@@@ specs queued" if @debug
puts "@@@@@@@@@@@@ process_queue" if @debug
if @queue.length == 0
puts "@@@@@@@@@@@@ queue is empty..." if @debug
specs.each { |s| puts s }
def start(opts = {})
lambda { |env|
key = key.to_sym
@email_valid = !!val
!!@failed
) && email_valid && email.present? && user.email != Email.downcase(email)
params = { userKey: uid }
iat: Time.now.to_i,
exp: Time.now.to_i + 60,
headers = { "alg" => "RS256", "typ" => "JWT" }
site: "https://discord.com/api",
extra { { "raw_info" => raw_info } }
@raw_info ||=
.get("users/@me")
user = User.find_by(id: uid.to_i) if uid
if u = User.find_by(id: user_id)
User.update_ip_address!(user_id, new_ip: ip, old_ip: old_ip)
if !is_user_api? && @user_token && @user_token.user == user
def log_on_user(user, session, cookie_jar, opts = {})
if @request.xhr? || api
User.find_by(id: user_id.to_i)
if user && can_write?
parameter_api_patterns.any? { |p| p.match?(env: @env) }
@user_api_key_limiter_60_secs ||=
@user_api_key_limiter_1_day ||=
@auth_token =
params.each { |key, value| public_send "#{key}=", value }
{ id: @id, options: @options }
@archetypes ||= {}
page = 0 if page < 0
asc.present? && asc ? "ASC" : "DESC"
order << "#{without_dir} #{custom_direction}"
query = klass.includes(:totps).order(order.reject(&:blank?).join(","))
levels = trust_levels.map { |key, _| key.to_s }
if ip =
@query.where("ip_address <<= :ip OR registration_ip_address <<= :ip", ip: ip.to_cidr_s)
if Hash === cookie
@items =
.reject { |m| m.name.to_s =~ /=$/ && m.is_attribute? }
.sort_by { |m| m.path }
@list_type = "method"
return if val == nil || val == "t"
sql_query = <<~SQL
)"
DB.exec(<<~SQL, regexp: '\d\.\d\.\d+|\d{3}')
execute(<<~SQL)
CASE WHEN t.value IN ('everyone', 'no_one', 'staff', 'tl1','tl2', 'tl3', 'tl4') THEN 't'
updated_at = NOW();
execute "UPDATE badges SET icon = '#{new_icon}' WHERE id IN (#{badge_ids.join(",")}) AND icon = '#{old_icon}'"
CASE WHEN (name = 'num_auto_bump_daily')
using: "gist",
execute <<~'SQL'
SET value = regexp_replace(value, '\*(\.)?|\?', '', 'g')
WHERE name = '#{old_name}'
result = execute <<~SQL
VALUES ('enable_experimental_hashtag_autocomplete', 5, 'f', now(), now())
VALUES ('navigation_menu', 8, '#{value}', now(), now())
SELECT 'whispers_allowed_groups', '20', '3', created_at, NOW()
WHERE name = 'enable_whispers' AND value = 't'
SET value = array_to_string(array_append(string_to_array(value, '|'), '3'), '|')
NOT '3' = ANY(string_to_array(value, '|'))
execute "UPDATE user_options SET seen_popups = seen_popups || '{3, 4, 5}'"
VALUES('default_composer_category', :setting, '16', NOW(), NOW())",
subquery_sql = <<~SQL
AND iu.redeemed_at > '2022-10-27'
execute "UPDATE user_options SET seen_popups = '{1, 2}'"
execute "UPDATE site_settings SET value = '-1', updated_at = now() WHERE name = 'general_category_id';"
VALUES ('secure_uploads', 5, 't', now(), now())
VALUES ('secure_uploads_allow_embed_images_in_emails', 5, 't', now(), now())
VALUES('personal_message_enabled_groups', :setting, '20', NOW(), NOW())",
new_value = new_tl,
order: {
score: :desc,
SET value = 't'
if allow_staff_to_tag_pms == "t"
default = "1|2|3"
VALUES ('pm_tags_allowed_for_groups', 20, '#{default}', now(), now())"
DB.exec(<<~SQL, group_deleted_id: 99, custom_action_id: 23)
dir.up { execute <<~SQL }
dir.down { execute <<~SQL }
) raw
WHERE raw_upload_id ~ '^\d+$'
VALUES (3, 'external_system_avatars_url', :previous, :new, true, NOW(), NOW(), -1)
VALUES('use_email_for_username_and_name_suggestions', 5, 't', NOW(), NOW())
execute <<~SQL if DB.query_single(<<~SQL).length > 0
) t
bounds << (max + 1)
low_id = min
AND (id >= #{low_id.to_i} AND id < #{high_id.to_i})
low_id = high_id
.map { |row| { id: row.id, token_hash: Digest::SHA256.hexdigest(row.token) } }
break if rows.size == 0
WHERE ((deleted_at IS NULL) AND ((archetype)::text <> 'private_message'::text));
break if count == 0
ON "topics" ("pinned_until")
new_value = new_value > 0 ? new_value * 60 : new_value
DB.exec(<<~SQL, delay: new_value)
VALUES ('pending_users_reminder_delay_minutes', 3, :delay, NOW(), NOW())
upload_ids = DB.query_single(<<~SQL)
( 'likes_received', true, true, 1, 1, 'heart' ),
( 'likes_given', true, true, 2, 2, 'heart' ),
( 'topic_count', true, true, 3, 3, NULL ),
( 'post_count', true, true, 4, 4, NULL ),
( 'topics_entered', true, true, 5, 5, NULL ),
( 'posts_read', true, true, 6, 6, NULL ),
( 'days_visited', true, true, 7, 7, NULL );
smtp_server != '' AND email_username != '' AND email_password != ''
imap_server != '' AND email_username != '' AND email_password != ''
SET topic_id = (payload->>'created_topic_id')::int, target_id = (payload->>'created_post_id')::int, target_type = 'Post'
reversible { |dir| dir.up { DB.exec <<~SQL } }
) b2
b1.id = b2.id
min_id, max_id = DB.query_single(<<~SQL, offset: offset, batch_size: BATCH_SIZE)
END, :min_date)
AND user_stats.user_id >= :min_id
AND user_stats.user_id <= :max_id
min_id: min_id,
max_id: max_id,
key = "#{model}_id"
table = "#{model}_search_data"
SET locale = 'en'
puts "Migrated #{count} rows of #{table} to new locale."
rename_locale(old: "en", new: "en_GB")
rename_locale(old: "en_US", new: "en")
rename_locale(old: "en", new: "en_US")
rename_locale(old: "en_GB", new: "en")
SET locale = '#{new}'
SET value = '#{new}'
WHERE name = 'default_locale' AND value = '#{old}'
WHERE id = #{flag_event_type_id}
updates.each { |id, slug| execute <<~SQL }
SET slug = '#{PG::Connection.escape_string(slug)}'
where: "slug != ''",
:post_id,
where: "name = 'notice'"
where: "name = 'notice_type'"
where: "name = 'notice_args'"
where: "target_type = 'Post'",
topic_timers_to_migrate.map { |tt| "(#{tt.user_id}, #{tt.topic_id})" }.join(", ")
bm.topic_id == tt.topic_id && bm.user_id == tt.user_id && bm.post_number == 1
new_bookmarks << "(#{tt.user_id}, #{tt.topic_id}, #{tt.first_post_id}, '#{tt.execute_at}', 6, '#{now}', '#{now}')"
VALUES #{new_bookmarks.join(",\n")}
.each do |url|
return if urls.size == 0 && sha1s.size == 0
if urls.size > 0
uploads_query << "url IN (#{urls.map { |url| ActiveRecord::Base.connection.quote(url) }.join(",")})"
uploads_query << "sha1 IN (#{sha1s.map { |sha1| ActiveRecord::Base.connection.quote(sha1) }.join(",")})"
SELECT 'selectable_avatars', data_type, '#{upload_ids.join("|")}', created_at, NOW()
WHERE name = '#{old_key}'
WHERE name = '#{new_key}'
updated_at = NOW()
).empty?
.map do |ref|
table, column = ref.split(".")
raw_info = DB.query_hash <<~SQL
schema_hash = {}
next if current_value == "NO"
next if current_value == "0.0"
execute "DELETE FROM tags WHERE id = #{none_tag_id} OR target_tag_id = #{none_tag_id}"
from = dir == "up" ? key : value
to = dir == "up" ? value : key
SET icon = '#{to}'
WHERE icon = '#{from}' OR icon = 'fa-#{from}'
SET flair_icon = '#{to}'
WHERE flair_icon = '#{from}' OR flair_icon = 'fa-#{from}'
DB.exec(<<~SQL, now: Time.zone.now)
last_update_id = -1
AND topics.id > #{last_update_id}
AND posts.id > #{last_update_id}
post_action_bookmarks = DB.query(<<~SQL, type_id: 1)
bookmarks_to_create << "(#{pab.topic_id}, #{pab.post_id}, #{pab.user_id}, '#{now}', '#{now}')"
end # loop
VALUES #{bookmarks_to_create.join(",\n")}
.map { |row| { id: row.id, key_hash: Digest::SHA256.hexdigest(row.key) } }
VALUES #{scores.join(",") << ";"}
to_update << { id: row.id, key_hash: hashed }
) as data(id, key_hash)
) d2
d1.id <> d2.id
execute(<<-SQL)
ids += muted_ids.split("|") if muted_ids.present?
if ids.count <= 10
DB.exec(<<~SQL, muted: 0)
ON u.id = cu.user_id
DB.exec(<<~SQL, value: ids.join("|"))
VALUES ('api_key_last_used_epoch', 1, now(), now(), now())"
JOIN badges ON ('badges.' || LOWER(REPLACE(badges.name, ' ', '_')) || '.name') = translation_overrides.translation_key
DB.exec <<~SQL if current_value && current_value != "1000"
data_type = 7,
data_type = 5,
WHERE groups.#{from} = ANY (string_to_array(site_settings.value, '|', '')#{cast_type})
).first == "t"
SELECT f.user_id, value::int, f.created_at, f.updated_at, 'f'
WHERE name in ('shadow_id', 'master_id')
WHERE name = 'default_locale' AND value = 'en'
SET value = 'en'
WHERE f2.post_id = f.post_id AND f2.name = f.name
name: "post_custom_field_#{field}_idx",
where: "name = '#{field}'"
WHERE (name = 'notice_type' OR name = 'notice_args')
id: :desc,
)::jsonb
min_score = 1.0 if (min_score < 1.0)
9,
default_email_level = 0 if email_direct != "f" && email_always == "t"
default_email_level = 2 if email_direct == "f"
VALUES ('default_email_level', 7, #{default_email_level}, now(), now())"
default_email_messages_level = 0 if email_personal_messages != "f" && email_always == "t"
json_build_object('email', email, 'first_name', first_name, 'last_name', last_name, 'name', name),
SELECT '#{I18n.locale}', 'uncategorized_category_name', name, now(), now()
WHERE name = 'is_welcome_topic' AND value = 'true'
t.id,
p.user_id,
MAX(pa.user_id),
AND pat.name_key <> 'notify_user'
AND p.user_id > 0
1.0 +
), 0),
state - 1,
)::jsonb || post_options::jsonb,
SET value = array_to_string(array_remove(regexp_split_to_array(value, '\\|'), 'google+'), '|')
t.jsonb :info, null: false, default: {}
t.jsonb :extra, null: false, default: {}
AND pa.user_id > 0
SELECT 'sso_provider_secrets', 8, '*|' || value, now(), now()
SET name = name || id
WHERE name = 'enable_s3_backups' AND value = 't';
WHERE name = 'backup_location' AND value = 's3';
if @handled.size > 0
WHERE parent_theme_id NOT IN (#{top_parents.map(&:parent_theme_id).join(", ")})
VALUES (#{top_parent.parent_theme_id}, #{parent.child_theme_id}, now(), now())
SET theme_ids = (
SELECT 'default_theme_id', 3, id, now(), now()
SELECT user_id, 'card_image_badge_id', card_image_badge_id, now(), now()
now(), now()
VALUES ('staff tags', now(), now())
SELECT 3, -1, 'censored_pattern', value, '', true, now(), now()
AND value != ''
execute "UPDATE site_settings SET name='#{new}' where name='#{old}'"
SET value = replace(value, '%{invitee_name}', '%{inviter_name}')
) AS x ON x.user_id = u.id
SELECT id, #{target}, '#{name}', #{value}, created_at, updated_at
ON t.id = tsp.topic_id
OR (t.closed AND tsp.execute_at >= now())
if (enabled_theme_count == 0 && enabled_scheme_id) || enabled_theme_count > 1
VALUES('Default', :now, :now, false, :key, -1)
VALUES('default_theme_key', 1, :key, :now, :now)
limit: 50,
SET logo_url = replace(logo_url, '#{Discourse.asset_host}', '')
, background_url = replace(background_url, '#{Discourse.asset_host}', '')
t.string :secret, default: ""
name: "idx_tag_users_ix1",
name: "idx_tag_users_ix2",
max_likes ||= 50
SET user_id = u.id
AND posts.via_email = 't'
condition = <<~SQL
(action = 16 AND previous_value in ('0','1','2','3','4')) OR
WHERE action > 5 AND id >= #{first_wrong_id} AND id <= #{last_wrong_id}",
VALUES (22, -1, '#{msg}', current_timestamp, current_timestamp)",
cu.id < cu1.id
m.user_id = group_users.user_id)"
p.user_id <> topics.user_id"
execute "UPDATE embeddable_hosts SET host = regexp_replace(host, '^https?:\/\/', '', 'i')"
WHERE s.name = 'embed_category'",
records = val.split("\n")
.each { |s| strings << s.sub("%{count}", "\\d+") }
, post_type = 3
AND (#{strings.map { |s| "raw ~* #{ActiveRecord::Base.connection.quote(s)}" }.join(" OR ")})
text = I18n.t("topic_statuses.#{action_code.gsub(".", "_")}")
execute "UPDATE posts SET action_code = '#{action_code}', raw = '', cooked = '', post_type = 3 where post_type = 2 AND raw = #{ActiveRecord::Base.connection.quote(text)}"
SET value = replace(value, 'like', 'like-count|like')
SET value = 'us-east-1'
where: "not read",
column = "#{period}_op_likes_count"
temp_keys.map! do |key|
if ttl > 0
ttl = "'#{ttl.seconds.ago.strftime("%Y-%m-%d %H:%M:%S")}'"
key.gsub!("temporary_key:", "")
user_id ? "('#{key}', #{user_id}, #{ttl}, #{ttl})" : nil
$do$
now(),
{ liked: 2, bookmarked: 1 }.each do |name, type|
SET #{name} = true
post_action_type_id = #{type})
r = execute <<SQL
SELECT tu.user_id, p.id, 1, coalesce(tu.starred_at, now()), coalesce(tu.starred_at, now())
pa.post_id = p.id AND
set search_data = TO_TSVECTOR('simple', username_lower || ' ' || lower(name))
WHERE name = 'I have read and accept the <a href="/tos" target="_blank">Terms of Service</a>.'
if res.present? && res.cmd_tuples > 0
rename 3, "Leader", "Regular"
rename 4, "Elder", "Leader"
rename 3, "Regular", "Leader"
rename 4, "Leader", "Elder"
SET name = regexp_replace(name, '^basic_', 'tl1_')"
SET name = regexp_replace(name, '^regular_', 'tl2_')"
SET name = regexp_replace(name, '^leader_', 'tl3_')"
flag_ids = "3,4,7,8"
pa.id < pa2.id AND
post_action_type_id IN (#{flag_ids})"
pa.post_id = x.post_id AND
pa.id < x.id AND
FROM incoming_links WHERE referer ~ '^https?://.+'
WHERE d.name = l.domain AND d.https = l.https AND d.port = l.port"
WHERE q.post_id = p.id AND q.quoted_post_id = p1.id
id = 0
WHERE raw like '%quote=%' AND id > #{start_id}
max_id = nil
uniq = {}
topic_id = #{topic_id}"
a = execute <<SQL
) pp ON p1.topic_id = pp.topic_id AND
p1.id <> pp.min_id
uncat_id =
cat_id_r =
email_r =
JOIN posts p ON p.id = l.post_id
lp.post_number::varchar || ',%topic:' ||
if result.first.to_i == 0
execute "INSERT INTO site_settings (name, data_type, value, created_at, updated_at) VALUES ('#{name}', 5, 't', now(), now())"
skip = -1
puts "Destroyed up to id: #{skip}"
.where("id IN (SELECT system_upload_id FROM user_avatars) AND id > ?", skip)
skip == initial ? nil : skip
execute "INSERT INTO site_settings (name, data_type, value, created_at, updated_at) VALUES ('enable_google_logins', 5, 't', now(), now())"
max_badge_id = Badge.order("id DESC").limit(1).first.try(:id)
.where("id > 0 AND id <= 100")
new_id = badge.id + max_badge_id + 100
SET value = replace(value, ',', '|')
;
SET value = replace(value, '|', ',')
JOIN posts p ON p.topic_id = t.id AND p.post_number = 1
add_column :top_topics, "#{period}_score".to_sym, :float
t.integer "#{period}_#{sort}_count".to_sym, null: false, default: 0
add_index :top_topics, "#{period}_#{sort}_count".to_sym, order: "desc"
execute "UPDATE posts SET word_count = COALESCE(array_length(regexp_split_to_array(raw, ' '),1), 0) WHERE id IN (#{post_ids.join(",")})"
VALUES ('#{name}', '0088CC', 'uncategorized', '', 'FFFFFF', -1, now(), now(), 0 )
VALUES ('uncategorized_category_id', 3, #{category_id}, now(), now())"
return unless is_local?(url) || is_on_s3?(url)
@local_optimized_base_url ||= "#{local_base_url}/_optimized"
@local_avatar_base_url ||= "#{local_base_url}/avatars"
@s3_avatar_base_url ||= "#{s3_base_url}/avatars"
url.starts_with?(local_base_url) && !is_local_thumbnail?(url) && !is_local_avatar?(url)
def is_on_s3?(url)
url.starts_with?(s3_base_url) && !is_s3_avatar?(url)
|| '_'
|| oi.width
|| 'x'
|| oi.height
|| substring(oi.url from '\\.\\w{3,4}$')
WHERE user_id = users.id AND created_at <= users.last_seen_at), 0)"
|| '_optimized/'
|| substring(oi.sha1 for 3) || '/'
|| substring(oi.sha1 from 4 for 3) || '/'
(ip >> 24 & 255) || '.' ||
(ip >> 16 & 255) || '.' ||
);"
a.user_id,
) as Y
Z.user_id = u.id
.order("id")
.each do |c|
.each do |tl|
to_remove << tl.id
TopicLink.where("id in (?)", to_remove).delete_all
where calc <> p.post_number and X.id = p.id",
add_column :users, :avatar_url, :string, null: false, default: ""
add_index :email_logs, :created_at, order: { created_at: :desc }
add_index :forum_threads, :bumped_at, order: { bumped_at: :desc }
AND posts.post_type = 2)"
t.integer :ip, null: false, limit: 8
) as c
where pp.id = c.id and pp.post_number <> c.real_number"
execute "update users set email= md5(random()::text) || 'domain.com'"
(1..5).each do |i|
t.integer :ip, limit: 8, null: false
add_column :users, :bio, :text
{ name: I18n.t("color_schemes.dark"), base_scheme_id: "Dark" },
{ name: I18n.t("color_schemes.wcag"), base_scheme_id: "WCAG" },
{ name: I18n.t("color_schemes.wcag_dark"), base_scheme_id: "WCAG Dark" },
{ name: I18n.t("color_schemes.dracula"), base_scheme_id: "Dracula" },
-1 => "d-logo-sketch.png", # Old version.
-2 => "d-logo-sketch-small.png", # Old version.
-3 => "default-favicon.ico", # No longer used.
-5 => "discourse-logo-sketch.png",
-6 => "discourse-logo-sketch-small.png",
}.each do |id, filename|
upload.url = "/images/#{filename}"
user = User.find_by("id <> -1 and username_lower = 'system'")
ue.id = -1
ue.email = "no_email"
ue.user_id = -1
u.id = -1
u.name = "system"
ue.id = 0
ue.user_id = 0
.seed do |u|
u.id = 0
u.name = "smoke_user"
b.name = "topic"
b.name = "post"
b.name = "user"
b.name = "group"
b.name = "category"
b.name = "tag"
b.name = "solved"
b.name = "assign"
b.name = "user_badge"
b.name = "group_user"
b.name = "like"
g.name = "Community"
g.name = "Posting"
g.name = "Trust Level"
g.name = "Other"
) OR (id < 100 AND badge_grouping_id = #{BadgeGrouping::Other})
b.id = id
b.name = name
b.default_icon = "fa-user"
b.id = Badge::Reader
b.name = "Reader"
b.name = "First Link"
b.default_icon = "link"
b.name = "First Quote"
b.name = "First Like"
b.name = "First Flag"
b.default_icon = "flag"
b.name = "First Share"
b.name = "Welcome"
b.id = Badge::Editor
b.name = "Editor"
b.default_icon = "pen"
b.name = "Wiki Editor"
b.query = nil
b.default_icon = "at"
b.name = "First Emoji"
b.name = "First Onebox"
b.default_icon = "cube"
b.name = "New User of the Month"
b.default_icon = "far-eye"
.where("NOT system AND id < 100")
.each do |badge|
b.id = 1
b.name = "Gold"
b.id = 2
b.name = "Silver"
b.id = 3
b.name = "Bronze"
s.id = 1
s.ip_address = "10.0.0.0/8"
s.id = 2
s.ip_address = "192.168.0.0/16"
s.id = 3
s.ip_address = "127.0.0.0/8"
s.id = 4
s.ip_address = "172.16.0.0/12"
s.id = 5
s.ip_address = "fc00::/7"
s.name_key = "like"
s.icon = "heart"
s.name_key = "off_topic"
s.is_flag = true
s.name_key = "spam"
s.name_key = "notify_user"
if g = Group.find_by(name: "trust_level_5", id: 15)
discourse_path = File.expand_path(File.expand_path(File.dirname(__FILE__)) + "/../")
rss =
rss ||= 0
rss * 1024
info = `ps -eo pid,rss,args | grep sidekiq | grep -v grep | awk '{print $1,$2}'`
pid, mem = row.split(" ").map(&:to_i)
if pid > 0 && (mem * 1024) > max_allowed_sidekiq_rss
(rss || 0) * 1024
def patch(*)
scope path: nil, constraints: { format: %r{(json|html|\*/\*)} } do
get "/404-body" => "exceptions#not_found_body"
scope path: nil, format: true, constraints: { format: :xml } do
get "/news" => "sitemap#news"
scope path: nil, constraints: { format: /.*/ } do
mount Sidekiq::Web => "/sidekiq"
mount Logster::Web => "/logs"
get "pub/:slug" => "published_pages#show"
get "site" => "site#site"
get "site/basic-info" => "site#basic_info"
get "srv/status" => "forums#status"
get "wizard" => "wizard#index"
get "wizard/steps" => "steps#index"
get "wizard/steps/:id" => "wizard#index"
put "wizard/steps/:id" => "steps#update"
get "" => "admin#index"
get "plugins" => "plugins#index"
collection { get "category/:id" => "site_settings#index" }
get "reports" => "reports#index"
get "reports/bulk" => "reports#bulk"
get "reports/:type" => "reports#show"
get "list" => "users#index"
get "list/:query" => "users#index"
get "ip-info" => "users#ip_info"
get "users/:id.json" => "users#show", :defaults => { format: "json" }
get "users/:id/:username" => "users#show",
:as => :user_show
get "users/:id/:username/badges" => "users#show"
get "sent"
get "/incoming/:id/raw" => "email#raw_email"
get "/incoming/:id" => "email#incoming"
scope "/logs" do
get "search_logs/term/" => "search_logs#term"
get "/logs" => "staff_action_logs#index"
get "preview" => "themes#preview"
post "import" => "themes#import"
get "themes/:id/:target/:field_name/edit" => "themes#index"
get "themes/:id" => "themes#index"
get "themes/:id/export" => "themes#export"
get "site_texts" => "site_texts#index"
delete "site_texts/:id.json" => "site_texts#revert",
post "reseed" => "site_texts#reseed"
put "email_templates/(:id)" => "email_templates#update",
get "robots" => "robots_txt#show"
put "robots.json" => "robots_txt#update"
get "email_style/:field" => "email_styles#show", :constraints => { field: /html|css/ }
get "action/:id" => "watched_words#index"
collection { get "scopes" => "api#scopes" }
post "revoke" => "api#revoke_key"
post "undo-revoke" => "api#undo_revoke_key"
get "web_hook_events/:id" => "web_hooks#list_events", :as => :web_hook_events
post "web_hooks/:id/ping" => "web_hooks#ping"
get "" => "backups#show", :constraints => { id: RouteFormat.backup }
put "" => "backups#email", :constraints => { id: RouteFormat.backup }
delete "" => "backups#destroy", :constraints => { id: RouteFormat.backup }
post "restore" => "backups#restore", :constraints => { id: RouteFormat.backup }
:format => :json
get "logs" => "backups#logs"
get "status" => "backups#status"
get "/award/:badge_id" => "badges#award"
post "/award/:badge_id" => "badges#mass_award"
get "types" => "badges#badge_types"
get "review/:reviewable_id" => "reviewables#show", :constraints => { reviewable_id: /\d+/ }
reviewable_id: /\d+/,
put "review/:reviewable_id" => "reviewables#update", :constraints => { reviewable_id: /\d+/ }
get "session/sso" => "session#sso"
get "session/csrf" => "session#csrf"
post "login" => "static#enter"
get "login" => "static#show", :id => "login"
get "password-reset" => "static#show", :id => "password_reset"
get "faq" => "static#show", :id => "faq"
get "tos" => "static#show", :id => "tos", :as => "tos"
get "privacy" => "static#show", :id => "privacy", :as => "privacy"
get "signup" => "static#show", :id => "signup"
get "login-preferences" => "static#show", :id => "login"
get faq_alias => "static#show", :id => "guidelines", :as => faq_alias
get "my/*path", to: "users#my_redirect"
get "user-cards" => "users#cards", :format => :json
get "#{root_path}" => "users#index", :constraints => { format: "html" }
post "#{root_path}/email-login" => "users#email_login"
get "#{root_path}/admin-login" => "users#admin_login"
put "#{root_path}/admin-login" => "users#admin_login"
post "#{root_path}/toggle-anon" => "users#toggle_anon"
post "#{root_path}/read-faq" => "users#read_faq"
format: "json",
get "#{root_path}/search/users" => "users#search_users"
{ "#{root_path}/account-created/" => "users#account_created" }.merge(
index == 1 ? { as: :users_account_created } : { as: :old_account_created },
{ "#{root_path}/password-reset/:token" => "users#password_reset_show" }.merge(
index == 1 ? { as: :password_reset_token } : {},
index == 1 ? { as: "perform_activate_account" } : {},
}.merge(index == 1 ? { as: "confirm_admin" } : {}),
post "#{root_path}/confirm-admin/:token" => "users#confirm_admin",
get "#{root_path}/:username.json" => "users#show",
:defaults => {
}.merge(index == 1 ? { as: "user" } : {}),
put "#{root_path}/:username" => "users#update",
get "#{root_path}/:username/emails" => "users#check_emails",
get "#{root_path}/:username/sso-email" => "users#check_sso_email",
get "#{root_path}/:username/sso-payload" => "users#check_sso_payload",
get "#{root_path}/:username/staff-info" => "users#staff_info",
get "#{root_path}/:username/summary" => "users#summary",
get "#{root_path}/:username/invited" => "users#invited",
get "#{root_path}/:username/invited/:filter" => "users#invited",
get "#{root_path}/:username/summary" => "users#show",
:format => :rss,
get "#{root_path}/:username/activity.rss" => "posts#user_posts_feed",
get "#{root_path}/:username/activity.json" => "posts#user_posts_feed",
get "#{root_path}/:username/activity" => "users#show",
get "#{root_path}/:username/activity/:filter" => "users#show",
get "#{root_path}/:username/badges" => "users#badges",
get "#{root_path}/:username/bookmarks" => "users#bookmarks",
format: /(json|ics)/,
get "#{root_path}/:username/notifications" => "users#show",
delete "#{root_path}/:username" => "users#destroy",
get "#{root_path}/by-external/:external_id" => "users#show",
get "#{root_path}/:username/flagged-posts" => "users#show",
get "#{root_path}/:username/deleted-posts" => "users#show",
get "#{root_path}/:username/card.json" => "users#show_card",
size: /\d+/,
format: :png,
version: /\h{40}/,
format: :js,
:format => false,
get "svg-sprite/:hostname/icon(/:color)/:name.svg" => "svg_sprite#svg_icon",
color: /(\h{3}{1,2})/,
format: :svg,
format: /css\.map/,
:format => true
format: "css",
digest: /\h{40}/,
format: :map,
get "uploads/:site/:sha(.:extension)" => "uploads#show",
site: /\w+/,
sha: /\h{40}/,
:as => :upload_short
get "uploads/:site/original/:tree:sha(.:extension)" => "uploads#show",
index: /\d+/,
get "uploads/:site/:id/:sha" => "uploads#show",
id: /\d+/,
sha: /\h{16}/,
format: /.*/,
get "posts" => "posts#latest", :id => "latest_posts", :constraints => { format: /(json|rss)/ }
get "private-posts" => "posts#latest",
:id => "private_posts",
format: /(json|rss)/,
get "posts/by-date/:topic_id/:date" => "posts#by_date"
get "posts/:id/reply-ids" => "posts#reply_ids"
get "posts/:id/reply-ids/all" => "posts#all_reply_ids"
get "posts.rss" => "groups#posts_feed", :format => :rss
get "mentions.rss" => "groups#mentions_feed", :format => :rss
get "logs" => "groups#histories"
get "check-name" => "groups#check_name"
get "search" => "groups#search"
put "owners" => "groups#add_owners"
put "join" => "groups#join"
delete "leave" => "groups#leave"
put "wiki"
get "revisions/:revision" => "posts#revisions", :constraints => { revision: /\d+/ }
put "revisions/:revision/hide" => "posts#hide_revision", :constraints => { revision: /\d+/ }
put "revisions/:revision/show" => "posts#show_revision", :constraints => { revision: /\d+/ }
put "revisions/:revision/revert" => "posts#revert", :constraints => { revision: /\d+/ }
token: /\h{32}/,
get "excerpt" => "excerpt#show"
get "/badges/:id(/:slug)" => "badges#show", :constraints => { format: /(json|html|rss)/ }
put "toggle_favorite" => "user_badges#toggle_favorite", :constraints => { format: :json }
get "/c", to: redirect(relative_url_root + "categories")
post "/move" => "categories#move"
put "/slug" => "categories#update_slug"
get "c/:id/show" => "categories#show"
get "c/*category_slug/edit(/:tab)" => "categories#find_by_slug",
format: "html",
get "/new-category" => "categories#show", :constraints => { format: "html" }
get "c/*category_slug_path_with_id.rss" => "list#category_feed", :format => :rss
get "/none" => "list#category_none_latest"
get "/none/l/top/#{period}", to: redirect("/none/l/top?period=#{period}", status: 301)
get "/l/top/#{period}", to: redirect("/l/top?period=#{period}", status: 301)
get "/none/l/#{filter}" => "list#category_none_#{filter}", :as => "category_none_#{filter}"
get "/l/#{filter}" => "list#category_#{filter}", :as => "category_#{filter}"
get "/all" => "list#category_default",
:as => "category_all",
get "/" => "list#category_default", :as => "category_default"
get "top/#{period}.rss", to: redirect("top.rss?period=#{period}", status: 301)
get "top/#{period}.json", to: redirect("top.json?period=#{period}", status: 301)
get "top/#{period}", to: redirect("top?period=#{period}", status: 301)
get "#{filter}.rss" => "list##{filter}_feed", :format => :rss
Discourse.filters.each { |filter| get "#{filter}" => "list##{filter}" }
get "filter" => "list#filter"
get "search/query" => "search#query"
get "search" => "search#show"
get "t/:id" => "topics#show"
put "t/:topic_id" => "topics#update", :constraints => { topic_id: /\d+/ }
delete "t/:id" => "topics#destroy"
put "t/:id/move-to-inbox" => "topics#move_to_inbox"
put "t/:id/publish" => "topics#publish"
put "t/:id/reset-bump-date" => "topics#reset_bump_date"
get "created-by/:username" => "list#topics_by",
:as => "topics_by",
:as => "topics_private_messages",
get "groups/:group_name" => "list#group_topics",
:as => "group_topics",
get "embed/topics" => "embed#topics"
get "embed/count" => "embed#count"
get "embed/info" => "embed#info"
get "new-topic" => "new_topic#index"
get "new-message" => "new_topic#index"
get "t/id_for/:slug" => "topics#id_for_slug"
get "t/:slug/:topic_id/print" => "topics#show",
:format => :html,
:print => "true",
topic_id: /\d+/,
get "t/:slug/:topic_id/wordpress" => "topics#wordpress", :constraints => { topic_id: /\d+/ }
get "t/:topic_id/wordpress" => "topics#wordpress", :constraints => { topic_id: /\d+/ }
get "t/:slug/:topic_id/summary" => "topics#show",
get "t/:topic_id/summary" => "topics#show", :constraints => { topic_id: /\d+/ }
put "t/:slug/:topic_id" => "topics#update", :constraints => { topic_id: /\d+/ }
put "t/:slug/:topic_id/star" => "topics#star", :constraints => { topic_id: /\d+/ }
put "t/:topic_id/star" => "topics#star", :constraints => { topic_id: /\d+/ }
put "t/:slug/:topic_id/status" => "topics#status", :constraints => { topic_id: /\d+/ }
put "t/:topic_id/status" => "topics#status", :constraints => { topic_id: /\d+/ }
put "t/:topic_id/clear-pin" => "topics#clear_pin", :constraints => { topic_id: /\d+/ }
put "t/:topic_id/re-pin" => "topics#re_pin", :constraints => { topic_id: /\d+/ }
put "t/:topic_id/mute" => "topics#mute", :constraints => { topic_id: /\d+/ }
put "t/:topic_id/unmute" => "topics#unmute", :constraints => { topic_id: /\d+/ }
post "t/:topic_id/timer" => "topics#timer", :constraints => { topic_id: /\d+/ }
put "t/:topic_id/make-banner" => "topics#make_banner", :constraints => { topic_id: /\d+/ }
put "t/:topic_id/remove-banner" => "topics#remove_banner", :constraints => { topic_id: /\d+/ }
put "t/:topic_id/recover" => "topics#recover", :constraints => { topic_id: /\d+/ }
get "t/:topic_id/:post_number" => "topics#show",
post_number: /\d+/,
get "t/:topic_id/last" => "topics#show",
:post_number => 99_999_999,
get "t/:slug/:topic_id.rss" => "topics#feed",
get "t/:slug/:topic_id" => "topics#show", :constraints => { topic_id: /\d+/ }
get "t/:slug/:topic_id/:post_number" => "topics#show",
get "t/:slug/:topic_id/last" => "topics#show",
get "t/:topic_id/posts" => "topics#posts", :constraints => { topic_id: /\d+/ }, :format => :json
get "t/:topic_id/post_ids" => "topics#post_ids",
get "t/:topic_id/excerpts" => "topics#excerpts",
post "t/:topic_id/timings" => "topics#timings", :constraints => { topic_id: /\d+/ }
post "t/:topic_id/invite" => "topics#invite", :constraints => { topic_id: /\d+/ }
post "t/:topic_id/invite-group" => "topics#invite_group", :constraints => { topic_id: /\d+/ }
post "t/:topic_id/move-posts" => "topics#move_posts", :constraints => { topic_id: /\d+/ }
post "t/:topic_id/merge-topic" => "topics#merge_topic", :constraints => { topic_id: /\d+/ }
delete "t/:topic_id/timings" => "topics#destroy_timings", :constraints => { topic_id: /\d+/ }
put "t/:topic_id/bookmark" => "topics#bookmark", :constraints => { topic_id: /\d+/ }
put "t/:topic_id/tags" => "topics#update_tags", :constraints => { topic_id: /\d+/ }
put "t/:topic_id/slow_mode" => "topics#set_slow_mode", :constraints => { topic_id: /\d+/ }
get "p/:post_id(/:user_id)" => "posts#short_link"
get "/posts/:id/cooked" => "posts#cooked"
get "/posts/:id/expand-embed" => "posts#expand_embed"
get "/posts/:id/raw" => "posts#markdown_id"
get "/posts/:id/raw-email" => "posts#raw_email"
get "raw/:topic_id(/:post_number)" => "posts#markdown_num"
get "/invites/:id" => "invites#show", :constraints => { format: :html }
put "/invites/:id" => "invites#update"
get "onebox" => "onebox#show"
get "exception" => "list#latest"
get "/service-worker.js" => "static#service_worker_asset", :format => :js
get "cdn_asset/:site/*path" => "static#cdn_asset",
get "brotli_asset/*path" => "static#brotli_asset",
get "favicon/proxied" => "static#favicon", :format => false
get "robots.txt" => "robots_txt#index"
get "opensearch" => "metadata#opensearch", :constraints => { format: :xml }
scope "/tag/:tag_id" do
get "/" => "tags#show", :as => "tag_show"
get "/info" => "tags#info"
put "/" => "tags#update"
delete "/" => "tags#destroy"
get "/l/#{filter}" => "tags#show_#{filter}", :as => "tag_show_#{filter}"
get "/" => "tags#tag_feed"
scope "/tags" do
get "/" => "tags#index"
get "/filter/list" => "tags#index"
get "/filter/search" => "tags#search"
post "/upload" => "tags#upload"
get "/unused" => "tags#list_unused"
get "/none/:tag_id/l/#{filter}" => "tags#show_#{filter}",
:as => "tag_category_none_show_#{filter}",
get "/all/:tag_id/l/#{filter}" => "tags#show_#{filter}",
:as => "tag_category_all_show_#{filter}",
get "/none/:tag_id" => "tags#show",
:as => "tag_category_none_show",
get "/all/:tag_id" => "tags#show",
:as => "tag_category_all_show",
get "/:tag_id/l/#{filter}" => "tags#show_#{filter}",
:as => "tag_category_show_#{filter}"
get "/:tag_id" => "tags#show", :as => "tag_category_show"
get "/intersection/:tag_id/*additional_tag_ids" => "tags#show", :as => "tag_intersection"
get "*tag_id", to: redirect(relative_url_root + "tag/%{tag_id}")
get "/tag_groups/filter/search" => "tag_groups#search", :format => :json
root to: "list##{filter}",
as: "list_#{filter}"
get "/user-api-key/new" => "user_api_keys#new"
post "/user-api-key" => "user_api_keys#create"
post "/user-api-key/revoke" => "user_api_keys#revoke"
get "/user-api-key/otp" => "user_api_keys#otp"
post "/user-api-key/otp" => "user_api_keys#create_otp"
get "/safe-mode" => "safe_mode#index"
post "/safe-mode" => "safe_mode#enter", :as => "safe_mode_enter"
get "/theme-qunit" => "qunit#theme"
post "/do-not-disturb" => "do_not_disturb#create"
get "/presence/get" => "presence#get"
get "user-status" => "user_status#get"
put "user-status" => "user_status#set"
stdout_redirect "#{APP_ROOT}/log/puma.log", "#{APP_ROOT}/log/puma.err.log"
start_path = ::Rails.root.join("app/assets").to_s
filename.start_with?(start_path) && !filename.include?("/node_modules/") &&
.each { |file| Rails.application.config.assets.precompile << "#{file}.js" }
drop_from: "2.8",
next if db == "default"
ip =
{ ip: ip, username: username }
output = {
if !Dir.glob(File.join(Rails.root, "public", "assets", "application*.js")).present?
def initialize(app, opts = {})
path_info.start_with?("/logs") || path_info.start_with?("/user_avatar") ||
Dir.glob("#{Rails.root}/app/jobs/scheduled/*.rb") { |f| require(f) } if Rails.env.development?
key: "_forum_session",
/(?m).*?Line: (?:\D|0).*?Column: (?:\D|0)/,
/^(Syntax|Script) error.*Line: (0|1)\b/m,
if (error_rate_per_minute || 0) > 0
{ rate: rate, duration: "minute", publish_at: Time.current.to_i },
if (error_rate_per_hour || 0) > 0
{ rate: rate, duration: "hour", publish_at: Time.current.to_i },
{ path: Rails.root.to_s, url: "https://github.com/discourse/discourse", main_app: true },
path: "#{Rails.root.to_s}/plugins/#{plugin.directory_name}",
if name == :must_approve_users && new_value == true
.where(r: { id: nil })
if name == :emoji_set
before = "/images/emoji/#{old_value}/"
after = "/images/emoji/#{new_value}/"
like: "%#{before}%",
if new_value == true &&
if new_value == false &&
DiscourseEvent.on(:topic_created) do |topic, _, _|
group_ids = user.groups.map(&:id)
@global_origins = GlobalSetting.cors_origin.split(",").map { |x| x.strip.chomp("/") }
id = id.to_s
user_id = user && user.id
is_admin = !!(user && user.admin?)
if Rails.env == "test" || $0 =~ /rake$/
Rails.logger.warn "#{e.class} #{e.message}: #{e.backtrace.join("\n")}"
@trace_filename = "#{TRACE_DIR}/#{Process.pid}_#{self.object_id}.txt"
define_method(method) { |*args, &blk| log_access { send(new_method, *args, &blk) } }
.to(*paths, only: /\.rb$/) do |modified, added, removed|
STDERR.puts not_autoloaded.map { |path| "- #{path}".indent(7) }.join("\n")
config.public_file_server.headers = { "Access-Control-Allow-Origin" => "*" }
(defined?(Rails::Server) || defined?(Puma) || defined?(Unicorn))
n = 1
port = 10_000 + n
Process.spawn("redis-server --dir tmp/test_data_#{n}/redis --port #{port}", out: "/dev/null")
require File.expand_path("../boot", __FILE__)
Dir.glob(File.join(File.dirname(__FILE__), "../plugins", "*", "register_provider.rb")) do |p|
if GlobalSetting.try(:cdn_url).present? && GlobalSetting.cdn_url !~ %r{^https?://}
config.autoload_paths << "#{root}/lib"
config.autoload_paths << "#{root}/lib/i18n"
word_matcher_regexp_list(action).map { |r| { r.source => { case_sensitive: !r.casefold? } } }
regexps = grouped_words.select { |_, w| w.present? }.transform_values { |w| w.join("|") }
regexp = "(#{regexp})"
regexps.map { |c, regexp| Regexp.new(regexp, c == :case_sensitive ? nil : Regexp::IGNORECASE) }
regexp = "(#{regexp})" if whole
regexp = Regexp.escape(word).gsub("\\*", '\S*')
regexp = "(?:\\W|^)(#{regexp})(?=\\W|$)"
if Array === m
set.add(m.find(&:present?))
elsif String === m
set.add(m)
).match?(@raw)
.reduce(text) do |t, (word_regexp, attrs)|
escaped_url = Regexp.escape(url).sub("\\*", '\S*')
url_regex = Regexp.new("\\A#{escaped_url}\\z", "i")
domain_regex = Regexp.new("\\A#{escaped_domain}\\z", "i")
def emit!(headers:, body:)
request: {
if error.is_a?(Faraday::Error) &&
if @actor && @old_username != @new_username
user_id:,
attrs.push("day_#{n}_start_time".to_sym)
attrs.push("day_#{n}_end_time".to_sym)
old_user_name = user.name.present? ? user.name : ""
(!save_options || user.user_option.save) &&
if saved && (name_changed && old_user_name.casecmp(attributes.fetch(:name)) != 0)
attributes.fetch(:name) { "" },
usernames ||= ""
MutedUser.where("user_id = ? AND muted_user_id not in (?)", user.id, desired_ids).destroy_all
DB.exec(<<~SQL, now: Time.now, user_id: user.id, desired_ids: desired_ids)
SELECT :user_id, id, :now, :now
DB.exec(<<~SQL, now: Time.zone.now, user_id: user.id, desired_ids: desired_ids)
website =~ /\Ahttp/ ? website : "http://#{website}"
def set!(user_stat:, count:, count_column:)
stat = user_stat || post.user&.user_stat
if action == :decrement! && stat.public_send(column) < 1
def initialize(user, by_user = nil, opts = {})
@user, @by_user, @opts = user, by_user, opts
def self.silence(user, by_user = nil, opts = {})
def self.unsilence(user, by_user = nil, opts = {})
.where("created_at > ?", 24.hours.ago)
.where(user_id: @user.id, post_number: 1)
ends_at: (local_time - 1.day).end_of_day.utc,
if days == 0
).utc
wday == 0 ? 6 : wday - 1
@instance ||=
.pluck(:topic_id, :id)
if last_topic_id != current_topic_id && post_ids.any?
SET msecs = LEAST(t.msecs::bigint + s.msecs, 2^31 - 1)
DB.exec(<<~SQL, target_user_id: @target_user.id)
WHERE t.id = :target_user_id AND s.id = :source_user_id
conditions: "x.user_id = y.user_id",
update_user_id(:tag_users, conditions: "x.tag_id = y.tag_id")
conditions: "x.email = y.email OR y.primary = false",
updates: '"primary" = false',
def update_user_id(table_name, opts = {})
builder = DB.build(<<~SQL)
/*set*/
builder.set("#{user_id_column_name} = :target_user_id")
updates.each { |u| builder.set(u) }
builder.where("y.#{user_id_column_name} = :target_user_id")
conditions.each { |c| builder.where(c) }
def destroy(user, opts = {})
).update_all(
if @actor == user
.find_each do |link|
bio_raw: nil,
acting_user_id: @actor ? @actor.id : @user.id,
.reject { |a| a.user_id == topic.user_id }
.each do |ta|
row = row.dup
rows << row
if ta.user_id == post.user_id
@id = user_id
def update!(status, enabled, opts = {})
def change(status, opts = {})
result = false if rc == 0
rc =
(status.enabled? && (status.autoclosed? || status.closed? || status.archived?)) ||
I18n.t("#{locale_key}_days", count: (num_minutes.minutes / 1.day).round)
if num_hours >= 2
I18n.t("#{locale_key}_hours", count: num_hours)
def options_for(status, opts = {})
define_method("#{status}?") { name == status }
(closed? || autoclosed?) && disabled?
(closed? || autoclosed?) && enabled?
closed? && enabled?
closed? && disabled?
.where("topic_users.user_id = ?", user.id)
AND (t.deleted_at < :grace_time)
counts = { installed: 0, updated: 0, errors: 0, skipped: 0 }
log << "#{name}: is already installed. Skipping update."
log << "#{name}: installed from #{installer.url}"
log << "#{name}: #{err.message}"
@url = url_or_options.fetch(:url, nil)
@url.gsub(Regexp.union("git@github.com:", "https://github.com/", ".git"), "")
.where("remote_url like ?", "%#{repo_name}%")
@theme =
@url,
tag =
) if tag.is_a?(Hash)
.map { |tag| tag_to_hashtag_item(tag, guardian) }
tags_with_counts, _ =
details = USER_FIELDS.map { |x| "#{x}: #{deleted_user.public_send(x)}" }.join("\n")
details ||= {}
details: details.join("\n"),
user = topic.user ? "#{topic.user.username} (#{topic.user.name})" : "(deleted user)"
details << "raw: #{first_post.raw}"
def log_lock_trust_level(user, opts = {})
def log_post_lock(post, opts = {})
def log_post_edit(post, opts = {})
def log_topic_closed(topic, opts = {})
def log_topic_archived(topic, opts = {})
def log_post_staff_note(post, opts = {})
old.each do |k, v|
next if k == "name"
next if k == "id"
def log_theme_change(old_json, new_theme, opts = {})
def log_theme_destroy(theme, opts = {})
subject: "#{theme.name}: #{setting_name.to_s}",
def log_site_text_change(subject, new_text = nil, old_text = nil, opts = {})
def log_name_change(user_id, old_name, new_name, opts = {})
def log_user_suspend(user, reason, opts = {})
def log_user_unsuspend(user, opts = {})
.select { |f, v| v.present? }
.map { |f, v| "#{f}: #{v}" }
def log_badge_grant(user_badge, opts = {})
def log_badge_revoke(user_badge, opts = {})
def log_title_revoke(user, opts = {})
def log_title_change(user, opts = {})
def log_check_email(user, opts = {})
def log_show_emails(users, opts = {})
def log_impersonate(user, opts = {})
def log_roll_up(subnet, ips, opts = {})
details: "#{subnet} from #{ips.join(", ")}",
def log_silence_user(user, opts = {})
def log_unsilence_user(user, opts = {})
def log_grant_admin(user, opts = {})
def log_revoke_admin(user, opts = {})
def log_backup_create(opts = {})
def log_entity_export(entity, opts = {})
def log_revoke_email(user, reason, opts = {})
def log_user_approve(user, opts = {})
def log_user_activate(user, reason, opts = {})
def log_wizard_step(step, opts = {})
def log_post_approved(post, opts = {})
def log_web_hook(web_hook, action, opts = {})
context: details.join(", "),
previous_value: old_values&.join(", "),
new_value: new_values&.join(", "),
def log_api_key(api_key, action, opts = {})
details: details.join(", "),
.sort_by { |k, _| k.to_s }
urls = section.sidebar_urls.map { |url| "#{url.name} - #{url.value}" }
!first_post.user.staff? && !@post.user.staff? && !first_post.user.staged? &&
!@post.user.staged? && @post.user != first_post.user &&
@post.user.ip_address == first_post.user.ip_address && @post.user.new_user? &&
result = DB.query(<<~SQL, params)
post_id: @post&.id,
counts = { updated: 0, not_found: 0, errors: 0 }
if h.has_key?(key)
log << "Changed #{key} FROM: #{result.previous_value} TO: #{result.new_value}"
log << "ERROR: #{e.message}"
klass.where(name: previous_value.split("|")).pluck(:id),
klass.where(name: new_value.split("|")).pluck(:id),
AND sidebar_section_links.linkable_id IN (#{@added_ids.join(",")})
tag_ids =
def self.update_index(table:, id:, a_weight: nil, b_weight: nil, c_weight: nil, d_weight: nil)
raw_data = { a: a_weight, b: b_weight, c: c_weight, d: d_weight }
search_data = raw_data.transform_values { |data| Search.prepare_data(data || "", :index) }
table_name = "#{table}_search_data"
foreign_key = "#{table}_id"
stemmer = table == "user" ? "simple" : Search.ts_config
ranked_index = <<~SQL
setweight(to_tsvector('#{stemmer}', #{Search.wrap_unaccent("coalesce(:a,''))")}, 'A') ||
setweight(to_tsvector('#{stemmer}', #{Search.wrap_unaccent("coalesce(:b,''))")}, 'B') ||
setweight(to_tsvector('#{stemmer}', #{Search.wrap_unaccent("coalesce(:c,''))")}, 'C') ||
setweight(to_tsvector('#{stemmer}', #{Search.wrap_unaccent("coalesce(:d,''))")}, 'D')
if lexeme !~ /\A(\d+\.)?(\d+\.)*(\*|\d+)\z/
term, _, remaining = lexeme.partition(".")
array << "'#{remaining}':#{positions}"
additional_words.map { |term, _| term }.join(" "),
.map do |term, _, indexes|
tsvector = "#{tsvector} #{additional_lexemes.join(" ")} #{extra_domain_word_terms}"
.each do |term, _, indexes|
.each do |index|
reduced << "#{term.strip}#{new_index_array.join(",")}"
tsvector = reduced.join(" ")
if table.to_s == "post"
search_data.values.select { |d| d.length > 0 }.join(" ")
table: "topic",
post_id:,
table: "post",
table: "user",
if Topic === obj
elsif Post === obj
tags = topic.tags.select(:id, :name).to_a
(tags.map(&:name) + Tag.where(target_tag_id: tags.map(&:id)).pluck(:name)).join(" ")
if Post === obj && obj.raw.present? &&
post_id: obj.id,
if User === obj && (obj.saved_change_to_username? || obj.saved_change_to_name? || force)
obj.username_lower || "",
obj.name ? obj.name.downcase : "",
if Topic === obj && (obj.saved_change_to_title? || force)
if Category === obj && (obj.saved_change_to_name? || force)
if Tag === obj && (obj.saved_change_to_name? || force)
raw_data.scan(Discourse::Utils::URI_REGEXP) { urls << $& }
raw_data.gsub!(url, I18n.t("search.video"))
raw_data.gsub!(url, I18n.t("search.audio"))
@scrubbed = +""
return +"" if html.blank?
document = Nokogiri.HTML5("<div>#{html}</div>", nil, Encoding::UTF_8.to_s)
return +""
elsif child_node.name == "a"
document.css("img.emoji").each { |node| node.remove_attribute("alt") }
scrubbed << " #{str} "
).call
results.map!(&:to_i)
if left > 0
if !File.exist?(
__dir__,
p256dh = parsed_data.dig("keys", "p256dh")
auth = parsed_data.dig("keys", "auth")
if (endpoint.blank? || p256dh.blank? || auth.blank?)
vapid: {
if post ==
AND (t.deleted_at < :grace_time OR p.deleted_at < :grace_time)
def self.post_created(post, opts = {})
def self.post_edited(post, opts = {})
excerpt ||
.where("user_api_key_scopes.name IN ('push', 'notifications')")
.order(client_id: :asc)
.pluck(:client_id, :push_url)
user.blank? || user.bot? || user.id == post.user_id
@all_allowed_users ||= post.topic.all_allowed_users.reject { |u| not_allowed?(u, post) }
@allowed_users ||= post.topic.allowed_users.reject { |u| not_allowed?(u, post) }
users.select { |u| all_allowed_users(post).include?(u) }
mentioned_opts = {}
if new_record && post.post_number == 1
).pluck(:user_id)
{ post_id: post.id, group_id: group.id, created_at: now, updated_at: now }
WHERE tu.user_id = ? AND tu.topic_id = ? ),0)",
group_id: g.id,
@group_stats ||= {}
read: user.id === acting_user_id ? true : false,
return if user.blank? || user.bot? || post.blank?
if is_liked &&
if count > 1
.where(id: groups.map(&:id))
groups = Group.where("LOWER(name) IN (?)", mentions)
mentions -= groups.map(&:name).map(&:downcase)
end.uniq.map { |q| q.first.strip.downcase }
.map do |link|
(linked_post && post.user_id != linked_post.user_id && linked_post.user) || nil
def notify_non_pm_users(users, type, post, opts = {})
def notify_users(users, type, post, opts = {})
if reply_to_user == user || pm_watching_users(post).include?(user) || user.staged?
.reject { |tau| not_allowed?(tau.user, post) }
condition = +<<~SQL
users.id IN (
/*topic*/
/*category*/
/*tags*/
condition.sub! "/*topic*/", <<~SQL if include_topic_watchers
condition.sub! "/*tags*/", <<~SQL if include_tag_watchers && tag_ids.present?
.where("last_read_post_number >= ?", post.post_number)
.pluck(:user_id),
.where("post_actions.created_at > ?", 1.day.ago)
if post.is_first_post? &&
filtered = filtered.where("data::json ->> '#{key}' = ?", value) if value
group_id.present? ? Group.select(:name).find_by(id: group_id.to_i)&.name : nil
notifications.where("data::json ->> '#{attribute_name}' = ?", value.to_s)
@from = from
@set_data_blk = nil
:from,
:to,
@no_delay = no_delay
type: type.to_s,
return if user.staged? && (type == :user_linked || type == :user_quoted)
@post_type ||=
if node.name == "img"
elsif !(
node.children.count == 1 &&
node.name == "a" && node.children.count > 1 &&
elsif node.name != "p"
link_occurrences << { link: seen_link, is_valid: false }
markdown.scan(/(\n{2,}|\A)#{regexp}$/) do |match|
markdown.scan(/^#{regexp}(\s)/) do |match|
uri = URI(link)
host = uri&.host
markdown.scan(/(__(\h{40})__)/) do |match|
replacement = +"#{" " * spaces_before}#{node.to_s}"
raw.gsub(%r{^(https?://\S+)(\s?)$}) do |match|
base_url = Discourse.base_url.sub(%r{https?://}, "(https?://)")
if GlobalSetting.cdn_url && (cdn_url = GlobalSetting.cdn_url.sub(%r{https?://}, "(https?://)"))
node = node.to_s
results = DB.query(<<~SQL)
results.inject({}) do |h, row|
elsif SiteSetting.get(name) == 0 || (new_value.to_f / SiteSetting.get(name) - 1.0).abs >= 0.05
if new_value > 9
{ type: "category", context: "topic-composer", priority: 100 },
{ type: "tag", context: "topic-composer", priority: 50 },
data_sources.find { |ds| ds.type == type }
slugs_without_suffixes.reject { |slug| slugs_with_suffixes.include?("#{slug}::#{type}") }
.select { |slug| slug.ends_with?("::#{type}") }
.map { |slug| slug.gsub("::#{type}", "") }
item.ref = "#{item.ref}::#{type}" if slugs_with_suffixes.include?("#{item.ref}::#{type}")
tag_hashtags = {}
limited_results.any? { |exact| exact.type == type && exact.slug === item.slug }
hashtag_items.each { |item| item.ref ||= item.slug }
hashtag_items.each { |item| item.type = type }
other_slugs = limited_results.reject { |r| r.type === hashtag_item.type }.map(&:slug)
hashtag_item.ref = "#{hashtag_item.slug}::#{hashtag_item.type}"
File.open(tmp_upload_path, "a") do |file|
(1..@chunk).each do |chunk_number|
@message_params ||=
previous_name: "%@#{previous_name}%",
post.raw.gsub!(/(^|\s)(@#{previous_name})(\s|$)/, "\\1@#{current_name}\\3")
{ group: @group, acting_user: @acting_user }
if upload_type == "backup"
if attrs.has_key?(:css)
host:,
port:,
pop3 = Net::POP3.new(host, port)
smtp = Net::SMTP.new(host, port)
if host == "smtp.gmail.com"
if port.to_i == 587
elsif port.to_i == 465
message: @exception.message.gsub(" (Failure)", ""),
@io = io
@io.puts "Deleting #{topic.slug}..."
.find_each do |pm|
@io.puts "Destroying #{pm.slug} pm"
@io.puts "destroying group: #{group.id}"
@io.puts "#{user.username} #{e.message}"
item.ref =
base_search = base_search.where("LOWER(slug) LIKE :term", term: "#{term}%")
})",
).to_json
def initialize(badge, user, opts = {})
@badge, @user, @opts = badge, user, opts
def self.grant(badge, user, opts = {})
usernames_map_to_ids = {}
emails_map_to_ids = {}
count_per_user = {}
<<~SQL * count,
:now,
:badge_id,
WHERE badge_id = :badge_id AND user_id = :user_id
), 0)
find_by = { badge_id: @badge.id, user_id: @user.id }
if user_badge.nil? || (@badge.multiple_grant? && @post_id.nil?)
seq = 0
seq = (seq || -1) + 1
post_id: @post_id,
seq: seq,
def self.contract_checks!(sql, opts = {})
if sql.match(/:user_ids/)
if sql.match(/:post_ids/)
if sql.match(/;\s*\z/)
def self.preview(sql, opts = {})
count_sql = <<~SQL
) q
JOIN users u on u.id = q.user_id
{ errors: e.message }
post_ids = user_ids = nil
full_backfill = !user_ids && !post_ids
post_clause = badge.target_posts ? "AND (q.post_id = ub.post_id OR NOT :multiple_grant)" : ""
post_id_field = badge.target_posts ? "q.post_id" : "NULL"
) q ON q.user_id = ub.user_id
id: badge.id,
SELECT :id, q.user_id, q.granted_at, -1, current_timestamp, #{post_id_field}
JOIN users u on u.id = w.user_id
if (post_ids || user_ids) && !badge.query.include?(":backfill")
if post_ids && !badge.query.include?(":post_ids")
if user_ids && !badge.query.include?(":user_ids")
raise GrantError, "Failed to backfill '#{badge.name}' badge: #{opts}. Reason: #{e.message}"
AND u.title <> ''
AND up.user_id = u.id
JOIN user_badges ub ON ub.user_id = u.id AND ub.badge_id = b.id
if shadow && (shadow.post_count + shadow.topic_count) > 0 && shadow.last_posted_at &&
@i18n_key ||= "wizard.step.#{object.id}".underscore
key = "#{i18n_key}.#{sub_key}"
vars.nil? ? I18n.t(key) : I18n.t(key, vars)
:icon,
@i18n_key ||= "wizard.step.#{object.step.id}.fields.#{object.id}".underscore
object.type == "dropdown" || object.type == "radio"
I18n.t("#{i18nkey}.label", default: id)
I18n.t("#{i18nkey}.description", default: "")
define_method("include_#{attr}?") { false }
WatchedWord.actions.keys.filter { |k| k != :tag }
expressions = {}
if Hash === object
Topic.url(topic_id, slug, (last_read_post_number || 0) + 1)
:can_edit,
keys =
.map do |k|
id: k.id,
scopes: k.scopes.map { |s| I18n.t("user_api_key.scopes.#{s.name}") },
keys.length > 0 ? keys : nil
super() && can_edit
method_name = "include_#{attr}?"
scope.is_me?(object) || scope.is_staff?
(object.id && object.id == scope.user.try(:id)) || (scope.is_staff? && object.staged?)
return if uri.nil? || uri.host.nil?
uri.host.sub(/\Awww\./, "") + uri.path
bm,
.pick(:name)
can_attributes.each { |ca| define_method(ca) { true } }
:per_page,
:top_tags,
key = "topic_flag_types.#{name_key}.#{field}"
vars ? I18n.t(key, vars) : I18n.t(key)
.find { |t| t.key == "theme_metadata.settings.#{setting}" }
attributes :name, :target, :value, :error, :type_id, :upload_id, :url, :filename
:is_git?,
:enabled?,
object.theme_fields.each { |o| @errors << o.error if o.error }
@errors << e.message
@permissions ||=
.find_each do |tgp|
:can_tag_pms,
.order("lower(name)")
theme_id: id,
name: n,
.select(:id, :name, :flair_icon, :flair_upload_id, :flair_bg_color, :flair_color)
.map do |g|
id: g.id,
name: g.name,
object.categories.map { |c| c.to_h }
types.map { |id| PostActionType.new(id: id) }
attributes :id, :title, :links, :slug, :public
def include_#{name}?
attributes.each { |a| create_attribute(a, "object.target&.#{a}") }
return text.gsub("_", " ") unless scope.is_staff?
:is_poll,
result = { posts: posts }
@posts ||=
:can_wiki,
:read,
:admin?,
:staff?,
!!(object&.user&.moderator?)
!!(object&.user&.admin?)
!!(object&.user&.staff?)
@group_moderator ||=
count_col = "#{sym}_count".to_sym
summary = { id: id, count: count }
(object.user && object.user.bot?)
@add_raw.present? && (!object.hidden || scope.user&.staff? || yours)
object.locked? && (yours || scope.is_staff?)
changes_name = "#{field}_changes".to_sym
@next_revision ||=
return if object.post.post_number > 1 && prev == cur
current: {
@post ||= object.post
@revisions ||=
(@all_revisions.count - 1)
.downto(1)
if tags.is_a?(Array) && tags.size > 0
i18n("title")
key = "post_action_types.#{name_key}.#{field}"
:post_url,
:tag_id,
:tag_name,
:raw_text,
object.invite.is_invite_link? ? "link" : "email"
((Time.now - object.created_at) / 60 / 60 / 24).ceil
if object.type == "pending" || object.type == "expired"
:link,
object.groups.pluck(:name).join(", ")
body ||=
.encode("utf-8", invalid: :replace, undef: :replace, replace: "")
:smtp_ssl,
:imap_ssl,
scope.is_admin? || (include_is_group_owner? && is_group_owner)
flair_icon.present? && (is_group_owner || scope.is_admin?)
flair_type.present? && (is_group_owner || scope.is_admin?)
.inject({}) do |h, arr|
attributes :id, :created_at, :title, :url, :category_id, :post_number, :topic_id, :post_type
fields = {}
attributes :id, :name, :type, :position, :icon, :user_field_id
!(1..4).include?(object.badge_id)
@_category_ids ||=
:read_faq?,
.where("public OR user_id = ?", object.id)
.pluck(:id, :name, :has_messages)
.map do |id, name, has_messages|
group = { id: id, name: name, has_messages: has_messages }
fields << f
included { attributes :id, :client_ip, :location, :browser, :device, :os, :icon, :created_at }
I18n.t("user_auth_tokens.device.#{val}")
I18n.t("user_auth_tokens.os.#{val}")
all_tags.map(&:name)
@tags = tags
:email_in,
.map { |cg| { permission_type: cg.permission_type, group_name: cg.group.name } }
perms << {
!include_can_delete? && scope && scope.can_edit?(object)
user = scope && scope.user
users = object.topic_list.topics.map { |t| t.posters.map { |poster| poster.try(:user) } }
users.uniq!(&:id)
groups.uniq!(&:id)
@post_custom_fields ||=
object.user_id == scope&.user&.id
:bio_raw,
staff? || (include_is_group_owner? && is_group_owner)
@staff ||= scope.is_staff?
key: k,
title: I18n.t("archetypes.#{object.id}.options.#{k}.title"),
def as_json(*_args)
.select { |k| k =~ name_or_regexp }
.each { |k| fragment_cache.delete(k) }
:key,
object.action.to_s.gsub("_", " ")
key: :tag_names,
embed: :ids,
:web_hook_id,
(scope.is_staff? && (object.id == scope.user.id || object.staged?)) ||
.select { |ua| ua.user_id = object.user_id }
attributes :id, :title, :subject, :body, :can_revert?
if I18n.exists?("#{object}.title")
I18n.t("#{object}.title")
object.gsub(/.*\./, "").titleize
@subject ||= I18n.t("#{object}.subject_template")
@body ||= I18n.t("#{object}.text_body_template")
scope.is_admin? && (object&.id != scope.user.id)
external_ids = {}
default_scope { order("id ASC") }
@content_types ||= Enum.new("application/json" => 1, "application/x-www-form-urlencoded" => 2)
self.payload_url = (payload_url || "").strip.presence
.where("web_hooks.wildcard_web_hook = ? OR web_hook_event_types.name = ?", true, type.to_s)
def self.enqueue_hooks(type, event, opts = {})
payload ||=
tag_ids: post.topic&.tags&.pluck(:id),
id = where(date: date, user_agent: user_agent).pick(:id)
id ||= create!({ date: date, user_agent: user_agent }.merge(count: 0)).id
if retries == 0
@actions ||=
block: 1,
censor: 2,
flag: 4,
link: 8,
tag: 6,
scope :by_action, -> { order("action ASC, word ASC") }
->(word:) {
w.strip.squeeze("*")
tag_list = replacement&.split(",")
if (tag_list.blank? || tags.empty? || tag_list.size != tags.size)
action == :replace || action == :tag || action == :link
@user ||= User.new(user)
if username.chars.any? { |c| !self.class.allowed_char?(c) }
result = where("visited_at >= ? and visited_at <= ?", start_date.to_date, end_date.to_date)
result = result.where("group_users.group_id = ?", group_id)
.where(user: @user)
.joins(:topic, :post)
.where(posts: { user_id: @user.id })
likers = {}
.pluck("acting_user_id, COUNT(*)")
liked_users = {}
.pluck("user_actions.user_id, COUNT(*)")
replied_users = {}
.where("replies.user_id <> ?", @user.id)
.pluck("replies.user_id, COUNT(*)")
top_categories = {}
.pluck(:id, :name, :color, :text_color, :slug, :read_restricted, :parent_category_id)
.pluck("category_id, COUNT(*)")
.map do |user_id|
if: Proc.new { |t| t.will_save_change_to_set_at? || t.will_save_change_to_ends_at? }
ends_at && ends_at < Time.zone.now
if ends_at && set_at > ends_at
WHEN u.admin OR u.moderator #{whisperers_group_ids.present? ? "OR gu.id IS NOT NULL" : ""}
AND cu.user_id = u.id
u.username) AS X ON X.user_id = u1.id
.where("reset_bounce_score_after < now()")
.where("bounce_score > 0")
DB.exec(<<~SQL, seen_at: last_seen)
X.c <> posts_read_count
sql = sql + " AND user_stats.user_id = #{user_id.to_i}" if user_id
diff = (Time.now.to_f - last_seen.to_f).round
-"user-last-seen:#{id}"
@methods ||= Enum.new(totp: 1, backup_codes: 2, security_key: 3)
def initialize(term, opts = {})
@term_like = @term.gsub("_", "\\_") + "%"
@topic = Topic.find(@topic_id) if @topic_id
users = users.joins(:group_users).where("group_users.group_id IN (?)", @groups.map(&:id))
.where("user_search_data.search_data @@ #{query}")
exact_matches = exact_matches.where("last_seen_at > ?", 1.year.ago) if @topic_id ||
exact_matches.limit(@limit).pluck(:id).each { |id| users << id }
in_topic =
@topic_id,
.each { |id| users << id }
DB.query_single(<<~SQL, @topic_id).first
AND user_count < ?
in_category = in_category.where("users.id <> ?", @searching_user.id)
.where("username_lower <-> ? < 1 OR name <-> ? < 1", @term, @term)
.where("username_lower <-> ? < 1", @term)
) x on uid = users.id",
).order("rn")
def self.add(user_profile_id, ip, user_id = nil, at = nil, skip_redis = false)
at ||= Time.zone.now
redis_key = +"user-profile-view:#{user_profile_id}:#{at.to_date}"
redis_key << ":user-#{user_id}"
ip = nil
redis_key << ":ip-#{ip}"
skip_redis ||
profile_views = self.where("viewed_at >= ? AND viewed_at < ?", start_date, end_date + 1.day)
url: true,
def bio_excerpt(length = 350, opts = {})
excerpt = PrettyText.excerpt(bio_cooked, length, opts).sub(/<br>\z/, "")
problems << { profile: p, ex: e }
domains: allowed_domains.split("|").join(", "),
scope :human_users, -> { where("user_id > 0") }
enum default_calendar: { none_selected: 0, ics: 1, google: 2 }, _scopes: false
Enum.new(always: 0, first_time_and_daily: 1, first_time: 2, never: 3)
@text_sizes ||= Enum.new(normal: 0, larger: 1, largest: 2, smaller: 3, smallest: 4)
@email_level_type ||= Enum.new(always: 0, only_when_away: 1, never: 2)
delay / 2,
return if user.trust_level > 0 && user.last_seen_at && user.last_seen_at > 1.month.ago
if !user.seen_before? || (user.trust_level == 0 && !redirected_to_top_yet?)
attrs = { enabled: false }
scope :enabled, -> { where(enabled: true) }
start_key = "day_#{n}_start_time"
end_key = "day_#{n}_end_time"
scope :only_staff_actions, -> { where("action IN (?)", UserHistory.staff_action_ids) }
roll_up: 20,
query = query.where("#{key}_id = ?", obj_id)
validates_presence_of :name, unless: -> { field_type == "confirm" }
scope :public_fields, -> { where(show_on_profile: true).or(where(show_on_user_card: true)) }
scope :secondary, -> { where(primary: false) }
username, domain = self.email.split("@", 2)
username = username.gsub(".", "").gsub(/\+.*/, "")
.where("lower(email) = ? OR lower(normalized_email) = ?", email, normalized_email)
self.class.where("lower(email) = ?", email).exists?
group(:badge_id, :user_id)
.includes(:user, :granted_by, { badge: :badge_type }, post: :topic)
gravatar_upload_id == id || custom_upload_id == id
ext = ".png" if ext.blank?
a =
Math.sin((lat2_rad - lat1_rad) / 2)**2 +
Math.cos(lat1_rad) * Math.cos(lat2_rad) * Math.sin((lon2_rad - lon1_rad) / 2)**2
c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
ips.none? do |ip|
path: nil,
if user_token.auth_token != token && user_token.prev_auth_token == token &&
.where("rotated_at < ?", 1.minute.ago)
action: changed_rows == 0 ? "prev seen token unchanged" : "prev seen token",
if changed_rows == 1
action: changed_rows == 0 ? "seen wrong token" : "seen token",
def rotate!(info = nil)
seen_at = null,
client_ip = :client_ip,
id: self.id,
AND uag.id != :uag_id
uag_id: id,
self.where("user_id IS NULL AND updated_at < ?", 1.day.ago).delete_all
scope :active, -> { where(revoked_at: nil) }
scope :with_key, ->(key) { where(key_hash: ApiKey.hash_key(key)) }
update_args = { last_used_at: Time.zone.now }
.where("id <> ?", self.id)
scopes.any? { |s| s.name == "push" || s.name == "notifications" } && push_url.present? &&
scopes.any? { |s| s.permits?(env) } || is_revoke_self_request?(env)
like: 1,
was_liked: 2,
new_topic: 4,
reply: 5,
quote: 9,
edit: 11,
builder.where("a.user_id = :user_id", user_id: user_id)
all, mine, unread = DB.query_single(sql, user_id: user_id).map(&:to_i)
result = { all: all, mine: mine, unread: unread }
.query(sql, user_id: user_id)
result = result.where("created_at > ? AND created_at < ?", start_date, end_date)
acting_cols << "u.#{c} AS acting_#{c}"
a.id,
/*offset*/
builder.where("a.id = :id", id: action_id.to_i)
builder.where("a.user_id = :user_id", user_id: user_id.to_i)
action = self.find_by(hash.select { |k, _| required_parameters.include?(k) })
current_user_id = -2
(c.read_restricted and c.id in (:cats)) )",
-> { merge(Reviewable.pending) },
-> { where(primary: true) },
->(record) { where(active: true) },
-> { where(linkable_type: "Category") },
->(email) { joins(:user_emails).where("lower(user_emails.email) IN (?)", email) }
->(email) {
scope :human_users, -> { where("users.id > 0") }
scope :silenced, -> { where("silenced_till IS NOT NULL AND silenced_till > ?", Time.zone.now) }
scope :not_silenced, -> { where("silenced_till IS NULL OR silenced_till <= ?", Time.zone.now) }
scope :suspended, -> { where("suspended_till IS NOT NULL AND suspended_till > ?", Time.zone.now) }
scope :not_suspended, -> { where("suspended_till IS NULL OR suspended_till <= ?", Time.zone.now) }
scope :activated, -> { where(active: true) }
scope :not_staged, -> { where(staged: false) }
->(filter) {
where("username_lower ~* ?", "(#{filter.join("|")})")
where("username_lower ILIKE ?", "%#{filter}%")
if filter.is_a?(String) && filter =~ /.+@.+/
if user_id = UserEmail.where("lower(email) = ?", filter.downcase).pick(:user_id)
return where("users.id = ?", user_id)
filter: "(#{filter.join("|")})",
filter: "%#{filter}%",
->(topic) {
@user_tips ||=
post_menu: 3,
.any? { |reserved| username.match?(/\A#{Regexp.escape(reserved).gsub('\*', ".*")}\z/) }
user_id > 0
return if role == :admin && User.real.where(admin: true).count == 1
user_id: id,
role: role.to_s,
@muted_user_ids ||= muted_users.pluck(:id)
AND n.user_id = :user_id
n.user_id = :user_id AND
Discourse.deprecate(<<~TEXT, since: "2.9", drop_from: "3.0")
n.user_id = :user_id
{ id => payload },
seen_before? && last_seen_at >= datetime
def create_visit_record!(date, opts = {})
def update_posts_read!(num_posts, opts = {})
if !_retry
unless old_ip == new_ip || new_ip.blank?
DB.exec(<<~SQL, user_id: user_id, ip_address: new_ip)
nx: true,
avatar_template_url.gsub("{size}", "45")
.reduce(0) do |result, char|
username ||= ""
url = +"#{Discourse.base_path}#{url}" unless url =~ %r{\Ahttps?://}
url.gsub! "{first_letter}",
length = colors.count("|") + 1
index = (num * hex_length) + num
color.map { |c| c.to_s(16).rjust(2, "0") }.join
return false if topic.try(:private_message?) || (topic.try(:user_id) == self.id)
!!(silenced_till && silenced_till > Time.zone.now)
return admin? if level.to_s == "admin"
return staff? if level.to_s == "staff"
name.present? && name != username ? "#{name} (#{username})" : username
result = result.where("users.created_at >= ? AND users.created_at <= ?", start_date, end_date)
cats =
field_ids = (@all_user_field_ids ||= UserField.pluck(:id)) if field_ids.nil?
@user_fields_cache ||= {}
@public_user_field_ids ||=
if email =~ Regexp.new("@(#{domains})$", true) && !group.users.include?(self)
.where(user_id: users.map(&:id))
.sum(:time_read)
@recent_time_read ||=
from_staged? && self.created_at && self.created_at < 1.day.ago
group_titles_query = groups.where("groups.title <> ''")
JOIN topics t ON (p.topic_id = t.id)
WHERE a.topic_id = t.id AND a.user_id > 0 AND a.user_id <> :user_id
LIMIT #{max_post_count + 1}
do_not_disturb_timings.where("starts_at <= ? AND ends_at > ?", now, now)
status = {
return if id < 0
user_id = existing.select { |u| u.is_user }.first&.id
same_user = user_id && user_id == self.id
category_ids = SiteSetting.get("default_categories_#{setting}").split("|").map(&:to_i)
values << {
tag_names = SiteSetting.get("default_tags_#{setting}").split("|")
.each do |tag_id|
tag_id: tag_id,
return if staged? || bot?
if title_changed? && !new_record? && user_profile
title &&
badge.allow_title? && (badge.display_name == title || badge.name == title)
if (saved_change_to_admin? || saved_change_to_moderator?) &&
if !target && !(target_type && target_id)
).where("ur.upload_id IS NULL")
new_extension = image_info&.type&.to_s || "unknown"
!(url =~ %r{\A(https?:)?//})
if extension == "svg"
).split(" ")
self.width = w || 0
self.height = h || 0
color = "" if !FileHelper.is_supported_image?("image.#{extension}") || extension == "svg"
local_path ||=
color = ""
color ||=
@file_quality ||=
self.posts.where("cooked LIKE '%/_optimized/%'").find_each(&:rebake!)
security_last_changed_reason: reason + " | source: #{source}",
.where("url NOT LIKE '%/original/_X/%' AND url LIKE ?", "%/uploads/#{db}%")
if scope.count == 0
external = previous_url =~ %r{\A//}
url = SiteSetting.scheme + ":" + previous_url
retry if (retries += 1) < 1
File.open(path) do |f|
remap_scope ||=
.select(:id, :raw, :cooked)
problems << { upload: upload, ex: e }
@associated_topic ||= topic || post&.topic
val.to_i.to_s == val.to_s && valid_values.any? { |v| v == val.to_i }
valid_values.map { |value| { name: translation(value), value: value } }
special_group?(val) || (val.to_i.to_s == val.to_s && valid_values.any? { |v| v == val.to_i })
I18n.t("trust_levels.#{value}")
valid_values.include?(val) || (val.to_i.to_s == val.to_s && valid_values.include?(val.to_i))
if value == "disabled"
@silenced += 1 if @silenced == 0 && user.silenced?
@suspended += 1 if @suspended == 0 && user.suspended?
(!@user.suspended?) && (!@user.silenced?) && penalty_counts.total == 0 &&
topics_viewed >= min_topics_viewed && posts_read >= min_posts_read &&
@user.suspended? || @user.silenced? || penalty_counts.total > 0 ||
.select("topic_id")
).round,
.where.not(user_id: @user.id)
@_num_flagged_by_users ||=
(min_likes_received.to_f / 4.0).ceil
@_flagged_post_ids ||=
data = { value: sanitized_value }
match = key.match(/(.*)\.(zero|two|few|many)\z/)
match ? match.to_a.second + ".other" : key
def self.add(topic_id, ip, user_id = nil, at = nil, skip_redis = false)
at ||= Date.today
redis_key = +"view:#{topic_id}:#{at}"
builder.where("user_id = :user_id AND topic_id = :topic_id")
Topic.where(id: topic_id).update_all "views = views + 1"
lambda { |topic_id, level|
return {} if user.blank? || topics.blank?
topic_ids = topics.map(&:id)
user = user.id if user.is_a?(User)
topic_id = topic_id.id if topic_id.is_a?(::Topic)
user_id = user_id.id if user_id.is_a?(::User)
user_id = user_id.to_i
.where("tag_id IN (SELECT tag_id FROM topic_tags WHERE topic_id = :id)", id: topic_id)
join users u on u.id = :user_id
tu.user_id = :user_id
SELECT :user_id, :topic_id, :post_number, :now, :now, :new_status
JOIN users u on u.id = :user_id
WHERE ftu.user_id = :user_id and ftu.topic_id = :topic_id)"
msecs = 0 if msecs.to_i < 0
if rows.length == 1
if rows.length == 0
SET #{action_type_name} = x.state
JOIN posts p on p.id = pa.post_id
tu2.topic_id = t.id AND
WHERE x.topic_id = tu.topic_id AND x.user_id = tu.user_id AND x.state != tu.#{action_type_name}
builder.where("tu2.user_id IN (:user_id)", user_id: user_id) if user_id
builder.where(<<~SQL, post_id: post_id)
tu2.user_id IN (
) m
tu.topic_id IN (
) as Y on Y.topic_id = X.topic_id
X.user_id = t.user_id AND
tag_ids, tags = nil
.where("users.last_seen_at > ?", 7.days.ago)
tags = nil
tag_ids = nil
.to_sql + " AND topics.created_at > :min_new_topic_date" +
END, u.created_at, :min_date)",
sql + "\n\n LIMIT :max_topics",
sql << report_raw_sql(
) tags
new =
select ||
u.id as user_id,
append = "OR u.admin" if !admin
tags_filter = ""
tags_filter = <<~SQL
sql << " AND topics.id = :topic_id" if topic_id
.find_by(id: topic_id)
.group("groups.id")
non_member_reading = (!write_event && !member)
->(before_time = Time.now.utc) {
if (will_save_change_to_execute_at? && !attribute_in_database(:execute_at).nil?) ||
close: 1,
open: 2,
delete: 4,
bump: 6,
{ max_width: max_width, max_height: max_height },
counters_to_update = { staff_topic_count: -1 }
topic_poster.extras << " single" if user_ids.uniq.size == 1
@descriptions_by_id ||=
ids = ids || user_ids
summary.reject! { |u| u.id == topic.last_post_user_id }
mute!: :muted,
(@preload_user_ids ||= Set.new) << blk
opts = @category ? { category: @category } : {}
Tag.top_tags(**opts)
@topics ||= load_topics
@topics.each do |ft|
user_ids << ft.user_id << ft.last_post_user_id << ft.featured_user_ids << ft.allowed_user_ids
{ "more_topics_url" => page }
def self.create_from(args = {})
urls << url
if url =~ /\Ahttp/
urls << url.sub(/\Ahttps/, "http")
urls << url.sub(/\Ahttp:/, "https:")
query = url.index("?")
endpos = url.index("#") || url.size
while i = url.rindex("&", i - 1)
cdn_uri =
urls << path
urls << "#{Discourse.store.absolute_base_url}#{path}"
link =
errors.add(:base, "can't link to the same topic") if (topic_id == link_topic_id)
l.post_id,
l.url,
/*left_join*/
builder.where("l.post_id in (:post_ids)", post_ids: posts.map(&:id))
url: l.url,
.map do |u|
.reject { |_, p| p.nil? || "mailto" == p.scheme }
.uniq { |_, p| p }
.each do |link, parsed|
.includes(:post, :user)
.joins(:post, :user)
.last(200)
lookup = {}
normalized = tl.url.downcase.sub(%r{\Ahttps?://}, "").sub(%r{/\z}, "")
topic_id:,
url:,
url << "/#{post_number}" if post_number.to_i > 1
if topic && post.topic && topic.archetype != "private_message" &&
update_query = <<~SQL
def choose(args = {})
filter = "#{"AND t.id = #{topic_id.to_i}" if topic_id}"
filter2 = "#{"AND tt.id = #{topic_id.to_i}" if topic_id}"
JOIN posts p ON p.topic_id = t.id
p.post_type in (#{Topic.visible_post_types.join(",")}) AND
p.user_id <> t.user_id AND
p.user_id <> t.last_post_user_id
cte2 as (
c.id,
) x ON x.id = tt2.id
.where("deleted_at IS NOT NULL AND embed_url = ?", embed_url)
url.downcase.sub(%r{/\z}, "").sub(/\-+/, "-").strip
return unless url =~ %r{\Ahttps?\://}
contents ||= ""
embed = TopicEmbed.find_by("lower(embed_url) = ?", url)
cook_method ||=
if post.user != user
if (content_sha1 != embed.content_sha1) || (title && title != post&.topic&.title)
title = +(raw_doc.title || "")
tags = { "img" => "src", "script" => "src", "a" => "href" }
.search(tags.keys.join(","))
unless (src.nil? || src.empty?)
if classes.length === 0
prefix = "#{uri.scheme}://#{uri.host}"
prefix += ":#{uri.port}" if uri.port != 80 && uri.port != 443
embed_url = normalize_url(embed_url).sub(%r{\Ahttps?\://}, "")
TopicEmbed.where("embed_url ~* ?", "^https?://#{Regexp.escape(embed_url)}$").pick(:topic_id)
.css("p")
result << p.to_s
doc.css("div").first.to_s
@posters ||=
operation = action == :increment ? "+" : "-"
users_to_allow = posters << @user.id
next if tau.user_id < 0 || tau.user_id == topic.user_id
infos << { # Always add original
infos << {
if: Proc.new { |t| t.new_record? || t.title_changed? },
Proc.new { |t|
if:
(t.new_record? || t.category_id_changed?) &&
has_many :ordered_posts, -> { order(post_number: :asc) }, class_name: "Post"
has_one :first_post, -> { where post_number: 1 }, class_name: "Post"
scope :topic_list_order, -> { order("topics.bumped_at desc") }
->(user) {
scope :by_newest, -> { order("topics.created_at desc, topics.id desc") }
scope :visible, -> { where(visible: true) }
scope :created_since, lambda { |time_ago| where("topics.created_at > ?", time_ago) }
lambda { |guardian = nil|
scope :with_subtype, ->(subtype) { where("topics.subtype = ?", subtype) }
if category_id.nil? && (archetype.nil? || self.regular?)
(has_flags? || is_official_warning?)
((Time.zone.now - created_at) / 1.minute).round
raw = raw.presence || ""
tsquery = "#{tsquery} & #{raw_tsquery}"
.where("search_data @@ #{tsquery}")
.order("ts_rank(search_data, #{tsquery}) DESC")
.joins("JOIN posts AS p ON p.topic_id = topics.id AND p.post_number = 1")
.where("topics.id IN (?)", candidate_ids)
).where(
).where("similarity(topics.title, :title) > 0.2", title: title)
if status == "closed"
def self.next_post_number(topic_id, opts = {})
X as (
Y as (
Y.topic_id = topics.id AND (
result = DB.query_single(<<~SQL, topic_id: topic_id)
post_type <> 4
posts_count = (
last_posted_at = (
), last_post_user_id)
def add_small_action(user, action_code, who = nil, opts = {})
raw: text,
if user.id == removed_by&.id
{ group_id: group.id, topic_id: self.id, op_user_id: self.user_id },
elsif username_or_email =~ /\A.+@.+\z/ && guardian.can_invite_via_email?(self)
{ html: post.cooked, key: self.id, url: self.url }
def title=(t)
slug = slug_for_topic(t.to_s)
url = +"#{Discourse.base_url}/t/#{slug}/#{id}"
url = +"#{Discourse.base_path}/t/"
url << "#{slug}/" if slug.present?
url << id.to_s
pinned_at: status ? Time.zone.now : nil,
Topic.where("pinned_until < ?", Time.now).update_all(
.where("bannered_until < ?", Time.now)
by_user: nil,
utc = Time.find_zone("UTC")
is_float =
topic_timer.user ||=
@acting_user || user
@acting_user = u
@secure_group_ids ||=
) =
WHERE tu.user_id = :user_id AND tu.topic_id = :topic_id
DB.exec(sql, user_id: user.id, topic_id: id) > 0
builder.where("p.user_id != t.user_id")
) tt
) = 1
result != 0
.where("topics.created_at >= ? AND topics.created_at <= ?", start_date, end_date)
).last || first_post
.where("reviewables.topic_id = ?", self.id)
.where("id = ?", category_id)
.where("topic_id != ? OR topic_id IS NULL", self.id)
.update_all("topic_count = topic_count + #{num.to_i}")
.where("created_at <= ?", received_before)
1.day.to_i,
if posts_count > 0 || all_posts_count > 1
target_audience = {}
stats = { like_count: topic.like_count }
stats = {
message = stats.merge({ id: topic_id, updated_at: Time.now, type: :stats })
).each do |group|
ascending_periods ||= Enum.new(daily: 1, weekly: 2, monthly: 3, quarterly: 4, yearly: 5, all: 6)
), visible_topics AS (
if period == :all
) as top_topics"
ELSE log(GREATEST(#{period}_views_count, 1)) * #{log_views_multiplier} +
CASE WHEN #{period}_likes_count > 0 AND #{period}_posts_count > 0
0 - ((10 - topics.posts_count) / 20) * #{period}_op_likes_count
AND #{period}_score <> top.score
SET #{period}_#{sort}_count = c.count
INNER JOIN (#{inner_join}) c ON tt.topic_id = c.topic_id
AND tt.#{period}_#{sort}_count <> c.count",
parts = value.split(",")
if value.start_with?("-")
@types ||= Enum.new(integer: 0, float: 1, string: 2, bool: 3, list: 4, enum: 5, upload: 6)
value.is_a?(Integer) || value.is_a?(Float)
next if value.is_a?(Array) && value.all? { |v| v.is_a?(String) }
.map { |s| s.public_send(modifier_name) }
.filter(&:present?)
if !val.all? { |v| v.is_a?(Array) && v.length == 2 }
type = nil
if info.type == :string && info.array?
elsif info.type == :boolean && !info.array?
->(theme_ids) {
SELECT #{theme_ids.map.with_index { |id, idx| "#{id.to_i} AS theme_id, #{idx} AS theme_sort_column" }.join(" UNION ALL SELECT ")}
) as X ON X.theme_id = theme_fields.theme_id",
->(locale_codes) {
SELECT * FROM (VALUES #{locale_codes.map { "(?)" }.join(",")}) as Y (locale_code, locale_sort_column)
) as Y ON Y.locale_code = theme_fields.name",
->(theme_ids, locale_codes) {
html: 0,
scss: 1,
theme_var: 4, # No longer used
yaml: 5,
js: 6,
is_raw = name =~ /\.(raw|hbr)\z/
js = <<~JS
withPluginApi(#{version.inspect}, (api) => {
js,
<link rel="preload" href="#{javascript_cache.url}" as="script">
<script defer src='#{javascript_cache.url}' data-theme-id='#{theme_id}'></script>
error = "Error with #{self.name}: #{e.inspect}"
raise if field.id == id
/* Translation data for theme #{self.theme_id} (#{self.name})*/
const data = #{data.to_json};
for (let lang in data){
doc = ""
.new(self)
.load do |name, default, type, opts|
elsif target.to_s == "extra_scss"
elsif target.to_s == "extra_js"
elsif target.to_s == "settings" || target.to_s == "translations"
css, _source_map =
@allowed_values = {}
plural = :"#{option}s"
is_match =
%r{\A(?<target>(?:mobile|desktop|common))/(?<name>(?:head_tag|header|after_header|body_tag|footer))\.html\z},
types: :html,
regex: %r{\A(?<target>(?:mobile|desktop|common))/(?:\k<target>)\.scss\z},
names: "scss",
types: :scss,
canonical: ->(h) { "common/embedded.scss" },
canonical: ->(h) { "common/color_definitions.scss" },
regex: %r{\A(?:scss|stylesheets)/(?<name>.+)\.scss\z},
regex: %r{\Ajavascripts/(?<name>.+)\z},
types: :js,
regex: %r{\Atest/(?<name>.+)\z},
regex: /\Asettings\.ya?ml\z/,
names: "yaml",
types: :yaml,
canonical: ->(h) { "settings.yml" },
regex: %r{\Alocales/(?<name>(?:#{I18n.available_locales.join("|")}))\.yml\z},
nil # Not a file (e.g. a theme variable/color)
if (will_save_change_to_value? || will_save_change_to_upload_id?) &&
if upload && upload.extension == "js"
-> { order(:name) },
-> { where("type_id IN (?)", ThemeField.theme_var_type_ids) },
-> { where("name IN (?)", ThemeField.scss_fields) },
.order(:name, :id)
.pluck(:name, :value)
id = id.to_i
all_ids =
components = components_for(id).tap { |c| c.sort!.uniq! }
.where(id: all_ids)
.select { |t| !t.supported? || !t.enabled? }
cache_key = "#{theme_ids.join(",")}:#{target}:#{field}:#{Theme.compiler_version}"
get_set_cache(cache_key) { val || "" }.html_safe
get_set_cache("#{theme_ids.join(",")}:modifier:#{modifier_name}:#{Theme.compiler_version}") do
@targets ||=
common: 0,
mobile: 2,
extra_js: 6,
tests_js: 7,
if target == :extra_js
.map(&:theme_id)
return caches.map { |c| <<~HTML.html_safe }.join("\n")
<link rel="preload" href="#{c.url}" as="script">
<script defer src='#{c.url}' data-theme-id='#{c.theme_id}'></script>
list_baked_fields(theme_ids, target, name).map { |f| f.value_baked || f.value }.join("\n")
name = name&.to_sym
list_baked_fields(target, name).map { |f| f.value_baked || f.value }.join("\n")
def set_field(target:, name:, value: nil, type: nil, type_id: nil, upload_id: nil)
type_id ||=
value ||= ""
theme_fields.find { |f| f.name == name && f.target_id == target_id && f.type_id == type_id }
if value.blank? && !upload_id
if field.value != value || field.upload_id != upload_id
if kind == :child
return {} if data.nil?
settings_hash = {}
{}.tap do |meta|
contents << "$#{field.name}: unquote(\"#{url}\");"
next if name == "theme_uploads" || name == "theme_uploads_local"
current_values = CSV.parse(setting_row.value, **{ col_sep: "|" }).flatten
parts = CSV.parse(item, **{ col_sep: "," }).flatten
.order(name: :asc)
content +=
if component? && !enabled?
@disable_log ||=
select("tag_users.*")
.where(id: tag_ids)
if tag_ids.present? &&
.where(user_id: user.id, tag_id: tag_ids)
remove = (old_ids - tag_ids)
records.where("tag_id in (?)", remove).destroy_all
(tag_ids - old_ids).map do |tag_id|
if tag_id.is_a?(::Tag)
tag = tag_id
tag_id = tag.id
tag = Tag.find_by_id(tag_id)
tag_id = tag_id.to_i
builder.where("tu.topic_id = :topic_id", topic_id: topic_id)
builder.where("tu.user_id = :user_id", user_id: user_id)
@permission_types ||= Enum.new(full: 1, readonly: 3)
-> { where(target_tag_id: nil) },
source: "tag"
if tag_name =
self.pluck(:id, :name).each { |id, name| return id if Slug.for(name) == slug }
filter_sql = <<~SQL
if: Proc.new { |t| t.new_record? || t.will_save_change_to_target_tag_id? }
->(name) {
where("lower(tags.name) IN (?)", name)
->(guardian) { where("tags.#{Tag.topic_count_column(guardian)} > 0") }
scope :base_tags, -> { where(target_tag_id: nil) }
self.find_by("lower(name) = ?", name.downcase)
WHERE stats.category_id in (#{scope_category_ids.join(",")})
DB.query_hash(<<~SQL).map!(&:symbolize_keys!)
WHERE user_id = #{user_id.to_i}
JOIN group_users gu ON gu.user_id = #{user_id.to_i}
DB.exec(<<~SQL, id: remove_lower, target: target)
VALUES.map { |l| { name: l, value: l } }
validates :custom_reason, presence: true, if: -> { is_custom? }
validates :custom_reason, absence: true, if: -> { !is_custom? }
custom: 1,
names_used.each { |name| touch(name) }
size += 1 if mod > 0
page_name = (index + 1).to_s
offset = (name.to_i - 1) * max_page_size
.new(file)
top_menu.split("|").map { |menu_item| TopMenuItem.new(menu_item) }
.map { |item| item.name }
!setting.split("|").include?(host)
force_https? ? "https" : "http"
upload ? full_cdn_url(upload.url) : ""
send("#{new_method}=", args)
@categories ||=
by_id = {}
seq = nil
.each { |key| Discourse.cache.redis.del(key) }
self.value = self.value.sub(%r{\Ahttp(s)?://#{Discourse.current_hostname}}, "")
self.external = value.start_with?("http://", "https://")
return 0 if click_through == 0 || searches == 0
((click_through.to_f / searches.to_f) * 100).ceil(1)
@search_types ||= Enum.new(header: 1, full_page: 2)
@search_result_types ||= Enum.new(topic: 1, user: 2, category: 3, tag: 4)
Discourse.redis.keys("__SEARCH__LOG_*").each { |k| Discourse.redis.del(k) }
def self.log(term:, search_type:, ip_address:, user_id: nil)
id, old_term = existing.split(",", 2)
.order("date")
.group("date")
select_sql = <<~SQL
result = result.where("created_at < ?", end_date) if end_date
self.domain = self.domain.downcase.sub(/\Awww\./, "") if self.domain
def self.watch(url, domain, opts = {})
normalized = url.gsub(%r{http(s?)://}i, "")
normalized.gsub!(%r{(/)+\z}, "") # trim trailing slashes
def self.watch(ip_address, opts = {})
if val.is_a?(IPAddr)
if v.nil?
ip_address = IPAddr === ip_address ? ip_address.to_cidr_s : ip_address.to_s
order("masklen(ip_address) DESC").find_by("? <<= ip_address", ip_address)
found = !!b && b.action_type == action_type
network(inet(host(ip_address) || '/' || :to_masklen))::text subnet
.map do |subnet|
old_ips =
.where("ip_address << ?", subnet)
.where("family(ip_address) = ?", family)
.where("masklen(ip_address) IN (?)", from_masklen)
name, domain = email.split("@", 2)
name = name.gsub(/\+.*/, "")
def self.block(email, opts = {})
distances = {}
(1..second.length).each do |i|
(1..first.length).each do |j|
@values ||= valid_values.sort.map { |x| { name: "s3.regions.#{x.tr("-", "_")}", value: x } }
a.icon = "user-plus"
delete_args = {}
reviewable_scores.any? { |rs| rs.reason == "suspect_user" }
enum status: { pending: 0, agreed: 1, disagreed: 2, ignored: 3 }
@types = nil
next_id = types.values.max + 1
score > 0 ? score : 0
1.0 + (user.staff? ? 5.0 : user.trust_level.to_f) + user_accuracy_bonus(user)
return 0.0 if user_stat.blank? || user.bot?
agreed ||= 0
disagreed ||= 0
total = (agreed + disagreed).to_f
return 0.0 if total <= 5
(Math.log(total, 4) * 5.0)
).round(2)
a.icon = "check"
a.icon = "times"
data: { post_url: created_post.url }.to_json,
saved_change_to_id?(from: nil) && pending? || saved_change_to_status?(from: "pending")
icon: "times",
@post ||= (target || Post.with_deleted.find_by(id: target_id))
action.label = "#{prefix}.title"
enum status: { pending: 0, approved: 1, rejected: 2, ignored: 3, deleted: 4 }
enum type: { created: 0, transitioned: 1, edited: 2, claimed: 3, unclaimed: 4 }
if !post.user_deleted? && !post.hidden?
icon: "far-trash-alt",
icon: "thumbs-up",
agree(performed_by, args) { |pa| post.hide!(pa.post_action_type_id) }
cached = {}
result.update_flag_stats = { status: :agreed, user_ids: actions.map(&:user_id) }
data = { topic_id: topic.id }
super("Can't perform `#{action_id}` on #{klass.name}")
enum :status, { pending: 0, approved: 1, rejected: 2, ignored: 3, deleted: 4 }
enum :priority, { low: 0, medium: 5, high: 10 }, scopes: false, suffix: true
enum :sensitivity, { disabled: 0, low: 9, medium: 6, high: 3 }, scopes: false, suffix: true
where("score >= ?", min_score_for_priority)
update_args = {
row = DB.query_single(<<~SQL, update_args)
take_action_bonus = take_action ? 5.0 : 0.0
rs =
values.each do |k, v|
high =
((high.to_f * ratio) * scale).truncate(2)
.each { |r| r.perform(performed_by, action, args) }
{ created_by: :user_stat },
ids: nil,
to_date: nil,
result = result.joins(<<~SQL)
if min_score > 0 && status == :pending
).where("rct.user_id IS NULL OR rct.user_id = ?", user.id)
@@serializers ||= {}
DB.query(<<~SQL, reviewable_id: id)
), 0.0)
icon: "user-times",
a.icon = "user-times"
a.icon = "ban"
result = DB.query(<<~SQL, user_ids: user_ids)
SET flags_#{status} = flags_#{status} + 1
:end_date,
{ type: :date, property: :x, title: I18n.t("reports.default.labels.day") },
{ type: :number, property: :y, title: I18n.t("reports.default.labels.count") },
@end_date ||= Time.now.utc.end_of_day
@prev_data = nil
@available_filters = {}
@filters = {}
report.end_date.to_date.strftime("%Y%m%d"),
def add_filter(name, options = {})
pattern = type ? "reports:#{type}:*" : "reports:*"
title: I18n.t("reports.#{type}.title", default: nil),
xaxis: I18n.t("reports.#{type}.xaxis", default: nil),
yaxis: I18n.t("reports.#{type}.yaxis", default: nil),
available_filters: self.available_filters.map { |k, v| { id: k }.merge(v) },
}.tap do |json|
)&.as_json
def self._get(type, opts = nil)
report = _get(type, opts)
report_method = :"report_#{type}"
elsif type =~ /_reqs\z/
.reject { |k, v| k =~ /mobile/ }
.map { |k, v| v if k =~ /page_view/ }
report.icon = "file" if filter == :page_view_total
.where("date >= ? AND date <= ?", report.start_date, report.end_date)
.order(date: :asc)
.group(:date)
.sum(:count)
.each { |date, count| report.data << { x: date, y: count } }
data.where("date >= ? AND date < ?", (report.start_date - 31.days), report.start_date).sum(
report.prev_data = prev_data.map { |k, v| { x: k, y: v } }
subject = Topic.where("topics.user_id > 0")
rgb = hex.scan(/../).map { |color| color.hex }
hex = hex.gsub("#", "")
if hex.size == 3
chars = hex.scan(/\w/)
hex = hex.ljust(6, hex.last) if hex.size < 3
hex_color = hex_color.gsub("#", "")
rgbs = hex_color.scan(/../)
rgbs.map! { |color| color.hex }.map! { |rgb| rgb.to_i }
.where(themes: { enabled: true })
.pluck("themes.name", "themes.id")
new_path = "#{File.dirname(path)}/#{SecureRandom.hex}#{File.extname(path)}"
:"#{modifier_name}=",
field_ids_to_destroy = theme.theme_fields.pluck(:id) - updated_fields.map { |tf| tf&.id }
next if topic_id == 0 || post_number == 0
if uniq.length == 0
) X ON X.topic_id = p.topic_id AND X.post_number = p.post_number
) X on X.topic_id = p1.topic_id AND X.post_number = p1.post_number
pp = nil
sql << report_raw_sql(user, skip_new: true)
u.id AS user_id,
JOIN users u on u.id = #{user.id.to_i}
((#{unread}) OR (#{new})) AND
.each do |tu|
}.as_json
{ name: "user.email_previous_replies.never", value: 2 },
).update_all "reads = reads + 1"
rows = DB.exec(<<~SQL, args)
SET msecs = msecs + :msecs
topic ||= Topic.find(topic_id)
last_read = nil if last_read < 1
PostTiming.where("user_id = ? and topic_id in (?)", user_id, topic_ids).delete_all
TopicUser.where("user_id = ? and topic_id in (?)", user_id, topic_ids).delete_all
Post.where(topic_id: topic_ids).update_all("reads = reads - 1")
UserStat.where("first_unread_pm_at > ? AND user_id = ?", date, user_id).update_all(
DB.exec(<<~SQL, date: date, user_id: user_id, topic_id: topic.id)
DB.exec(<<~SQL, date: date, user_id: user_id)
user_id = :user_id
max_time_per_post = ((Time.now - current_user.created_at) * 1000.0)
while i > 0
join_table << "SELECT #{topic_id.to_i} topic_id, #{post_number.to_i} post_number,
SET msecs = LEAST(t.msecs::bigint + x.msecs, 2^31 - 1)
x.user_id = t.user_id
id = :topic_id
is_regular = DB.exec(sql, topic_id: topic_id) == 1
super&.delete("-")
@move_types ||= Enum.new(:new_topic, :existing_topic)
@post_ids = post_ids
@move_to_pm = move_to_pm
@move_map = {}
@reply_count = {}
update = {
DB.exec(<<~SQL, metadata)
VALUES (:old_topic_id, :old_post_id, :old_post_number, :new_topic_id, :new_topic_title, :new_post_id, :new_post_number)
WHERE x.post_id = p.id AND x.new_topic_id <> p.topic_id
AND (pr.reply_post_id = mp.old_post_id OR pr.post_id = mp.old_post_id)
AND p.user_id = tu.user_id
JOIN topics t ON (t.id = :new_topic_id)
post_id: @post_ids,
move_type_str.sub!("topic", "message") if @move_to_pm
.where.not(raw: "")
by_user: @user,
too_large: "too_large",
def cook(raw, opts = {})
next if limit <= 0
@onebox_urls << url
.css("img", "video", "audio")
.reject do |t|
@linked_hosts = {}
@cooked_stripped ||=
href.start_with?("#{Discourse.base_path}/u/") ||
href.start_with?("#{Discourse.base_path}/c/") ||
@types = Enum.new(like: 2)
scope :active, -> { where(disagreed_at: nil, deferred_at: nil, agreed_at: nil, deleted_at: nil) }
return {} if collection.blank? || !user
user_id = user.try(:id) || 0
user_actions = {}
JOIN posts p ON pa.post_id = p.id
pa.user_id = :user_id AND
p.topic_id IN (:topic_ids)
def self.act(created_by, post, post_action_type_id, opts = {})
SELECT #{target_post.id}, #{cols_to_copy}
if public_send("is_#{type}?")
if (is_flag? || is_like?) && user && user.trust_level >= 2
@rate_limiter = RateLimiter.new(user, "create_#{type}", limit, 1.day.to_i)
column = "#{post_action_type_key}_count"
.sum(
has_many :revisions, -> { order(:number) }, foreign_key: :post_id, class_name: "PostRevision"
:no_bump,
scope :by_newest, -> { order("created_at DESC, id DESC") }
scope :by_post_number, -> { order("post_number ASC") }
scope :with_user, -> { includes(:user) }
scope :created_since, ->(time_ago) { where("posts.created_at > ?", time_ago) }
-> { joins(:topic).where("topics.archetype <> ?", Archetype.private_message) }
-> { joins(:topic).where("topics.archetype = ?", Archetype.private_message) }
scope :with_topic_subtype, ->(subtype) { joins(:topic).where("topics.subtype = ?", subtype) }
scope :visible, -> { joins(:topic).where("topics.visible = true").where(hidden: false) }
->(guardian) { where("posts.post_type IN (?)", Topic.visible_post_types(guardian&.user)) }
->(user, since) {
q =
->(pattern, type = "string") {
where("raw ILIKE ?", "%#{pattern}%")
where("raw ~* ?", "(?n)#{pattern}")
posts.cooked LIKE '%<img %' OR
posts.cooked LIKE '%<video %'
@hidden_reasons ||=
@types ||= Enum.new(regular: 1, moderator_action: 2, small_action: 3, whisper: 4)
@cook_methods ||= Enum.new(regular: 1, raw_html: 2, email: 3)
@notices ||= Enum.new(custom: "custom", new_user: "new_user", returning_user: "returning_user")
if user && user.new_user_posting_on_first_day? && post_number && post_number > 1
read_count < 0 ? 0 : read_count
post_id != (nil) && post_id.to_i != (id)
@post_analyzers ||= {}
self.last_editor_id ? (User.find_by_id(self.last_editor_id) || user) : user
.map { |h| h.strip }
.reject { |h| !h.include?(".") }
hosts.reject! { |h| allowlisted.any? { |w| h.end_with?(w) } }
.group(:domain, :post_id)
.each_key do |tuple|
WHERE posts.topic_id = #{topic_id.to_i}
WHERE p1.percent_rank <= ?
AND p1.topic_id = #{topic_id.to_i}
return cooked.sub(%r{\<aside.+\</aside\>}m, "")
@reply_to_post ||=
).try(:user)
def excerpt(maxlength = nil, options = {})
post_number.blank? ? topic.try(:highest_post_number) == 0 : post_number == 1
via_email && post_number.present? && post_number > 1
).count != 0
def url(opts = nil)
page = ""
page = "?page=#{topic_view.page}" if topic_view.page > 1
result = +"/t/"
ids = post_ids.map { |u| u }
urls = {}
.where("posts.id" => ids)
def revise(updated_by, changes = {}, opts = {})
post = Post.find(id)
problems << { post: post, ex: e }
{ raw: self.raw, user_id: new_user.id, edit_reason: edit_reason },
.each do |quote|
post_id: id,
.where("posts.created_at >= ? AND posts.created_at <= ?", start_date, end_date)
post_ids = DB.query_single(<<~SQL, post_id: id, topic_id: topic_id)
JOIN breadcrumb AS b ON (r.post_id = b.id)
builder.where("level > 0")
replies.each { |r| r.symbolize_keys! }
%r{/uploads/#{current_db}/},
%r{/original/},
%r{/optimized/},
selectors = fragments.css("a/@href", "img/@src", "source/@src", "track/@src", "video/@poster")
.map do |media|
if src.end_with?("/images/transparent.png") &&
if src.start_with?("upload://")
src = "#{SiteSetting.force_https ? "https" : "http"}:#{src}" if src.start_with?("//")
)&.path
sha1 =
.select(:id, :cooked)
ids = posts.pluck(:id)
.where(upload_references: { target_type: "Post" })
.pluck(:sha1)
upload_id ||= yield(post, src, path, sha1)
rows = PluginStoreRow.where("plugin_name = ? AND key IN (?)", plugin_name, keys).to_a
hash = { plugin_name: plugin_name, key: key }
if row.type_name == "JSON"
value.is_a?(Hash) || value.is_a?(Array) ? "JSON" : value.class.to_s
value == "true"
@rules = source.split("|").map { |rule| parse_rule(rule) }.compact if source.present?
return unless rule =~ %r{/.*/}
regex = +""
sub = +""
c = 0
c += 1 if !escaping && l == "/"
escaping = l == "\\"
if c > 1
sub << l
regex << l
@rules.each { |(regex, sub)| url = url.sub(regex, sub) }
permalinks.where!("url ILIKE :url OR external_url ILIKE :url", url: "%#{url}%") if url.present?
def self.create_for(upload, width, height, opts = {})
return if width <= 0 || height <= 0
url: "",
to = prepend_decoder!(to, to, opts)
def self.resize(from, to, width, height, opts = {})
optimize("resize", from, to, "#{width}x#{height}", opts)
def self.crop(from, to, width, height, opts = {})
optimize("crop", from, to, "#{width}x#{height}", opts)
def self.downsize(from, to, dimensions, opts = {})
error << $1
error << " unknown reason"
lambda { |n = nil|
n ||= 10
->(user, types, limit = 30) {
->(user_id, limit: 30) {
) n2
WHERE n1.user_id = n2.user_id AND n1.id < n2.id
AND t.id = n.topic_id
quoted: 3,
edited: 4,
liked: 5,
posted: 9,
where("created_at > ?", min_date)
to_remove << r.id
result.reject! { |r| to_remove.include?(r.id) }
@data_hash ||=
count ||= 10
builder.where(<<~SQL, user_id: user.id)
.where(id: ids)
.uniq(&:id)
.sort do |x, y|
y.created_at <=> x.created_at
{ name: "user.new_topic_duration.not_viewed", value: -1 },
{ name: "user.new_topic_duration.after_1_day", value: 60 * 24 },
{ name: "user.new_topic_duration.after_2_days", value: 60 * 24 * 2 },
{ name: "user.new_topic_duration.after_1_week", value: 60 * 24 * 7 },
{ name: "user.new_topic_duration.after_2_weeks", value: 60 * 24 * 7 * 2 },
{ name: "user.new_topic_duration.last_here", value: -2 },
{ name: "user.mailing_list_mode.individual", value: 1 },
@values ||=
@language_names ||=
.glob(File.join(Rails.root, "config", "locales", "client.*.yml"))
belongs_to :invite, -> { unscope(where: :deleted_at) }
name: nil,
user ||= User.new
field_params = user_custom_fields || {}
invited_user ||=
.where("invites.email = ?", email)
group = Group.find_by(id: id)
.where("invites.email = ? AND invites.id != ?", email, invite.id)
Enum.new(not_required: 0, pending: 1, bulk_pending: 2, sending: 3, sent: 4)
if user && user.id != self.invited_users&.first&.user_id
!redeemed? && !expired? && !deleted_at? && !destroyed? && link_valid?
_, domain = email.split("@")
.where("expires_at > ?", Time.zone.now)
.where("expires_at < ?", Time.zone.now)
.where("invites.invited_by_id = ?", inviter.id)
:y_titles,
@y_titles = {}
title: I18n.t("reports.#{self.type}.title"),
xaxis: I18n.t("reports.#{self.type}.xaxis"),
def self.find(type, _opts = {})
.inject({}) do |sum, v|
id: v.id,
report.data << {
end_date:,
topic = topics.find { |t| t.id == topic_id }
.group("topic_id")
username = nil if !(String === username)
username = nil if username&.include?("\0")
user_id = u.id if u
post_id ||=
cid = current_user ? (current_user.id) : (nil)
unless cid && cid == user_id
if parsed.scheme == "http" || parsed.scheme == "https"
if (referer.length < 3 || referer.length > 100) || (domain.length < 1 || domain.length > 100)
scope :addressed_to, ->(email) { where(<<~SQL, email: "%#{email}%") }
scope :addressed_to_user, ->(user) { where(<<~SQL, user_id: user.id) }
incoming_emails.to_addresses ILIKE '%' || user_emails.email || '%' OR
incoming_emails.cc_addresses ILIKE '%' || user_emails.email || '%')
@types ||= Enum.new(unknown: 0, handle_mail: 1, pop3_poll: 2, imap: 3, group_smtp: 4)
@mail_message ||= Mail.new(self.raw)
to = to.map(&:downcase).join(";") if to&.is_a?(Array)
cc = cc.map(&:downcase).join(";") if cc&.is_a?(Array)
from = from.first if from&.is_a?(Array)
https = uri.scheme == "https"
current || find_by(name: name, https: https, port: port)
url = +"http#{https ? "s" : ""}://#{name}"
url << ":#{port}" if https && port != 443 || !https && port != 80
@levels ||= Enum.new(:debug, :info, :warn, :error)
def self.log(message, level, group_id = nil, db = true)
now = Time.now.strftime("%Y-%m-%d %H:%M:%S.%L")
:warn,
group_id = group_or_id.is_a?(Integer) ? group_or_id : group_or_id.id
X.user_id,
) AS Z ON Z.user_id = gu.user_id AND Z.group_id = gu.group_id
.each_with_object({}) do |r, h|
(tag_ids - old_ids).each do |id|
records = records.where("#{filter}_id" => id)
.delete_all > 0
params = { group_id: group.id, level_num: level_num }
changed = true if DB.exec(sql, params) > 0
AND gag.id != :gag_id
gag_id: id,
def self.move_to_inbox!(group_id, topic, opts = {})
def self.archive!(group_id, topic, opts = {})
.where(topic_id: topic_id, posts: { post_number: 1 })
if: Proc.new { |g| g.name_before_last_save && g.saved_change_to_name? }
admins: 1,
staff: 3,
nobody: 0,
@visibility_levels = Enum.new(public: 0, logged_on_users: 1, members: 2, staff: 3, owners: 4)
Proc.new { |user, order, opts|
is_staff = !!user&.staff?
groups = self.order(order || "name ASC")
lambda { |user|
user_id: user && user.id,
clause = +<<~SQL
.each do |email|
.where(groups: { id: id })
.where("group_mentions.group_id = ?", self.id)
(10..19).to_a
next if user_id == -1
group.id = id
WHERE group_id = #{group.id}
SELECT #{group.id}, X.id, now(), now()
where_sql = ""
where_sql = "WHERE group_id IN (#{only_group_ids.map(&:to_i).join(",")})"
groups ||= Group
groups.where("name ILIKE :term_like OR full_name ILIKE :term_like", term_like: "%#{name}%")
if sort == :auto
prefix = "#{name.gsub("_", "\\_")}%"
group_ids = group_ids.split(",") if group_ids.is_a?(String)
group_ids.map!(&:to_i)
group_names = group_names.split(",")
if group = find_by(id: id)
current = usernames.split(",")
expected = val.split(",")
map =
group_users.each { |gu| @deletions << gu if deletions.include?(gu.user_id) }
users.pluck(:username).join(",")
data: { group_id: id, group_name: name }.to_json,
gu.group_id = :group_id
user_attributes = {}
WHERE gu.group_id = g.id)
if users.exclude?(user) && add(user)
@category_notifications ||= {}
define_method("#{level}_tags=") do |tag_names|
@tag_notifications ||= {}
group_path: "/g/#{self.name}",
builder.where(<<~SQL, id: id)
builder.set("#{column} = :id")
builder.where("#{column} IS NULL") if column == :flair_group_id
builder.set("#{column} = NULL")
builder.where("#{column} = :id")
pattern = "@(#{domains.gsub(".", '\.')})$"
.where("user_emails.email ~* ?", pattern)
domain.sub!(%r{\Ahttps?://}, "")
domain.sub!(%r{/.*\z}, "")
if @safe_secret_key_base && @token_in_redis &&
@safe_secret_key_base ||=
FileProvider.from(File.expand_path("../../../config/discourse_defaults.conf", __FILE__))
.each do |key|
instance_variable_set("@#{key}_cache", nil)
val = instance_variable_get("@#{key}_cache")
val = :missing if val.nil?
instance_variable_set("@#{key}_cache", val)
val == :missing ? nil : val
def self.skip_db=(v)
@skip_db = v
@skip_redis = v
@use_s3 ||=
if s3_bucket && s3_region &&
(s3_use_iam_profile || (s3_access_key_id && s3_secret_access_key))
) == :true
@use_s3 = nil
hash = { "adapter" => "postgresql" }
if val = self.public_send("db_#{s}")
db_variables = provider.keys.filter { |k| k.to_s.starts_with? "db_variables_" }
{ "production" => hash }
@config ||=
c = {}
@message_bus_config ||=
return setting == "true" if setting == "true" || setting == "false"
.new(File.read(@file))
.result()
resolve(var, var.nil? ? default : "")
resolve(var, var.nil? ? default : nil)
if key == :redis_port
FileProvider.from(File.expand_path("../../../config/discourse.conf", __FILE__)) ||
rows = find_for(user_id, given_date).update_all("likes_given = likes_given + 1")
if rows == 0
@statuses ||= Enum.new(created: 1, uploaded: 2, failed: 3)
{ name: "emoji_set.apple_international", value: "apple" },
{ name: "emoji_set.google", value: "google" },
{ name: "emoji_set.twitter", value: "twitter" },
{ name: "emoji_set.win10", value: "win10" },
{ name: "emoji_set.google_classic", value: "google_classic" },
name = name.delete_prefix(":").delete_suffix(":")
Emoji.custom.detect { |e| e.name == name }.present?
.detect { |e| e.name == normalized_name && (!is_toned || (is_toned && e.tonable)) }
Emoji.new.tap do |e|
e.name = name
@groups_file ||= "#{Rails.root}/lib/emoji/groups.json"
@groups ||=
groups = {}
.open(groups_file, "r:UTF-8") { |f| JSON.parse(f.read) }
@db_file ||= "#{Rails.root}/lib/emoji/db.json"
@db ||= File.open(db_file, "r:UTF-8") { |f| JSON.parse(f.read) }
.each do |emoji|
result << Emoji.new.tap do |e|
e.url = url
code.split("-").map!(&:hex).pack("U*")
next if name == "tm"
@reverse_map ||=
toned_code = (code.codepoints.insert(1, scale.to_i(16))).pack("U*")
str =
code = $1
if code && Emoji.custom?(code)
embedding_args = { id: "default" }
self.host.sub!(%r{\Ahttps?://}, "")
self.host.sub!(%r{/.*\z}, "")
if uri.is_a?(String)
host << ":#{uri.port}" if uri.port.present? && uri.port != 80 && uri.port != 443
path << "?" << uri.query if uri.query.present?
where("lower(host) = ?", host).each do |eh|
scope :unconfirmed, -> { where(confirmed: false) }
.where.not(id: self.id)
@scopes ||= Enum.new(signup: 1, password_reset: 2, email_login: 3, email_update: 4)
@_default_template ||=
File.read(File.join(Rails.root, "app", "views", "email", "default_template.html"))
scope :bounced, -> { where(bounced: true) }
email_logs.cc_addresses ILIKE '%' || user_emails.email || '%')
@topic ||= self.topic_id.present? ? Topic.find_by(id: self.topic_id) : self.post&.topic
count = where("created_at > ?", 1.day.ago).where(user_id: user.id).count
.group("DATE(created_at)")
.order("DATE(created_at)")
@cc_users ||= User.where(id: self.cc_user_ids)
{ name: "user.email_level.always", value: 0 },
{ name: "user.email_level.only_when_away", value: 1 },
{ name: "user.email_level.never", value: 2 },
VALUES (:user_id, :draft_key, 1)
r, _ =
r.to_i
force_save = force_save.to_s == "true"
user_id = :user_id AND
draft_key = :key
sequence += 1
{ sequence: sequence, draft_key: key, user_id: user.id },
DB.exec(<<~SQL, id: draft_id, sequence: sequence, data: data, owner: owner || current_owner)
, data = :data
, owner = :owner
opts = { user_id: user.id, draft_key: key, data: data, sequence: sequence, owner: owner }
draft_id = DB.query_single(<<~SQL, opts).first
data = :data,
owner = :owner,
return if !user || !user.id || !User.human_user_id?(user.id)
opts = { user_id: user.id, draft_key: key, sequence: sequence }
post&.user || topic&.user || user
!!defined?(@topic)
@topic :
!!defined?(@post)
post_ids = drafts.map(&:post_id)
draft.preload_topic(topics.detect { |t| t.id == draft.topic_id })
draft.preload_post(posts.detect { |p| p.id == draft.post_id })
draft_body = <<~MD
seq: #{sequence}
key: #{key}
return if post && post.raw == draft_body
{ raw: draft_body },
raw: I18n.t("draft_backup.pm_body"),
Discourse.cache.read(nonce_key) || "/"
if sso_record && (user = sso_record.user)
if sso_record && (user = sso_record.user) && !user.active && !require_activation
names = (groups || "").split(",").map(&:downcase)
to_be_added = to_be_added.where("groups.id NOT IN (?)", current_groups.map(&:id))
to_be_removed = to_be_removed.where("groups.id NOT IN (?)", desired_groups.map(&:id))
split = add_groups.split(",").map(&:downcase)
to_be_added = Group.where("LOWER(name) in (?) AND NOT automatic", split)
to_be_added = to_be_added.where("id NOT IN (?)", already_member)
split = remove_groups.split(",").map(&:downcase)
.where(automatic: false, group_users: { user_id: user.id })
.where("LOWER(name) IN (?)", split)
user_params = {
@types ||= Enum.new(all: 1, yearly: 2, monthly: 3, weekly: 4, daily: 5, quarterly: 6)
period_types.each_key { |p| refresh_period!(p) }
u.id user_id,
x.user_id = di.user_id AND
di.post_count <> x.post_count )
DB.exec <<~SQL if period_type == :all
enum type: { automatic: 0, user_field: 1, plugin: 2 }, _scopes: false
.map(&:to_sym)
) do |column|
{ name: "never", value: 0 },
{ name: "every_30_minutes", value: 30 },
{ name: "every_hour", value: 60 },
{ name: "daily", value: 1440 },
{ name: "weekly", value: 10_080 },
{ name: "every_month", value: 43_200 },
{ name: "every_six_months", value: 259_200 },
scope :with_deleted, -> { unscope(where: :deleted_at) }
:ok,
def create_totp(opts = {})
ROTP::TOTP.new(data, issuer: SiteSetting.title.gsub(":", ""))
last_used = 0
!token.blank? &&
10.times { codes << SecureRandom.hex(16) }
{ salt: salt, code_hash: hash_backup_code(code, salt) }
PRIORITIES = Enum.new(ignore: 1, very_low: 2, low: 3, normal: 0, high: 4, very_high: 5)
scope :admins, -> { where(admin: true) }
scope :moderators, -> { where(moderator: true) }
scope :staff, -> { where("moderator or admin ") }
@whisperer ||=
if group_name == :admins || group_name == :moderators
.where("date >= ? and date <= ?", report.start_date, report.end_date)
.map { |ua, count| { user_agent: ua, count: count } }
report.icon = "user"
:by_day,
{ property: :x, title: I18n.t("reports.users_by_type.labels.type") },
{ property: :y, type: :number, title: I18n.t("reports.default.labels.count") },
label = Proc.new { |x| I18n.t("reports.users_by_type.xaxis_labels.#{x}") }
url = Proc.new { |key| "/admin/users/list/#{key}" }
if admins > 0
url: url.call("admins"),
icon: "shield-alt",
key: "admins",
x: label.call("admin"),
y: admins,
url: url.call("silenced"),
key: "silenced",
x: label.call("silenced"),
.each do |level, count|
url = Proc.new { |k| "/admin/users/list/#{k}" }
report.data << { url: url.call(key), key: key, x: level.to_i, y: count }
subject = Post.where("posts.user_id > 0")
type: :user,
id: :user_id,
ELSE ROUND((1-(#{agreed} / #{disagreed})) * (#{disagreed} - #{agreed})) END
) AS score
AND rs.created_at <= :end_date
flagger = {}
count(*) filter (WHERE previous_value::integer < 1 AND new_value = '1')
count(*) filter (WHERE previous_value::integer < 2 AND new_value = '2')
created_at >= '#{report.start_date}'
AND created_at <= '#{report.end_date}'
x: row.date.strftime("%Y-%m-%d"),
y: row.instance_variable_get("@#{filter}"),
type: "list",
type: :link,
id: :author_id,
type: :text,
ON u.id = up.user_id
LIMIT #{report.limit || 250}
builder.where("up.extension = :extension", extension: extension_filter.sub(/\A\./, ""))
limit: report.limit || 8,
type: :topic,
id: :topic_id,
WHERE created_at >= '#{report.start_date}' AND created_at <= '#{report.end_date}'
.query(sql, limit: report.limit || 250)
type: :date,
JOIN users u ON u.id = t.user_id
AND t.created_at <= :end_date
report.data = {
WHERE t.user_id IN (#{User.admins.pluck(:id).join(",")})
LIMIT #{report.limit || 20}
) t1
JOIN users u ON u.id = t1.user_id
start_date + 1,
type: :post,
topic_id: :topic_id,
id: :editor_id,
ON p.id = pr.post_id
/*join*/
revision = {}
report.prev_period = prev_period_data.sum { |k, v| v }
data.each { |key, value| report.data << { x: key, y: value } }
ON m.user_id = uv.user_id
WHERE uv.visited_at >= '#{report.start_date}'
AND uv.visited_at <= '#{report.end_date}'
AND created_at >= '#{report.start_date}'
ON pa.agreed_by_id = m.user_id
ON df.user_id = af.user_id
ON pr.user_id = m.user_id
WHERE pr.created_at >= '#{report.start_date}'
AND pr.created_at <= '#{report.end_date}'
AND p.user_id <> pr.user_id
ON t.user_id = m.user_id
AND t.created_at >= '#{report.start_date}'
AND t.created_at <= '#{report.end_date}'
ON p.user_id = m.user_id
ON t.id = p.topic_id
AND p.created_at >= '#{report.start_date}'
AND p.created_at <= '#{report.end_date}'
pm_count AS (
m.user_id,
mod = {}
id: :staff_id,
id: :poster_id,
id: :flagger_id,
WHERE post_action_type_id IN (#{flag_types.values.join(",")})
ON p.id = pa.post_id
ON u.id = p.user_id
ON u.id = pa.user_id
ON sd.id = pa.id
ON fd.id = pa.id
ON pd.id = pa.id
report.icon = "flag"
{ type: :percent, property: :y, title: I18n.t("reports.default.labels.percent") },
dau_avg =
(sum.to_f / data_points.count.to_f).ceil(2)
prev = prev_data.sum { |k, v| v }
prev = prev / ((report.end_date - report.start_date) / 1.day) if prev > 0
.map { |date, count| { x: date, y: count } }
included { before_save { self.position ||= self.class.count } }
created_at && (time_limit > 0) && (created_at < time_limit.minutes.ago)
result ||= self.find_by(url: uri.path)
if self.name == "Upload"
urls << uri.path
field = field.gsub("%7B", "{").gsub("%7D", "}")
sorted_types = types.keys.select { |k| k.end_with?("*") }.sort_by(&:length).reverse
if Array === type
.where(foreign_key => ids, :name => allowed_fields)
.each do |cf|
@custom_field_types ||= {}
empty = {}
fk = (name.underscore << "_id")
.where("#{fk} in (?)", map.keys)
.where("name in (?)", fields)
.pluck(fk, :name, :value)
.each do |id, name, value|
fields.each do |k, v|
_custom_fields.create!(name: k, value: v) if row_count == 0
array_fields = {}
t = {}
dup.each do |k, v|
if v.is_a?(Array) && field_type != :json
v.each { |subv| _custom_fields.create!(name: k, value: subv) }
write_value = value.is_a?(Hash) || field_type == :json ? value.to_json : value
row_count = DB.exec(<<~SQL, name: name, value: write_value, id: id, now: Time.zone.now)
VALUES (:id, :name, :value, :now, :now)
.map(&:downcase)
.map do |slug|
slug_path.map! { |slug| CGI.escape(slug) }
if @thread && @thread.alive?
delta = @last_ensure_thread && (now - @last_ensure_thread)
@thread = nil if !@thread&.alive?
@thread ||= Thread.new { thread_loop }
if Redis::CommandError === ex && ex.message =~ /READONLY/
@flush = true
key, klass, db, time = QUEUE.deq
_redis_key = "#{klass},#{db},#{time.strftime("%Y%m%d")},#{key}"
counts ||= Hash.new(0)
if val > 0
klass_name, db, date, local_key = key.split(",", 4)
date = Date.strptime(date, "%Y%m%d")
val == -1 || ColorScheme.find_by_id(val)
ColorScheme.all.map { |c| values << { name: c.name, value: c.id } }
Dark: {
Neutral: {
Latte: {
Summer: {
Dracula: {
base_colors.each { |name, color| base_with_hash << { name: name, hex: "#{color}" } }
v.each { |name, color| colors << { name: name, hex: "#{color}" } }
has_many :color_scheme_colors, -> { order("id ASC") }, dependent: :destroy
base_colors = {}
@base_color_scheme.colors = base_colors.map { |name, hex| { name: name, hex: hex } }
{ name: name, hex: hex }
(enabled_color_scheme || base).colors.find { |c| c.name == name }.try(:hex) || "nil"
cache_key = scheme_id ? name + "_#{scheme_id}" : name
@colors_by_name ||=
.inject({}) do |sum, c|
color_scheme_colors.map { |c| { name: c.name, hex: c.hex } }
-0.78,
0.9,
-0.8,
params = { user_id: user.id, level_num: level_num }
def self.auto_track(opts = {})
def self.auto_watch(opts = {})
/*where2*/
builder.where("X.topic_id = tu.topic_id AND X.user_id = tu.user_id")
builder.where2("tu1.user_id = :user_id", user_id: user_id)
.where("topic_count > 0")
.update_all("topic_count = topic_count - 1")
WHERE tag_id in (:tag_ids)
tag_ids = topic.tags.map(&:id)
(tag_ids - updated_tag_ids).each do |tag_id|
@topics_by_id = {}
@topics_by_category_id = {}
@all_topics =
@all_topics.each do |t|
subcategory_ids = {}
to_delete << c
@categories.delete_if { |c| to_delete.include?(c) }
@permission_types ||= Enum.new(full: 1, create_post: 2, readonly: 3)
current = {}
.order(:rank)
.where("id >= ?", next_category_id)
.order("id ASC")
next_id =
query_opts = {
-> { select "id, title, slug" },
class_name: "Topic",
Proc.new { |c|
c.new_record? || c.will_save_change_to_name? ||
in: 1..50,
scope :latest, -> { order("topic_count DESC") }
->(guardian = nil) {
cats: ids,
->(guardian) {
where("1 = 0")
.where("category_groups.category_id = ?", self.id)
self.slug = Slug.for(name, "")
match_id = /\A(\d+)-category/.match(self.slug)
slug.present? ? self.slug : "#{self.id}-category"
ids = Group.where(name: names.split(",")).pluck(:id)
ids.each { |id| category_groups.build(group_id: id) }
RateLimiter.new(nil, "auto_bump_limit_#{self.id}", 1, 86_400 / num_auto_bump_daily.to_i)
.where('NULLIF(value, \'\')::int > 0')
if (auto_bumps.length > 0)
.where("id <> ?", self.topic_id)
.where("bumped_at < ?", (self.auto_bump_cooldown_days || 1).days.ago)
.order("bumped_at ASC")
.map do |tag_group|
.sort_by(&:order)
self.email_in = (email_in || "").strip.downcase.presence
.where("NOT hidden")
.where("topics.category_id = :id", id: self.id)
.pluck("posts.id")
.pluck("topics.id")
slug: (encoded_slug_or_id || slug_or_id),
@has_children ||= (id && Category.where(parent_category_id: id).exists?) ? :true : :false
@has_children == :true
def full_slug(separator = "-")
start_idx = "#{Discourse.base_path}/c/".size
url = +"#{Discourse.base_path}/c"
url << "/#{parent_category.slug_path.join("/")}" if parent_category_id
url << "/#{old_slug}/#{id}"
permalink = Permalink.find_by_url("c/#{slug_path.join("/")}")
if match_id = /\A(\d+)-category/.match(slug).presence
slug_path = slug_path_with_id.split("/")
if slug_path.last =~ /\A\d+\Z/
id = slug_path.pop.to_i
.where(topics: { id: nil })
topic_link: "<a href=\"#{oldest_topic.url}\">#{CGI.escapeHTML(oldest_topic.title)}</a>",
tags.count > 0 || tag_groups.count > 0
result = DB.query(<<-SQL, id: id, everyone: everyone, full: full)
Proc.new { |b|
scope :with_reminders, -> { where("reminder_at IS NOT NULL") }
->(user_id, topic_id) {
(topics.id = posts.topic_id)",
Gold = 1
Silver = 2
Bronze = 3
Other = 5
id && id <= 5
Member = 2
Leader = 4
@trigger_hash ||=
None = 0
(1..4).to_a
@like_badge_counts ||= {
NicePost => 10,
GoodPost => 25,
GreatPost => 50,
NiceTopic => 10,
GoodTopic => 25,
DB.exec(<<~SQL, badge_id: self.id, updated_at: Time.zone.now)
SET title = '', updated_at = :updated_at
DB.exec(<<~SQL, badge_id: self.id)
name.downcase.tr(" ", "_")
id <= 4
self.icon ||= val
Slug.for(self.display_name, "-")
query.blank? && !system?
S3 ||= "s3"
{ name: "admin.backups.location.s3", value: S3 },
{ name: "user.auto_track_options.never", value: -1 },
{ name: "user.auto_track_options.after_30_seconds", value: 1000 * 30 },
{ name: "user.auto_track_options.after_1_minute", value: 1000 * 60 },
{ name: "user.auto_track_options.after_2_minutes", value: 1000 * 60 * 2 },
{ name: "user.auto_track_options.after_3_minutes", value: 1000 * 60 * 3 },
{ name: "user.auto_track_options.after_4_minutes", value: 1000 * 60 * 4 },
{ name: "user.auto_track_options.after_5_minutes", value: 1000 * 60 * 5 },
{ name: "user.auto_track_options.after_10_minutes", value: 1000 * 60 * 10 },
.where("last_used < ?", 1.week.ago)
id = req_id(date, req_type)
req_id(date, req_type, 1)
global: {
write: {
update: {
aliases: {
topic_id: :id,
read_lists: {
list: {
show: {
create: {
sync_sso: {
log_out: {
suspend: {
invites: {
badges: {
search: {
engine_mount_path = nil if engine_mount_path == "/"
path = route.path.spec.to_s.gsub(/\(\.:format\)/, "")
urls << "#{engine_mount_path}#{path} (#{route.verb})"
methods.each { |method| urls << "* (#{method})" } if methods.present?
scope :active, -> { where("revoked_at IS NULL") }
scope :revoked, -> { where("revoked_at IS NOT NULL") }
->(key) {
@key ||= SecureRandom.hex(32) # Not saved to DB
if allowed_ips.present? && allowed_ips.none? { |ip| ip.include?(Rack::Request.new(env).ip) }
api_key_scopes.blank? || api_key_scopes.any? { |s| s.permits?(env) }
return if last_used_at && (last_used_at > 1.minute.ago)
@json ||= get_json
@@problem_blocks << blk if blk
s ? Time.zone.parse(s) : nil
if Jobs.queued > 0 && (last_job_performed_at.nil? || last_job_performed_at < 2.minutes.ago)
bad_keys =
if errors > 0
.map do |name, id|
@stats ||= {
posts_last_day: Post.where("created_at > ?", 1.days.ago).count,
posts_7_days: Post.where("created_at > ?", 7.days.ago).count,
posts_30_days: Post.where("created_at > ?", 30.days.ago).count,
users_last_day: User.real.where("created_at > ?", 1.days.ago).count,
users_7_days: User.real.where("created_at > ?", 7.days.ago).count,
users_30_days: User.real.where("created_at > ?", 30.days.ago).count,
active_users_last_day: User.where("last_seen_at > ?", 1.days.ago).count,
active_users_7_days: User.where("last_seen_at > ?", 7.days.ago).count,
active_users_30_days: User.where("last_seen_at > ?", 30.days.ago).count,
final_plugin_stats = {}
if !stats.key?(:last_day) || !stats.key?("7_days") || !stats.key?("30_days") ||
!stats.key?(:count)
per_cat_limit = 1 if per_cat_limit < 1
JOIN users u ON u.id = gu.user_id
def signup(user, opts = {})
tips =
def post_approved(user, opts = {})
def signup_after_reject(user, opts = {})
os: I18n.t("user_auth_tokens.os.#{os}"),
def notify_old_email(user, opts = {})
def notify_old_email_add(user, opts = {})
def confirm_old_email(user, opts = {})
def confirm_old_email_add(user, opts = {})
def confirm_new_email(user, opts = {})
def forgot_password(user, opts = {})
def email_login(user, opts = {})
def admin_login(user, opts = {})
def account_created(user, opts = {})
def account_exists(user, opts = {})
def digest(user, opts = {})
digest_opts = {
.where("topics.created_at < ?", 24.hours.ago)
@other_new_for_you =
@excerpts = {}
href: "#{Discourse.base_url}/new",
if value > 0
@counts << {
if @counts.size < 3
href: "#{Discourse.base_url}/about",
result = +"#{post.raw}\n\n"
result << "#{I18n.t("user_notifications.posted_by", username: post.username, post_date: post.created_at.strftime("%m/%d/%Y"))}\n\n"
.where("post_number < ?", post.post_number)
.where("posts.topic_id = ? AND posts.post_number = 1", post.topic_id)
template << "_pm"
template << "_group"
template << "_staged"
.where("topic_tags.topic_id = ?", post.topic_id)
show_tags_in_subject = tags.any? ? tags.join(" ") : nil
I18n.t("subject_pm")
context = +""
context << +"-- \n*#{I18n.t("user_notifications.previous_discussion")}*\n"
topic_excerpt = post.excerpt.tr("\n", " ") if post.is_first_post? && post.excerpt
topic_excerpt = ""
topic_url = ""
(EmailLog.where(user_id: user.id).where("created_at > ?", 1.day.ago).count) >=
if (allow_reply_by_email && user.staged) || (user.suspended? || user.staged?)
email_opts = {
list.push("#{u.email}")
min_date_str = min_date.is_a?(String) ? min_date : min_date.strftime("%Y-%m-%d")
((count = Discourse.redis.get(key)) && count.to_i) ||
.where("created_at > ?", min_date_str)
def send_test(to_address, opts = {})
context: "",
.find_each { |u| Promotion.new(u).review_tl2 }
logs: "#{ex}\n" + ex.backtrace.join("\n"),
return unless res && res.size == 2
tag_ids.each do |id|
tag = Tag.find_by(id: id)
topic = Topic.find_by(id: id)
post = Post.find_by(id: id)
OR posts.raw = ''
.order("tags.id ASC")
.where("posts.raw != ''")
.order("posts.id DESC")
.order("users.id ASC")
AND dndt.ends_at <= :now
pop.each_mail do |p|
if count > 3
@args,
@call_count ||= 0
@call_count += 1
(@call_count % 24) == 1
args = { min_topic_age: 1.day.ago }
error_context(args, "Rebaking post id #{post_id}", post_id: post_id),
error_context(args, "Rebaking user id #{user_id}", user_id: user_id),
.map do |user|
unseen_count == 0 ? user.username : nil
mentions = usernames.size > 0 ? "@#{usernames.join(", @")} " : ""
.sort_by { |key| key.updated_at }
@old_api_keys ||=
old_keys << api_key
message &&
old_site_settings_keys.map { |key| "#{key.name} - #{key.updated_at.to_date.to_fs(:db)}" }
messages.join("\n")
.where("created_at < ?", 1.hour.ago)
.find_each { |upload| upload.destroy! }
.where("optimized_images.url NOT LIKE '%/optimized/_X/%'")
.where("uploads.url LIKE '%/original/_X/%'")
.limit(50)
.where("last_seen_at < ?", timestamp)
user_ids = DB.query_single(<<~SQL, params)
User.where(id: user_ids).find_each { |user| notify_user(user) }
.new(user)
::Jobs.enqueue(:run_heartbeat, {})
if score > 0.0
url: "#{Discourse.base_url}/badges",
AND u.id NOT IN (#{current_owners.join(",")})
end_date = start_date + 1.year
suffix = 1
user.username = "#{old_username}#{suffix}"
suffix += 1
.where("users.created_at <= ? AND users.created_at >= ?", 1.day.ago, 6.months.ago)
) AS ucf ON ucf.user_id = users.id
users.each { |user_id| ::Jobs.enqueue(:user_email, type: "digest", user_id: user_id) }
.order("post_id DESC")
.each { |u| u.user.refresh_avatar }
.where("created_at < ?", grace_period.hour.ago)
.where(url: "")
.find_each(&:destroy!)
return if (Time.zone.now.to_i - c) < (grace_period / 2).hours
v ? v.to_i : v
.where("users.created_at < ?", clean_up_after_days.days.ago)
.where("last_match_at < ?", last_match_threshold)
.each_slice(50) { |slice| destroy(slice) }
WHERE date = '#{1.day.ago.strftime("%Y-%m-%d")}'
.where.not(remote_url: "")
error_context({}, code_desc: "Exception granting badges", extra: { badge_id: b.id }),
.where("users.created_at BETWEEN ? AND ?", 3.days.ago, 2.days.ago)
return 1.hour + (rand(30) * (count + 1))
if to_address == "no_email_found"
@skip_context = { type: type, user_id: user_id, to_address: to_address, post_id: post_id }
if type == "digest"
email_args = {}
(!post.try(:topic).try(:private_message?)) &&
if (notification && notification.read?) || (post && post.seen?(user))
if type == "confirm_new_email"
type == "notify_old_email_add"
if user.suspended? && (!post.user&.staff? || !post.user&.human?)
type == "user_private_message" &&
type != "user_private_message" &&
@#{@old_username}
@cooked_quote_username_regex = /(?<=\s)#{cooked_username}(?=:)/i
.where("raw ILIKE ?", "%@#{@old_username}%")
.joins(quoted("posts.id"))
.where("p.user_id = :user_id", user_id: @user_id)
.where("modifications SIMILAR TO ?", "%(raw|cooked)%@#{@old_username}%")
JOIN quoted_posts AS q ON (q.post_id = #{post_id_column})
JOIN posts AS p ON (q.quoted_post_id = p.id)
raw.gsub(@raw_mention_regex, "@#{@new_username}").gsub(
.css("a.mention")
user_id: @user_id,
post = Post.find_by(id: @post_id)
if post.raw != raw
changes = { raw: raw, edit_reason: I18n.t("upload.edit_reason") }
if user && avatar && avatar.user&.id == user.id && user.primary_email.present?
AND rs.user_id <> p.user_id
.find_each do |ua|
if (topic = topic_timer.topic).blank? || topic.closed == state
DB.exec(<<~SQL, topic_id: topic_id)
topic_users.user_id = b.user_id #{topic_id.present? ? "AND topic_users.topic_id = :topic_id" : ""}
) = 0 #{topic_id.present? ? "AND topic_users.topic_id = :topic_id" : ""}
time =
.each do |push_url, group|
retries ||= 3
if (retries -= 1) > 0 && !Rails.env.test?
:info,
.map { |s| normalize_src(s) }
return false if !(src =~ %r{/uploads/} || Upload.secure_uploads_url?(src))
uri = URI.parse(src)
if email_log.user.user_stat.bounce_score.to_s.start_with?("4.") ||
if cooked != (recooked || orig_cooked)
if !post.user&.staff? && !post.user&.staged?
s = post.raw
s << " #{post.topic.title}" if post.post_number == 1
.where.not(tag_group_permissions: { group_id: 0 })
counts = Hash.new(0)
User.real.moderators.where("id NOT IN (?)", @contacted).pluck(:id),
User.real.moderators.where("id NOT IN (?)", @contacted),
@contacted += users.pluck(:id)
post = post_id ? Post.with_deleted.find_by(id: post_id) : nil
if !post || post.trashed? || post.user_deleted? || !post.topic || post.raw.blank? ||
WHERE mu.muted_user_id = ? AND mu.user_id = users.id
if (user.id == post.user_id) && (user.user_option.mailing_list_mode_frequency == 2)
{ success: "OK" }.merge(merged: true, user: user_json),
post_id: post&.id,
id: user.id,
@timestamp ||= Time.now.strftime("%y%m%d-%H%M%S")
export_method = "#{name}_export"
h = { name: name, method: :"#{export_method}" }
condition_method = :"include_#{name}?"
filename = "#{filename}-#{user_export.id}"
type: "csv_export",
.select(:topic_id, :post_number, :raw, :cooked, :like_count, :reply_count, :created_at)
.select(:location, :website, :bio_raw, :views)
.each do |token|
.each do |log|
:seq,
.each do |ub|
link = ""
.each do |cu|
.each do |pa|
pa.id,
.each do |rev|
if entity == "user_list"
is_pm =
topic_hash = {
if attr == "bio"
@entity.gsub("_", " ").titleize
condition = {}
titles = {}
data.each { |row| yield row.values_at(*header).map(&:to_s) }
string&.include?(",") ? %Q|"#{string}"| : string
group_names = user.groups.map { |g| g.name }.join(";")
if attr == "action"
elsif attr == "staff_user"
elsif attr == "subject"
@web_hook,
@retry_count += 1
@web_hook.tag_ids.present? &&
body = {}
raise e unless e.message == "url"
previous_topics = ""
.each { |topic| previous_topics += "- #{topic.url}\n" }
params = { old_topic_id: parent_topic_id, new_topic_id: new_topic_id }
).last
) == 1
@sent = 0
@skipped = 0
@warnings = 0
@failed = 0
@groups = {}
@user_fields = {}
@valid_groups = {}
if Invite === result
@sent += 1
@skipped += 1
@failed += 1
save_log "Bulk Invite Process Failed -- '#{e.message}'"
group_names = group_names.split(";")
save_log "Invalid Group '#{group_name}'"
@warnings += 1
save_log "Invalid Topic ID '#{topic_id}'"
user_fields = {}
.where("name ILIKE ?", key)
.first || :nil
save_log "Invalid User Field '#{key}'"
user ||=
invite_opts = { email: email, topic: topic, group_ids: groups.map(&:id) }
if @sent > 0 && @failed == 0
sent: @sent,
logs: @logs.join("\n"),
group = Group.find_by("lower(name) = ?", group_name)
tmp_backup_path = "#{backup_path}.tmp"
IncomingEmail.where("user_id = ? OR from_address = ?", @user_id, @prev_email).delete_all
.where(user_id: @user_id)
def ip_where(column = "user_id")
details: "id: #{@user_id}\n%",
user = User.find(@user_id)
SET time_read = (
klass.name.sub(/\AJobs\:\:/, "")
.select { |klass| klass < self }
.each do |klass|
.create(all_tags.map { |tag_name| { name: tag_name } })
.where(name: "tags")
.find_each do |tcf|
.where(value: "true")
.where.not(value: "true")
Post.where("cooked LIKE ?", "%#{Emoji.base_url}%").find_each { |post| post.rebake! }
if row.count > 0
column_exists = DB.exec(<<~SQL) == 1
.select(:id, :image_upload_id, :image)
file = nil
break if count >= 3
to_award = {}
.select(:id, :created_at, :raw, :user_id)
.where("raw LIKE '%http%'")
if doc.search("a.onebox").size > 0
.select(:id, :created_at, :user_id)
.select(:id, :created_at, :cooked, :user_id)
.where("cooked LIKE '%emoji%'")
if (doc.css("img.emoji") - doc.css(".quote img")).size > 0
u.user_id,
).order("granted_at")
award_date = (first + (idx + 1).years)
.having("COUNT(email_tokens.email) > 1")
.each_key do |email|
query = users.where("email_tokens.email = ?", email).order(id: :asc)
.offset(1)
loop { break if DB.exec(sql) == 0 }
.reject { |c| c.seeded? }
c.slug = nil
.each { |t| SearchIndexer.update_tags_index(t.id, t.name) }
old = base_url.sub("s3.dualstack.", "s3-")
old_like = %"#{old}%"
DB.exec(<<~SQL, from: old, to: base_url, old_like: old_like)
SET url = replace(url, :from, :to)
.map do |l|
I18n.with_locale(:"#{l}") do
slugs = slugs.reject { |s| s == "%-topic" }
created_at < ? AND
user_id = -1
int = r.get("last_job_perform_at")
int ? Time.at(int.to_i) : nil
Sidekiq::RetrySet.new.count { |job| job.klass =~ /Email\z/ }
def initialize(job_class:, opts:, db:, jid:)
@@active_jobs << self
@@logger ||=
f = File.open "#{Rails.root}/log/sidekiq.log", "a"
@@log_queue ||= Queue.new
if !defined?(@@log_thread) || !@@log_thread.alive?
@@log_thread =
@@logger << @@log_queue.pop
self.class.raw_log("#{@data.to_json}\n")
@@mutex ||= Mutex.new
@@interval_thread ||=
def error_context(opts, code_desc = nil, extra = {})
ctx = {}
ctx.merge!(extra) if extra != nil
def execute(opts = {})
@db_duration || 0
if opts.has_key?(:current_site_id) &&
rescue => exc
Sidekiq.redis { |r| r.set("last_job_perform_at", Time.now.to_i) } if ::Jobs.run_later?
dbs =
dbs.each do |db|
exception = {}
logster_env = {}
super("Wrapped #{ex.class}: #{ex.message}")
@wrapped = ex
super if (::Jobs::Heartbeat === self) || !Discourse.readonly_mode?
def self.enqueue(job, opts = {})
klass = "::Jobs::#{job.to_s.camelcase}".constantize
Discourse.deprecate(<<~TEXT.squish, since: "2.9", drop_from: "3.0") if opts != parsed_opts
if ::Jobs.run_later?
def self.enqueue_in(secs, job_name, opts = {})
def self.enqueue_at(datetime, job_name, opts = {})
def self.scheduled_for(job_name, opts = {})
job_class = "Jobs::#{job_name.to_s.camelcase}"
def indent(text, by = 2)
spacer = " " * by
text.each_line { |line| result << spacer << line }
logo_url = SiteSetting.site_logo_url if logo_url.blank? || logo_url =~ /\.svg\z/i
return nil if logo_url.blank? || logo_url =~ /\.svg\z/i
.css("body > p, aside.onebox, body > ul, body > blockquote")
result << node.to_s
!(url.nil? || url.downcase.end_with?("svg"))
<script>#{raw_js}</script>
@loaded_js ||= load_js
url = nil if url && !url.start_with?(post.topic.url)
total_pages = (posts / TopicView.chunk_size) + (posts == TopicView.chunk_size ? 0 : 1)
result = "("
result << " <a href='#{topic.relative_url}?page=#{page}'>#{page}</a> "
page += 1
result << ")"
if dt >= 1.day.ago
dt.strftime("%e %b")
dt.strftime("%b '%y")
key = "js.action_codes.#{post.action_code}"
raw "<a href='#{Discourse.base_url}#{url}' style='color: ##{@anchor_color}'>#{title}</a>"
.sub("%{email_content}") { capture { yield } }
.gsub("%{html_lang}", html_lang)
.gsub("%{dark_mode_meta_tags}", dark_mode_meta_tags)
.gsub("%{dark_mode_styles}", dark_mode_styles)
html {
h1,
h2,
h3,
h4,
h5,
h6,
p,
td {
</style>
SiteSetting.private_email? ? "email/secure_#{name}" : "email/#{name}"
Discourse.redis.setex "#{sk}_#{key}", 7.days, current_user.id.to_s
File.join(resolved_s3_asset_cdn_url, "/"),
path = "#{resolved_s3_asset_cdn_url}#{path}"
elsif GlobalSetting.cdn_url&.start_with?("https") && is_brotli_req? &&
@links_to_preload << %Q(<#{resource_url}>; rel="preload"; as="#{type}")
list << (mobile_view? ? "mobile-view" : "desktop-view")
list << (mobile_device? ? "mobile-device" : "not-mobile-device")
list << "ios-device" if ios_device?
list << "rtl" if rtl?
list.join(" ")
result << "category-#{@category.slug_path.join("-")}" if @category && @category.url.present?
result.join(" ")
if cookie_seq && server_seq && cookie_seq.to_i >= server_seq &&
javascript.gsub!(/\342\200\250/u, "&#x2028;")
javascript.gsub!(%r{(</)}u, '\u003C/')
I18n.l(dt, format: :date_only)
(request ? I18n.locale.to_s : SiteSetting.default_locale).sub("_", "-")
if url.encoding.name != "UTF-8" || !url.valid_encoding?
result << tag(:meta, property: "og:type", content: "website")
result << tag(:meta, { property: "og:#{property}", content: content }, nil, true)
result << tag(:meta, { name: "twitter:#{property}", content: content }, nil, true)
.each { |tag_name| result << tag(:meta, property: "og:article:tag", content: tag_name) }
result << tag(:meta, name: "twitter:label1", value: I18n.t("reading_time"))
result << tag(:meta, name: "twitter:label2", value: I18n.t("likes"))
result.join("\n")
img_url =
if img_url.ends_with?(".svg")
result << tag(:meta, name: "twitter:image", content: img_url)
result << tag(:meta, name: "twitter:card", content: "summary")
if current_page?("/") || current_page?(Discourse.base_path)
json = {
:target => "#{Discourse.base_url}/search?q={search_term_string}",
if dark_scheme_id != -1
safe_mode.join(",")
controller.class.name.split("::").first == "Admin"
matcher = Regexp.new("/connectors/#{name}/.*\.html\.erb$")
erbs.each { |erb| result << render(inline: File.read(erb), locals: locals) }
uri = URI.parse("http://#{uri}") if uri.scheme.nil?
mobile_view? ? :mobile : :desktop,
:extra_js,
if opts.key?(:theme_id)
return "{}" if @preloaded.blank?
setup_data = {
if link.start_with?("//")
absolute_url = "#{uri.scheme}:#{link}"
elsif link.start_with?("/uploads/", "/images/", "/user_avatar/")
absolute_url = "#{Discourse.base_url}#{link}"
.each do |event|
message_id = event.dig("msg", "metadata", "message_id")
to_address = event.dig("msg", "email")
error_code = event.dig("msg", "diag")
if bounce_class == 10 || bounce_class == 25 || bounce_class == 30
key = "mailgun_token_#{token}"
message_id = data.dig("message", "headers", "message-id")
.sort_by(&:first)
.each do |key, value|
payload += key.to_s
if !@error
if type == :old
elsif type == :new
@user = token&.user
@error = I18n.t("change_email.already_done") if (!@user || !@change_request)
if current_user && current_user.id != @user&.id
@user =
if topic_id != 0 && guardian.can_see?(Topic.find_by_id(topic_id))
user_ids = params.require(:user_ids).split(",").map(&:to_i)
users = users.filter { |u| guardian.can_see_profile?(u) }
value = nil if value === "false"
) do |u|
render json: { email: email }
log_params = {
user.title = ""
counts: {
render(json: { available: true })
!(current_user&.admin? && is_api?)
associations.each { |a| a.update!(user: user) }
SiteSetting.hide_email_address_taken ? {} : { user_id: user.id },
values: {
admin: @user.admin?,
if @error || @user&.errors&.any?
admin: @user&.admin?,
type: "admin_login",
type: "email_login",
return redirect_to(path("/"))
.find_by(invited_users: { user_id: @user.id })
@user = User.where(id: user_key.to_i).first
if @user.blank? || @user.active? || current_user.present? || @user.from_staged?
if type.blank? || type == "system"
if type == "gravatar"
.select(:id, :name, :last_used, :created_at, :method)
size: 240,
success_json.merge(key: totp_data.scan(/.{4}/).join(" "), qr: qrcode_png.to_data_url)
!auth_token.blank? &&
if !current_user.staff? &&
) do |query|
@user = User.find(user_id) if user_id > 0
render json: { success: false, message: I18n.t(key) }
@origin = +"#{parsed.path}"
@origin << "?#{parsed.query}" if parsed.query
@origin = Discourse.base_path("/") if @origin.blank?
@auth_hash ||=
post: :topic,
post_id = nil
master_api_call = current_user.nil? && is_api?
current_user == user_badge.user && !(1..4).include?(user_badge.badge_id)
Time.new(1990, 01, 01),
return render_blank if size < 8 || size > 1000
closest = Discourse.avatar_sizes.to_a.min { |a, b| (size - a).abs <=> (size - b).abs }
filename = "#{sha}#{File.extname(url)}"
key: key.key,
push: key.has_push?,
if type == "avatar" && !me.admin? &&
is_api = is_api?
info =
sha1 = sha1.partition("_").first if sha1.include?("_")
serialized ||= (data || {}).as_json
file:,
type:,
is_api:,
if url.present? && is_api
render json: { slug: topic.slug, topic_id: topic.id, url: topic.url }
(!guardian.can_see_topic?(ex.obj) && ex.obj&.access_topic_via_group && ex.obj.deleted_at)
if (page < 0) || ((page - 1) * @topic_view.chunk_size >= @topic_view.topic.highest_post_number)
if last_modified = @topic_view.posts&.map { |p| p.updated_at }&.max&.httpdate
.where("posts.id in (?)", post_ids)
.joins("LEFT JOIN users u on u.id = posts.user_id")
.pluck(:id, :cooked, :username, :action_code, :created_at)
@topic =
group_id = id
name = Group.find_by(id: group_id).try(:name)
params.permit(:topic_id, :topic_time, timings: {})
url << "/#{post_number}" if post_number.to_i > 0
url << ".json" if request.format.json?
opts.each do |k, v|
s = url.include?("?") ? "&" : "?"
url << "#{s}#{k}=#{v}"
@last_modified ||=
File.exist?(@cache_file) ? File.ctime(@cache_file) : nil
type = cache_file.end_with?(".map") ? "application/json" : "text/javascript"
Discourse.anonymous_filters.map { |f| :"show_#{f}" }
.order("name ASC")
tags = tags.order(:id)
.map do |c|
{ id: c.id, tags: category_tags }
format.json { render json: { tags: @tags, extras: @extras } }
@list = nil
if filter == :top
@rss = "tag"
@description_meta = I18n.t("rss_by_tag", tag: tag_params.join(" & "))
render json: { tag: { id: tag.name, description: tag.description } }
tag = Tag.find_by_name(tag_name) || Tag.create!(name: tag_name)
render json: { tags: Tag.unused.pluck(:name) }
@link = "#{Discourse.base_url}/tag/#{tag_id}"
@description = I18n.t("rss_by_tag", tag: tag_id)
@title = "#{SiteSetting.title} - #{@description}"
@atom_link = "#{Discourse.base_url}/tag/#{tag_id}.rss"
@topic_list = query.create_list(:by_tag, {}, latest_results)
json_response = { results: tags }
render json: { tags: pm_tags }
value.inject({}) do |h, t|
.map do |t|
next if topic_count == 0 && t.pm_topic_count > 0 && !show_pm_tags
id: t.name,
text: t.name,
name: t.name,
pm_only: topic_count == 0 && t.pm_topic_count > 0,
t.target_tag_id ? target_tags.find { |x| x.id == t.target_tag_id }&.name : nil,
route_params = { format: "json" }
).join("/")
if pg > 1
def url_method(opts = {})
url.sub(".json?", "?")
root: "tag_groups",
matches.map { |x| { name: x.name, tag_names: x.tags.base_tags.pluck(:name).sort } },
doc.at_xpath("symbol").name = "svg"
extension = source_map ? ".css.map" : ".css"
query = query.order("id desc")
underscore_digest = digest ? "_" + digest : ""
location = location.sub(".css.map", ".css")
result = { success: "OK" }
errors << { field: field, description: msg.join }
redirect: "faq_url",
redirect: "tos_url",
topic_id: "tos_topic_id",
if map.has_key?(@page)
@page = "faq" if @page == "guidelines"
if I18n.exists?("js.#{@page}")
I18n.t("js.#{@page}")
@title = "#{title_prefix} - #{SiteSetting.title}"
@title << " - #{SiteSetting.short_site_description}"
if I18n.exists?("static.#{@page}")
if lookup_context.find_all("static/#{@page}").any?
destination = path("/")
if uri.path.present? && (uri.host.blank? || uri.host == forum_uri.host) && uri.path !~ /\./
destination = "#{uri.path}#{uri.query ? "?#{uri.query}" : ""}"
file&.read || ""
content.sub(%r{^//# sourceMappingURL=(service-worker-.+\.map)$}) do
opts = { disposition: nil }
@output =
@locale = dlocale.gsub(/_.*/, "")
@locale = dlocale.sub("_", "-") if @locale === "zh"
page += 1 if mod > 0
page > 1 ? "#{base_url}?page=#{page}" : base_url
results = {
topics.map! { |t| SimilarTopic.new(t) }
.where("public OR user_id = ?", current_user.id)
if destination_url && return_path == path("/")
return_path = "#{uri.path}#{uri.query ? "?#{uri.query}" : ""}"
redirect_to path("/")
return_path = topic.present? ? path(topic.relative_url) : path("/")
return_path = path("/")
return_path = path("/") if return_path.include?(path("/session/sso"))
connect_verbose_warn { <<~TEXT }
message = +"Failed to create or lookup user: #{e}."
json = {}
ok: false,
.slice(:ok, :error, :reason)
ok: true,
redirect_url ||= path("/login")
redirect_url ||= path("/")
event_data = {
if is_api?
{ error: I18n.t("login.not_approved") }
if @search_term.present? && @search_term.include?("\u0000")
raise Discourse::InvalidParameters if page && (!page.is_a?(String) || page.to_i.to_s != page)
search_args = {
search_context = { type: context, id: id }
safe_mode << "no_plugins"
redirect_to path("/?safe_mode=#{safe_mode.join(",")}")
/auth/
/*?api_key*
/*?*api_key*
.each do |agent|
filters = {
if (offset + PER_PAGE) < total_rows
).as_json,
unique_users = {}
topic_ids << r.topic_id
users << rs.user_id
{ created_by: "user", target_created_by: "user", reviewed_by: "user", claimed_by: "user" }
if (id = get_param(:id)).present?
theme = Theme.find_by(id: id.to_i)
param_key = :id
elsif (name = get_param(:name)).present?
elsif (url = get_param(:url)).present?
param_key = :url
.pluck(:id, :name)
result, pp =
render json: { valid_slug: true }
if !(names.is_a?(Array) && names.all? { |n| n.is_a? String })
if !client_id.is_a?(String) || client_id.blank?
!(present_channels.is_a?(Array) && present_channels.all? { |c| c.is_a? String })
!(leave_channels.is_a?(Array) && leave_channels.all? { |c| c.is_a? String })
content = topic_view.posts.map { |p| <<~MD }
-------------------------
last_post_id = Post.last.id if last_post_id <= 0
.where("posts.id <= ?", last_post_id)
.where("posts.id > ?", last_post_id - 50)
posts = posts.reject { |post| !guardian.can_see?(post) || post.topic.blank? }
@title = "#{SiteSetting.title} - #{rss_description}"
@title =
@link = "#{user.full_url}/activity"
if !guardian.public_send("can_edit?", post) && post.user_id == current_user.id &&
if raw_old.present? && raw_old != post.raw
user_custom_fields = {}
posts.each { |p| guardian.ensure_can_delete!(p) }
defer_flags: !(agree_with_first_reply_flag && i == 0),
).pick(:id)
since: "2.8.0.beta4",
drop_from: "2.9",
.select(:post_id),
if !success && GlobalSetting.try(:verbose_api_logging) && (is_api? || is_user_api?)
render json: json_obj, status: (!!success) ? 200 : 422
{ key => {} }
emails = recipients.select { |user| user.match(/@/) }
+"post##" << Digest::SHA1.hexdigest(
.join { |x, y| "#{x}:#{y}" },
if !post.topic ||
id: r.id,
flag_topic = flag_topic && (flag_topic == true || flag_topic == "true")
data = { found: false, html: build_not_found_page(status: 200) }
hijack(info: "#{url} topic_id: #{topic_id} user_id: #{user_id}") do
types.map! do |type|
manifest = {
start_url: Discourse.base_path.present? ? "#{Discourse.base_path}/" : "/",
title: "title",
text: "body",
url: "#{Discourse.base_path}/new-topic",
url: "#{Discourse.base_path}/top",
icon_entry = {
.each do |image|
sizes: "#{upload.width}x#{upload.height}",
if current_user && current_user.trust_level >= 1 &&
Discourse.filters.map { |f| :"category_#{f}" },
Discourse.filters.map { |f| :"category_none_#{f}" },
TopTopic.periods.map { |p| :"category_top_#{p}" },
TopTopic.periods.map { |p| :"category_none_top_#{p}" },
Discourse.anonymous_filters.map { |f| "#{f}_feed" },
Discourse.anonymous_filters.map { |f| :"category_#{f}" },
Discourse.anonymous_filters.map { |f| :"category_none_#{f}" },
:top,
TopTopic.periods.map { |p| :"top_#{p}" },
TopTopic.periods.map { |p| :"top_#{p}_feed" },
@rss = filter
filter_title = I18n.t("js.filters.#{filter.to_s}.title", count: 0)
@title << " - #{SiteSetting.title}"
elsif @category.blank? && (filter.to_s == current_homepage) &&
@title = "#{SiteSetting.title} - #{I18n.t("rss_description.latest")}"
@link = "#{Discourse.base_url}/latest"
@title = "#{SiteSetting.title} - #{I18n.t("rss_description.top")}"
@link = "#{Discourse.base_url}/top"
@atom_link = "#{Discourse.base_url}/top.rss"
@title = "#{@category.name} - #{SiteSetting.title}"
@link = "#{Discourse.base_url_no_prefix}#{@category.url}"
@atom_link = "#{Discourse.base_url_no_prefix}#{@category.url}.rss"
period ||=
define_method("top_#{period}") do |options = nil|
@rss = "top"
@params = { period: period }
@rss_description = "top_#{period}"
@title = I18n.t("js.filters.top.#{period}.title") + " - #{SiteSetting.title}"
define_method("top_#{period}_feed") do |options = nil|
@link = "#{Discourse.base_url}/top?period=#{period}"
@atom_link = "#{Discourse.base_url}/top.rss?period=#{period}"
current_slug = current_slug.split("/").map { |slug| CGI.escape(slug) }.join("/")
real_slug = @category.full_slug("/")
method = url_prefix.blank? ? "#{action_name}_path" : "#{url_prefix}_#{action_name}_path"
url = public_send(method, opts.merge(page_params)).sub(".json?", "?")
).to_sym
top_topics = TopTopic.where("#{period}_score > 0")
periods << :daily if date > (1.week + 1.day).ago
periods << :weekly if date > (1.month + 1.week).ago
periods << :monthly if date > (3.months + 3.weeks).ago
periods << :quarterly if date > (1.year + 1.month).ago
periods << :yearly if date > 3.years.ago
periods << :all
group_ids: groups&.map(&:id),
if params.has_key?(:group_ids) || params.has_key?(:group_names)
info = {
render json: { "inline-oneboxes" => oneboxes }
my:
sort = order ? "#{order} #{dir}" : nil
group = find_group(:id)
@full_title = "#{@title} - #{SiteSetting.title}"
json: {
filter = filter.split(",") if filter.include?(",")
order = "group_users.created_at #{dir}"
).create!
groups = groups.where("name ILIKE :term OR full_name ILIKE :term", term: "%#{term}%")
group = Group.find_by("LOWER(name) = ?", name.downcase)
tags = {}
metadata = { old_value: old_value, new_value: value }
if action == :update
ids += users.pluck(:user_id)
ids += tag_users.pluck(:user_id)
.select(:id, :user_id)
category_users << {
tag_users << {
@by_site ||= {}
@bundle_js_hash ||= {}
bundle_str = "#{bundle}_js"
bundle == OVERRIDES_BUNDLE || (bundle =~ /\A(admin|wizard)\z/ && current_user&.staff?)
@_export_params ||=
@template = "basic"
create_url_params = {}
@list =
@topic_view =
@posts_left = 0
@second_post_url = "#{@topic_view.topic.url}/2"
@reply_count = 0 if @reply_count < 0
by_url = {}
urls = embed_urls.map { |u| u.sub(/#discourse-comments\z/, "").sub(%r{/\z}, "") }
if @found && @key_owner_found
if current_user.present? && (@user != current_user)
url = path("/email/unsubscribed?key=#{cache_key}")
@topic = topic if topic && Guardian.new(nil).can_see?(topic)
.where("show_on_profile=? OR show_on_user_card=?", true, true)
ends_at =
render json: { ends_at: ends_at }
if string == "tomorrow"
result = result.includes(user: :groups).where(users: { groups: { id: group.id } })
result = result.order("users.#{order} #{dir}, directory_items.id")
position = result.index { |r| r.user_id == current_user.id }
if (position || 10) >= 10
serializer_opts = {}
if Hash === obj
if user_count == 1
user_reasons = {}
group_reasons = {}
.reduce({}) do |hash, group|
if @topic && !user.guardian.can_see?(@topic)
reason = nil if !guardian.is_staff? && reason != :private && reason != :category
elsif (@topic&.private_message? || @allowed_names.present?) &&
user_ids.include?(user.id) || user.group_ids.any? { |group_id| group_ids.include?(group_id) }
@users ||=
.where("lower(name) IN (?)", @names.map(&:downcase))
.index_by(&:name)
@topic_muted_by ||=
.where(user_id: users.values.map(&:id))
@title = "#{I18n.t("js.filters.categories.title")} - #{SiteSetting.title}"
@topic_list =
old_permissions = { "everyone" => 1 } if old_permissions.empty?
@category_params ||=
path, query = assets_for_url.split("?", 2)
.each { |file| add_style(file, plugin: true) }
.map { |f| script_asset_path(f) }
bootstrap = {
urls =
.map do |target|
stylesheet = <<~CSS
/* For use in tests only - `@import`s all plugin stylesheets */
return if scheme_id.to_i == -1
if style =
@stylesheets << {
media: "all",
}.merge(opts || {})
html = {}
theme_html = {}
theme_view = mobile_view? ? :mobile : :desktop
badges = badges.where("name ILIKE ?", "%#{search}%")
root: "badges",
@rss_title =
@rss_link = "#{Discourse.base_url}/badges/#{@badge.id}/#{@badge.slug}"
unless is_api? || is_user_api?
if: -> { is_feed_request? || !SiteSetting.allow_index_in_robots_txt }
@use_crawler_layout ||=
has_escaped_fragment? || params.key?("print") || show_browser_update? ||
Rails.logger.error("#{e.class} #{e.message}: #{e.backtrace.join("\n")}")
if (request.format && request.format.json?) || request.xhr? || !request.get?
(request.format && request.format.json?) || (request.xhr?) ||
opts = { type: type, status: status_code }
cookie_args = {}
@preloaded ||= {}
safe_mode = safe_mode.split(",")
if id.present? && seq && seq.to_i == user_option&.theme_key_seq.to_i
if theme_id.blank? && SiteSetting.default_theme_id != -1 &&
serializer_opts = { scope: guardian }.merge!(opts || {})
)&.user
if name.start_with?("client:")
banner = topic.present? ? topic.banner : {}
def render_json_error(obj, opts = {})
opts = { status: opts } if opts.is_a?(Integer)
{ success: "OK" }
def json_result(obj, opts = {})
return if !request.get? && (is_api? || is_user_api?)
def self.requires_login(arg = {})
def build_not_found_page(opts = {})
@top_viewed =
.first(10)
id = @theme_id
return "{}" if id.blank?
Theme.where(id: ids).pluck(:id, :name).to_h.to_json
request.get? && !(request.format && request.format.json?) && !request.xhr?
limit = 50
content_types: WebHook.content_types.map { |name, id| { id: id, name: name } },
WebHook.last_delivery_statuses.map { |name, id| { id: id, name: name.to_s } },
web_hook_id: @web_hook.id,
event_type: "ping",
event_name: "ping",
data = { url: "/ok" }
content = content.pluck(:word).join("\n")
render json: { error: I18n.t("admin_js.admin.users.id_not_found") }, status: 404
elsif level == 3 && Promotion.tl3_lost?(@user)
@user.manual_locked_trust_level = (new_lock == "true") ? @user.trust_level : nil
silence: {
render json: { deleted: true }
sso =
field.position = (UserField.maximum(:position) || 0) + 1
field.user_field_options_attributes = options.map { |o| { value: o } }.uniq
redirect_to path("/?preview_theme_id=#{theme.id}")
@theme = nil
@theme = Theme.new(user_id: theme_user&.id || -1, name: theme_name)
respond_to { |format| format.json { render json: payload } }
format.json { render json: @theme, status: :ok }
error ||= I18n.t("themes.other_error")
respond_to { |format| format.json { head :no_content } }
expected = ids.map(&:to_i)
expected.reject! { |id| id == relative.child_theme_id }
expected.reject! { |id| id == relative.parent_theme_id }
@theme_params ||=
if param.to_s == "false" && @theme.component?
elsif param.to_s == "true" && !@theme.component?
diff_fields = {}
output = +"<h2>#{CGI.escapeHTML(cur&.dig("name").to_s)}</h2><p></p>"
prev: prev&.dig("color_scheme", "name").to_s,
cur: cur&.dig("color_scheme", "name").to_s,
diff_fields.each do |k, v|
output << "<h3>#{k}</h3><p></p>"
if f = val&.dig("theme_fields")
f.each do |row|
extras = {}
results.sort! do |x, y|
per_page = 50
first = page * per_page
last = first + per_page
root: "site_texts",
old_value = I18n.with_locale(locale) { I18n.t(id) }
old_text = I18n.with_locale(locale) { I18n.t(id) }
def is_badge_title?(id = "")
badge_parts = id.split(".")
value ||= I18n.with_locale(locale) { I18n.t(key) }
{ id: key, value: value, locale: locale }
if value&.is_a?(Hash)
key: "#{key}.#{plural_key}",
return value if value.keys.size == plural_keys.size && plural_keys.all? { |k| value.key?(k) }
fallback_value = I18n.t(key, locale: :en, default: {})
if old_name == id
value = Upload.get_from_urls(value.split("|")).to_a
if user_option == "text_size_key"
attrs = { user_option => new_value }
new_category_ids = new_value.split("|")
new_tag_ids = Tag.where(name: new_value.split("|")).pluck(:id)
tag_id: (previous_tag_ids - new_tag_ids),
(new_tag_ids - previous_tag_ids).each do |tag_id|
user_ids +=
.pluck("users.id")
.joins("LEFT JOIN tag_users tu ON users.id = tu.user_id AND t.id = tu.tag_id")
value.nil? ? "" : value
.select { |r| r =~ /\Apage_view_/ && r !~ /mobile/ }
.map { |r| r + "_reqs" } +
type = name.to_s.gsub("report_", "")
title: I18n.t("reports.#{type}.title"),
end_date =
).end_of_day
revert_and_log("#{key}.subject_template", "#{key}.text_body_template")
old_value = I18n.t(key)
new_value = I18n.t(key)
reply_keys = {}
.pluck(:post_id, :user_id, "reply_key::text")
render json: { reject: false }
if retry_count == 0
.includes(:user, post: :topic)
action_mailer_settings.reject { |k, _| k == :password }.map { |k, v| { name: k, value: v } }
.to_a,
line_number += 1
if line.include?("@")
group = badge_groupings.find { |b| b.id == id } || BadgeGrouping.new
badge_groupings.each { |g| g.destroy unless g.system? || ids.include?(g.id) }
enable = params.fetch(:enable).to_s == "true"
/\.(tar\.gz|t?gz)\z/i =~ filename
.reduce({}) do |memo, (resource, actions)|
scope_id: "#{resource}:#{k}",
name: k.to_s.gsub("_", " "),
@title = "#{I18n.t("js.about.simple_title")} - #{SiteSetting.title}"
path = if File.exist?(File.join(Rails.root, 'db', 'samples', "#{file}.rb"))
File.expand_path(File.join(Rails.root, 'db', 'samples', "#{file}.rb"))
File.expand_path(samples_path + "#{file}.rb")
Pathname.new(File.join(File.dirname(__FILE__), '..', '..', 'db', 'samples'))
variant.sku = product.sku + '_' + option_values.map(&:name).join('_')
SPECIAL_TAXONS = { 'New Collection': "Summer #{Date.today.year}", 'Special Offers': '30% Off' }.freeze
CHILDREN_TAXON_NAMES = CSV.read(File.join(__dir__, 'variants.csv')).map do |(parent_name, taxon_name, _product_name, _color_name)|
amount: 0.1,
).first_or_create! do |tax_rate|
eu_store.name = 'EU Store'
uk_store.name = 'UK Store'
city: 'City',
puts 'Couldn\'t find \'North America\' zone. Did you run `rake db:seed` first?'
europe_vat = Spree::Zone.find_by!(name: 'EU_VAT')
display_on: 'both',
name: 'Shirt',
name: 'Bag',
name: 'Mugs',
brand: 'Brand',
model: 'Model',
made_from: 'Made from',
fit: 'Fit',
type: 'Type',
size: 'Size',
color: 'Color',
size = Spree::OptionValue.find_by!(name: 'xs')
eligible_values = "#{size.id},#{color.id}"
match_policy: 'any',
preferences: { match_policy: 'any', eligible_values: { product.id.to_s => eligible_values } }
PRODUCTS = CSV.read(File.join(__dir__, 'variants.csv')).map do |(parent_name, taxon_name, product_name, _color_name)|
product.price = rand(10...100) + 0.99
product.set_property(:gender, (product.taxons.pluck(:name).include?('Men') ? 'Men\'s' : 'Women\'s'))
month: 12,
last_digits: '1111',
name: 'Credit Card',
name: 'Check',
).first_or_create! do |order|
colors = {
purple: '#800080',
red: '#FF0000',
black: '#000000',
brown: '#8B4513',
green: '#228C22',
grey: '#808080',
orange: '#FF8800',
burgundy: '#A8003B',
beige: '#E1C699',
blue: '#0000FF',
dark_blue: '#00008b',
light_blue: '#add8e6',
lila: '#cf9de6',
ecru: '#F4F2D6'
lengths = { mini: 'Mini', midi: 'Midi', maxi: 'Maxi' }
sizes = { xs: 'XS', s: 'S', m: 'M', l: 'L', xl: 'XL' }
name: 'color',
name: 'length',
name: 'size',
name: 'Main Menu',
name: 'Footer Menu',
when 'en'
root_name_a = 'Women'
root_name_b = 'Men'
t_shirts = 'T-Shirts'
tops = 'Tops'
pants = 'Pants'
promo_b_subtitle = 'Get up to 30% off'
when 'fr'
root_name_a = 'Femmes'
root_name_b = 'Hommes'
root_name_c = 'Tenue de sport'
skirts = 'Jupes'
tops = 'Hauts'
when 'de'
root_name_a = 'Frauen'
pants = 'Hose'
when 'es'
root_name_a = 'Hombres'
root_name_b = 'Mujeres'
item_type: 'Link',
name: 'Promos',
code: 'promo',
men_j_c.save!
title: 'About Us',
name_txt = 'Hero Image'
button_txt = 'Shop Now'
title_one = 'Men'
title_two = 'Women'
title_two = 'Frauen'
title_one = 'Hommes'
title_two = 'Femmes'
title_txt = "Summer #{Date.today.year}"
title_txt = "Sommer #{Date.today.year}"
title_txt = "Verano #{Date.today.year}"
button_txt = 'Lee mas'
subtitle_two = 'Up To 30% OFF'
type: 'Spree::Cms::Pages::Homepage',
label: 'Tax',
state: 'open',
).first_or_create! do |adj|
united_states = Spree::Country.find_by!(iso: 'US')
new_york = Spree::State.find_by!(name: 'New York')
add_filter '/bin/'
add_filter '/db/'
add_filter '/spec/'
config.fixture_path = File.join(__dir__, 'fixtures')
let(:order) { create(:order) }
let(:shipping_method) { create(:shipping_method, name: 'UPS') }
can_ship?: true,
paid?: false,
context "from #{state}" do
let!(:tax_zone) { create(:zone_with_country, default_tax: true) }
let(:store) { create(:store) }
let(:user) { create(:user) }
let(:order) { create(:order, user: user) }
let(:store) { Spree::Store.default }
let(:order) { create(:order, email: 'test@example.com', store: store) }
let(:order) { build(:order) }
let!(:variant) { create(:variant) }
let!(:shipment) { create(:shipment) }
let!(:line_items) { create_list(:line_item, 2, order: order, price: 10) }
before { create(:store) }
let!(:store) { create(:store) }
let(:order) { create(:shipped_order, store: store, email: 'test@example.com', user: nil) }
pt_br_shipped_email = { spree: { shipment_mailer: { shipped_email: { dear_customer: 'Caro Cliente,' } } } }
pt_br_shipped_email = { spree: { reimbursement_mailer: { reimbursement_email: { dear_customer: 'Caro Cliente,' } } } }
let(:first_store) { create(:store, name: 'First Store', default: true) }
let(:second_store) { create(:store, name: 'Second Store', url: 'other.example.com') }
product = create(:product, name: %{The "BEST" product})
pt_br_confirm_mail = { spree: { order_mailer: { confirm_email: { dear_customer: 'Caro Cliente,' } } } }
I18n.locale = :'pt-BR'
let(:variant) { create(:variant, images: images) }
let(:image) { create(:image) }
let(:order) { create(:order, ship_address_id: nil, bill_address_id: nil) }
let(:address) { create(:address) }
let(:logo_image) { File.open(File.expand_path('../../../app/assets/images/logo/spree_50.png', __dir__)) }
let(:logo_image) { File.open(File.expand_path('../../../app/assets/images/noimage/mini.png', __dir__)) }
Dir.glob(File.join(File.dirname(__FILE__), '../../../app/**/*_decorator*.rb')).sort.each do |c|
File.expand_path('templates', __dir__)
@order = order.respond_to?(:id) ? order : Spree::Order.find(order)
subject += "#{current_store.name} #{Spree.t('order_mailer.confirm_email.subject')} ##{@order.number}"
subject += "#{current_store.name} #{Spree.t('order_mailer.cancel_email.subject')} ##{@order.number}"
order.name || Spree.t('customer')
it { expect(Spree::Test::Product.new(url: nil).valid?).to eq(false) }
it { expect(Spree::Test::Product.new(url: '').valid?).to eq(false) }
it { expect(Spree::Test::Product.new(url: 'google.com').valid?).to eq(false) }
it { expect(Spree::Test::Product.new(url: 'http:/google').valid?).to eq(false) }
it { expect(Spree::Test::Product.new(url: 'www.google.com').valid?).to eq(false) }
it { expect(Spree::Test::Product.new(url: 'http://google.com').valid?).to eq(true) }
it { expect(Spree::Test::Product.new(url: 'https://google.com').valid?).to eq(true) }
it { expect(Spree::Test::Product.new(url: 'http://www.google.com').valid?).to eq(true) }
it { expect(Spree::Test::Product.new(url: 'https://www.google.com').valid?).to eq(true) }
it { expect(Spree::Test::Product.new(url: 'http://google').valid?).to eq(true) }
let(:test_product) { Spree::Test::Product.new(url: nil) }
let(:message) { 'is needed' }
let(:tester) { Tester.new }
let(:task_path) { "lib/tasks/#{task_name.split(':').first}" }
load File.expand_path(Rails.root + "../../#{task_path}.rake")
let(:order) { create(:order_with_line_items) }
let(:value) { execute.value }
cc_type: 'visa',
name: 'John',
month: '12',
year: '2021'
last_digits: '',
name: '',
month: '',
year: ''
let(:variant) { create(:variant) }
let(:orders) { create_list(:order_with_line_items, 3) }
let(:time_current) { Time.local(1990) }
let(:order) { create(:order_ready_to_ship, store: store, user: nil, email: 'john@snow.org') }
it { expect(execute.success?).to eq(true) }
it { expect { execute }.to change(order.line_items, :count).by(-1) }
it { expect { execute }.to change(order.shipments, :count).by(-1) }
it { expect { execute }.not_to change(order.line_items, :count) }
it { expect(execute.error.to_s).to eq('variant_not_found') }
let(:order) { create(:order_with_totals, store: store, user: nil, email: 'john@snow.org') }
let!(:old_line_item) { create(:line_item, order: order, variant: variant, quantity: 2) }
it { expect(execute.error.to_s).to eq('order_not_found') }
let(:shipment) { create(:shipment, order: order) }
let(:order) { create(:order_with_totals, store: store, user: user) }
it { expect(execute.error.to_s).to eq('source_not_found') }
payment_method_id: '',
cc_type: '',
let!(:user) { create(:user) }
it { expect { result }.to change(order, :state).to('canceled') }
it { expect(result.value).to eq(order) }
let(:order) { create(:order_with_totals) }
it { expect { result }.to change(order, :canceler).to(user) }
it { expect { result }.to change(order, :considered_risky).to(false) }
it { expect { result }.to change(order, :approver).to(user) }
let!(:line_item) { create :line_item, variant: variant, price: nil, quantity: 10 }
let(:variant) { create :variant, price: 20 }
let(:line_item_attributes) { { quantity: 11 } }
let(:options) { { shipment: shipment } }
expect { execute }.to change { order.line_items.count }.by(-1)
let(:order) { create :order }
it { expect(call.error.to_s).to eq('is not a number') }
lastname: 'Doe',
let(:user) { create(:user_with_addresses) }
let(:state) { create(:state) }
}) }
let(:order_state) { 'cart' }
let(:ship_address_id) { nil }
let(:bill_address_id) { nil }
let(:order_state) { 'address' }
let(:address) { create(:address, user: user) }
let(:ship_address_id) { address.id }
let(:bill_address_id) { address.id }
let(:country) { create(:country) }
let(:store) { create(:store, checkout_zone: zone) }
let(:zone) { create(:zone_with_country) }
let!(:line_item) { create(:line_item, variant: product_2.master, order: order) }
let(:order_total) { 500.00 }
let(:store_credit) { create(:store_credit, amount: order_total - 1, store: store) }
let(:line_item) { create(:line_item, order: order) }
let(:error) { execute.error.to_s }
let!(:country) { create(:country) }
let!(:zone) { create(:zone) }
let(:requested_amount) { 300.0 }
let(:expected_cc_total) { 100.0 }
let!(:store_credit_2) { create(:store_credit, amount: 10) }
let(:order) { create(:order, store: store) }
let(:line_item) { create :line_item, variant: variant, quantity: 2, price: nil }
expect { execute }.to change(order, :amount).by(-20)
let(:variant_2) { create :variant }
let(:order) { Spree::Order.create(email: 'test@example.com') }
let(:promotion) { create :promotion, code: '10off' }
let(:order) { nil }
let!(:payment) { create(:payment, amount: order.total, order: order) }
let!(:line_item_ids) { order.line_item_ids }
let!(:payment_ids) { order.payment_ids }
let(:user) { create :user }
let(:store) { create :store, default_currency: 'EUR' }
let(:currency) { 'USD' }
let(:public_metadata) { { prop1: 2 } }
let(:private_metadata) { { prop2: 'val2' } }
let(:expected) { Order.first }
let(:store_2) { create :store }
let(:order_params) { { store: store_2, currency: 'XVII' } }
let(:order_params) { { store: store, currency: nil } }
let!(:default_store) { create :store, default: true }
let(:order) { create(:order_with_line_items, store: store, currency: 'USD') }
let(:new_currency) { 'EUR' }
let(:order) { create(:order_with_totals, store: store, currency: 'USD', state: 'delivery') }
let(:new_currency) { 'XOF' }
let(:order) { create(:order, user: nil) }
let(:assigned_user) { create(:user) }
let(:order) { create(:order, user: assigned_user) }
let(:qty) { 1 }
it 'not to add' do
let!(:rate) do
name: 'Tax Rate 1',
amount: 0.25,
let(:variant) { create(:variant, price: 1000) }
let(:options) { { quantity: 2, variant_id: variant.id } }
let(:options) { { quantity: 2 } }
let(:options) { { dummy_param: true } }
let(:public_metadata) { {'prop1' => 'value1'} }
let(:private_metadata) { {'prop2' => 'value2'} }
let(:value) { result.value }
let(:state) { create(:state, country: country) }
let!(:address) { create(:address, user: user) }
phone: '',
zipcode: ''
let(:address_params) { {} }
let(:option_type_1) { create :option_type, position: 2, name: 'Foo Type', presentation: 'Foo Type' }
let(:option_type_2) { create :option_type, position: 1, name: 'Bar Type', presentation: 'Bar Type' }
let(:option_type) { create :option_type, name: 'color', presentation: 'Color' }
let(:option_type_1) { create :option_type, position: 2 }
let(:option_type_2) { create :option_type, position: 1 }
it { is_expected.to eq(nil) }
let(:price) { PricePresenter.new(amount: 50, currency: 'USD') }
let(:quantifier) { :less_than }
describe '#to_s' do
let(:quantifier) { :more_than }
let(:brand) { create(:property, :brand, :filterable) }
describe '#to_a' do
expect(price_range.to_s).to eq('$50 - $100')
let(:price) { described_class.new(amount: 50, currency: 'USD') }
describe '#to_i' do
expect(price.to_s).to eq('$50')
let(:size) { create(:option_type, :size) }
let(:s_size) { create(:option_value, option_type: size, name: 's') }
let(:m_size) { create(:option_value, option_type: size, name: 'm') }
let(:color) { create(:option_type, :color) }
let(:red_color) { create(:option_value, option_type: color, name: 'red') }
let(:green_color) { create(:option_value, option_type: color, name: 'green') }
let(:blue_color) { create(:option_value, option_type: color, name: 'blue') }
s_size, m_size,
let(:country_zone) { create(:zone, kind: 'country') }
let(:zone_with_default_tax) { create(:zone, kind: 'country', default_tax: true) }
let(:zone_not_with_default_tax) { create(:zone, kind: 'country', default_tax: false) }
let!(:zone_with_default_tax) { create(:zone, kind: 'country', default_tax: true) }
let!(:zone_not_with_default_tax) { create(:zone, kind: 'country', default_tax: false) }
let(:second_zone) { create(:zone, name: 'SecondZone', kind: 'country') }
let(:country2) { create(:country) }
let(:state_zone) { create(:zone, kind: 'state') }
let(:address) { create(:address, state: state) }
it 'is true' do
before { @foo_zone = create(:zone, name: 'whatever', default_tax: true) }
create(:zone, name: 'foo')
it 'is nil' do
let(:country1) { create(:country) }
let(:country3) { create(:country) }
let(:state1) { create(:state) }
let(:state2) { create(:state) }
let(:state3) { create(:state) }
it 'is false' do
zone1 = create(:zone, name: 'foo', default_tax: true)
create(:zone, name: 'bar', default_tax: true)
zone = Spree::Zone.new kind: 'city'
let!(:country2) { create(:country, name: 'OtherCountry') }
let!(:country3) { create(:country, name: 'TaxCountry') }
let!(:zone) do
create(:zone, kind: 'country').tap do |z|
let!(:zone2) do
create(:zone, kind: 'country').tap do |zone|
expect(result.select { |z| z == zone }.size).to be 1
let!(:state2) { create(:state, country: country2, name: 'OtherState') }
let!(:state3) { create(:state, country: country2, name: 'State') }
create(:zone).tap do |z|
create(:zone).tap { |z| z.members.create(zoneable: state) && z.save! }
let!(:zone3) do
create(:zone).tap { |z| z.members.create(zoneable: state2) && z.save! }
expect(@result.select { |z| z == zone }.size).to be 1
let!(:state) { create(:state, country: country) }
create(:zone, kind: 'state').tap do |zone|
let!(:country1) { create(:country) }
let!(:country2) { create(:country) }
let(:zone) { create(:zone, kind: 'country') }
let!(:store) { Spree::Store.default }
let!(:other_store) { create(:store) }
let!(:other_user) { create(:user) }
let!(:wishlist) { create(:wishlist, user: user, name: 'My Wishlist', store: store, is_default: true) }
let!(:new_wl) { create(:wishlist, name: 'My New WishList', user: user, store: store, is_default: true) }
let!(:wished_item) { create(:wished_item) }
let!(:wishlist) { create(:wishlist) }
it { expect(subject.quantity).to eq(1) }
it { expect(wished_item_with_variant.total(currency: 'USD')).to eql(variant.amount_in('USD') * 3) }
it { expect(wished_item_with_variant.display_total(currency: 'USD')).to eq Spree::Money.new((variant.amount_in('USD') * 3), currency: 'USD') }
let(:variant_2) { build(:variant, sku: variant.sku) }
let(:variant_2) { build(:variant, sku: 'OTHER-SKU') }
variant_2.sku = ''
let!(:variant) { create(:variant, product: product) }
let!(:variant_2) { create(:variant, discontinue_on: Time.current + 1.day) }
let!(:variant_2) { create(:variant, discontinue_on: nil) }
let!(:variant_2) { create(:variant, deleted_at: nil) }
let(:currency) { 'EUR' }
let!(:price_1) { create(:price, currency: currency, variant: variant, amount: 10) }
let!(:unavailable_currency) { 'INR' }
let!(:currency) { 'EUR' }
it { expect(subject).to eq(false) }
let!(:variant2) { create(:variant) }
it { expect(subject).to eq(true) }
context '#price=' do
subject.price = '1,599.99'
let(:currency) { nil }
expect(subject.to_s).to eql '$0.00'
expect(subject.to_s).to eql '$19.99'
let(:variant) { build :variant }
let!(:master) { create(:master_variant) }
let(:variant) { build(:variant) }
let(:product) { build(:product) }
let(:variant_zero_width) { create(:variant, width: 0) }
let(:variant_live) { build(:variant) }
let(:variant2) { create(:variant) }
it { expect(variant.send(:check_price)).to be(nil) }
before { variant.price = nil }
let!(:line_item) { create(:line_item, order: order, variant: variant) }
let!(:order) { create(:order) }
let!(:line_item) { create(:line_item, order: order, variant: variant, quantity: 2) }
let!(:line_item_2) { create(:line_item, order: order, variant: variant, quantity: 3) }
let!(:product_1) { create(:product, name: 'First product') }
let!(:product_2) { create(:product, name: 'Second product') }
let!(:product_3) { create(:product, name: 'Third product') }
let!(:variant_1) { create(:variant, product: product_1, sku: 'first_variant_red') }
let!(:variant_2) { create(:variant, product: product_2, sku: 'second_variant_green') }
let!(:variant_3) { create(:variant, product: product_3, sku: 'third_variant_blue') }
let(:store) { create :store }
let(:order_1) { create(:order, created_at: 1.day.ago, user: user, created_by: user, store: store) }
let(:order_2) { create(:order, user: user, created_by: user, store: store) }
let(:order_3) { create(:order, user: user, created_by: create(:user), store: store) }
let!(:cc) do
let(:order_value) { BigDecimal('80.94') }
let(:order_count) { 4 }
let(:orders) {}
it 'returns 0.00' do
let(:eur_currency) { 'EUR' }
let(:eur_order_value) { BigDecimal('12.34') }
let(:eur_order_count) { 2 }
subject { create(:user) }
subject { user }
let!(:store) { create(:store, default: true) }
let(:amount) { 120.25 }
let(:additional_amount) { 55.75 }
let!(:store_credit) { create(:store_credit, user: user, amount: amount, amount_used: 0.0, store: store) }
let(:amount_used) { 35.00 }
let(:authorized_amount) { 10 }
let(:usd_amount) { 120.25 }
let(:gbp_amount) { '123.12' }
let(:eur_amount) { '321.31' }
let(:address2) { create(:address) }
it 'is valid' do
let!(:user) { create(:user_with_addresses) }
let!(:other_user) { create(:user_with_addresses) }
let(:assigned_user) { nil }
let(:assigned_user) { user }
let(:taxonomy) { create(:taxonomy) }
let(:taxon) { build(:taxon, name: 'Ruby on Rails', parent: nil) }
subject { super().to_param }
let(:valid_taxon) { build(:taxon, name: 'Vaild Rails', parent_id: 1, taxonomy: taxonomy) }
let(:idx) { rand(0..100) }
let!(:taxonomy) { create(:taxonomy) }
let!(:parent) { create(:taxon, taxonomy: taxonomy) }
let(:taxon) { build(:taxon, parent: parent, taxonomy: nil) }
it { expect(taxon.valid?).to eq(true) }
it { expect { taxon.save }.to change(taxon, :taxonomy).to(taxonomy) }
let!(:taxonomy) { create(:taxonomy, name: 'Soft Goods') }
let!(:taxon) { create(:taxon, taxonomy: taxonomy, name: 'Socks' ) }
let(:image_file) { File.open(Spree::Core::Engine.root + 'spec/fixtures' + 'thinking-cat.jpg') }
let(:text_file) { File.open(Spree::Core::Engine.root + 'spec/fixtures' + 'text-file.txt') }
Spree::TaxRate.create(name: 'Tax Rate #1', amount: 1, zone: create(:zone))
name: 'Tax Rate #1',
amount: 1,
zone: @zone,
name: 'Tax Rate #2',
amount: 2,
let(:included_in_price) { false }
let(:included_in_price) { true }
let!(:tax_category_1) { create(:tax_category) }
let!(:tax_category_2) { create(:tax_category) }
let!(:rate_1) { create(:tax_rate, tax_category: tax_category_1) }
let!(:rate_2) { create(:tax_rate, tax_category: tax_category_2) }
let!(:line_item) { create(:line_item, price: 10.0, quantity: 1, tax_category: tax_category_1, order: order) }
let!(:line_item) { create(:line_item, price: 10.0, quantity: 2, tax_category: nil, order: order) }
let(:germany) { create :country, name: 'Germany' }
let(:india) { create :country, name: 'India' }
let(:france) { create :country, name: 'France' }
let(:france_zone) { create :zone_with_country, kind: 'country', name: 'France Zone' }
let(:india_zone) { create :zone_with_country, kind: 'country', name: 'India' }
let(:eu_zone) { create(:zone, name: 'EU') }
let!(:german_vat) do
amount: 0.19,
let!(:french_vat) do
let!(:eu_vat) do
let(:order) { Spree::Order.create }
let!(:order) { create :order_with_line_items }
amount: 0.10,
amount: 0.05,
name: 'New Tax Rate',
amount: 0.2,
@new_zone = create(:zone, name: 'New Zone', default_tax: false)
@price_before_taxes = line_item.price / (1 + @rate1.amount + @rate2.amount)
let!(:tax_category) { create(:tax_category) }
let!(:tax_rate) { create(:tax_rate, tax_category: tax_category) }
subject { create(:store) }
let!(:variant_2) { create(:variant, product: product_2) }
let!(:stock_items_2) { product_2.stock_items }
let!(:order) { create(:order, store: subject) }
let!(:order_2) { create(:order, store: create(:store)) }
let!(:line_item) { create(:line_item, order: order) }
let!(:line_item_2) { create(:line_item, order: order_2) }
let!(:payment) { create(:payment, order: order) }
let!(:payment_2) { create(:payment, order: order_2) }
let!(:shipment) { create(:shipment, order: order) }
let!(:shipment_2) { create(:shipment, order: order_2) }
let!(:order) { create(:shipped_order, store: subject) }
let!(:order_2) { create(:shipped_order, store: create(:store)) }
let!(:store_credit_2) { create(:store_credit, store: create(:store)) }
let!(:menu) { create(:menu, store: subject) }
let!(:menu_2) { create(:menu, store: create(:store)) }
let!(:menu_item) { menu.menu_items.first }
let!(:menu_item_2) { menu_2.menu_items.first }
let!(:taxonomy) { create(:taxonomy, store: subject) }
let!(:taxonomy_2) { create(:taxonomy, store: create(:store)) }
let!(:taxon) { create(:taxon, taxonomy: taxonomy) }
let!(:taxon_2) { create(:taxon, taxonomy: taxonomy_2) }
it { expect(taxon).not_to be_nil }
it { expect(taxon_2).not_to be_nil }
let(:store_code) { 'store_code' }
let!(:default_store) { create(:store) }
let!(:deleted_store) { create(:store, code: store_code).destroy! }
let!(:store_1) { Spree::Store.first || create(:store) }
let!(:store_2) { create(:store, default: false, url: 'www.subdomain.com') }
let!(:store) { create(:store, default_locale: 'en') }
let!(:store_2) { create(:store, default_locale: 'de') }
let!(:store_3) { create(:store, default_locale: 'en') }
let!(:store_a) { create(:store, default_locale: 'en') }
let!(:store_b) { create(:store, default_locale: 'en') }
let!(:menu_a) { create(:menu, store: store_a, locale: 'en') }
let!(:menu_b) { create(:menu, store: store_a, locale: 'de') }
let!(:menu_c) { create(:menu, store: store_b, locale: 'de') }
let!(:menu_d) { create(:menu, store: store_b, locale: 'pl') }
let(:zone) do
let!(:country3) { create(:country) }
Spree::Zone.first || create(:zone, kind: 'country').tap do |zone|
subject { build(:store) }
let!(:other_country) { create(:country) }
let!(:other_country_2) { create(:country) }
let!(:zone) { create(:zone, kind: 'country') }
let!(:store) { build(:store) }
expect(store.unique_name).to eq("#{store.name} (#{store.code})")
let(:currencies) { 'USD, EUR, dummy' }
::Money::Currency.find('EUR'), ::Money::Currency.find('USD')
::Money::Currency.find('EUR')
let(:store) { build(:store, default_locale: 'fr', supported_locales: 'fr,de') }
let(:store) { build(:store, default_locale: 'fr', supported_locales: nil) }
it { expect { store.save! }.to change(store, :supported_locales).from(nil).to('fr') }
it { expect { store.save! }.not_to change(store, :supported_locales).from(nil) }
it { expect { store.save! }.not_to change(store, :supported_locales) }
it { expect { store.save! }.to change(store, :supported_currencies).from(nil).to('EUR') }
let(:store) { create(:store, :with_favicon) }
let(:another_store) { create(:store) }
let!(:another_store) { create(:store) }
let(:file) { File.open(file_fixture('icon_256x256.png')) }
let(:size) { 1.megabyte }
let(:size) { 1.megabyte + 1 }
let(:currency) { 'TEST' }
let(:store_credit_attrs) { {} }
let(:store_credit) { create(:store_credit, amount: 100, amount_used: 1) }
it 'is not valid' do
let(:store_credit) { build(:store_credit, amount: 100) }
let(:authorized_amount) { 15.00 }
let(:amount_used) { 10.0 }
let(:originator) { nil }
let(:originator) { create(:refund, amount: 10) }
let(:store_credit_attrs) { { amount: 8.21 } }
let(:authorized_amount) { 10.00 }
let(:auth_code) { '1-SC-20141111111111' }
let(:captured_amount) { 10.0 }
let(:authorized_amount) { 10.0 }
let!(:auth_event) do
let(:currency) { 'AUD' }
let(:credit_amount) { 5.0 }
let(:captured_amount) { 100.0 }
let(:auth_code) { event_auth_code }
let(:credit_amount) { 100.0 }
let(:captured_amount) { 5.0 }
it 'sets a memo' do
let(:amount_used) { 100.0 }
let(:amount_authorized) { 100.0 }
let(:payment_state) { 'pending' }
let(:payment_state) { 'checkout' }
let(:payment_state) { 'invalid' }
let(:payment_state) { 'completed' }
let(:payment_state) { :checkout }
let(:store_credit_amount) { 100.0 }
let(:event_amount) { 120.0 }
let(:user_total_amount) { 300.0 }
let(:authorization_code) { '1-SC-TEST' }
it { is_expected.to eq 'PO123' }
it { is_expected.to match(/T\d+/) }
variants = { variant => 5 }
it 'return 2**31 - 1' do
it 'return -2**31' do
change { Variant.count }.by(0).and(
change { StockItem.count }.from(0).to(2)
it 'all on_hand' do
it 'some on_hand' do
it 'zero on_hand' do
let(:variant) { create(:base_variant) }
let(:state) { create(:state, name: 'virginia', abbr: 'va') }
let(:state) { create(:state, name: 'virginia', abbr: nil) }
let(:item) { subject.items.last }
it { expect { subject.update(active: false).to change(item, :updated_at) } }
it { expect(subject.count_on_hand).to eq(0) }
before { subject.set_count_on_hand(-2) }
it 'has :no errors_on' do
let(:packer) { build(:stock_packer) }
let(:variant) { build(:variant, weight: 25.0) }
let(:variant) { create(:variant, weight: 25.0) }
let(:line_item_1) { create(:line_item) }
let(:line_item_2) { create(:line_item, quantity: 2) }
let(:currency) { '' }
let(:currency) { 'GBP' }
let(:shipping_methods) { Array.new(2) { create(:shipping_method) } }
let!(:tax_rate) { create(:tax_rate, zone: order.tax_zone) }
let!(:other_vat) do
amount: 0.3,
let(:variant1) { create(:variant) }
let(:order) { create(:order_with_line_items, store: store) }
let!(:order) do
let!(:line_item) { order.line_items.first }
state = create(:state, name: 'California', abbr: 'CA')
let(:shipment) { create(:shipment) }
let!(:default_zone) { create(:zone, default_tax: true) }
to eq("$10.00 (incl. $0.91 #{default_tax_rate.name})")
let!(:non_default_zone) { create(:zone, default_tax: false) }
to eq("$10.00 (incl. $1.67 #{non_default_tax_rate.name})")
let(:tax_rate) { create(:tax_rate, name: 'Sales Tax', amount: 0.1) }
to eq("$10.00 (+ $1.00 #{tax_rate.name})")
let!(:tax_rate) { create(:tax_rate) }
it 'returns 0.0' do
let(:order) { shipment.order }
let(:tracking_url) { 'https://track-o-matic.com/:tracking' }
let(:variant1) { build(:variant, price: 10) }
let(:variant2) { build(:variant, price: 20) }
let(:shipment) { build(:shipment) }
let!(:order) { create(:order, number: 'S12345') }
let!(:line_item) { create(:line_item) }
it '#final_price' do
context '#free?' do
let!(:shipment) { create(:shipment, cost: 10, order: order) }
let!(:order) { create(:order, store: store) }
let!(:order) { create(:order, currency: 'EUR') }
let(:other_order) { create(:order) }
amount: 5,
it 'sets cost to 0' do
let(:variant) { double('Variant', id: 9) }
{ variant_id: variant.id, state: 'on_hand', order_id: order.id, line_item_id: line_item.id, quantity: 1 }
let(:return_item) { build(:return_item) }
let(:status) { status }
it { expect { subject }.not_to change { stock_item.reload.count_on_hand } }
let(:pre_tax_amount) { 21.22 }
let(:status) { 'awaiting' }
let(:validator_errors) { {} }
let(:status) { 'pending' }
it { expect(subject).to be_nil }
let(:return_item) { create(:return_item) }
it { expect { subject }.to change(inventory_unit, :state).to('returned').from('shipped') }
let(:color_option_type) { create(:option_type, name: 'color') }
let(:waist_option_type) { create(:option_type, name: 'waist') }
let(:inseam_option_type) { create(:option_type, name: 'inseam') }
let(:time_error) { {} }
expect(subject).to eq({})
let(:time_error) { { time: time_error_text } }
let(:order) { create(:shipped_order) }
let(:pre_tax_amount_1) { 15.0 }
let(:pre_tax_amount_2) { 50.0 }
let(:pre_tax_amount_3) { 5.0 }
let(:promo_total) { 0.0 }
let(:promo_total) { -10.0 }
let(:return_item_1) { create(:return_item) }
let(:return_item_2) { create(:return_item) }
it { is_expected.to eq true }
it { is_expected.to eq false }
let(:simulate) { false }
let(:simulate) { true }
let!(:tax_rate) { nil }
let!(:tax_rate) do
name: 'Sales Tax',
end.to change { Spree::Refund.count }.by(1)
let!(:tax_rate) { create(:tax_rate, name: 'Sales Tax', amount: 0.10, included_in_price: false, zone: tax_zone) }
let!(:tax_rate) { create(:tax_rate, name: 'VAT Tax', amount: 0.1, included_in_price: true, zone: tax_zone) }
let!(:non_return_refund) { create(:refund, amount: 1, payment: payment) }
let(:dummy) { DummyClass.new }
let(:shipped_at) { nil }
let(:shipped_at) { (dummy.refund_time_constraint - 1.day).ago }
let(:shipped_at) { (dummy.refund_time_constraint + 1.day).ago }
let(:credit_double) { double(amount: 99.99) }
let(:amount) { 100.0 }
let(:amount_in_cents) { amount * 100 }
let(:payment_amount) { amount * 2 }
let(:gateway_response_message) { '' }
let(:gateway_response_params) { {} }
let(:gateway_response_options) { {} }
let(:transaction_id) { '12kfjas0' }
expect { subject }.to change { Spree::Refund.count }.by(1)
let(:payment_amount) { 10 }
let(:amount) { payment_amount * 2 }
expect { subject }.to raise_error { |error|
subject { build(:property, name: 'Brand Name') }
it { expect { subject.save! }.to change(subject, :filter_param).from(nil).to('brand-name') }
let(:property) { create(:property) }
promotion = create(:promotion, name: 'test1', code: '')
let(:promotion) { create(:promotion, name: 'delete me') }
let(:payload) { { order: order, user: user } }
let!(:promotion) { create(:promotion, name: 'Foo', code: 'XXX') }
let!(:action) do
let(:line_item) { create :line_item, order: order }
let(:promotion) { create(:promotion, name: 'promo', code: '10off') }
let!(:line_item) { create(:line_item, order: promotable) }
let(:promotion) { create(:promotion, name: 'Promo', match_policy: 'any') }
let(:order) { double Spree::Order }
allow(rules).to receive(:for) { rules }
it { is_expected.not_to be true }
promotion = create(:promotion, name: 'A promotion', code: '', path: '')
describe '#used_by?' do
let(:excluded_order) { order }
let(:order) { create :order, user: user }
let(:variant) { create :variant }
let(:promotion) { create(:promotion, code: 'spree123') }
let!(:promotion) { create(:promotion) }
let(:store_2) { create(:store) }
match_policy: 'all',
code: 'test1',
path: 'test1',
let(:order) { double('Order', coupon_code: '10off', store: store).as_null_object }
let(:coupon) { Coupon.new(order) }
let(:status) { :coupon_code_not_found }
before { create(:promotion, name: 'promo', code: nil) }
before { create(:promotion, name: 'promo', code:'10off') }
let(:line_item) { create(:line_item) }
let(:order) { line_item.order }
let(:adjustable) { line_item }
let(:adjustable) { order }
let(:name) { 'Nom' }
let(:name) { nil }
let(:rule) { Spree::Promotion::Rules::User.new }
let(:random_user) { create :user }
let(:order) { Spree::Order.new }
let(:users) { create_list(:user, 2) }
expect { rule.user_ids = "#{random_user.id}, #{user_placing_order.id}" }.not_to raise_error
user = double('User')
let(:rule) { subject }
let(:taxonomy) { create(:taxonomy, store: store) }
let(:taxon) { create :taxon, name: 'first', taxonomy: taxonomy }
let(:taxon2) { create :taxon, name: 'second', taxonomy: taxonomy }
before { rule.taxons << taxon2 }
before { rule.taxons << taxon }
let(:rule_options) { {} }
let!(:products) { create_list(:product, 3) }
let(:rule_product) { create(:product) }
let(:other_product) { create(:product) }
let(:line_item) { rule_line_item }
let(:line_item) { other_line_item }
let(:line_item) { create :line_item }
name: 'Blue',
name: 'foo-colour',
name: 'Medium',
let(:product_id) { 99 }
let(:order) { double Spree::Order, user: user }
let(:used_by) { false }
let(:used_by) { true }
let(:order) { double(:order) }
let(:order) { create(:order, store: store, email: nil, user: nil) }
let(:order) { create(:order, store: store, user: user) }
let(:email) { 'user@spreecommerce.org' }
let(:order) { create(:order, store: store, email: email, user: nil) }
let(:other_country) { create(:country) }
let(:payload) { { order: order } }
let(:shirt) { create(:variant) }
let(:mug) { create(:variant) }
let(:payload) { { order: order, promotion: promotion } }
let!(:second_line_item) { create(:line_item, order: order) }
let!(:line_item) { create :line_item, order: order, price: 15 }
let!(:line_item) { create :line_item, order: order, price: 12 }
amount: 0,
let(:shipping_discount) { 10 }
let(:shipping_discount) { 0 }
describe "#{method_name}?" do
expect(product.send("#{method_name}?")).to eq true
expect(clone.name(locale: :fr)).to eq ('COPY OF ' + product.name(locale: :fr))
product.price = '$10'
before { product.price = 10.55 }
let!(:high) { create(:variant, product: product) }
let!(:low) { create(:variant, product: product) }
product.slug = 'hey//joe'
product.send(:slug=, "french_slug", locale: :fr)
product.slug = 'x' * 255
product1.sku = '123'
product2.sku = '456'
let(:corrent_total_on_hand) { 5 }
let(:incorrent_total_on_hand) { 15 }
let(:name) { 'foo' }
let(:presentation) { 'baz' }
it { is_expected.to eq name }
let!(:prototype) { create(:prototype) }
let(:file) { File.open(File.expand_path('../../fixtures/thinking-cat.jpg', __dir__)) }
let(:params) { { viewable_id: product.master.id, viewable_type: 'Spree::Variant', alt: 'position 2', position: 2 } }
let(:product_live) { build(:product, sku: 'a-sku') }
let(:product_discontinued) { build(:product, sku: 'a-sku', discontinue_on: Time.now - 1.day) }
let!(:variant_1) { create(:variant, product: product, position: 1) }
let!(:variant_2) { create(:variant, product: product, position: 2) }
it { expect(product.save).to eq(false) }
let(:product) { build(:product, slug: 'My-slug') }
it { expect { product.valid? }.to change(product, :slug).to('my-slug') }
let(:taxonomy_2) { create(:taxonomy, store: store_2) }
let(:taxon) { create(:taxon, taxonomy: taxonomy) }
let(:taxon_2) { create(:taxon, taxonomy: taxonomy_2) }
let(:taxon_3) { create(:taxon, taxonomy: taxonomy) }
it { expect(product.digital?).to eq(true) }
@pp.property_name = 'Size'
it { expect { subject.save! }.to change(subject, :filter_param).from(nil).to('90-cotton-10-elastan') }
subject { build(:product_property, value: ' 90% Cotton 10% Elastan ') }
it { expect { subject.save! }.to change(subject, :value).to('90% Cotton 10% Elastan') }
alt: 'position 1',
let!(:price_eur) { create(:price, variant: product.master, currency: 'EUR') }
let(:taxon_1) { create(:taxon) }
let(:taxon_2) { create(:taxon) }
it { expect(subject.call('PLN')).to be_empty }
let(:name) { property.name }
let(:value) { 'Alpha' }
let(:property) { create(:property, :brand) }
it 'finds by an id' do
let(:value_2) { 'Beta 10%' }
let(:parent_taxon) { create(:taxon) }
let(:option_type) { create(:option_type) }
expect(with_option.call('fake', 'fake').count).to eq({})
expect(with_option.call(0, 'fake').count).to eq({})
let(:price) { build :price }
let(:amount) { '3,0A0' }
let(:compare_at_amount) { '169.99' }
let(:amount) { 3000.00 }
let(:compare_at_amount) { 3000.00 }
let(:amount) { nil }
let(:amount) { -1 }
let(:default_zone) { Spree::Zone.new }
let(:zone) { Spree::Zone.new }
let(:amount) { 10 }
let(:price_options) { { tax_zone: zone } }
let(:compare_at_amount) { 100 }
subject { build :price, amount: 10 }
@store.set :test, 1
expect(@store.get(:test)).to eq 1
expect(@store.get(:test)).to eq '123'
expect(@store.get(:test) { false }).to be false
expect(@store.get(:test) { true }).to be true
expect(@store.get(:random_key) { nil }).to be_nil
let(:prefix) { nil }
let(:suffix) { nil }
let(:store) { double(:store) }
let(:prefix) { 'my_class' }
scoped_store.fetch('attr') { 'default' }
let(:suffix) { 123 }
@id = rand(999)
@a = A.new
@b = B.new
it 'has a type' do
@a.preferred_color = 'red'
@a.set_preference(:bad, :bone)
color: 'green')
@a.set_preference(:is_integer, '3')
@a.set_preference(:is_integer, '')
@a.set_preference(:if_decimal, '3.3')
@a.set_preference(:if_decimal, '')
@a.set_preference(:is_boolean, '0')
@a.set_preference(:is_boolean, 'f')
@a.set_preference(:is_boolean, 't')
@a.set_preference(:is_boolean, '')
@a.set_preference(:is_array, {})
A.preference :is_hash, :hash, default: {}
@a.set_preference(:is_hash, {})
@a.set_preference(:is_hash, 1 => 2, 3 => 4)
@a.set_preference(:is_hash, '{"0"=>{"answer"=>"1", "value"=>"No"}}')
@pt.save!
@pt1 = PrefTest.new(col: 'aaaa')
@pt1.id = @pt.id
@pt1.save!
p.key = key
it ':boolean' do
key = 'boolean_key'
it ':integer' do
value = 10
key = 'integer_key'
it ':decimal' do
value = 1.5
key = 'decimal_key'
it ':string' do
value = 'This is a string'
key = 'string_key'
it ':text' do
key = 'text_key'
key = 'password_key'
it ':any' do
key = 'any_key'
let(:avs_code) { 'D' }
let(:cvv_code) { 'M' }
let(:card) { create :credit_card }
let(:amount_in_cents) { (payment.amount * 100).round }
avs_result: { code: avs_code })
ActiveMerchant::Billing::Response.new(false, '', {}, {})
create(:payment, avs_response: 'Y', cvv_response_code: 'M', cvv_response_message: '', state: 'invalid')
create(:payment, avs_response: 'Y', cvv_response_code: 'M', cvv_response_message: '', state: 'failed')
create(:payment, avs_response: 'A', cvv_response_code: 'M', cvv_response_message: '', state: 'checkout')
create(:payment, avs_response: 'Y', cvv_response_code: 'N', cvv_response_message: '', state: 'completed')
let!(:payment_1) { create(:payment, avs_response: 'Y', cvv_response_code: 'M', cvv_response_message: 'Match') }
let!(:payment_2) { create(:payment, avs_response: 'Y', cvv_response_code: 'M', cvv_response_message: '') }
let!(:payment_3) { create(:payment, avs_response: 'A', cvv_response_code: 'M', cvv_response_message: 'Match') }
let!(:payment_4) { create(:payment, avs_response: 'Y', cvv_response_code: 'N', cvv_response_message: 'No Match') }
expiry: '01 / 99',
source_attributes: { expiry: '1 / 12' } }
let(:amount) { '2.99' }
it '#amount' do
let(:amount) { '2' }
let(:amount) { '$2.99' }
let(:amount) { '$2,999.99' }
let(:amount) { '-2.99' }
let(:amount) { 'invalid' }
let(:amount) { '' }
let(:amount) { 1.55 }
I18n.backend.store_translations(:fr, number: { currency: { format: { delimiter: ' ', separator: ',' } } })
let(:amount) { '2,99' }
let(:amount) { '2,99 $' }
let(:amount) { 2.99 }
let(:amount) { '-2,99 $' }
('A'..'Z').reject { |x| subject.class::RISKY_AVS_CODES.include?(x) }.to_a.each do |char|
('A'..'Z').reject { |x| subject.class::NON_RISKY_AVS_CODES.include?(x) }.to_a.each do |char|
it "returns false if cvv_response_code == 'M'" do
(%w{N P S U} << '').each do |char|
let(:state) { 'checkout' }
let(:state) { 'pending' }
context "when the state is '#{state}'" do
let(:state) { state }
{ 'checkout' => 'processing' },
{ 'processing' => 'pending' }
let(:card) { create(:credit_card) }
let(:payment) { create(:check_payment) }
let(:auto_capture) { false }
let(:auto_capture) { true }
let!(:store_1) { create(:store) }
let(:payment) { create(:payment, order: order) }
let(:store_credit) { nil }
let(:auth_amount) { 10 }
let(:auth_amount) { (store_credit.amount_remaining * 100) + 1 }
let(:store_credit) { create(:store_credit, currency: 'AUD') }
let(:capture_amount) { 10_00 }
let(:auth_code) { -1 }
let(:authorized_amount) { (capture_amount - 1) / 100 }
let(:auth_code) { 1 }
let!(:user_with_store_credits) { create(:user) }
expect { subject }.to change(payment, :state).to('void')
number: 'P1566',
currency: 'EUR',
user_id: 144,
last_ip_address: '0.0.0.0',
number: 'R1444',
ship_total: '12.44'.to_d,
item_total: '15.11'.to_d,
promo_total: '2.57'.to_d,
it { is_expected.to eq 'test@email.com' }
it { is_expected.to eq 144 }
it { is_expected.to eq '0.0.0.0' }
it { is_expected.to eq 'R1444-P1566' }
it { is_expected.to eq 1244 }
it { is_expected.to eq 153 }
it { is_expected.to eq 1511 }
it { is_expected.to eq 257 }
it { is_expected.to eq 'EUR' }
it { is_expected.to eq(bill: :address) }
it { is_expected.to eq(ship: :address) }
ip: '0.0.0.0',
shipping: '1244'.to_d,
tax: '153'.to_d,
subtotal: '1511'.to_d,
discount: '257'.to_d,
billing_address: { bill: :address },
let(:promotion) { create(:promotion, name: '10% off') }
it "is #{state}" do
let(:order) { Order.new }
it 'is paid' do
it 'is void' do
let(:order) { create(:order, user: user, store: store) }
let(:admin_user) { create :admin_user }
let(:shipment) { double }
let(:order) { Spree::Order.create(email: 'test@example.com', store: store) }
before { order.currency = 'ABC' }
let!(:variant3) { create(:variant) }
let(:other_variant) { create(:variant) }
let!(:line_items) do
let(:user) { create(:user_with_addreses) }
let(:created_by) { user }
let(:override_email) { true }
user: nil,
let(:override_email) { false }
let(:email) { 'test@example.com' }
let(:bill_address) { build(:address) }
let(:ship_address) { build(:address) }
let(:user) { build(:user) }
context '#can_ship?' do
let(:order) { create(:order_ready_to_ship) }
@order = create(:order, user: user)
let(:shipments) { create_list(:shipment, 2) }
it 'can lock' do
line_item_2 = create(:line_item, order: order, price: 30, quantity: 1)
let(:refund) { create(:refund, reimbursement_id: nil, amount: 5) }
build(:payment, amount: -1, order: order, state: 'completed', source: payment).tap do |p|
let(:line_item) { Spree::LineItem.new(price: 10, quantity: 1) }
let(:shipment) { Spree::Shipment.new(cost: 10) }
let(:payment) { Spree::Payment.new(amount: 10) }
let(:new_order_x) { create(:order) }
let(:promo_code) { '10off' }
let!(:order) { create(:order_with_line_items, line_items_count: 2, store: store) }
let!(:order) { create(:order_with_line_items, line_items_count: 2) }
let!(:order) { create(:order_with_line_items) }
it { expect { order.destroy }.to change { Spree::Address.count }.by(-2) }
state: 'closed',
let!(:order) { create(:order_with_line_items, line_items_count: 10) }
it 'reeturns -100.0' do
it 'reeturns -10.0' do
it 'returns -110.00' do
let(:line_items_count) { 10 }
let(:line_items_count) { 15 }
let(:order) { build(:order, number: 'r1234') }
it { expect { order.valid? }.to change(order, :number).to('R1234') }
describe '#paid?' do
subject { order.paid? }
let!(:payment_0) { create(:payment, order: order, amount: amount) }
let!(:payment_1) { create(:payment, order: order, amount: amount) }
let!(:payment_2) { create(:payment, order: order, amount: amount) }
let(:amount) { 100 }
let(:order) { create(:order, total: total) }
let(:total) { 200 }
let(:total) { 201 }
let(:total) { 199 }
:shipment, 2,
before { order.currency = 'EUR' }
let(:order_1) { Spree::Order.create }
let(:order_2) { Spree::Order.create }
@line_item_1 = Spree::Cart::AddItem.call(order: order_1, variant: variant, quantity: 1, options: {foos: {}}).value
@line_item_2 = Spree::Cart::AddItem.call(order: order_2, variant: variant, quantity: 1, options: {foos: {}}).value
let(:variant_2) { create(:variant) }
let(:line_items) { create_list(:line_item, 1, amount: 5) }
let(:zone) { create :zone }
@default_zone = create(:zone, name: 'foo_zone')
let(:order) { payment.order }
subject { create(:order, user: user) }
let!(:second_store) { create(:store) }
let!(:store_credit) { create(:store_credit, amount: '100', user: user, store: store) }
let(:order_total) { 100.0 }
let(:order) { create(:order, user: store_credit.user, store: store) }
let(:order_total) { store_credit.amount - 1 }
let(:order_total) { store_credit.amount * 10 }
subject { create(:order) }
context '#next!' do
let(:payment) { create(:payment) }
context "with avs_response == ''" do
let(:payment) { FactoryBot.create(:payment, avs_response: '') }
context "state == 'failed'" do
let!(:payment_amount) { 70.00 }
let!(:store_credit_amount) { 30.00 }
let!(:payment_amount) { 90.00 }
let!(:store_credit_amount) { 10.00 }
name: 'Ryan Bigg',
expiry: '01 / 15',
it { expect(order).to be_paid }
variants.each { |v| add_line_item_to_order(order, v, 1) }
variants = 3.times.map { create(:variant) }
let(:mixed_order_digitals) { 2.times.map { create(:digital) } }
let!(:euro_price) { create(:price, variant: line_item.variant, amount: 8, currency: 'EUR') }
expect { line_item.order.update!(currency: 'EUR') }.to change { line_item.reload.currency }.from('USD').to('EUR')
let(:order) { build(:order, store: store) }
let!(:state) { country.states.first || create(:state, country: country) }
{ address: :delivery },
{ delivery: :payment },
{ payment: :confirm },
{ confirm: :complete },
{ payment: :complete },
{ delivery: :complete }
order_attributes = order.send("#{address_kind}_address".to_sym).try(:attributes) || {}
let(:address_kind) { 'ship' }
let(:address_kind) { 'bill' }
let(:payment_state) { 'failed' }
let(:digital) { create(:digital) }
expect(state_machine.states.any? { |s| s.name == :address }).to be false
let(:permitted_params) { {} }
let(:credit_card) { create(:credit_card, user_id: order.user_id) }
cvc_confirm: '737',
expiry: '06 / 2016',
cc_type: '' }
before { order.user_id = 3 }
let(:params) { ActionController::Parameters.new(order: { bad_param: 'okay' }) }
let(:params) { ActionController::Parameters.new(order: { good_param: 'okay' }) }
let(:user) { double(:user, email: 'test@example.com') }
order.state = 'cart'
let!(:persisted_order) { create(:order) }
let!(:tax_rate) {
before { order.use_billing = 'true' }
context "with '1'" do
before { order.use_billing = '1' }
before { order.use_billing = '0' }
let(:address) { create(:address, user: order.user) }
params = { bill_address_id: address.id }
params = { ship_address_id: address.id }
let!(:option_type) { create(:option_type, name: 'color', presentation: 'Color') }
let!(:store_b) { create(:store) }
let!(:menu_a) { create(:menu, store: store) }
let!(:menu_b) { create(:menu, store: store_b) }
let!(:store_milti) { create(:store) }
let!(:menu_en) { create(:menu, store: store_milti, locale: 'en') }
let!(:menu_fr) { create(:menu, store: store_milti, locale: 'fr') }
let!(:fr_store) { create(:store, default_locale: 'fr', supported_locales: 'fr,en,de') }
let!(:menu_en) { create(:menu, name: 'Main Menu EN', store: fr_store, locale: 'en') }
let!(:menu_fr) { create(:menu, name: 'Main Menu FR', store: fr_store, locale: 'fr') }
let(:store_1) { create(:store) }
let(:store_3) { create(:store) }
let!(:menu) { create(:menu, name: 'Footer Menu', location: 'Footer', store: store_1) }
let(:store_a) { create(:store) }
let(:m_x) { create(:menu, name: 'Main Menu', location: 'Header', store: store_a) }
m_x.update!(name: 'Super Menu')
let(:menu) { build(:menu, store: store) }
it { expect { menu.save! }.to change(store, :updated_at) }
let!(:menu) { create(:menu, name: 'Main Menu', store: store) }
let(:container_item){ create(:menu_item, name: 'Link 1', item_type: 'Container', menu: menu) }
let(:link_item) { create(:menu_item, name: 'Home', item_type: 'Link', menu: menu) }
describe '#code?' do
let(:coded_item){ create(:menu_item, name: 'Link 1', item_type: 'Container', menu: menu, code: 'some-code') }
let(:not_coded_item) { create(:menu_item, name: 'Home', item_type: 'Link', menu: menu) }
let(:i_b) do
create(:menu_item, name: 'Home', item_type: 'Link', menu: menu,
expect(i_b.link).to eql('/')
let(:i_c) do
let(:taxon) { create(:taxon) }
let(:cms_page) { create(:cms_standard_page) }
let(:cms_page_with_no_slug) { create(:cms_homepage) }
let(:item_url) { create(:menu_item, name: 'URL To Random Site', item_type: 'Link', menu: menu, linked_resource_type: 'Spree::Linkable::Uri', destination: 'https://some-other-website.com') }
let(:item_empty_url) { create(:menu_item, name: 'URL To Random Site', item_type: 'Link', menu: menu, linked_resource_type: 'Spree::Linkable::Uri', destination: nil) }
let(:item_home) { create(:menu_item, name: 'Home', item_type: 'Link', menu: menu, linked_resource_type: 'Spree::Linkable::Homepage') }
let(:item_taxon) { create(:menu_item, name: taxon.name, item_type: 'Link', menu: menu, linked_resource_type: 'Spree::Taxon') }
let(:item_cms_page) { create(:menu_item, name: cms_page.title, item_type: 'Link', menu: menu, linked_resource_type: 'Spree::CmsPage') }
expect(item_home.link).to eq '/'
let(:item) { create(:menu_item, name: 'URL', item_type: 'Link', menu: menu, parent: menu.root, linked_resource_type: 'Spree::Linkable::Uri', code: 'My Fantastic Code') }
let(:item_x) { create(:menu_item, name: 'URL', item_type: 'Link', menu: menu, linked_resource_type: 'Spree::Linkable::Uri', code: 'My Fantastic Code') }
it 'is not a root' do
it 'is level 1' do
let(:menu_item) { build(:menu_item, menu: menu, icon: nil) }
it { expect { menu_item.save! }.to change(store, :updated_at) }
let(:log_entry) { create(:log_entry, details: details) }
it { expect(line_item).to be_valid }
it { expect(line_item).not_to be_valid }
let(:original_quantity) { 1 }
expect(line_item.money.to_s).to eq('$7.00')
expect(line_item.single_money.to_s).to eq('$3.50')
let(:order) { Spree::Order.create(email: 'spree@example.com') }
line_item.options = { price: 123 }
line_item.options = { gift_wrap: true }
let(:line_item) { create :line_item, pre_tax_amount: 4.2051 }
end.to change(line_item, :currency).to('EUR').from('USD')
end.to change { line_item.price.to_f }.to(11.99)
end.to change { line_item.price.to_f }.to(1.99)
let(:line_item) { create :line_item, variant: create(:variant, price: 10) }
end.to change { line_item.price.to_f }.to(11.99).from(10)
let!(:inventory_unit_1) { create(:inventory_unit, state: 'on_hand') }
let!(:inventory_unit_3) { create(:inventory_unit, state: 'shipped') }
let!(:inventory_unit_4) { create(:inventory_unit, state: 'returned') }
order.tap(&:save!)
let!(:unit) do
unit.tap(&:save!)
on_hand_unit.state = 'on_hand'
let!(:other_unit) do
let (:shipment) { create(:shipment) }
let(:quantity) { 2 }
let(:text_file) { File.open("#{Spree::Core::Engine.root}/spec/fixtures/text-file.txt") }
let(:order) { store.orders.create(user_id: 1) }
let(:cc) do
response = subject.capture(123, '12345', {})
response = subject.capture(123, 'wrong', {})
let(:quantity) { 3 }
).run!
let(:quantity) { 1 }
let(:desired_count_on_hand) { 2 }
let(:quantity) { 7 }
let(:desired_count_on_hand) { 5 }
let(:desired_count_on_hand) { -1 }
let(:desired_count_on_hand) { 0 }
let(:quantity) { 0 }
let(:quantity) { 5 }
let(:quantity) { 30 }
expect { subject }.to change { Spree::Shipment.count }.by(-1)
expect { subject }.to change { Spree::Shipment.count }.by(1)
describe '#to_key' do # for dom_id
it { expect(Exchange.new(nil, nil).to_key).to be_nil }
let(:line_item) { create(:line_item, variant: variant) }
let(:second_order) { create(:order) }
it { is_expected.to eq '$30.00' }
let(:test_currency) { 'EUR' }
expiry: "12 / #{(Time.current.year + 1).to_s.last(2)}",
let(:payment) { create(:payment, amount: 100, order: order) }
context '#can_void?' do
context '#valid?' do
credit_card.number = ({})
credit_card.expiry = '04 / 14'
credit_card.expiry = '04 / 2014'
expect { credit_card.expiry = '' }.not_to raise_error
context '#cc_type=' do
credit_card.cc_type = ''
credit_card.number = ''
let(:previous_year) { DateTime.now.year - 1 }
let(:next_year) { DateTime.now.year + 1 }
let(:past_month) { DateTime.now.month - 1 }
let(:future_month) { DateTime.now.month + 1 }
let(:credit_card) { create(:credit_card, cc_type: cc_type, user_id: order.user_id) }
let(:cc_type) { nil }
it { expect(credit_card.display_brand).to eq('N/A') }
let(:cc_type) { 'visa' }
let(:america) { create :country }
expect(Spree::Country.new(name: 'Canada', iso: 'CA', iso3: 'CAN', iso_name: 'CANADA')).not_to be_valid
let(:dummy_iso) { 'XY' }
let(:zone) { Zone.new }
let(:zone) { nil }
let(:zone) { default_zone }
let(:test_user) { create :user }
let(:role) { Spree::Role.create(name: name) }
let(:name) { 'test' }
before { test_user.spree_roles << role }
it { is_expected.to be_falsy }
it { is_expected.to be_nil }
let(:order) { create(:order, approver_id: test_user.id, created_at: 1.day.ago) }
let(:other_user) { create :user }
let(:menu) { create :menu }
let(:menu_b) { create :menu, location: 'footer' }
object = Spree::CmsPage.new(title: 'Got Name', locale: 'de', type: 'Spree::Cms::Pages::StandardPage')
let!(:store_a) { create(:store) }
let!(:homepage) { create(:cms_homepage, store: store_a) }
let!(:homepage) { create(:cms_homepage, store: store_a, locale: 'en') }
it 'valid' do
let!(:page) { create(:cms_standard_page, store: store_a, slug: 'got-name', locale: 'en') }
let(:homepage) { create(:cms_homepage, store: store_a, locale: 'en') }
let(:standard_page) { create(:cms_standard_page, title: 'About Us', store: store_a) }
let!(:homepage_en) { create(:cms_homepage, store: store_a, locale: 'en') }
let!(:homepage_de) { create(:cms_homepage, store: store_a, locale: 'de') }
let!(:standard_page_slug_a) { create(:cms_standard_page, store: store_a, title: 'Little Page') }
let!(:standard_page_slug_b) { create(:cms_standard_page, store: store_a, title: 'Big Page') }
let!(:homepage) { create(:cms_homepage, store: store) }
it '#gutters? is true' do
it '#gutters? is false' do
before { calculator.preferred_tiers = { 'nope' => 20 } }
before { calculator.preferred_tiers = { 10 => 110 } }
100 => 15,
it { is_expected.to eq 5 }
it { is_expected.to eq 22 }
it { is_expected.to eq 10 }
it { is_expected.to eq 15 }
let(:variant) { build(:variant, price: 2) }
let(:variant1) { build(:variant) }
let(:variant2) { build(:variant) }
build(:stock_package, variants_contents: { variant1 => 5, variant2 => 3 })
expect(subject.compute(package).to_f).to eq(80) # 5 x 10 + 3 x 10
build(:stock_package, variants_contents: { variant1 => 4, variant2 => 6 })
let(:variant1) { build(:variant, price: 10.11) }
let(:variant2) { build(:variant, price: 20.2222) }
let(:line_item_quantity) { 2 }
before { order.line_items << line_item }
let(:adjustment_amount) { -10.0 }
let(:adjustment_total) { -50.0 }
it { is_expected.to eq 0.0 }
let!(:line_item) { create(:line_item, price: 10, quantity: 3, tax_category: tax_category) }
let!(:shipment) { create(:shipment, cost: 15) }
let!(:line_item_1) { line_item }
let!(:line_item_2) { create(:line_item, price: 10, quantity: 3, tax_category: tax_category) }
it 'is 0' do
it 'is 5% of 15' do
let(:rate) { create(:tax_rate, amount: 0.07, included_in_price: true) }
let(:line_item) { create(:line_item, quantity: 50, price: 8.50) }
it { expect(Spree::Address.json_api_type).to eq('address') }
let (:deps) { described_class.new }
let(:amount) { '1,599,99' }
let(:adjustment) { create(:adjustment, order: order, state: 'open') }
let(:order) { Spree::Order.new(currency: 'EUR') }
let(:state) { 'closed' }
let(:state) { 'open' }
let(:promotion_code) { 'somecode' }
let(:tax_rate) { create(:tax_rate, amount: 0.05) }
create(:promotion, name: '$10 off')
amount: -3.50,
label: 'Other',
amount: -500,
let!(:promo_a) { create_adjustment('Promotion A', -100) }
let!(:promo_c) { create_adjustment('Promotion C', -300) }
label: 'Home',
user_id: 976,
let(:address) { Spree::Address.new }
let(:state) { create(:state, name: 'maryland', abbr: 'md') }
address.phone = ''
address.zipcode = ''
let(:address) { create(:address, state: nil, state_name: 'virginia') }
specify { expect(address.state_text).to eq('va') }
let(:address) { create(:address, state: state, state_name: nil) }
let(:address) { create(:address, state: state, state_name: 'virginia') }
let (:address) { create(:address) }
it { expect { address.send(:clear_state) }.not_to change(address, :state_name) }
it { expect { address.send(:clear_state_name) }.not_to change(address, :state_id) }
it { expect { address.send(:clear_state_name) }.to change(address, :state_name).to(nil).from('maryland') }
context '#==' do
it { expect(address == address2).to eq(true) }
it { expect(address == address2).to eq(false) }
let(:address2) { create(:address, user: user) }
expect(address.to_s).to eq("#{a.full_name}<br/>#{a.address1}<br/>#{a.address2}<br/>#{a.city}, #{a.state_text} #{a.zipcode}<br/>#{a.country}")
dangerous_string = '<script>alert("BOOM!")</script>'
let(:ability) { Spree::Ability.new(user) }
let(:token) { nil }
let(:resource) { Object.new }
let(:resource_user) { create(:user) }
let(:user) { Spree::DummyModel.create(name: 'admin') }
let(:resource) { Spree::Order.new }
let(:token) { 'TOKEN123' }
let(:token) { 'FAIL' }
let(:resource) { Spree::State.new }
let(:resource) { Spree::Taxon.new }
let(:resource) { user }
let(:resource) { create(:user) }
let(:resource) { Spree::Zone.new }
let(:image) { create(:image, viewable: variant) }
let(:gravity) { 'north' }
it { expect { subject.invoke }.not_to change { Spree::Order.count } }
let!(:order) { create(:shipped_order, line_items_count: 2) }
let(:product) { create(:product) }
let(:result) { service.call }
def call(params: {})
let(:result) { service.call(params: {}) }
param = 'param'
let(:currency) { Money::Currency.new('USD') }
expect(money.to_s).to eq('$10.00')
expect(money.to_s).to eq('$10.00 USD')
expect(money.to_s).to eq('$10')
expect(money.to_s).to eq('$10.00 CAD')
money = described_class.new(10, format: '%n %u', html_wrap: false)
expect(money.to_s).to eq('10.00 $')
it 'defaults to -$10.00' do
expect(money.to_s).to eq('-$10.00')
expect(money.to_s).to eq('$-10.00')
money = described_class.new(10, format: '%n %u')
expect(money.to_html).to eq('10.00&nbsp;&#x20AC;')
money = described_class.new(10, format: '%n %u', with_currency: true)
expect(money.to_html).to eq('10.00&nbsp;&#x20AC; EUR')
let(:money) { described_class.new(10) }
money = described_class.new(10, decimal_mark: ',')
let(:options) { double('options') }
expect(money.as_json(options)).to eq('$10.00')
let(:config) { double('Config', root: 'dir') }
let(:engine_dir) { 'dir/db/migrate' }
let(:app_dir) { "#{Rails.root}/db/migrate" }
I18n.backend.store_translations(:de, number: { currency: { format: { delimiter: '.', separator: ',' } } })
number = '1.599,99'
let!(:dummy1) { Spree::DummyModel.create(name: 'TestName', position: 3) }
let!(:dummy2) { Spree::DummyModel.create(name: 'Test', position: 10) }
position: { eq: 'TestName' }
position: { contains: 'Test' }
let!(:dummy1) { Spree::DummyModel.create(name: '1', position: 3) }
let!(:dummy2) { Spree::DummyModel.create(name: '2', position: 10) }
let!(:dummy3) { Spree::DummyModel.create(name: '3', position: 4) }
position: { gt: 3 }
position: { gteq: 4 }
position: { lt: 4 }
position: { lteq: 4 }
let(:options) { { prefix: 'R' } }
describe "##{name}" do
let(:value) { double('Generic Value') }
describe "##{name}=" do
let(:value_a) { double('Generic Value A') }
let(:value_b) { double('Generic Value B') }
expect { object.public_send(:"#{name}=", value_b) }.
let(:resource) { model.new }
let(:record_count) { 10**expected_length / 2 }
let(:resource) { model.new(number: 'Test') }
let(:sku) { variant.sku }
let(:variant_id) { variant.id }
params = { number: '123-456-789' }
email: 'test@test.com',
params = { email: 'wooowww@test.com' }
let(:other_user) { create(:user) }
params = { user_id: other_user.id }
params = { currency: 'GBP' }
currency: 'GBP',
let(:other_state) { create(:state, name: 'Uhuhuh', country: create(:country)) }
hash = { sku: variant.sku }
address = { country: { field => country.send(field) } }
address = { country: { 'name' => 'NoNoCountry' } }
address = { country_id: country.id, state: { field => state.send(field) } }
cost: '14.99',
inventory_units: Array.new(3) { { sku: sku, variant_id: variant.id } }
inventory_units: Array.new(2) { { sku: sku, variant_id: variant.id } }
cost: '4.99',
amount: -4.99
amount: -3.00
amount: -4.99,
{ label: 'Order Discount', amount: -5.99 }
{ label: 'Line Item Tax', amount: -4.99, tax: true }
{ label: 'Promotion Discount', amount: -3.00 }
expect(order.total).to eq(163.1) # = item_total (166.1) - adjustment_total (3.00)
amount: '-3.00'
amount: '4.99',
source: {
name: 'Fox',
last_digits: '7424',
year: '2022',
month: '5'
cc_type: 'visa'
let!(:store) { create :store, default: true }
let!(:store_2) { create :store, url: 'another.com' }
let!(:store_3) { create :store, url: 'some.another.com' }
let!(:store_2) { create :store }
let(:other_zone) { Spree::Zone.new }
let(:current_order) { Spree::Order.new }
let!(:store) { create(:store, default: true, default_currency: 'USD') }
let!(:order) { create :order, user: user, store: store }
let!(:guest_order) { create :order, user: nil, email: nil, token: 'token', store: store }
let(:user) { create(:user, email: '') }
let!(:incomplete_order) { create(:order, user: user, store: create(:store)) }
let(:user) { build(:user, selected_locale: 'pl') }
let!(:store) { create :store, default: true, default_locale: 'fr', supported_locales: 'fr,de,pl' }
let!(:store) { create :store, default: true, default_locale: 'fr', supported_locales: 'fr,de' }
controller.params = { locale: 'de' }
let!(:store) { create :store, default: true, default_locale: 'fr' }
let!(:store) { create :store, default: true, default_locale: nil }
let!(:store) { create :store, default: true, default_locale: 'de', supported_locales: 'de, pl' }
let!(:store) { create :store, default: true, default_locale: 'en', supported_locales: 'en,de,fr' }
it { expect(controller.locale_param).to eq('de') }
let!(:store) { create :store, default: true, default_currency: 'GBP' }
before { controller.params = { currency: 'EUR' } }
before { controller.params = { currency: 'GBP' } }
let(:product1) { create(:product, name: 'RoR Mug', price: 9.00) }
let!(:product2) { create(:product, name: 'RoR Shirt', price: 11.00) }
let(:taxon) { create(:taxon, name: 'Ruby on Rails') }
let(:pln_price) { create(:price, variant_id: product1.master.id, price: 5, currency: 'PLN') }
params = { per_page: '' }
let(:params) { { include_images: true, keyword: product1.name, taxon: taxon } }
@product3 = create(:product, name: 'RoR Pants', price: 14.00)
params = { per_page: '2' }
params = { per_page: '', search: { 'name_not_cont' => 'Shirt' } }
let(:eu_store) { create(:store, name: 'EU Store', default_currency: 'EUR') }
let(:uk_store) { create(:store, name: 'UK Store', default_currency: 'GBP') }
let(:spree_store) { create(:store, name: 'Spree Demo Site', default_currency: 'USD', default: true) }
(1..3).map do |v|
(1..2).map do |v|
let(:params) { { current_store: current_store } }
let(:current_store) { eu_store }
let(:current_store) { uk_store }
params = { keywords: 'shirt', include_images: true }
spree: {
foo: 'bar',
bar: {
expect(Spree.normal_t(:foo)).to eql('bar')
expect(Spree.normal_t(:foo, scope: 'bar')).to eql('bar within bar scope')
expect(message).not_to(be_nil, "expected '#{key}' to be missing, but it wasn't.")
Spree.t(:foo)
expect(message).not_to(be_nil, "expected '#{key}' to be unused, but it was used.")
expect(message).to(be_nil, "expected '#{key}' to be used, but it wasn't.")
let!(:line_item) { order.line_items.take }
let(:product_price) { 10 }
let(:variant_price) { 10 }
let(:product_price) { nil }
let(:variant_price) { 15 }
it { is_expected.to eq('(Add: $5.00)') }
let(:product_price) { 15 }
it { is_expected.to eq('(Subtract: $5.00)') }
let(:variant_price) { 100 }
let(:product_price) { 100 }
let(:currency) { 'JPY' }
let(:variant_price) { 150 }
it { is_expected.to eq('(Add: &#x00A5;50)') }
let(:product_price) { 150 }
it { is_expected.to eq('(Subtract: &#x00A5;50)') }
let(:description) { nil }
let(:description) { 'test_desc' }
let(:description) { 'test&nbsp;desc' }
it { is_expected.to eq('test desc') }
let(:description) { "test\n\r\ndesc" }
let(:product_ids) { products.map(&:id).join('-') }
let(:updated_at) { Date.new(2011, 12, 13) }
let(:today) { Date.new(2013, 12, 11) }
allow(Date).to receive(:today) { today }
it { is_expected.to eq('en/USD/spree/products/new/') }
a: nil,
a: true,
b: Spree::Zone.new,
let(:germany) { create(:country, name: 'Germany', iso: 'GR') }
i18n: {
let(:current_store) { create(:store, supported_locales: 'en', default_locale: 'en') }
@zone = create(:zone, name: 'No Limits', kind: 'country')
let!(:taxon) { create(:taxon) }
let!(:product) { create(:product) }
a = link_to_tracking_html(shipping_method: true, tracking: '123', tracking_url: 'http://g.c/?t=123').css('a')
expect(a.text).to eq '123'
expect(a.attr('href').value).to eq 'http://g.c/?t=123'
expect(html.css('span').text).to eq '123'
expect(html.css('span').text).to eq ''
let(:current_currency) { 'USD' }
let!(:user) { create(:admin_user) }
let!(:user) { nil }
text = FFaker::Lorem.paragraphs(2).join(' ')
let(:image) { create(:image, position: 1) }
time = Time.new(2012, 5, 6, 13, 33)
expect(pretty_time(nil)).to eq ''
expect(pretty_date(Time.new(2012, 5, 6, 13, 33))).to eq 'May 06, 2012'
expect(pretty_date(nil)).to eq ''
let(:current_price_options) { { tax_zone: current_tax_zone } }
let (:current_tax_zone) { nil }
it { is_expected.to eq(master_image_1) }
it { is_expected.to eq(image_1) }
let!(:image_1) { create :image, viewable: variant }
let!(:image_2) { create :image, viewable: variant }
let!(:image_1) { create :image, viewable: variant_2 }
let!(:image_2) { create :image, viewable: variant_2 }
let(:current_store) { create(:store, :with_favicon) }
let(:option_type_1) { create :option_type, position: 2, name: 'color' }
let!(:taxon_shirts) { create(:taxon, name: 'Shirts') }
let!(:taxon_shorts) { create(:taxon, name: 'Shorts') }
let(:params) { { filter: { 'name': 'Shirts' } } }
let!(:store_2) { create(:store, url: 'another.com', default_currency: 'GBP') }
let(:scope) { nil }
let(:url) { nil }
it { expect(subject).to eq(store) }
let(:url) { 'another.com' }
it { expect(subject).to eq(store_2) }
let(:url) { 'something-different.com' }
let(:scope) { Spree::Store.where(default_currency: 'GBP') }
ids: '',
skus: '',
price: '',
currency: 'USD',
taxons: '',
concat_taxons: '',
let(:option_type_1) { create :option_type, name: 'size' }
let(:option_type_2) { create :option_type, name: 'state' }
let(:option_value_1_1) { create :option_value, option_type: option_type_1, name: 's', presentation: 'S' }
let(:option_value_1_2) { create :option_value, option_type: option_type_1, name: 'm', presentation: 'M' }
let(:option_value_2_1) { create :option_value, option_type: option_type_2, name: 'old', presentation: 'Old' }
let(:option_value_2_2) { create :option_value, option_type: option_type_2, name: 'new', presentation: 'New' }
size: 's',
state: 'old'
let!(:scope) { Spree::Product.all }
let(:child_taxon) { create(:taxon) }
let(:params) { { store: store, filter: { taxons: parent_taxon.id } } }
let(:params) { { store: store, filter: { taxons: "#{taxon.id},#{taxon_2.id}" } } }
let(:params) { { store: store, filter: { taxons: "#{taxon.id},#{taxon_2.id}", concat_taxons: taxon_3.id.to_s } } }
let(:taxon_3) { create(:taxon) }
let(:params) { { store: store, filter: { concat_taxons: "#{taxon_2.id},#{taxon_3.id}" } } }
let(:params) { { store: store, filter: { concat_taxons: taxon_3.id.to_s } } }
let!(:scope) { store.products }
let(:params) { { filter: { price: price_param } } }
let(:price_param) { '0,20' }
let(:price_param) { '16,24' }
let(:price_param) { '23,Infinity' }
let(:brand) { create(:property, :brand) }
let!(:product_1) do
let!(:product_2) do
let(:properties_param) { { brand: 'alpha,beta,gamma' } }
let(:params) { { sort_by: 'default' } }
{ store: store, sort_by: 'default', filter: { taxons: taxonomy.root.id } }
).execute.map(&:id)
sort_by: 'name-a-z'
sort_by: 'name-z-a'
let!(:size) { create(:option_type, :size) }
let!(:s_size) { create(:option_value, option_type: size, name: 's') }
let!(:m_size) { create(:option_value, option_type: size, name: 'm') }
let!(:xl_size) { create(:option_value, option_type: size, name: 'xl') }
let!(:color) { create(:option_type, :color) }
let!(:red_color) { create(:option_value, option_type: color, name: 'red') }
let!(:green_color) { create(:option_value, option_type: color, name: 'green') }
let!(:blue_color) { create(:option_value, option_type: color, name: 'blue') }
m_size, xl_size,
let!(:white_color) { create(:option_value, option_type: color, name: 'white') }
let!(:black_color) { create(:option_value, option_type: color, name: 'black') }
let!(:wool) { create(:option_value, option_type: material, name: 'wool') }
let!(:silk) { create(:option_value, option_type: material, name: 'silk') }
nullify_translatable_fields = @resource_class.translatable_fields.map { |f| "#{f}=null" }.join(', ')
translation_table_fields = @resource_class.translatable_fields.map { |f| "#{@translations_table}.#{f}" }.join(', ')
row_expression = @resource_class.translatable_fields.count == 1 ? 'ROW' : ''
store ||= if Spree::Store.exists?
it { expect(subject.public_metadata).to eq({}) }
it { expect(subject.private_metadata).to eq({}) }
expect(described_class.where("public_metadata->>'color' = ?", 'red').count).to eq(1)
expect(described_class.where("public_metadata->>'priority' = ?", '1').count).to eq(1)
expect(described_class.where("public_metadata -> 'additional_data' ->> 'size' = :size", size: 'big').count).to eq(1)
cart_page: {
title: 'Panier',
cart: 'Panier',
close: 'Fermer',
home: 'Accueil',
nav_bar: {
used_translations.map { |a| a.split('.') }.each do |translation_keys|
error = "#{(processed_keys << key).join('.')} (#{I18n.locale})"
def fill_in_date_with_js(label_text, options = {})
accurate_month = (month.to_i - 1)
kind { :country }
sequence(:name) { |n| "GlobalZone_#{n}" }
sequence(:name) { |n| "Wishlist_#{n}" }
is_private { true }
is_default { false }
sequence(:random_float) { BigDecimal("#{rand(200)}.#{rand(99)}") }
images { create_list(:image, 1) }
is_master { 1 }
public_metadata { {} }
private_metadata { {} }
sequence(:name) { |n| "taxonomy_#{n}" }
sequence(:name) { |n| "taxon_#{n}" }
name { "TaxRate - #{rand(999_999)}" }
amount { 0.1 }
name { "TaxCategory - #{rand(999_999)}" }
filepath { Spree::Core::Engine.root.join('spec', 'fixtures', 'favicon.ico') }
image_type { 'image/x-icon' }
sequence(:store_credits_order_number) { |n| "R1000#{n}" }
created_by { create(:user) }
amount { 150.00 }
currency { 'USD' }
store { Spree::Store.default || create(:store) }
name { 'Exchange' }
number {}
type {}
quantity { 1 }
action { 'received' }
)&.destroy
variants_contents { {} }
transient { variants_contents { { build(:variant) => 2 } } }
stateful { build(:order) }
previous_state { 'cart' }
next_state { 'address' }
user { build(:user) }
cost { BigDecimal(10) }
display_on { 'both' }
sequence(:name) { |n| "ShippingCategory #{n}" }
tracking { 'U10000' }
sequence(:name) { |n| "Role #{n}" }
name { 'admin' }
memo { 'Items were broken' }
sequence(:name) { |n| "Defect #{n}" }
sequence(:name) { |n| "Reimbursement Type #{n}" }
amount { 100.00 }
sequence(:name) { |n| "Refund for return #{n}" }
filter_param { 'brand' }
name { 'Promo' }
value { "val-#{rand(50)}" }
price { 17.99 }
create(:property, :brand, id: 10)
name { 'Test' }
name { 'Check' }
type { 'Spree::Gateway::Bogus' }
name { 'Credit Card' }
response_code { '12345' }
state { 'completed' }
amount { 45.75 }
amount { 10.0 }
completed_at { nil }
state { 'complete' }
shipment_state { 'ready' }
sequence(:name) { |n| "Size-#{n}" }
sequence(:name) { |n| "foo-size-#{n}" }
name { 'size' }
presentation { 'Size' }
name { 'color' }
sequence(:name) { |n| "Link no. #{n} To Somewhere" }
item_type { 'Link' }
locale { 'en' }
location { 'Header' }
source { build(:order) }
details { 'Some details' }
state { 'on_hand' }
line_item { nil }
sequence(:iso_name) { |n| "ISO_NAME_#{n}" }
type { 'Spree::Cms::Sections::HeroImage' }
type { 'Spree::Cms::Pages::Homepage' }
type { 'Spree::Cms::Pages::StandardPage' }
type { 'Spree::Cms::Pages::FeaturePage' }
position { 1 }
after(:create) { |c| c.set_preference(:amount, 10.0) }
after(:create) { |c| c.set_preference(:amount, 0) }
alt {}
sequence(:address1) { |n| "#{n} Lovely Street" }
sequence(:sku) { |n| "SKU-#{n}" }
Please use get, params: {}
Please use put, params: {}
parameters ||= {}
task :test_app, :user_class do |_t, args|
Rails.env = 'test'
task :seed do |_t|
puts 'Seeding ...'
text.to_s.split('').each do |char|
first(".icon-#{type}").click
within("table.table tbody tr:nth-child(#{num})", match: :first, &block)
find("td:nth-child(#{num})").text
def wait_for(options = {})
user ||= Spree::User.new
block ||= proc { |_u| can :manage, :all }
def call(*args, **kwargs)
new.call(*args, **kwargs).tap do |result|
input ||= {}
result = if input.is_a?(Hash)
:id, :firstname, :lastname, :first_name, :last_name,
:address1, :address2, :city, :country_iso, :country_id, :state_id,
:user_id, :deleted_at, :label,
:name, :active, :address1, :address2, :city, :zipcode,
{ mailer_logo_attributes: {}, favicon_image_attributes: {}, logo_attributes: {} },
:weight, :height, :width, :depth, :sku, :barcode, :cost_currency,
def to_html(opts = { html: true })
output = output.sub(' ', '&nbsp;').html_safe
def ==(obj)
name, engine = file_name.split('.', 2)
name = file_name.split('_', 2).last.split('.', 2).first
name.empty? ? next : name
name = file_name.split('_', 2).last
if engine_name == 'spree'
engine == "#{engine_name}.rb"
number.gsub!(separator, '.') unless separator == '.'
def translate(key, options = {})
(SpreeI18n::Locale.all << :en).map(&:to_sym)
token = "#{random_token}#{unique_ending}"
(Time.now.to_f * 1000).to_i
@properties = {}
{ images: { attachment_attachment: :blob } }
base_scope = base_scope.i18n { name.matches("%#{query}%").or(description.matches("%#{query}%")) }
low_price = 0
@spree_routes.each { |r| eval_block(&r) }
@append_routes.each { |r| eval_block(&r) }
name: 'Taxons under ' + taxon.name,
name: 'All taxons',
product.translations.each { |t| new_product.send(:name=, "COPY OF #{t.name}", locale: t.locale) }
@cache.exist?(key) ||
unless (val = @cache.read(key)).nil?
methods.grep(/\Apreferred_.*=\Z/).map do |pref_method|
pref_method.to_s.gsub(/\Apreferred_|=\Z/, '').to_sym
(value.presence || 0).to_s.to_d
if value.is_a?(FalseClass) ||
value.nil? ||
value == 0 ||
value&.to_s =~ /^(f|false|0)$/i ||
(value.respond_to?(:empty?) && value.empty?)
value.is_a?(Array) ? value : Array.wrap(value)
JSON.parse value.gsub('=>', ':')
value.try(:to_h)
name = method.to_s.delete('=')
if method.to_s =~ /=$/
length += 1 if host.count > Rational(BASE**length, 2)
characters = @letters ? 36 : 10
end # Core
params.delete(:user_id) unless user.try(:has_spree_role?, 'admin') && params.key?(:user_id)
raise "Order import shipments: #{e.message} #{s}"
raise "Order import payments: #{e.message} #{p}"
sku = hash.delete(:sku)
search = {}
load File.join(root, 'lib', 'tasks', 'exchanges.rake')
File.dirname(__FILE__), '../../../config/locales', '*.{rb,yml}'
) - I18n.load_path))
Dir.glob(File.join(File.dirname(__FILE__), '../../../app/**/*_decorator*.rb')) do |c|
values << { injection_point.to_s => instance_variable_get("@#{injection_point}") }
@menu_finder = 'Spree::Menus::Find'
:store_id,
).
redirect_to main_app.respond_to?(:root_path) ? main_app.root_path : '/'
@@api_available ||= ::Rails::Engine.subclasses.map(&:instance).map { |e| e.class.to_s }.include?('Spree::Api::Engine')
@@backend_available ||= ::Rails::Engine.subclasses.map(&:instance).map { |e| e.class.to_s }.include?('Spree::Backend::Engine')
@@frontend_available ||= ::Rails::Engine.subclasses.map(&:instance).map { |e| e.class.to_s }.include?('Spree::Frontend::Engine')
@@emails_available ||= ::Rails::Engine.subclasses.map(&:instance).map { |e| e.class.to_s }.include?('Spree::Emails::Engine')
@@sample_available ||= ::Rails::Engine.subclasses.map(&:instance).map { |e| e.class.to_s }.include?('SpreeSample::Engine')
if @@user_class.is_a?(Class)
elsif @@user_class.is_a?(String) || @@user_class.is_a?(Symbol)
@@admin_user_class ||= @@user_class
elsif @@admin_user_class.is_a?(String) || @@admin_user_class.is_a?(Symbol)
@@searcher_class ||= 'Spree::Core::Search::Base'
elsif @@searcher_class.is_a?(String) || @@searcher_class.is_a?(Symbol)
paths << File.expand_path('../templates', "../../#{__FILE__}")
paths << File.expand_path('../templates', "../#{__FILE__}")
paths << File.expand_path('templates', __dir__)
User-agent: *
Dir.glob(File.join(File.dirname(__FILE__), "../app/**/*_decorator*.rb")) do |c|
Dir.glob(File.join(File.dirname(__FILE__), "../app/overrides/*.rb")) do |c|
cmd = -> { rake("db:seed #{rake_options.join(' ')}") }
mount Spree::Core::Engine, at: '/'
puts '*' * 50
puts ' '
puts 'Enjoy!'
extensions = %w(.js.coffee .js.erb .js.coffee.erb .js)
extensions = %w(.css.scss .css.erb .css.scss.erb .css)
File.exist?("#{filename}#{extension}")
format('%.3d', (current_migration_number(dirname) + 1))
gemfile = File.expand_path("<%= gemfile_path %>", __FILE__)
require File.expand_path('../boot', __FILE__)
require '<%= lib_name %>'
Devise.secret_key = "<%= SecureRandom.hex(50) %>"
if lib_name == 'spree/backend'
require "#{gem}"
@camelized ||= name.gsub(/\W/, '_').squeeze('_').camelize
end\n}
Time.new.utc.strftime('%Y%m%d%H%M%S')
slug) =
where('available_on <= ?', Time.current).
where(status: 'draft').
where('discontinue_on <= ?', Time.current).
t.string "type", limit: 75
t.text "alt"
t.decimal "promo_total", precision: 10, scale: 2, default: "0.0"
t.decimal "pre_tax_amount", precision: 12, scale: 4, default: "0.0", null: false
t.decimal "item_total", precision: 10, scale: 2, default: "0.0", null: false
t.decimal "total", precision: 10, scale: 2, default: "0.0", null: false
t.decimal "payment_total", precision: 10, scale: 2, default: "0.0"
t.decimal "shipment_total", precision: 10, scale: 2, default: "0.0", null: false
t.decimal "amount", precision: 10, scale: 2, default: "0.0"
t.decimal "amount", precision: 10, scale: 2, default: "0.0", null: false
t.string "name", default: "", null: false
t.text "memo"
t.decimal "cost", precision: 10, scale: 2, default: "0.0"
t.decimal "cost", precision: 8, scale: 2, default: "0.0"
t.decimal "user_total_amount", precision: 8, scale: 2, default: "0.0", null: false
t.decimal "amount", precision: 8, scale: 2, default: "0.0", null: false
t.decimal "amount_used", precision: 8, scale: 2, default: "0.0", null: false
t.string "sku", default: "", null: false
t.decimal "weight", precision: 8, scale: 2, default: "0.0"
t.string "kind", default: "state"
if scope == :class
uri.host.present? && uri.is_a?(URI::HTTP)
if value && limit && value.to_s.length > limit
select("#{Spree::Product.table_name}.*, #{Spree::Price.table_name}.amount").
return scope unless (value = sort_by?('sku'))
where(Spree::Variant.table_name.to_s => { is_master: true }).
if sort_by?('sku') || sort_by?('price')
fields << field if sort_by?(field.to_s)
scope = scope.order("#{value}": order)
desc_order(field) ? :desc : :asc
def call(payment_method:, params: {}, user: nil)
shipment.send("#{state}!")
quantity = quantity&.to_i || 1
uk_vat = Spree::Zone.where(name: 'UK_VAT', kind: 'country').first_or_create!
asia = Spree::Zone.where(name: 'Asia', description: 'Asia', kind: 'country').first_or_create!
%w(US CA).each do |name|
Spree::Store.new do |s|
name: 'default',
elsif carmen_country.alpha_2_code == 'CA' || carmen_country.alpha_2_code == 'MX'
def call(order:, params: {})
def call(line_item:, line_item_attributes: {}, options: {})
def call(line_item:, options: {})
def call(order:, line_item_attributes: {}, options: {})
xml.rss('xmlns:g' => 'http://base.google.com/ns/1.0', 'version' => '2.0') do
information = {}
title << " - #{option_value.name}"
if position.is_a?(String) && !position.match(/^\d+$/)
quantity ||= 1
def call(user:, store:, currency:, public_metadata: {}, private_metadata: {}, order_params: {})
order_params ||= {}
def call(order:, variant:, quantity: nil, public_metadata: {}, private_metadata: {}, options: {})
def add_to_line_item(order:, variant:, quantity: nil, public_metadata: {}, private_metadata: {}, options: {})
def call(address_params: {}, user: nil)
def call(user:, user_params: {})
def call(user_params: {})
@variant_ids = variants.map(&:id)
}.merge(
prices = param.split('-')
where('zoneable_id IS NULL OR zoneable_type != ?', "Spree::#{kind.classify}")
scope :with_default_tax, -> { where(default_tax: true) }
spree_zone_members.zoneable_id IN (?))",
if match = matches.detect { |zone| zone_kind == zone.kind }
kind == 'country'
kind == 'state'
ids.reject(&:blank?).map do |id|
belongs_to :user, class_name: "::#{Spree.user_class}", touch: true
belongs_to :product, -> { with_deleted }, touch: true, class_name: 'Spree::Product', inverse_of: :variants
has_many :images, -> { order(:position) }, as: :viewable, dependent: :destroy, class_name: 'Spree::Image'
scope :in_stock, -> { joins(:stock_items).where("#{Spree::StockItem.table_name}.count_on_hand > ? OR #{Spree::Variant.table_name}.track_inventory = ?", 0, false) }
scope :eligible, -> {
scope :not_deleted, -> { where("#{Spree::Variant.quoted_table_name}.deleted_at IS NULL") }
scope :active, ->(currency = nil) do
define_method("#{m}=") do |argument|
is_master? ? name + ' - Master' : name + ' - ' + options_text
def options=(options = {})
m = "#{key}_price_modifier_amount_in".to_sym
m = "#{key}_price_modifier_amount".to_sym
(width || 0) * (height || 0) * (depth || 0)
(width || 0) + (height || 0) + (depth || 0)
has_one :root, -> { where parent_id: nil }, class_name: 'Spree::Taxon', dependent: :destroy
default_scope { order("#{table_name}.position, #{table_name}.created_at") }
self.root ||= Taxon.create!(taxonomy_id: id, name: name)
@styles ||= {
mini: '32x32>',
scope :for_store, ->(store) { joins(:taxonomy).where(spree_taxonomies: { store_id: store.id }) }
scope :for_stores, ->(stores) { joins(:taxonomy).where(spree_taxonomies: { store_id: stores.ids }) }
name += "#{ancestor.name} -> "
if saved_change_to_name? && root?
scope :by_zone, ->(zone) { where(zone_id: zone.id) }
->(zone) do
->(category) { where(tax_category_id: category.try(:id)) }
scope :included_in_price, -> { where(included_in_price: true) }
pre_tax_amount /= (1 + included_rates.sum(&:amount))
amount * 100,
dimension: { max: 256..256 },
size: { less_than_or_equal_to: 1.megabyte }
belongs_to :user, class_name: "::#{Spree.user_class}", foreign_key: 'user_id'
connected? &&
table_exists? &&
scope :by_url, ->(url) { where('url like ?', "%#{url}%") }
@unique_name ||= "#{name} (#{code})"
@formatted_url ||= if url.match(/http:\/\/|https:\/\//)
Rails.env.development? || Rails.env.test? ? "http://#{url}" : "https://#{url}"
if default? && can_be_deleted?
Country.find_by(iso: 'US') || Country.first
max: 2**31 - 1,
min: -2**31
scope :recent, -> { order(created_at: :desc) }
scope :active, -> { where(active: true) }
scope :order_default, -> { order(default: :desc, name: :asc) }
state.try(:abbr) || state.try(:name) || state_name
on_hand = 0 if on_hand < 0
belongs_to :variant, -> { with_deleted }, class_name: 'Spree::Variant'
less_than_or_equal_to: 2**31 - 1,
}, if: :verify_count_on_hand?
count_on_hand_changed? && !backorderable? && (count_on_hand < count_on_hand_was) && (count_on_hand < 0)
saved_change_to_count_on_hand.any?(&:zero?)) ||
@item_shipping_category ||= {}
@adjusters = {}
(!state || item.state.to_s == state.to_s)
matched_contents = state.nil? ? contents : contents.select { |c| c.state.to_s == state.to_s }
end.join(' / ')
missing.values.any? { |v| v > 0 }
@missing = Hash.new(0)
@packed = Hash.new(0)
@required = Hash.new(0)
state.to_s == 'on_hand'
belongs_to :user, class_name: "::#{Spree.user_class}", optional: true
-> { where(zoneable_type: 'Spree::State') },
where('name = ? OR abbr = ?', name_or_abbr, name_or_abbr)
belongs_to :tax_rate, -> { with_deleted }, class_name: 'Spree::TaxRate'
if free? || cost < -discount_amount
has_many :shipping_rates, -> { order(:cost) }
scope :pending, -> { with_state('pending') }
scope :shipped, -> { with_state('shipped') }
scope :trackable, -> { where("tracking IS NOT NULL AND tracking != ''") }
scope :with_state, ->(*s) { where(state: s) }
scope :valid, -> { where.not(state: :canceled) }
manifest.map { |m| (m.line_item.price + (m.line_item.adjustment_total / m.line_item.quantity)) * m.quantity }.sum
units.group_by(&:line_item_id).map do |_line_item_id, units|
states = {}
ready? || pending?
return unless value == '1' && shipped_at.nil?
after_ship if new_state == 'shipped' && old_state != 'shipped'
belongs_to :user, class_name: "::#{Spree.user_class}"
has_many :users, through: :role_users, class_name: "::#{Spree.user_class}"
validators.map(&:errors).reduce({}, :merge)
scope :received, -> { where(reception_status: 'received') }
scope :pending, -> { where(acceptance_status: 'pending') }
scope :accepted, -> { where(acceptance_status: 'accepted') }
scope :rejected, -> { where(acceptance_status: 'rejected') }
unpaid_amount = return_items.map { |ri| ri.total.to_d.round(2) }.sum
return_items.map { |ri| ri.total.to_d.round(2) }.sum
if return_items.any? { |ri| ri.inventory_unit.order_id != order_id }
(reimbursement_count - 1) * 0.01.to_d
scope :sorted, -> { order(:name) }
scope :filterable, -> { where(filterable: true) }
scope :of_type, ->(t) { where(type: t) }
def eligible?(_promotable, _options = {})
@new_promotion.path = "#{@promotion.path}_#{@random_string}"
@new_promotion.name = "New #{@promotion.name}"
@new_promotion.code = "#{@promotion.code}_#{@random_string}"
charset = Array('A'..'Z') + Array('a'..'z')
@path = path.gsub(/\A\//, '')
@error = Spree.t(code)
def perform(_options = {})
def eligible?(order, _options = {})
user_ids.join(',')
taxons.pluck(:id).join(',')
ids = s.to_s.split(',').map(&:strip)
when 'any', 'all'
product_ids.join(',')
values = super || {}
(v.is_a?(Array) ? v : v.split(','))
def eligible?(promotable, _options = {})
when 'any'
def eligible?(order, options = {})
if user || email
def perform(payload = {})
def perform(options = {})
def revert(options = {})
quantity: (item.quantity || 1))
amounts.min * -1
validate :expires_at_must_be_later_than_starts_at, if: -> { starts_at && expires_at }
scope :coupons, -> { where.not(code: nil) }
scope :advertised, -> { where(advertise: true) }
where("lower(#{table_name}.code) = ?", coupon_code.strip.downcase).
!!(starts_at && Time.current < starts_at || expires_at && Time.current > expires_at)
rules.send(match_all? ? :all? : :any?) do |rule|
where.not(spree_orders: { id: excluded_orders.map(&:id) }).
where(spree_promotions: { id: id }).
match_policy == 'all'
scope :filterable, -> { joins(:property).where(Property.table_name => { filterable: true }) }
-> { where is_master: true },
-> { where(is_master: false).order(:position) },
-> { order(:position) },
scope :for_store, ->(store) { joins(:store_products).where(StoreProduct.table_name => { store_id: store.id }) }
:sku, :barcode, :price, :currency, :weight, :height, :width, :depth, :is_master,
active? && !deleted?
variants.active.group_by { |v| v.option_values.detect { |o| o.option_type == opt_type } }
options.empty? || options.any? do |opt|
@brand ||= taxons.joins(:taxonomy).
order(depth: :desc).
master && (
belongs_to :variant, -> { with_deleted }, class_name: 'Spree::Variant', inverse_of: :prices, touch: true
amount_in_cents / 100.0.to_d,
payment.state != 'void'
def cancel(*)
def void(*)
def credit(*)
ActiveMerchant::Billing::Response.new(true, '', {}, {})
unscoped { find(*args) }
send("#{success_state}!")
:ip,
:order_id,
:tax,
has_many :offsets, -> { offset_payment }, class_name: 'Spree::Payment', foreign_key: :source_id
scope :from_credit_card, -> { where(source_type: 'Spree::CreditCard') }
scope :with_state, ->(s) { where(state: s.to_s) }
scope :offset_payment, -> { where("source_type = 'Spree::Payment' AND amount < 0 AND state = 'completed'") }
scope :checkout, -> { with_state('checkout') }
scope :completed, -> { with_state('completed') }
scope :processing, -> { with_state('processing') }
scope :failed, -> { with_state('failed') }
scope :risky, -> { where("avs_response IN (?) OR (cvv_response_code IS NOT NULL and cvv_response_code != 'M') OR state = 'failed'", RISKY_AVS_CODES) }
end || amount
payment_source.actions.select { |action| !payment_source.respond_to?("can_#{action}?") || payment_source.send("can_#{action}?", self) }
if payment? || confirm? || complete?
total - payments.map { |p| p.amount if p.source.is_a?(Spree::StoreCredit) && p.pending? }.sum(&:to_f)
self.checkout_steps ||= {}
name: 'order',
def self.go_to_state(name, options = {})
return nil if options.nil? || !options.include?(:from) || !options.include?(:to)
end).map(&:to_s)
if address && address.user_id == user_id
attributes.transform_values! { |v| v == '' ? nil : v }
format: { with: /\A-?\d+(?:\.\d{1,2})?\z/, allow_blank: true }
go_to_state :delivery, if: ->(order) { order.delivery_required? }
go_to_state :payment, if: ->(order) { order.payment? || order.payment_required? }
has_many :line_items, -> { order(:created_at) }, inverse_of: :order, class_name: 'Spree::LineItem'
has_many :adjustments, -> { order(:created_at) }, as: :adjustable, class_name: 'Spree::Adjustment'
validates :email, length: { maximum: 254, allow_blank: true }, email: { allow_blank: true }, if: :require_email
scope :complete, -> { where.not(completed_at: nil) }
scope :incomplete, -> { where(completed_at: nil) }
scope :not_canceled, -> { where.not(state: 'canceled') }
scope :with_deleted_bill_address, -> { joins(:bill_address).where.not(Address.table_name => { deleted_at: nil }) }
scope :with_deleted_ship_address, -> { joins(:ship_address).where.not(Address.table_name => { deleted_at: nil }) }
line_items.inject(0.0) { |sum, li| sum + li.amount }
total.to_f > 0.0
complete? || resumed? || awaiting_return? || returned?
complete? || canceled? || returned?
if line_items.any? { |li| !li.variant || li.variant.discontinued? }
state = "#{name}_state"
old_state = send("#{state}_was")
state: 'cart',
store ||= self.store
where(Variant.table_name => { product_id: products.map(&:id) })
has_many :option_values, -> { order(:position) }
find_by(name: 'color')
def code?(item_code = nil)
if menu.try(:root).present? && parent_id.nil?
has_one :root, -> { where(parent_id: nil) }, class_name: 'Spree::MenuItem', dependent: :destroy
scope :by_locale, ->(locale) { where(locale: locale) }
@details ||= if Gem::Version.new(RUBY_VERSION) >= Gem::Version.new('3.1.0')
self.quantity = 0 if quantity.nil? || quantity < 0
self.price = (variant.price_in(currency).amount || 0) +
scope :backordered, -> { where state: 'backordered' }
scope :on_hand, -> { where state: 'on_hand' }
scope :shipped, -> { where state: 'shipped' }
scope :returned, -> { where state: 'returned' }
where.not(spree_shipments: { state: 'canceled' }).
mini: '48x48>',
small: '100x100>',
product: '240x240>',
large: '600x600>',
plp: '278x371>',
width, height = size.chop.split('x').map(&:to_i)
def authorize(_money, credit_card, _options = {})
def purchase(_money, credit_card, _options = {})
if VALID_CCS.include?(credit_card.number) || (profile_id&.starts_with?('BGS-'))
def credit(_money, _credit_card, _response_code, _options = {})
def void(_response_code, _credit_card, _options = {})
random = "#{prefix}-#{Array.new(6) { rand(6) }.join}"
end.join(' | ')
belongs_to :user, class_name: "::#{Spree.user_class}", foreign_key: 'user_id',
scope :default, -> { where(default: true) }
scope :not_removed, -> { where(deleted_at: nil) }
visa: /^4\d{12}(\d{3})?(\d{3})?$/,
switch: /^6759\d{12}(\d{2,3})?$/,
solo: /^6767\d{12}(\d{2,3})?$/,
dankort: /^5019\d{12}$/,
laser: /^(6304|6706|6709|6771(?!89))\d{8}(\d{4}|\d{6,7})?$/
if expiry =~ /\d{2}\s?\/\s?\d{2,4}/ # will match mm/yy and mm / yyyy
expiry.delete(' ').split('/')
elsif match = expiry.match(/(\d{2})(\d{2,4})/) # will match mmyy and mmyyyy
@verification_value = value.to_s.gsub(/\s/, '')
self.last_digits ||= number.to_s.length <= 4 ? number : number.to_s.slice(-4..-1)
-> { order name: :asc },
-> { where(zoneable_type: 'Spree::Country') },
default || find_by(iso: 'US') || first
define_method("img_#{count}_#{size}") do |dimensions = nil|
image = send("image_#{count}")&.attachment
fit == 'Screen'
scope :by_slug, ->(slug) { where(slug: slug) }
scope :home, -> { where(type: 'Spree::Cms::Pages::Homepage') }
scope :standard, -> { where(type: 'Spree::Cms::Pages::StandardPage') }
scope :feature, -> { where(type: 'Spree::Cms::Pages::FeaturePage') }
type == 'Spree::Cms::Pages::Homepage'
gutters == 'Gutters'
self.gutters ||= 'Gutters'
self.fit ||= 'Container'
self.link_type_one ||= 'Spree::Taxon'
self.link_type_two ||= 'Spree::Taxon'
self.fit ||= 'Screen'
:link_type_two, :link_two, :title_two,
self.link_type_three ||= 'Spree::Taxon'
self.gutters ||= 'No Gutters'
base, percent = preferred_tiers.sort.reverse.detect { |b, _| object.amount >= b }
unless preferred_tiers.keys.all? { |k| k.is_a?(Numeric) && k > 0 }
unless preferred_tiers.values.all? { |k| k.is_a?(Numeric) && k >= 0 && k <= 100 }
base, amount = preferred_tiers.sort.reverse.detect { |b, _| object.amount >= b }
(value * 100).round.to_f / 100
base = if object.is_a?(Array)
object.map { |o| o.respond_to?(:amount) ? o.amount : BigDecimal(o.to_s) }.sum
plural_model_name = model_name.plural.gsub(/spree_/, '').to_sym
column_names.reject { |c| c.match(/_id$|id|preferences|(.*)password|(.*)token|(.*)api_key/) }
skipped_attributes.push('lft', 'rgt', 'depth')
dimensions.split('x').map(&:to_i)
scope :not_finalized, -> { where(state: 'open') }
scope :finalized, -> { where(state: 'closed') }
scope :tax, -> { where(source_type: 'Spree::TaxRate') }
scope :non_tax, -> do
scope :price, -> { where(adjustable_type: 'Spree::LineItem') }
scope :shipping, -> { where(adjustable_type: 'Spree::Shipment') }
scope :optional, -> { where(mandatory: false) }
scope :eligible, -> { where(eligible: true) }
scope :charge, -> { where("#{quoted_table_name}.amount >= 0") }
scope :credit, -> { where("#{quoted_table_name}.amount < 0") }
scope :nonzero, -> { where("#{quoted_table_name}.amount != 0") }
scope :is_included, -> { where(included: true) }
scope :additional, -> { where(included: false) }
array << object if array.none? { |a| a.id == id }
def where(array, opts = {})
array.select { |a| opts.all? { |k, v| a.respond_to?(k) && a.send(k) == v } }
totals = {
promo_total ||= 0.0
scope :not_deleted, -> { where(deleted_at: nil) }
validates :label, uniqueness: { conditions: -> { where(deleted_at: nil) },
scope: :user_id,
delegate :name, :iso3, :iso, :iso_name, to: :country, prefix: true
def self.default(user = nil, kind = 'bill')
if user && user_address = user.public_send(:"#{kind}_address")
attributes.except('id', 'created_at', 'updated_at', 'country_id').all? { |_, v| v.nil? }
new_record? || (shipments.empty? && !Order.complete.where('bill_address_id = ? OR ship_address_id = ?', id, id).exists?)
shipments.empty? && !Order.where('bill_address_id = ? OR ship_address_id = ?', id, id).exists?
attrs = attributes.except('id', 'updated_at', 'created_at')
if states.size == 1
can :read, ::Spree::Menu
can :show, ::Spree::Order do |order, token|
order.user == user || order.token && token == order.token
can :update, ::Spree::Order do |order, token|
!order.completed? && (order.user == user || order.token && token == order.token)
can :read, ::Spree::State
can :read, ::Spree::Store
can :read, ::Spree::Taxon
can :read, ::Spree::Zone
amount / (1 + default_vat(tax_category))
scope :spree_admin, -> { joins(:spree_roles).where(Spree::Role.table_name => { name: 'admin' }) }
column: :all)
where("#{table_name}.email LIKE ?", "%#{query}%")
where("#{Spree::Address.table_name}.firstname like ?", "%#{query}%").
or(left_outer_joins(address).where("#{Spree::Address.table_name}.lastname like ?", "%#{query}%"))
has_many :addresses, -> { where(deleted_at: nil).order('updated_at DESC') },
scope :for_store, ->(store) { where(store_id: store.id) }
parts = name.to_s.match(/(.*)_by_(.*)/)
when Property then { "#{properties_table}.id" => property.id }
{ "#{property_translations_table}.name" => property }
where(Price.table_name => { amount: low..high })
where("#{price_table_name}.amount <= ?", price)
where("#{price_table_name}.amount >= ?", price)
group(:id).
group("#{Spree::Product.table_name}.id").
where("#{OptionValue.table_name}.name = ? OR #{ProductProperty.table_name}.value = ?", value, value)
order(%Q{
where.not(Price.table_name => { amount: nil }).
if user.try(:has_spree_role?, 'admin')
pg_search_scope :search_by_name, against: :name, using: { tsearch: { any_word: true, prefix: true } }
i18n { name.lower.matches("%#{query.downcase}%") }
default_scope { order(Arel.sql("LOWER(#{table_name}.name)")) }
scope :for_store, ->(store) { joins(:stores).where(Store.table_name => { id: store.id }) }
(hash || {}).with_indifferent_access
def reload(options = {})
instance_variable_set(:"@#{v.gsub(/\?/, '')}", nil)
size = size.gsub(/\s+/, '')
return unless size.match(/(\d+)x(\d+)/)
width, height = size.split('x').map(&:to_i)
money_method = { money_method => {} } unless money_method.is_a? Hash
define_method("display_#{method_name}") do |**args_list|
default_opts = respond_to?(:currency) ? { currency: currency } : {}
to_s.tableize.tr('/', '_').sub('spree_', '')
).save
string.slice(0..449) + '...'
{ images: { attachment_attachment: :blob } },
!(@product_price.nil? || @product_price.zero?)
value.try(:cache_key) || value
elsif locale.to_s == 'en'
end.sort_by { |c| c.name.parameterize }
last_word = resource.class.name.split('::', 10).last
def logo(image_path = nil, options = {})
og_meta = {}
meta = {}
def seo_url(taxon, options = {})
options = options.first || {}
if method_name.to_s.match(/_image$/) && style = method_name.to_s.sub(/_image$/, '')
taxons.i18n { name.matches("%#{taxon_name}%") }
@scope = scope || Spree::Store
attr_reader :ids, :skus, :price, :currency, :taxons, :concat_taxons, :name, :options, :option_value_ids, :scope,
having("COUNT(#{Spree::Product.table_name}.id) = ?", concat_taxons.length).
products.i18n { name.matches("%#{product_name}%") }
group("#{Spree::Product.table_name}.id, #{Spree::Variant.table_name}.id").
product_ids = index == 0 ? ids : product_ids & ids
when 'name-a-z'
select("#{Product.table_name}.*").select(:name).order(name: :asc)
when 'name-z-a'
select("#{Product.table_name}.*").select(:name).order(name: :desc)
taxons = store.taxons.where(id: taxons_ids.to_s.split(','))
select("#{Product.table_name}.*, #{Spree::Price.table_name}.amount").
reorder('').
def execute(user:, store:, **params)
def execute(order:, variant:, options: {})
@title = params.dig(:filter, :title)
gem 'pg', '~> 1.1'
gem 'sprockets-rails', '>= 2.0.0'
gem 'capybara', '~> 3.24'
gem 'capybara-screenshot', '~> 1.0'
gem 'factory_bot_rails', '~> 6.0'
gem 'rspec-activemodel-mocks', '~> 1.0'
gem 'rspec-rails', '~> 4.0'
gem 'simplecov', '0.17.1'
gem 'webmock', '~> 3.7'
gem 'rubocop', '~> 1.0', require: false
gem 'webdrivers', '~> 4.1'
gem 'puma'
template 'rspec', "#{file_name}/.rspec"
template 'travis.yml', "#{file_name}/.travis.yml"
template '.rubocop.yml', "#{file_name}/.rubocop.yml"
say %{
@file_name = prefix + Thor::Util.snake_case(file_name) unless file_name =~ /^#{prefix}/
when 'version', '-v', '--version'
system("bundle exec rspec #{rspec_arguments.join(' ')}")
log("Running #{suffix}")
log("- #{project.name}")
log("Building: #{project.name}")
config.swagger_root = Rails.root.join('../../docs').to_s # Rails.root is a dummy app
openapi: '3.0.3',
contact: {
version: 'v2'
paths: {},
url: 'http://{defaultHost}',
{ name: 'Addresses' },
{ name: 'Adjustments' },
{ name: 'Classifications' },
{ name: 'Countries' },
{ name: 'CMS Pages' },
{ name: 'CMS Sections' },
{ name: 'Digital Assets' },
{ name: 'Digital Links' },
{ name: 'Line Items' },
{ name: 'Menus' },
{ name: 'Menu Items' },
{ name: 'Option Types' },
{ name: 'Option Values' },
{ name: 'Orders' },
{ name: 'Payments' },
{ name: 'Payment Methods' },
{ name: 'Products' },
{ name: 'Promotions' },
{ name: 'Promotion Actions' },
{ name: 'Promotion Categories' },
{ name: 'Promotion Rules' },
{ name: 'Roles' },
{ name: 'Shipments' },
{ name: 'Shipping Categories' },
{ name: 'Shipping Methods' },
{ name: 'States' },
{ name: 'Stock Items' },
{ name: 'Stock Locations' },
{ name: 'Store Credit Categories' },
{ name: 'Store Credit Types' },
{ name: 'Store Credits' },
{ name: 'Tax Categories' },
{ name: 'Tax Rates' },
{ name: 'Taxons' },
{ name: 'Taxonomies' },
{ name: 'Users' },
{ name: 'Variants' },
{ name: 'Webhook Events' },
{ name: 'Webhook Subscribers' },
{ name: 'Wishlists' },
{ name: 'Wished Items' },
{ name: 'Zones' }
type: :http,
country_id: { type: :string, example: '224' },
state_id: { type: :string, example: '516' },
state_name: { type: :string, example: 'New York' },
address1: { type: :string, example: '5th ave' },
address2: { type: :string, example: '1st suite' },
city: { type: :string, example: 'NY' },
zipcode: { type: :string, example: '10001' },
phone: { type: :string, example: '+1 123 456 789' },
firstname: { type: :string, example: 'John' },
lastname: { type: :string, example: 'Snow' },
label: { type: :string, example: 'My home address' },
company: { type: :string, example: 'Vendo Cloud Inc' },
user_id: { type: :string },
public_metadata: { type: :object, example: { 'distance_from_nearest_city_in_km' => 10, 'location_type' => 'building' } },
private_metadata: { type: :object, example: { 'close_to_shop' => true } }
public_metadata: { type: :object, example: { 'distance_from_city_in_km' => 10, 'location_type' => 'building' } },
order_id: { type: :string },
label: { type: :string, example: 'Shipping costs' },
adjustable_id: { type: :string },
adjustable_type: { type: :string, example: 'Spree::LineItem' },
source_id: { type: :string },
source_type: { type: :string, example: 'Spree::TaxRate' },
amount: { type: :number, example: 10.90 },
mandatory: { type: :boolean },
eligible: { type: :boolean },
included: { type: :boolean, example: true, default: false },
product_id: { type: :string, example: '1' },
taxon_id: { type: :string, example: '1' },
position: { type: :integer, example: 1 }
cms_page: {
title: { type: :string, example: 'About Us', description: 'Give your page a title.' },
slug: { type: :string, nullable: true, example: 'about-us', description: 'Set a slug for this page.' },
title: { type: :string, example: 'Our Flash Homepage', description: 'Give your page a title.' },
title: { type: :string, example: 'About Us', description: 'Update the page title.' },
slug: { type: :string, nullable: true, example: 'about-us', description: 'Update the slug for this page.' },
locale: { type: :string, example: 'en-US', description: 'Update the language of this page.' }
name: { type: :string, description: 'Give this section a name.' },
cms_page_id: { type: :string, description: 'Set the `cms_page` ID that this section belongs to.' },
title: { type: :string, example: 'Shop Today', description: 'Create a title for the Section.' },
name: { type: :string, description: 'Update this section name.' },
name: { type: :string, description: 'Change this section name.' },
access_counter: { type: :integer, example: 0 },
line_item_id: { type: :string, example: '1' },
digital_id: { type: :string, example: '1' }
line_item: {
order_id: { type: :string, example: '1' },
variant_id: { type: :string, example: '1' },
quantity: { type: :integer, example: 2 },
public_metadata: { type: :object },
quantity: { type: :integer, example: 2 }
menu: {
name: { type: :string, example: 'Main Menu', description: 'Give this Menu a name.' },
locale: { type: :string, example: 'en-US', description: 'Set the language of this menu.' }
name: { type: :string, example: 'Main Menu', description: 'Update this Menu name.' },
locale: { type: :string, example: 'en-US', description: 'Change the language of this menu.' }
menu_item: {
name: { type: :string, example: 'T-Shirts', description: 'The name of this Menu Item' },
name: { type: :string, example: 'T-Shirts', description: 'Update the name of this Menu Item' },
name: { type: :string, example: 'color' },
presentation: { type: :string, example: 'Color' },
name: { type: :string, example: 'red' },
presentation: { type: :string, example: 'Red' },
item_total: { type: :number, example: 170.90 },
total: { type: :number, example: 190.90 },
adjustment_total: { type: :number, example: 20.0 },
user_id: { type: :string, example: '1' },
bill_address_id: { type: :string, example: '1' },
ship_address_id: { type: :string, example: '1' },
payment_total: { type: :number, example: 190.90 },
payment_state: { type: :string, example: 'paid', enum: Spree::Order::PAYMENT_STATES },
email: { type: :string, format: :email, example: 'hi@getvendo.com' },
special_instructions: { type: :string, example: 'I need it ASAP!' },
currency: { type: :string, example: 'USD' },
last_ip_address: { type: :string, example: '127.0.0.1' },
created_by_id: { type: :string, example: '1' },
shipment_total: { type: :number, example: 10.0 },
additional_tax_total: { type: :number, example: 10.0 },
promo_total: { type: :number, example: 0.0 },
channel: { type: :string, example: 'online' },
included_tax_total: { type: :number, example: 0.0 },
item_count: { type: :integer, example: 2 },
approver_id: { type: :string },
canceled_at: { type: :string, format: :date_time },
canceler_id: { type: :string },
items: { '$ref': '#/components/schemas/update_line_item_params' }
name: { type: :string, example: 'Test Payment Method' },
active: { type: :boolean },
auto_capture: { type: :boolean },
store_ids: {
{ type: :string, example: '2' }
preferred_test_mode: { type: :boolean },
name: { type: :string },
description: { type: :string },
available_on: { type: :string },
discontinue_on: { type: :string },
permalink: { type: :string },
meta_description: { type: :string },
meta_keywords: { type: :string },
price: { type: :string },
sku: { type: :string },
deleted_at: { type: :string },
prototype_id: { type: :string },
option_values_hash: { type: :string },
weight: { type: :string },
height: { type: :string },
width: { type: :string },
depth: { type: :string },
shipping_category_id: { type: :string },
tax_category_id: { type: :string },
cost_currency: { type: :string },
cost_price: { type: :string },
compare_at_price: { type: :string },
option_type_ids: { type: :string },
taxon_ids: { type: :string },
advertise: { type: :boolean },
role: {
name: { type: :string, example: 'vendor' }
name: { type: :string, example: 'vendor' },
stock_location_id: { type: :string, example: '101' },
order_id: { type: :string, example: '101' },
variant_id: { type: :string, example: '101' },
name: { type: :string, example: 'Another Category' }
name: { type: :string, example: 'DHL Express' },
admin_name: { type: :string, example: 'DHL Area Code D' },
code: { type: :string, example: 'DHL-A-D' },
tax_category_id: { type: :string, example: '1' },
stock_item: {
variant_id: { type: :string, example: '2' },
stock_location_id: { type: :string, example: '2' },
count_on_hand: { type: :number, example: 200 },
name: { type: :string, example: 'Warehouse 3' },
default: { type: :boolean },
address1: { type: :string, example: 'South St. 8' },
address2: { type: :string, example: 'South St. 109' },
country_id: { type: :string, example: '2' },
state_id: { type: :string, example: '4' },
city: { type: :string, example: 'Los Angeles' },
state_name: { type: :string, example: 'California' },
zipcode: { type: :string, example: '90005' },
phone: { type: :string, example: '23333456' },
admin_name: { type: :string },
name: { type: :string, example: 'refunded' },
priority: { type: :integer, example: 1 }
user_id: { type: :string, example: '2' },
category_id: { type: :string, example: '4' },
created_by_id: { type: :string, example: '5' },
amount: { type: :number, example: 25.0 },
amount_used: { type: :number, example: 10.0 },
memo: { type: :string, example: 'This credit was given as a refund' },
amount_authorized: { type: :number, example: 15.5 },
originator_id: { type: :string, example: '3' },
originator_type: { type: :string, example: 'Refund' },
type_id: { type: :string, example: '1' },
store_id: { type: :string, example: '2' },
name: { type: :string, example: 'Clothing' },
is_default: { type: :boolean, example: true },
tax_code: { type: :string, example: '1257L' },
tax_rate: {
amount: { type: :number, example: 0.05 },
zone_id: { type: :string, example: '2' },
included_in_price: { type: :boolean, example: true },
name: { type: :string, example: 'California' },
show_rate_in_label: { type: :boolean, example: false },
type: { type: :string, example: 'Spree::Calculator::FlatRate' },
example: { amount: 0, currency: 'USD' }
taxon: {
taxonomy_id: { type: :string },
parent_id: { type: :string },
public_metadata: { type: :object, example: { 'ability_to_recycle' => '90%' } },
private_metadata: { type: :object, example: { 'profitability' => 2 } }
email: { type: :string },
first_name: { type: :string },
last_name: { type: :string },
password: { type: :string },
ship_address_id: { type: :string },
bill_address_id: { type: :string },
active: { type: :boolean, example: true, default: false },
{ type: :string, example: 'order.completed' }
url: { type: :string, example: 'https://www.url.com/' }
is_default: { type: :boolean },
is_private: { type: :boolean }
wishlist_id: { type: :string },
variant_id: { type: :string },
zone: {
name: { type: :string, example: 'EU' },
default_tax: { type: :boolean },
amount: { type: :number }
coupon_code: { type: :string }
{ '$ref' => '#/components/schemas/resource_properties' }
count: { type: :integer },
total_count: { type: :integer },
total_pages: { type: :integer }
links: {
self: { type: :string },
next: { type: :string },
prev: { type: :string },
last: { type: :string },
first: { type: :string }
id: { type: :string },
type: { type: :string },
attributes: { type: :object },
data: { '$ref' => '#/components/schemas/resource_properties' },
error: {
error: { type: :string },
errors: { type: :object }
def api_get(action, params = {}, session = nil, flash = nil)
def api_post(action, params = {}, session = nil, flash = nil)
def api_put(action, params = {}, session = nil, flash = nil)
def api_delete(action, params = {}, session = nil, flash = nil)
def api_process(action, params = {}, session = nil, flash = nil, method = 'get')
api_post :create, product: { name: 'Brand new product!' }
api_put :update, id: product.to_param, product: { name: 'I hacked your store!' }
let(:event_name) { 'order.finalize' }
let(:webhook_payload_body) { {} }
let(:queue) { 'spree_webhooks' }
expect { subject }.to(
let(:url) { 'http://google.com/' }
let(:execution_time_in_seconds) { ((end_time - start_time) * 1000).to_i }
let(:rand_variation) { rand(1..10) }
before { stub_request(:post, url) }
let(:headers) { { 'Content-Type' => 'application/json' } }
let(:http) { Net::HTTP.new(uri.host, uri.port) }
let(:uri) { URI(url) }
it 'sets use_ssl' do
with(headers: { 'Content-Type' => 'application/json' })
with(headers: { 'X-Spree-Hmac-SHA256' => signature })
it { expect(subject).to eq(0) }
it { expect(subject).to eq(200) }
it { expect(subject.success?).to eq(true) }
let(:url) { 'google.com' }
context 'uri with path ""' do
before { uri.path = '' }
uri.path = ''
let(:event_name) { 'order.canceled' }
let(:resource) { create(:address) }
it "#{with_log_level} logs" do
map(&:values)
}.from(
).to(
it { expect(subject.call).to eq(nil) }
let(:execution_time) { 0 }
let(:response_code) { 0 }
let(:success) { false }
let(:failed_request) { true }
let(:execution_time) { rand(1..999999) }
let(:failed_request) { false }
let(:success) { true }
let(:event_name) { 'order.placed' }
let(:order) { create(:order, email: 'test@example.com') }
let(:message) { 'error' }
let(:result) { subject }
it { expect(subject).to be_kind_of(Hash) }
display_price: '$19.99',
display_total: '$99.95',
variant: {
id: user.id.to_s,
public_metadata: {},
create(:store_credit, amount: '100', store: store, user: user, currency: 'USD')
create(:store_credit, amount: '90', store: store, user: user, currency: 'EUR')
let(:user) { create(:user_with_addresses, selected_locale: 'fr') }
let(:menu) { create(:menu) }
id: menu.id.to_s,
type: :menu,
menu_items: {
let(:menu_item) { create(:menu_item, menu: menu, linked_resource: create(:taxon)) }
let!(:children) { create(:menu_item, parent_id: menu_item.id, menu: menu) }
id: menu_item.id.to_s,
icon: {
parent: {
let(:menu_item) { create(:menu_item, menu: menu) }
let(:icon) { create(:icon, viewable: menu_item) }
id: icon.id.to_s,
type: :icon,
let(:cms_section) { create(:cms_section) }
let(:file) { File.open(file_fixture('icon_256x256.jpg')) }
let(:homepage) { create(:cms_homepage) }
let(:adjustment_total) { 100.0 }
let(:created_at) { 1.day.ago }
let(:id) { 1 }
let(:item_total) { 110.0 }
let(:updated_at) { Time.now }
eq(
id: test_order.id.to_s,
let(:resource) { create(:zone) }
let!(:wishlist) { create(:wishlist, user: user) }
display_total: '$59.97',
id: variant.id.to_s,
let(:resource) { create(type) }
let(:type) { :subscriber }
let(:type) { :event }
let!(:digital) { create(:digital, variant: variant) }
display_price: '$10.00',
images: {
id: taxon.id.to_s,
root: {
taxons: {
type: :taxon,
image: {
id: taxon.icon.id.to_s,
let(:image) { create(:taxon_image) }
id: image.id.to_s,
let(:resource) { create(:tax_rate) }
let(:resource) { create(:tax_category) }
let(:type) { :tax_category }
tax_rates: {
let!(:logo) do
id: store.id.to_s,
type: :store,
menus: {
let(:resource) { create(:store_credit) }
let(:type) { :stock_transfer }
let(:type) { :stock_movement }
let(:type) { :stock_location }
country: {
id: country.id.to_s,
let(:type) { :stock_item }
id: state.id.to_s,
type: :state,
let(:resource) { create(:state_change) }
let(:resource) { create(:shipment) }
let(:type) { :role }
let(:resource) { create(:return_item) }
let(:payment) { create(:payment, state: 'completed') }
let(:type) { :reimbursement }
refunds: {
id: refund.id.to_s,
let(:resource) { create(:refund, amount: 5.0) }
let(:type) { :refund_reason }
let(:type) { :prototype }
let(:type) { :property }
stores: {
let!(:images) { create_list(:image, 2) }
price: 10.00,
id: product.id.to_s,
let(:resource) { create(:price) }
let(:type) { :price }
let(:resource) { create(:payment) }
server: 'test',
code: nil,
let(:resource) { create(:log_entry) }
let(:resource) { create(:line_item) }
type: :image,
id: digital.id.to_s,
digital: {
let(:resource) { create(:credit_card) }
let(:country) { create(:country, states: create_list(:state, 2)) }
states: {
let(:cms_page) { create(:cms_feature_page) }
id: cms_page.id.to_s,
type: :cms_page,
let(:viewable) { create(:variant) }
let(:type) { :asset }
let(:address) { create(:address, user: create(:user)) }
id: address.id.to_s,
state: {
let!(:user) { create(:user, email: 'new@user.com', password: 'secret', password_confirmation: 'secret') }
let(:client_secret) { 'secret' }
let(:active_value) { true }
let(:active_value) { false }
let(:wishlist) { create(:wishlist) }
let(:user) { wishlist.user }
let!(:wishlists) { create_list(:wishlist, 30, user: user) }
name: 'fathers day',
is_private: '1',
is_default: '1'
name: 'books'
let!(:set_variant) { create(:variant) }
quantity: '0'
let!(:taxon_3) { create(:taxon, taxonomy: taxonomy_3, parent: taxonomy_3.root) }
let(:taxon) { taxons.first }
let!(:image) { create(:taxon_image, viewable: taxon) }
let!(:store) { create(:store, default_country: create(:country)) }
before { get "/api/v2/storefront/stores/#{store.code}" }
let!(:store) { create(:store, :with_favicon) }
let(:store2) { create(:store) }
let!(:taxon2) { taxonomy2.root }
let!(:store) do
context 'A-Z' do
.order(:name).map(&:id).map(&:to_s)
context 'Z-A' do
.order(name: :desc).map(&:id).map(&:to_s)
before { store.products.each_with_index { |p, i| p.update(status: 'active', available_on: Time.current - i.days) } }
let(:params) { '' }
let(:params) { '&include=variants' }
let(:params) { ',updated_at' }
let!(:time) { Time.current }
before { store.products.each { |p| p.update(updated_at: time) } }
before { available_products_with_master.each_with_index { |p, i| p.update(updated_at: time - i.day) } }
let!(:option_type2) { create(:option_type) }
let!(:unused_option_type) { create(:option_type) }
let(:image_transformation_params) { '' }
let!(:order) { create(:order, state: 'complete', completed_at: Time.current, store: store) }
let(:order_2) { create(:order, state: 'complete', completed_at: Time.current, store: store_2) }
let(:headers_order_token) { { 'X-Spree-Order-Token' => '' } }
let(:headers_order_token) { { 'X-Spree-Order-Token' => 'WRONG' } }
let!(:header_en) { create(:menu, store: store, location: 'Header') }
let!(:footer_en) { create(:menu, store: store, location: 'Footer') }
let!(:header_fr) { create(:menu, store: store, location: 'Header', locale: 'fr') }
let!(:footer_fr) { create(:menu, store: store, location: 'Footer', locale: 'fr') }
let!(:header_store_2) { create(:menu, store: create(:store), location: 'Header') }
let(:menu) { header_en }
let(:menu) { header_fr }
let!(:menu_item) { create(:menu_item, menu: header_en, linked_resource: taxon) }
have_type('menu_item').
and(have_jsonapi_attributes(:name, :code, :subtitle, :link, :new_window, :lft, :rgt, :depth, :is_container, :is_root, :is_child, :is_leaf))
let!(:menu) { create(:menu, store: store) }
let!(:menu_item) { create(:menu_item, menu: menu, linked_resource: taxon) }
let!(:menu) { create(:menu, store: create(:store)) }
before { get "/api/v2/storefront/menus/#{menu.id}" }
before { get '/api/v2/storefront/menus/0' }
let!(:countries_list) { create_list(:country, 238) }
let!(:new_country) { create(:country) }
let!(:second_country) { create(:country) }
let!(:home_en) { create(:cms_homepage, store: store) }
let!(:standard_en) { create(:cms_standard_page, store: store, title: 'About us') }
let!(:home_fr) { create(:cms_homepage, store: store, locale: 'fr') }
let!(:standard_fr) { create(:cms_standard_page, store: store, locale: 'fr') }
let!(:home_store_2) { create(:cms_homepage, store: create(:store)) }
let(:page) { home_en }
let(:page) { home_fr }
let(:kind) { 'home' }
let(:kind) { 'standard' }
let(:page) { standard_en }
let(:kind) { 'feature' }
let!(:page) { create(:cms_feature_page, store: store) }
:name, :content, :settings, :link, :fit, :type, :position, :is_fullscreen,
:img_one_sm, :img_one_md, :img_one_lg, :img_two_sm, :img_two_md, :img_two_lg,
:img_three_sm, :img_three_md, :img_three_lg
let!(:page) { create(:cms_standard_page, store: store) }
before { get "/api/v2/storefront/cms_pages/#{page.slug}" }
let!(:page) { create(:cms_standard_page, store: create(:store)) }
before { get "/api/v2/storefront/cms_pages/#{page.id}" }
let(:order) { create(:order, user: user, store: store, currency: currency) }
let!(:country_zone) { create(:zone, name: 'CountryZone') }
let(:params) { { order_token: order.token } }
let!(:order) { create(:order, total: order_total, store: store) }
let!(:payment) { Spree::Payment.all.first }
let(:params) { { order_token: order.token, include: 'payments', fields: { payment: 'state' } } }
let(:zone) { create(:zone, name: 'US') }
let(:order) { Spree::Order.last }
public_metadata: { 'property1' => 'value1' },
private_metadata: { 'property2' => 'value2' }
let(:params) { { currency: 'EUR' } }
let(:order) { create(:order, user: user, store: store, currency: currency, state: 'canceled') }
public_metadata: { 'prop1' => 'value1' },
private_metadata: { 'prop2' => 'value2' },
let(:options) { { cost_price: 1.99 } }
expect{ execute }.to change { Spree::Order.count }.by(-1)
let(:params) { { order: order, line_item_id: line_item.id, quantity: 5 } }
let!(:headers) { headers_bearer }
let(:params) { { currency: currency } }
get '/api/v2/storefront/cart', headers: headers, params: { currency: 'USD' }
get '/api/v2/storefront/cart', headers: headers, params: { currency: 'PLN' }
let(:bill_addr_params) { { include: 'billing_address' } }
let(:ship_addr_params) { { include: 'shipping_address' } }
let(:params) { { coupon_code: coupon_code, include: 'promotions' } }
let!(:coupon_code) { 'zxr' }
let!(:coupon_code) { '' }
let(:params) { { include: 'promotions' } }
let(:coupon_code) { 'something-else' }
let(:coupon_code) { nil }
let(:coupon_code) { '' }
let(:params) { { country_iso: 'USA' } }
let(:guest_order_token) { 'invalid' }
let(:headers) {}
email: 'new@email.com',
first_name: 'Peter',
last_name: 'Parker',
public_metadata: { 'has_other_account' => 'true' },
private_metadata: { 'shops_in_other_stores' => 'false' }
let(:params) { { user: new_attributes } }
last_name: 'Scott',
.with_data({ 'id' => new_default_bill_address.id.to_s, 'type' => 'address' })
.with_data({ 'id' => new_default_ship_address.id.to_s, 'type' => 'address' })
.with_data({ 'id' => user.bill_address_id.to_s, 'type' => 'address' })
.with_data({ 'id' => user.ship_address_id.to_s, 'type' => 'address' })
let!(:order) { create(:order, state: 'complete', user: user, completed_at: Time.current, store: store) }
let!(:order_1) { create(:order, state: 'complete', user: user, completed_at: Time.current + 1.day, store: store) }
let!(:order_2) { create(:order, state: 'complete', user: user, completed_at: Time.current + 2.days, store: store) }
let!(:order_3) { create(:order, state: 'complete', user: user, completed_at: Time.current + 3.days, store: store) }
let!(:order) { create(:order, state: 'complete', user: user, completed_at: Time.current) }
let!(:order_1) { create(:order, state: 'complete', user: user, completed_at: Time.current + 1.day) }
let!(:order_2) { create(:order, state: 'complete', user: user, completed_at: Time.current + 2.days) }
let!(:order_3) { create(:order, state: 'complete', user: user, completed_at: Time.current + 3.days) }
let!(:order_2) { create(:order, state: 'complete', user: user, completed_at: Time.current, store: create(:store)) }
let(:order) { create(:order, state: 'complete', user: user, completed_at: Time.current, store: store) }
let!(:credit_cards) { create_list(:credit_card, 3, user_id: user.id) }
let(:display_on) { :none }
let(:display_on) { :front_end }
let!(:new_user) { create(:user) }
let!(:new_credit_card) { create(:credit_card, user_id: new_user.id, last_digits: '2222') }
let!(:credit_card) { create(:credit_card, user_id: user.id, default: false) }
let!(:credit_card) { create(:credit_card, user_id: user.id) }
let!(:params) { { user_id: user.id } }
let!(:addresses) { create_list(:address, 3, user_id: user.id) }
let!(:country) { create(:country, iso: 'GBR') }
let!(:address) { create(:address, user_id: user.id) }
let(:country) { create(:country, name: 'France') }
let!(:eu_address) { create(:address, user_id: user.id, country: country) }
let(:eu_country) { create(:country, name: 'France') }
let!(:us_address) { create(:address, user_id: user.id, country: country) }
let!(:address) { create(:address, user_id: nil) }
city: 'London',
phone: '079 4721 9458',
zipcode: 'SE25 3FZ',
state_name: 'EAW',
let(:params) { { address: new_attributes } }
city: '',
let!(:another_store) { create(:store, url: 'another-store.lvh.me', name: 'Another Store') }
before { host!('another-store.lvh.me') }
before { host!('missing-store.lvh.me') }
let(:bearer_token) { { 'Authorization' => valid_authorization } }
let(:type) { 'subscriber' }
let(:url) { 'https://www.mysite.com/spree_webhooks' }
let(:active) { true }
let(:active) { false }
let!(:subscriber) { create(:subscriber, url: url) }
let!(:another_subscriber) { create(:subscriber, url: 'http://localhost/') }
let(:params) { { subscriber: { active: true, url: url, subscriptions: events } } }
let(:type) { 'event' }
let!(:event_1) { create(:event, name: name_filter) }
let!(:event_2) { create(:event, name: 'order.created') }
let(:name_filter) { 'order.canceled' }
let!(:event_2) { create(:event, :successful) }
let!(:event_2) { create(:event, response_code: '301') }
let(:response_code_filter) { '200' }
let!(:event_success) { create(:event, :successful) }
let!(:event_fail) { create(:event, :failed) }
let(:success_filter) { true }
let!(:event_1) { create(:event, url: 'https://mysite.com/spree_webhooks') }
let!(:event_2) { create(:event, url: 'http://localhost.com/') }
let(:url_filter) { 'mysite' }
let!(:variants) { create_list(:variant, 5, product: product) }
let!(:variant) { create(:variant, product: product_2) }
let!(:variant) { create(:variant, price: 100) }
let!(:taxon) { create(:taxon, name: 'T-Shirts', taxonomy: taxonomy) }
let!(:taxon_2) { create(:taxon, name: 'Pants', taxonomy: taxonomy) }
let!(:taxon_3) { create(:taxon, name: 'T-Shirts', taxonomy: create(:taxonomy, store: store_2)) }
let(:public_metadata_params) { { ability_to_recycle: '60%' } }
let(:public_metadata_params) { { profitability: 3.4 } }
let(:private_metadata_params) { { ability_to_recycle: '60%' } }
let(:private_metadata_params) { { profitability: 3.4 } }
name: 'Tires',
let!(:taxon_a) { create(:taxon, name: 'T-Shirts', taxonomy: taxonomy) }
let!(:taxon_b) { create(:taxon, name: 'Shorts', taxonomy: taxonomy) }
let!(:taxon_c) { create(:taxon, name: 'Pants', taxonomy: taxonomy) }
expect(taxon_a.lft).to eq(taxon_b.lft + 1)
let!(:variants) { create_list(:variant, 2, product: product_1) }
let!(:variants) { create_list(:variant, 2, product: product_2) }
let!(:store_two) { create(:store) }
let!(:store_three) { create(:store) }
let(:resource_params) { {} }
let(:params) { { address: resource_params } }
let(:id) { resource.id }
let(:valid_http_status) { 200 }
let(:bearer_token) { nil }
let(:bearer_token) { { 'Authorization' => bogus_authorization } }
let(:id) { 'bogus' }
let(:params) { }
let!(:resources) { create_list(:address, 5) }
let(:resources_count) { 5 }
let(:ids) { resources.last(2).map(&:id) }
let(:params) { { filter: { 'id_in': ids } } }
let(:params) { { filter: { 'id_in': ids, firstname_cont: 'Joan' } } }
let(:params) { { page: 1, per_page: 2 } }
let(:params) { { page: 1, per_page: 10 } }
let(:params) { { page: 1, per_page: '-1' } }
let(:params) { { page: 1, per_page: 0 } }
let(:bearer_token) { { 'Authorization' => valid_user_authorization } }
resources.first(3).each { |r| r.update(user: user) }
let(:resources_count) { 3 }
let(:user) { create(:admin_user) }
let(:execute) { get "/api/v2/platform/addresses/#{id}", headers: bearer_token }
let(:another_user) { create(:user) }
let(:bearer_token) { { 'Authorization' => valid_read_authorization } }
let!(:third_store) { create(:store) }
code: 'CM-20',
starts_at: '2021-10-20 13:09:00 UTC',
expires_at: '2021-10-25 13:09:00 UTC',
code: 'BF-20',
path: '/black-fri/today',
before { store.products.each_with_index { |p, i| p.update(price: p.price + i) } }
before { store.products.each_with_index { |p, i| p.update(available_on: Time.current - i.days) } }
before { store.products.each_with_index { |p, i| p.update(make_active_at: Time.current - i.days) } }
let!(:menu_item_a) { create(:menu_item, menu: menu) }
let!(:menu_item_b) { create(:menu_item, menu: menu) }
let!(:menu_item_c) { create(:menu_item, menu: menu, parent: menu_item_b) }
expect(menu_item_a.lft).to eq(menu_item_c.rgt + 1)
let!(:line_items) { create_list(:line_item, 5) }
let(:order_2) { create(:order, store: store_2) }
let!(:line_item) { create(:line_item, order: order, price: 100) }
before { store.line_items.each_with_index { |p, i| p.update(price: p.price + i) } }
let(:params) { { digital: { variant_id: variant.id.to_s, attachment: file_upload } } }
it 'creates a blob ' do
let!(:page) { create(:cms_homepage, store: store) }
let!(:resource_a) { create(:cms_hero_image_section, cms_page: page) }
cms_section: { position: 5 }
let!(:order) { create(:order, user: another_user) }
let!(:zone) { create(:zone, default_tax: true) }
let(:locale) { 'de' }
let(:event) { 'order.placed' }
let(:url) { 'https://url1.com/' }
event = build(:event, :successful, name: '')
let(:event) { create(:event) }
let(:payload) { { id: 123 }.to_json }
let(:event_payload) { { event_name: 'order.create', data: { id: 123 } } }
described_class.new(webhook_event, { event_name: 'order.finished', data: { id: 123 } })
let(:user) { LegacyUser.new }
let(:stock_item) { create(:stock_item) }
let(:event_name) { 'product.out_of_stock' }
let(:event_name) { 'product.back_in_stock' }
let(:event_name) { 'variant.back_in_stock' }
let(:event_name) { 'variant.out_of_stock' }
let(:movement_quantity) { 0 }
let(:event_name) { 'shipment.shipped' }
context 'ready -> ship' do
let(:event_name) { 'order.shipped' }
let(:event_name) { 'product.activated' }
let(:event_name) { 'product.drafted' }
let(:event_name) { 'product.archived' }
let(:event_name) { 'payment.paid' }
let(:event_name) { 'payment.voided' }
let(:event_name) { 'order.paid' }
context 'order.paid? == true' do
context 'order.paid? == false' do
let(:store) { create(:store, default: true) }
let(:event_name) { 'order.resumed' }
let(:order) { create(:order, store: store, state: :canceled) }
let(:images) { create_list(:image, 2) }
let(:event_name) { 'product.create' }
let(:cms_page) { create(:cms_homepage, store: store, locale: 'en') }
let(:event_name) { 'cms_page.create' }
let(:event_name) { 'product.update' }
let!(:store2) { create(:store) }
let!(:cms_page) { create(:cms_homepage, store: store2, locale: 'en') }
let(:body) do
let(:event) { 'order.cancel' }
let(:id) { create(:zone).id }
let(:records_list) { create_list(:zone, 2) }
name: 'EU',
let(:id) { create(:wishlist, name: 'My Wishlist', user: user).id }
build_list(:wishlist, 2) do |record, i|
record.name = if i == 0
name: ''
let(:id) { create(:wished_item).id }
quantity: ''
let(:id) { subscriber.tap(&:save).id }
let(:invalid_param_value) { { url: '' } }
let(:valid_update_param_value) { { active: true } }
let(:records_list) { create_list(:event, 2, :successful) }
let(:event) { build(:event, :successful) }
let(:id) { create(:variant, product: product).id }
sku: '',
path "/api/v2/platform/#{resource_path}/{id}" do
let(:id) { create(:user).id }
let(:option_type) { create(:user, store: store) }
let(:records_list) { create_list(:user, 2) }
let!(:bill_address) { create(:address, user: create(:user)) }
let(:id) { create(:taxon, taxonomy: taxonomy).id }
name: 'new_taxon',
name: 'T-Shirts',
public_metadata: { 'profitability' => 3 }
parameter name: :id, in: :path, type: :string
parameter name: :taxon, in: :body, schema: { '$ref' => '#/components/schemas/taxon_reposition' }
let(:id) { create(:taxonomy, store: store).id }
let(:records_list) { create_list(:taxonomy, 2) }
let(:id) { create(:tax_rate, tax_category: tax_category).id }
amount: 25.9,
zone_id: create(:zone).id,
amount: ''
let(:id) { create(:tax_category).id }
let(:records_list) { create_list(:tax_category, 2) }
let(:id) { create(:store_credit, user: user).id }
let(:records_list) { create_list(:store_credit, 2, user: user) }
currency: 'CAD',
amount: -200,
let(:id) { create(:store_credit_type).id }
let(:id) { create(:store_credit_category).id }
let(:id) { create(:stock_location).id }
name: 'Warehouse 3',
city: 'Los Angeles',
before { create_list(:state, 2) }
let(:id) { create(:state).id }
let(:id) { create(:shipping_method).id }
let(:id) { create(:shipping_category).id }
let(:order) { create(:order_ready_to_ship, store: store) }
let(:id) { create(:shipment, order: order).id }
let(:records_list) { create_list(:shipment, 2) }
parameter name: :shipment, in: :body, schema: { '$ref' => '#/components/schemas/add_item_shipment_params' }
parameter name: :shipment, in: :body, schema: { '$ref' => '#/components/schemas/remove_item_shipment_params' }
variant_id: '1',
path "/api/v2/platform/#{resource_path}/{id}/ship" do
let(:id) { create(:shipment, order: order, state: :ready).id }
let(:id) { create(:shipment, order: order, state: :canceled).id }
path "/api/v2/platform/#{resource_path}/{id}/pend" do
let(:id) { create(:role).id }
let(:records_list) { create_list(:role, 2) }
{ '$ref' => '#/components/schemas/update_promotion_params' },
{ '$ref' => '#/components/schemas/update_promotion_add_rule_params' },
{ '$ref' => '#/components/schemas/update_promotion_update_rule_params' },
{ '$ref' => '#/components/schemas/update_promotion_add_action_params' },
name: 'Black Friday 20% Off',
code: 'BLK-20',
user_id: '223',
product_group_id: '3',
name: '10% OFF',
let(:id) { create(:promotion_category, code: 'MJO').id }
price: 87.43,
{ '$ref' => '#/components/schemas/update_payment_method_params' },
type: 'Spree::Gateway::Bogus',
let(:records_list) { create_list(:order, 2) }
total: 10.00,
parameter name: param_name, in: :body, schema: { '$ref' => "#/components/schemas/create_#{param_name}_params" }
path "/api/v2/platform/#{resource_path}/{id}/next" do
parameter name: :amount, in: :body, schema: { '$ref' => '#/components/schemas/amount_param' }
let(:amount) { { amount: 15.0 } }
parameter name: :coupon_code, in: :body, schema: { '$ref' => '#/components/schemas/coupon_code_param' }
let(:coupon_code) { { coupon_code: promotion.code } }
let(:coupon_code) { { coupon_code: 'wrong-code' } }
let(:id) { create(:option_value).id }
let(:option_type) { create(:option_value) }
let(:records_list) { create_list(:option_value, 2) }
name: 'M'
let(:id) { create(:option_type).id }
let(:records_list) { create_list(:option_type, 2) }
name: 'Size-X'
let(:id) { create(:menu, name: 'Main Menu').id }
build_list(:menu, 2) do |record, i|
if i == 0
record.locale = 'en'
locale: 'en'
locale: '',
location: ''
let(:menu) { create(:menu, store: store) }
let(:id) { create(:menu_item, menu: menu).id }
let!(:menu_item_one) { create(:menu_item, menu: menu) }
let!(:menu_item_two) { create(:menu_item, menu: menu) }
let!(:menu_item_three) { create(:menu_item, menu: menu) }
let(:records_list) { create_list(:menu_item, 4, menu: menu) }
parameter name: :menu_item, in: :body, schema: { '$ref' => '#/components/schemas/menu_item_reposition' }
let(:id) { create(:line_item, order: order, variant: variant).id }
let(:records_list) { create_list(:line_item, 2, order: order) }
let!(:id) { create(:digital).id }
let!(:records_list) { create_list(:digital, 2) }
variant_id: ''
let(:id) { create(:digital_link).id }
let(:records_list) { create_list(:digital_link, 2) }
before { create_list(:country, 2) }
let(:id) { create(:country).id }
{ '$ref' => '#/components/schemas/create_hero_image_cms_section_params' },
{ '$ref' => '#/components/schemas/create_side_by_side_images_cms_section_params' },
{ '$ref' => '#/components/schemas/create_rich_text_cms_section_params' }
{ '$ref' => '#/components/schemas/update_hero_image_cms_section_params' },
{ '$ref' => '#/components/schemas/update_side_by_side_images_cms_section_params' },
{ '$ref' => '#/components/schemas/update_rich_text_cms_section_params' }
let!(:cms_page) { create(:cms_feature_page, store: store) }
name: 'Super Hero',
{ '$ref' => '#/components/schemas/create_standard_cms_page_params' },
{ '$ref' => '#/components/schemas/create_homepage_cms_page_params' },
{ '$ref' => '#/components/schemas/create_feature_cms_page_params' }
{ '$ref' => '#/components/schemas/update_standard_cms_page_params' },
{ '$ref' => '#/components/schemas/update_homepage_cms_page_params' },
{ '$ref' => '#/components/schemas/update_feature_cms_page_params' }
let(:id) { create(:cms_standard_page, store: store).id }
title: ''
let(:id) { create(:classification).id }
let(:valid_create_param_value) { { position: 1, product_id: product.id, taxon_id: taxon.id } }
amount: 15.0,
label: ''
let(:id) { create(:address).id }
let(:records_list) { create_list(:address, 2) }
firstname: '',
lastname: ''
let(:i18n) { I18n::Tasks::BaseTask.new }
let!(:addresses) { create_list(:address, 1, user_id: user.id, country: country, state: state) }
let(:params) { { filter: {}, page: 1, per_page: 10 } }
name: 'Test'
dummy_controller.params = { fields: { product: { values: 'name,slug,price' } } }
dummy_controller.params = { fields: { product: 'name,slug,price' } }
r.draw { get 'index', to: 'spree/api/v2/base#index' }
let!(:user) { create :user }
let(:result_class) { Struct.new(:value) }
let(:result) { result_class.new({message: 'foo'}) }
opts: { user: user }
get :index, params: { token: 'exception-message' }
expect(json_response).to eql('error' => 'foo')
before { expect($!).to receive(:message).and_return('foo') }
let(:price_options) { { tax_zone: Spree::Zone.new } }
let(:store) { Spree::Store.default || create(:store, default: true) }
let(:zone) { Spree::Zone.default_tax || create(:zone, default_tax: true) }
price_options: { tax_zone: zone }
if split.first == 'User'
let(:admin_app) { Spree::OauthApplication.find_or_create_by!(name: 'Admin Panel', scopes: 'admin', redirect_uri: '') }
let(:read_app) { Spree::OauthApplication.find_or_create_by!(name: 'Read App', scopes: 'read', redirect_uri: '') }
let(:per_page) { '' }
let(:include) { nil }
let(name) { nil }
schema '$ref' => '#/components/schemas/error'
let(:id) { 'invalid' }
parameter name: param_name, in: request_data_type, schema: { '$ref' => "#/components/schemas/create_#{param_name}_params" }
parameter name: param_name, in: request_data_type, schema: { '$ref' => "#/components/schemas/update_#{param_name}_params" }
let!(:line_item) { create(:line_item, order: order, currency: currency) }
let!(:digital) { create(:digital) }
let(:guest_token) { 'guest_token' }
let(:headers_bearer) { { 'Authorization' => "Bearer #{token.token}" } }
let(:headers_order_token) { { 'X-Spree-Order-Token' => order.token } }
it "returns #{status_code}" do
sequence(:url) { |n| "https://www.url#{n}.com/" }
active { true }
active { false }
execution_time { rand(1..99_999) }
name { 'order.canceled' }
request_errors { '' }
response_code { '500' }
response_code { '200' }
success { true }
url { nil }
name { "Admin Panel" }
scopes { "admin" }
Dir.glob(File.join(File.dirname(__FILE__), '../../../app/models/spree/api/webhooks/*_decorator*.rb')) do |c|
@root ||= Pathname.new(File.expand_path('../../..', __dir__))
namespace :api, defaults: { format: 'json' } do
get '/countries/:iso', to: 'countries#show', as: :country
get '/stores/:code', to: 'stores#show', as: :store
get '/store', to: 'stores#current', as: :current_store
get '/digitals/:token', to: 'digitals#download', as: 'digital'
get '/google/:unique_url', to: 'google#rss_feed'
api_mime_types = %w(
uri_path == '' && uri_host.nil? && uri_port.nil?
HEADERS = { 'Content-Type' => 'application/json' }.freeze
delegate :host, :path, :port, to: :uri, prefix: true
http = Net::HTTP.new(uri_host, uri_port)
Rails.logger.debug(msg("sending to '#{url}'"))
return process(:warn, msg("can not make a request to '#{url}'"))
process(:debug, msg("success for URL '#{url}'"))
@request ||=
@event ||= Spree::Webhooks::Event.create!(
def call(exception:, opts: {})
attributes :code, :name, :subtitle, :link, :destination, :item_type, :new_window, :lft, :rgt, :depth
Spree::Cms::Pages::Homepage => :cms_page
attribute "img_#{count}_#{size}".to_sym do |section|
if section.send("image_#{count}")&.attachment&.attached? && section.send("img_#{count}_#{size}").present?
:slug, :type
stats.map { |value| { currency: value.currency.to_s, amount: value.money.to_s } }
next if param.nil? || value.nil?
end.compact.reject(&:blank?).join('-')
serializer_base_name = base.to_s.sub(/^Spree::Api::V2::Platform::/, '').sub(/Serializer$/, '')
next if method_name.to_s.end_with?('=')
taxon_ids = taxons_param.to_s.split(',')
scope :inactive, -> { where(active: false) }
to_h do |model|
errors.add(:url, 'the URL must have a path') if uri.blank? || uri.path.blank?
@payload.is_a?(String) ? @payload : @payload.to_json
params.permit(:format, :page, :per_page, :sort, :include, :locale, fields: {}, filter: {})
if action_name == 'show'
render json: { error: I18n.t(:wrong_quantity, scope: 'spree.api.v2.cart') }, status: 422
params.permit(:quantity, :variant_id, public_metadata: {}, private_metadata: {}, options: {})
quantity = params.dig(:shipment, :quantity)&.to_i || 1
serializer_base_name = model_class.to_s.sub('Spree::', '')
if action_name == 'update'
{ error: error.to_s, errors: error.to_h }
{ error: error }
select { |_, v| v.is_a?(String) }.
